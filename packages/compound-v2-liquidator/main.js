// @bun
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getProtoOf = Object.getPrototypeOf;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __toESM = (mod, isNodeMode, target) => {
  target = mod != null ? __create(__getProtoOf(mod)) : {};
  const to = isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target;
  for (let key of __getOwnPropNames(mod))
    if (!__hasOwnProp.call(to, key))
      __defProp(to, key, {
        get: () => mod[key],
        enumerable: true
      });
  return to;
};
var __commonJS = (cb, mod) => () => (mod || cb((mod = { exports: {} }).exports, mod), mod.exports);
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, {
      get: all[name],
      enumerable: true,
      configurable: true,
      set: (newValue) => all[name] = () => newValue
    });
};

// node_modules/@ioredis/commands/built/commands.json
var require_commands = __commonJS((exports, module) => {
  module.exports = {
    acl: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    append: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    asking: {
      arity: 1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    auth: {
      arity: -2,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bgrewriteaof: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bgsave: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bitcount: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitfield: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitfield_ro: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    bitop: {
      arity: -4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 2,
      keyStop: -1,
      step: 1
    },
    bitpos: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    blmove: {
      arity: 6,
      flags: [
        "write",
        "denyoom",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    blmpop: {
      arity: -5,
      flags: [
        "write",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    blpop: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    brpop: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    brpoplpush: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "noscript",
        "blocking"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    bzmpop: {
      arity: -5,
      flags: [
        "write",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    bzpopmax: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking",
        "fast"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    bzpopmin: {
      arity: -3,
      flags: [
        "write",
        "noscript",
        "blocking",
        "fast"
      ],
      keyStart: 1,
      keyStop: -2,
      step: 1
    },
    client: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    cluster: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    command: {
      arity: -1,
      flags: [
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    config: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    copy: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    dbsize: {
      arity: 1,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    debug: {
      arity: -2,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    decr: {
      arity: 2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    decrby: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    del: {
      arity: -2,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    discard: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    dump: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    echo: {
      arity: 2,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    eval: {
      arity: -3,
      flags: [
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    eval_ro: {
      arity: -3,
      flags: [
        "readonly",
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    evalsha: {
      arity: -3,
      flags: [
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    evalsha_ro: {
      arity: -3,
      flags: [
        "readonly",
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    exec: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "skip_slowlog"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    exists: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    expire: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    expireat: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    expiretime: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    failover: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    fcall: {
      arity: -3,
      flags: [
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    fcall_ro: {
      arity: -3,
      flags: [
        "readonly",
        "noscript",
        "stale",
        "skip_monitor",
        "no_mandatory_keys",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    flushall: {
      arity: -1,
      flags: [
        "write"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    flushdb: {
      arity: -1,
      flags: [
        "write"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    function: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    geoadd: {
      arity: -5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geodist: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geohash: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geopos: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadius: {
      arity: -6,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadius_ro: {
      arity: -6,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadiusbymember: {
      arity: -5,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    georadiusbymember_ro: {
      arity: -5,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geosearch: {
      arity: -7,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    geosearchstore: {
      arity: -8,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    get: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getbit: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getdel: {
      arity: 2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getex: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getrange: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    getset: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hdel: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hello: {
      arity: -1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    hexists: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hget: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hgetall: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hincrby: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hincrbyfloat: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hkeys: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hmget: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hmset: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hrandfield: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hscan: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hset: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hsetnx: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hstrlen: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    hvals: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incr: {
      arity: 2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incrby: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    incrbyfloat: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    info: {
      arity: -1,
      flags: [
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    keys: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lastsave: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    latency: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lcs: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    lindex: {
      arity: 3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    linsert: {
      arity: 5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    llen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lmove: {
      arity: 5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    lmpop: {
      arity: -4,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lolwut: {
      arity: -1,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    lpop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpos: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpush: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lpushx: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lrange: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lrem: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    lset: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    ltrim: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    memory: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    mget: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    migrate: {
      arity: -6,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 3,
      keyStop: 3,
      step: 1
    },
    module: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    monitor: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    move: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    mset: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 2
    },
    msetnx: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 2
    },
    multi: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    object: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    persist: {
      arity: 2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpire: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpireat: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pexpiretime: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pfadd: {
      arity: -2,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    pfcount: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    pfdebug: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "admin"
      ],
      keyStart: 2,
      keyStop: 2,
      step: 1
    },
    pfmerge: {
      arity: -2,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    pfselftest: {
      arity: 1,
      flags: [
        "admin"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    ping: {
      arity: -1,
      flags: [
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    psetex: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    psubscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    psync: {
      arity: -3,
      flags: [
        "admin",
        "noscript",
        "no_async_loading",
        "no_multi"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    pttl: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    publish: {
      arity: 3,
      flags: [
        "pubsub",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    pubsub: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    punsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    quit: {
      arity: -1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    randomkey: {
      arity: 1,
      flags: [
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    readonly: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    readwrite: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    rename: {
      arity: 3,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    renamenx: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    replconf: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    replicaof: {
      arity: 3,
      flags: [
        "admin",
        "noscript",
        "stale",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    reset: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "no_auth",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    restore: {
      arity: -4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    "restore-asking": {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "asking"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    role: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    rpop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    rpoplpush: {
      arity: 3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    rpush: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    rpushx: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sadd: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    save: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading",
        "no_multi"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    scan: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    scard: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    script: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sdiff: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sdiffstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    select: {
      arity: 2,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    set: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setbit: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setex: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setnx: {
      arity: 3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    setrange: {
      arity: 4,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    shutdown: {
      arity: -1,
      flags: [
        "admin",
        "noscript",
        "loading",
        "stale",
        "no_multi",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sinter: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sintercard: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sinterstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sismember: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    slaveof: {
      arity: 3,
      flags: [
        "admin",
        "noscript",
        "stale",
        "no_async_loading"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    slowlog: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    smembers: {
      arity: 2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    smismember: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    smove: {
      arity: 4,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    sort: {
      arity: -2,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sort_ro: {
      arity: -2,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    spop: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    spublish: {
      arity: 3,
      flags: [
        "pubsub",
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    srandmember: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    srem: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sscan: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    ssubscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    strlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    subscribe: {
      arity: -2,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    substr: {
      arity: 4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    sunion: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sunionstore: {
      arity: -3,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    sunsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    swapdb: {
      arity: 3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    sync: {
      arity: 1,
      flags: [
        "admin",
        "noscript",
        "no_async_loading",
        "no_multi"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    time: {
      arity: 1,
      flags: [
        "loading",
        "stale",
        "fast"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    touch: {
      arity: -2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    ttl: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    type: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    unlink: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    unsubscribe: {
      arity: -1,
      flags: [
        "pubsub",
        "noscript",
        "loading",
        "stale"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    unwatch: {
      arity: 1,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    wait: {
      arity: 3,
      flags: [
        "noscript"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    watch: {
      arity: -2,
      flags: [
        "noscript",
        "loading",
        "stale",
        "fast",
        "allow_busy"
      ],
      keyStart: 1,
      keyStop: -1,
      step: 1
    },
    xack: {
      arity: -4,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xadd: {
      arity: -5,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xautoclaim: {
      arity: -6,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xclaim: {
      arity: -6,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xdel: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xgroup: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xinfo: {
      arity: -2,
      flags: [],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xlen: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xpending: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xread: {
      arity: -4,
      flags: [
        "readonly",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xreadgroup: {
      arity: -7,
      flags: [
        "write",
        "blocking",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    xrevrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xsetid: {
      arity: -3,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    xtrim: {
      arity: -4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zadd: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zcard: {
      arity: 2,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zcount: {
      arity: 4,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zdiff: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zdiffstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zincrby: {
      arity: 4,
      flags: [
        "write",
        "denyoom",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zinter: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zintercard: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zinterstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zlexcount: {
      arity: 4,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zmpop: {
      arity: -4,
      flags: [
        "write",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zmscore: {
      arity: -3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zpopmax: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zpopmin: {
      arity: -2,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrandmember: {
      arity: -2,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangebylex: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangebyscore: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrangestore: {
      arity: -5,
      flags: [
        "write",
        "denyoom"
      ],
      keyStart: 1,
      keyStop: 2,
      step: 1
    },
    zrank: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrem: {
      arity: -3,
      flags: [
        "write",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebylex: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebyrank: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zremrangebyscore: {
      arity: 4,
      flags: [
        "write"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrange: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrangebylex: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrangebyscore: {
      arity: -4,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zrevrank: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zscan: {
      arity: -3,
      flags: [
        "readonly"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zscore: {
      arity: 3,
      flags: [
        "readonly",
        "fast"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    },
    zunion: {
      arity: -3,
      flags: [
        "readonly",
        "movablekeys"
      ],
      keyStart: 0,
      keyStop: 0,
      step: 0
    },
    zunionstore: {
      arity: -4,
      flags: [
        "write",
        "denyoom",
        "movablekeys"
      ],
      keyStart: 1,
      keyStop: 1,
      step: 1
    }
  };
});

// node_modules/@ioredis/commands/built/index.js
var require_built = __commonJS((exports) => {
  var exists = function(commandName) {
    return Boolean(commands_json_1.default[commandName]);
  };
  var hasFlag = function(commandName, flag) {
    if (!flags[commandName]) {
      throw new Error("Unknown command " + commandName);
    }
    return Boolean(flags[commandName][flag]);
  };
  var getKeyIndexes = function(commandName, args, options) {
    const command = commands_json_1.default[commandName];
    if (!command) {
      throw new Error("Unknown command " + commandName);
    }
    if (!Array.isArray(args)) {
      throw new Error("Expect args to be an array");
    }
    const keys = [];
    const parseExternalKey = Boolean(options && options.parseExternalKey);
    const takeDynamicKeys = (args2, startIndex) => {
      const keys2 = [];
      const keyStop = Number(args2[startIndex]);
      for (let i = 0;i < keyStop; i++) {
        keys2.push(i + startIndex + 1);
      }
      return keys2;
    };
    const takeKeyAfterToken = (args2, startIndex, token) => {
      for (let i = startIndex;i < args2.length - 1; i += 1) {
        if (String(args2[i]).toLowerCase() === token.toLowerCase()) {
          return i + 1;
        }
      }
      return null;
    };
    switch (commandName) {
      case "zunionstore":
      case "zinterstore":
      case "zdiffstore":
        keys.push(0, ...takeDynamicKeys(args, 1));
        break;
      case "eval":
      case "evalsha":
      case "eval_ro":
      case "evalsha_ro":
      case "fcall":
      case "fcall_ro":
      case "blmpop":
      case "bzmpop":
        keys.push(...takeDynamicKeys(args, 1));
        break;
      case "sintercard":
      case "lmpop":
      case "zunion":
      case "zinter":
      case "zmpop":
      case "zintercard":
      case "zdiff": {
        keys.push(...takeDynamicKeys(args, 0));
        break;
      }
      case "georadius": {
        keys.push(0);
        const storeKey = takeKeyAfterToken(args, 5, "STORE");
        if (storeKey)
          keys.push(storeKey);
        const distKey = takeKeyAfterToken(args, 5, "STOREDIST");
        if (distKey)
          keys.push(distKey);
        break;
      }
      case "georadiusbymember": {
        keys.push(0);
        const storeKey = takeKeyAfterToken(args, 4, "STORE");
        if (storeKey)
          keys.push(storeKey);
        const distKey = takeKeyAfterToken(args, 4, "STOREDIST");
        if (distKey)
          keys.push(distKey);
        break;
      }
      case "sort":
      case "sort_ro":
        keys.push(0);
        for (let i = 1;i < args.length - 1; i++) {
          let arg = args[i];
          if (typeof arg !== "string") {
            continue;
          }
          const directive = arg.toUpperCase();
          if (directive === "GET") {
            i += 1;
            arg = args[i];
            if (arg !== "#") {
              if (parseExternalKey) {
                keys.push([i, getExternalKeyNameLength(arg)]);
              } else {
                keys.push(i);
              }
            }
          } else if (directive === "BY") {
            i += 1;
            if (parseExternalKey) {
              keys.push([i, getExternalKeyNameLength(args[i])]);
            } else {
              keys.push(i);
            }
          } else if (directive === "STORE") {
            i += 1;
            keys.push(i);
          }
        }
        break;
      case "migrate":
        if (args[2] === "") {
          for (let i = 5;i < args.length - 1; i++) {
            const arg = args[i];
            if (typeof arg === "string" && arg.toUpperCase() === "KEYS") {
              for (let j = i + 1;j < args.length; j++) {
                keys.push(j);
              }
              break;
            }
          }
        } else {
          keys.push(2);
        }
        break;
      case "xreadgroup":
      case "xread":
        for (let i = commandName === "xread" ? 0 : 3;i < args.length - 1; i++) {
          if (String(args[i]).toUpperCase() === "STREAMS") {
            for (let j = i + 1;j <= i + (args.length - 1 - i) / 2; j++) {
              keys.push(j);
            }
            break;
          }
        }
        break;
      default:
        if (command.step > 0) {
          const keyStart = command.keyStart - 1;
          const keyStop = command.keyStop > 0 ? command.keyStop : args.length + command.keyStop + 1;
          for (let i = keyStart;i < keyStop; i += command.step) {
            keys.push(i);
          }
        }
        break;
    }
    return keys;
  };
  var getExternalKeyNameLength = function(key) {
    if (typeof key !== "string") {
      key = String(key);
    }
    const hashPos = key.indexOf("->");
    return hashPos === -1 ? key.length : hashPos;
  };
  var __importDefault = exports && exports.__importDefault || function(mod) {
    return mod && mod.__esModule ? mod : { default: mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getKeyIndexes = exports.hasFlag = exports.exists = exports.list = undefined;
  var commands_json_1 = __importDefault(require_commands());
  exports.list = Object.keys(commands_json_1.default);
  var flags = {};
  exports.list.forEach((commandName) => {
    flags[commandName] = commands_json_1.default[commandName].flags.reduce(function(flags2, flag) {
      flags2[flag] = true;
      return flags2;
    }, {});
  });
  exports.exists = exists;
  exports.hasFlag = hasFlag;
  exports.getKeyIndexes = getKeyIndexes;
});

// node_modules/standard-as-callback/built/utils.js
var require_utils = __commonJS((exports) => {
  var tryCatcher = function(err, val) {
    try {
      const target = tryCatchTarget;
      tryCatchTarget = null;
      return target.apply(this, arguments);
    } catch (e) {
      exports.errorObj.e = e;
      return exports.errorObj;
    }
  };
  var tryCatch = function(fn) {
    tryCatchTarget = fn;
    return tryCatcher;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.tryCatch = exports.errorObj = undefined;
  exports.errorObj = { e: {} };
  var tryCatchTarget;
  exports.tryCatch = tryCatch;
});

// node_modules/standard-as-callback/built/index.js
var require_built2 = __commonJS((exports) => {
  var throwLater = function(e) {
    setTimeout(function() {
      throw e;
    }, 0);
  };
  var asCallback = function(promise, nodeback, options) {
    if (typeof nodeback === "function") {
      promise.then((val) => {
        let ret;
        if (options !== undefined && Object(options).spread && Array.isArray(val)) {
          ret = utils_1.tryCatch(nodeback).apply(undefined, [null].concat(val));
        } else {
          ret = val === undefined ? utils_1.tryCatch(nodeback)(null) : utils_1.tryCatch(nodeback)(null, val);
        }
        if (ret === utils_1.errorObj) {
          throwLater(ret.e);
        }
      }, (cause) => {
        if (!cause) {
          const newReason = new Error(cause + "");
          Object.assign(newReason, { cause });
          cause = newReason;
        }
        const ret = utils_1.tryCatch(nodeback)(cause);
        if (ret === utils_1.errorObj) {
          throwLater(ret.e);
        }
      });
    }
    return promise;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils();
  exports.default = asCallback;
});

// node_modules/redis-errors/lib/old.js
var require_old = __commonJS((exports, module) => {
  var RedisError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var ParserError = function(message, buffer, offset) {
    assert(buffer);
    assert.strictEqual(typeof offset, "number");
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    const tmp = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(this, this.constructor);
    Error.stackTraceLimit = tmp;
    this.offset = offset;
    this.buffer = buffer;
  };
  var ReplyError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    const tmp = Error.stackTraceLimit;
    Error.stackTraceLimit = 2;
    Error.captureStackTrace(this, this.constructor);
    Error.stackTraceLimit = tmp;
  };
  var AbortError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var InterruptError = function(message) {
    Object.defineProperty(this, "message", {
      value: message || "",
      configurable: true,
      writable: true
    });
    Error.captureStackTrace(this, this.constructor);
  };
  var assert = import.meta.require("assert");
  var util = import.meta.require("util");
  util.inherits(RedisError, Error);
  Object.defineProperty(RedisError.prototype, "name", {
    value: "RedisError",
    configurable: true,
    writable: true
  });
  util.inherits(ParserError, RedisError);
  Object.defineProperty(ParserError.prototype, "name", {
    value: "ParserError",
    configurable: true,
    writable: true
  });
  util.inherits(ReplyError, RedisError);
  Object.defineProperty(ReplyError.prototype, "name", {
    value: "ReplyError",
    configurable: true,
    writable: true
  });
  util.inherits(AbortError, RedisError);
  Object.defineProperty(AbortError.prototype, "name", {
    value: "AbortError",
    configurable: true,
    writable: true
  });
  util.inherits(InterruptError, AbortError);
  Object.defineProperty(InterruptError.prototype, "name", {
    value: "InterruptError",
    configurable: true,
    writable: true
  });
  module.exports = {
    RedisError,
    ParserError,
    ReplyError,
    AbortError,
    InterruptError
  };
});

// node_modules/redis-errors/lib/modern.js
var require_modern = __commonJS((exports, module) => {
  var assert = import.meta.require("assert");

  class RedisError extends Error {
    get name() {
      return this.constructor.name;
    }
  }

  class ParserError extends RedisError {
    constructor(message, buffer, offset) {
      assert(buffer);
      assert.strictEqual(typeof offset, "number");
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      super(message);
      Error.stackTraceLimit = tmp;
      this.offset = offset;
      this.buffer = buffer;
    }
    get name() {
      return this.constructor.name;
    }
  }

  class ReplyError extends RedisError {
    constructor(message) {
      const tmp = Error.stackTraceLimit;
      Error.stackTraceLimit = 2;
      super(message);
      Error.stackTraceLimit = tmp;
    }
    get name() {
      return this.constructor.name;
    }
  }

  class AbortError extends RedisError {
    get name() {
      return this.constructor.name;
    }
  }

  class InterruptError extends AbortError {
    get name() {
      return this.constructor.name;
    }
  }
  module.exports = {
    RedisError,
    ParserError,
    ReplyError,
    AbortError,
    InterruptError
  };
});

// node_modules/redis-errors/index.js
var require_redis_errors = __commonJS((exports, module) => {
  var Errors = process.version.charCodeAt(1) < 55 && process.version.charCodeAt(2) === 46 ? require_old() : require_modern();
  module.exports = Errors;
});

// node_modules/cluster-key-slot/lib/index.js
var require_lib = __commonJS((exports, module) => {
  var lookup = [
    0,
    4129,
    8258,
    12387,
    16516,
    20645,
    24774,
    28903,
    33032,
    37161,
    41290,
    45419,
    49548,
    53677,
    57806,
    61935,
    4657,
    528,
    12915,
    8786,
    21173,
    17044,
    29431,
    25302,
    37689,
    33560,
    45947,
    41818,
    54205,
    50076,
    62463,
    58334,
    9314,
    13379,
    1056,
    5121,
    25830,
    29895,
    17572,
    21637,
    42346,
    46411,
    34088,
    38153,
    58862,
    62927,
    50604,
    54669,
    13907,
    9842,
    5649,
    1584,
    30423,
    26358,
    22165,
    18100,
    46939,
    42874,
    38681,
    34616,
    63455,
    59390,
    55197,
    51132,
    18628,
    22757,
    26758,
    30887,
    2112,
    6241,
    10242,
    14371,
    51660,
    55789,
    59790,
    63919,
    35144,
    39273,
    43274,
    47403,
    23285,
    19156,
    31415,
    27286,
    6769,
    2640,
    14899,
    10770,
    56317,
    52188,
    64447,
    60318,
    39801,
    35672,
    47931,
    43802,
    27814,
    31879,
    19684,
    23749,
    11298,
    15363,
    3168,
    7233,
    60846,
    64911,
    52716,
    56781,
    44330,
    48395,
    36200,
    40265,
    32407,
    28342,
    24277,
    20212,
    15891,
    11826,
    7761,
    3696,
    65439,
    61374,
    57309,
    53244,
    48923,
    44858,
    40793,
    36728,
    37256,
    33193,
    45514,
    41451,
    53516,
    49453,
    61774,
    57711,
    4224,
    161,
    12482,
    8419,
    20484,
    16421,
    28742,
    24679,
    33721,
    37784,
    41979,
    46042,
    49981,
    54044,
    58239,
    62302,
    689,
    4752,
    8947,
    13010,
    16949,
    21012,
    25207,
    29270,
    46570,
    42443,
    38312,
    34185,
    62830,
    58703,
    54572,
    50445,
    13538,
    9411,
    5280,
    1153,
    29798,
    25671,
    21540,
    17413,
    42971,
    47098,
    34713,
    38840,
    59231,
    63358,
    50973,
    55100,
    9939,
    14066,
    1681,
    5808,
    26199,
    30326,
    17941,
    22068,
    55628,
    51565,
    63758,
    59695,
    39368,
    35305,
    47498,
    43435,
    22596,
    18533,
    30726,
    26663,
    6336,
    2273,
    14466,
    10403,
    52093,
    56156,
    60223,
    64286,
    35833,
    39896,
    43963,
    48026,
    19061,
    23124,
    27191,
    31254,
    2801,
    6864,
    10931,
    14994,
    64814,
    60687,
    56684,
    52557,
    48554,
    44427,
    40424,
    36297,
    31782,
    27655,
    23652,
    19525,
    15522,
    11395,
    7392,
    3265,
    61215,
    65342,
    53085,
    57212,
    44955,
    49082,
    36825,
    40952,
    28183,
    32310,
    20053,
    24180,
    11923,
    16050,
    3793,
    7920
  ];
  var toUTF8Array = function toUTF8Array(str) {
    var char;
    var i = 0;
    var p = 0;
    var utf8 = [];
    var len = str.length;
    for (;i < len; i++) {
      char = str.charCodeAt(i);
      if (char < 128) {
        utf8[p++] = char;
      } else if (char < 2048) {
        utf8[p++] = char >> 6 | 192;
        utf8[p++] = char & 63 | 128;
      } else if ((char & 64512) === 55296 && i + 1 < str.length && (str.charCodeAt(i + 1) & 64512) === 56320) {
        char = 65536 + ((char & 1023) << 10) + (str.charCodeAt(++i) & 1023);
        utf8[p++] = char >> 18 | 240;
        utf8[p++] = char >> 12 & 63 | 128;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      } else {
        utf8[p++] = char >> 12 | 224;
        utf8[p++] = char >> 6 & 63 | 128;
        utf8[p++] = char & 63 | 128;
      }
    }
    return utf8;
  };
  var generate = module.exports = function generate(str) {
    var char;
    var i = 0;
    var start = -1;
    var result = 0;
    var resultHash = 0;
    var utf8 = typeof str === "string" ? toUTF8Array(str) : str;
    var len = utf8.length;
    while (i < len) {
      char = utf8[i++];
      if (start === -1) {
        if (char === 123) {
          start = i;
        }
      } else if (char !== 125) {
        resultHash = lookup[(char ^ resultHash >> 8) & 255] ^ resultHash << 8;
      } else if (i - 1 !== start) {
        return resultHash & 16383;
      }
      result = lookup[(char ^ result >> 8) & 255] ^ result << 8;
    }
    return result & 16383;
  };
  module.exports.generateMulti = function generateMulti(keys) {
    var i = 1;
    var len = keys.length;
    var base = generate(keys[0]);
    while (i < len) {
      if (generate(keys[i++]) !== base)
        return -1;
    }
    return base;
  };
});

// node_modules/lodash.defaults/index.js
var require_lodash = __commonJS((exports, module) => {
  var apply = function(func, thisArg, args) {
    switch (args.length) {
      case 0:
        return func.call(thisArg);
      case 1:
        return func.call(thisArg, args[0]);
      case 2:
        return func.call(thisArg, args[0], args[1]);
      case 3:
        return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  };
  var baseTimes = function(n, iteratee) {
    var index = -1, result = Array(n);
    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  };
  var arrayLikeKeys = function(value, inherited) {
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  };
  var assignInDefaults = function(objValue, srcValue, key, object) {
    if (objValue === undefined || eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key)) {
      return srcValue;
    }
    return objValue;
  };
  var assignValue = function(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) || value === undefined && !(key in object)) {
      object[key] = value;
    }
  };
  var baseKeysIn = function(object) {
    if (!isObject(object)) {
      return nativeKeysIn(object);
    }
    var isProto = isPrototype(object), result = [];
    for (var key in object) {
      if (!(key == "constructor" && (isProto || !hasOwnProperty.call(object, key)))) {
        result.push(key);
      }
    }
    return result;
  };
  var baseRest = function(func, start) {
    start = nativeMax(start === undefined ? func.length - 1 : start, 0);
    return function() {
      var args = arguments, index = -1, length = nativeMax(args.length - start, 0), array = Array(length);
      while (++index < length) {
        array[index] = args[start + index];
      }
      index = -1;
      var otherArgs = Array(start + 1);
      while (++index < start) {
        otherArgs[index] = args[index];
      }
      otherArgs[start] = array;
      return apply(func, this, otherArgs);
    };
  };
  var copyObject = function(source, props, object, customizer) {
    object || (object = {});
    var index = -1, length = props.length;
    while (++index < length) {
      var key = props[index];
      var newValue = customizer ? customizer(object[key], source[key], key, object, source) : undefined;
      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
  };
  var createAssigner = function(assigner) {
    return baseRest(function(object, sources) {
      var index = -1, length = sources.length, customizer = length > 1 ? sources[length - 1] : undefined, guard = length > 2 ? sources[2] : undefined;
      customizer = assigner.length > 3 && typeof customizer == "function" ? (length--, customizer) : undefined;
      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        customizer = length < 3 ? undefined : customizer;
        length = 1;
      }
      object = Object(object);
      while (++index < length) {
        var source = sources[index];
        if (source) {
          assigner(object, source, index, customizer);
        }
      }
      return object;
    });
  };
  var isIndex = function(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && (value > -1 && value % 1 == 0 && value < length);
  };
  var isIterateeCall = function(value, index, object) {
    if (!isObject(object)) {
      return false;
    }
    var type = typeof index;
    if (type == "number" ? isArrayLike(object) && isIndex(index, object.length) : type == "string" && (index in object)) {
      return eq(object[index], value);
    }
    return false;
  };
  var isPrototype = function(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
  };
  var nativeKeysIn = function(object) {
    var result = [];
    if (object != null) {
      for (var key in Object(object)) {
        result.push(key);
      }
    }
    return result;
  };
  var eq = function(value, other) {
    return value === other || value !== value && other !== other;
  };
  var isArguments = function(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  };
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isArrayLikeObject = function(value) {
    return isObjectLike(value) && isArrayLike(value);
  };
  var isFunction = function(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var isObject = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var keysIn = function(object) {
    return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var reIsUint = /^(?:0|[1-9]\d*)$/;
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  var nativeMax = Math.max;
  var isArray = Array.isArray;
  var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
    copyObject(source, keysIn(source), object, customizer);
  });
  var defaults = baseRest(function(args) {
    args.push(undefined, assignInDefaults);
    return apply(assignInWith, undefined, args);
  });
  module.exports = defaults;
});

// node_modules/lodash.isarguments/index.js
var require_lodash2 = __commonJS((exports, module) => {
  var isArguments = function(value) {
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
  };
  var isArrayLike = function(value) {
    return value != null && isLength(value.length) && !isFunction(value);
  };
  var isArrayLikeObject = function(value) {
    return isObjectLike(value) && isArrayLike(value);
  };
  var isFunction = function(value) {
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
  };
  var isLength = function(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  };
  var isObject = function(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
  };
  var isObjectLike = function(value) {
    return !!value && typeof value == "object";
  };
  var MAX_SAFE_INTEGER = 9007199254740991;
  var argsTag = "[object Arguments]";
  var funcTag = "[object Function]";
  var genTag = "[object GeneratorFunction]";
  var objectProto = Object.prototype;
  var hasOwnProperty = objectProto.hasOwnProperty;
  var objectToString = objectProto.toString;
  var propertyIsEnumerable = objectProto.propertyIsEnumerable;
  module.exports = isArguments;
});

// node_modules/ioredis/built/utils/lodash.js
var require_lodash3 = __commonJS((exports) => {
  var noop = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isArguments = exports.defaults = exports.noop = undefined;
  var defaults = require_lodash();
  exports.defaults = defaults;
  var isArguments = require_lodash2();
  exports.isArguments = isArguments;
  exports.noop = noop;
});

// node_modules/ms/index.js
var require_ms = __commonJS((exports, module) => {
  var parse = function(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || "ms").toLowerCase();
    switch (type) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return n * y;
      case "weeks":
      case "week":
      case "w":
        return n * w;
      case "days":
      case "day":
      case "d":
        return n * d;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return n * h;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return n * m;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return n * s;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return n;
      default:
        return;
    }
  };
  var fmtShort = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + "d";
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + "h";
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + "m";
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + "s";
    }
    return ms + "ms";
  };
  var fmtLong = function(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, "day");
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, "hour");
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, "minute");
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, "second");
    }
    return ms + " ms";
  };
  var plural = function(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
  };
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === "string" && val.length > 0) {
      return parse(val);
    } else if (type === "number" && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
  };
});

// node_modules/debug/src/common.js
var require_common = __commonJS((exports, module) => {
  var setup = function(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require_ms();
    createDebug.destroy = destroy;
    Object.keys(env).forEach((key) => {
      createDebug[key] = env[key];
    });
    createDebug.names = [];
    createDebug.skips = [];
    createDebug.formatters = {};
    function selectColor(namespace) {
      let hash = 0;
      for (let i = 0;i < namespace.length; i++) {
        hash = (hash << 5) - hash + namespace.charCodeAt(i);
        hash |= 0;
      }
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
      let namespacesCache;
      let enabledCache;
      function debug(...args) {
        if (!debug.enabled) {
          return;
        }
        const self2 = debug;
        const curr = Number(new Date);
        const ms = curr - (prevTime || curr);
        self2.diff = ms;
        self2.prev = prevTime;
        self2.curr = curr;
        prevTime = curr;
        args[0] = createDebug.coerce(args[0]);
        if (typeof args[0] !== "string") {
          args.unshift("%O");
        }
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          if (match === "%%") {
            return "%";
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === "function") {
            const val = args[index];
            match = formatter.call(self2, val);
            args.splice(index, 1);
            index--;
          }
          return match;
        });
        createDebug.formatArgs.call(self2, args);
        const logFn = self2.log || createDebug.log;
        logFn.apply(self2, args);
      }
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy;
      Object.defineProperty(debug, "enabled", {
        enumerable: true,
        configurable: false,
        get: () => {
          if (enableOverride !== null) {
            return enableOverride;
          }
          if (namespacesCache !== createDebug.namespaces) {
            namespacesCache = createDebug.namespaces;
            enabledCache = createDebug.enabled(namespace);
          }
          return enabledCache;
        },
        set: (v) => {
          enableOverride = v;
        }
      });
      if (typeof createDebug.init === "function") {
        createDebug.init(debug);
      }
      return debug;
    }
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
    function enable(namespaces) {
      createDebug.save(namespaces);
      createDebug.namespaces = namespaces;
      createDebug.names = [];
      createDebug.skips = [];
      let i;
      const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
      const len = split.length;
      for (i = 0;i < len; i++) {
        if (!split[i]) {
          continue;
        }
        namespaces = split[i].replace(/\*/g, ".*?");
        if (namespaces[0] === "-") {
          createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
        } else {
          createDebug.names.push(new RegExp("^" + namespaces + "$"));
        }
      }
    }
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
      ].join(",");
      createDebug.enable("");
      return namespaces;
    }
    function enabled(name) {
      if (name[name.length - 1] === "*") {
        return true;
      }
      let i;
      let len;
      for (i = 0, len = createDebug.skips.length;i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
      for (i = 0, len = createDebug.names.length;i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
      return false;
    }
    function toNamespace(regexp) {
      return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
    }
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
    function destroy() {
      console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    }
    createDebug.enable(createDebug.load());
    return createDebug;
  };
  module.exports = setup;
});

// node_modules/debug/src/browser.js
var require_browser = __commonJS((exports, module) => {
  var useColors = function() {
    if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
      return true;
    }
    if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
    return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31 || typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
  };
  var formatArgs = function(args) {
    args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + exports.humanize(this.diff);
    if (!this.useColors) {
      return;
    }
    const c = "color: " + this.color;
    args.splice(1, 0, c, "color: inherit");
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, (match) => {
      if (match === "%%") {
        return;
      }
      index++;
      if (match === "%c") {
        lastC = index;
      }
    });
    args.splice(lastC, 0, c);
  };
  var save = function(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem("debug", namespaces);
      } else {
        exports.storage.removeItem("debug");
      }
    } catch (error) {
    }
  };
  var load = function() {
    let r;
    try {
      r = exports.storage.getItem("debug");
    } catch (error) {
    }
    if (!r && typeof process !== "undefined" && "env" in process) {
      r = process.env.DEBUG;
    }
    return r;
  };
  var localstorage = function() {
    try {
      return localStorage;
    } catch (error) {
    }
  };
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
    return () => {
      if (!warned) {
        warned = true;
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
    };
  })();
  exports.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33"
  ];
  exports.log = console.debug || console.log || (() => {
  });
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.j = function(v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return "[UnexpectedJSONParseError]: " + error.message;
    }
  };
});

// node_modules/has-flag/index.js
var require_has_flag = __commonJS((exports, module) => {
  module.exports = (flag, argv = process.argv) => {
    const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
    const position = argv.indexOf(prefix + flag);
    const terminatorPosition = argv.indexOf("--");
    return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
  };
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS((exports, module) => {
  var translateLevel = function(level) {
    if (level === 0) {
      return false;
    }
    return {
      level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  };
  var supportsColor = function(haveStream, streamIsTTY) {
    if (forceColor === 0) {
      return 0;
    }
    if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
      return 3;
    }
    if (hasFlag("color=256")) {
      return 2;
    }
    if (haveStream && !streamIsTTY && forceColor === undefined) {
      return 0;
    }
    const min = forceColor || 0;
    if (env.TERM === "dumb") {
      return min;
    }
    if (process.platform === "win32") {
      const osRelease = os.release().split(".");
      if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }
      return 1;
    }
    if ("CI" in env) {
      if (["TRAVIS", "CIRCLECI", "APPVEYOR", "GITLAB_CI", "GITHUB_ACTIONS", "BUILDKITE"].some((sign) => (sign in env)) || env.CI_NAME === "codeship") {
        return 1;
      }
      return min;
    }
    if ("TEAMCITY_VERSION" in env) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env.TEAMCITY_VERSION) ? 1 : 0;
    }
    if (env.COLORTERM === "truecolor") {
      return 3;
    }
    if ("TERM_PROGRAM" in env) {
      const version = parseInt((env.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
      switch (env.TERM_PROGRAM) {
        case "iTerm.app":
          return version >= 3 ? 3 : 2;
        case "Apple_Terminal":
          return 2;
      }
    }
    if (/-256(color)?$/i.test(env.TERM)) {
      return 2;
    }
    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env.TERM)) {
      return 1;
    }
    if ("COLORTERM" in env) {
      return 1;
    }
    return min;
  };
  var getSupportLevel = function(stream) {
    const level = supportsColor(stream, stream && stream.isTTY);
    return translateLevel(level);
  };
  var os = import.meta.require("os");
  var tty = import.meta.require("tty");
  var hasFlag = require_has_flag();
  var { env } = process;
  var forceColor;
  if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
    forceColor = 0;
  } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
    forceColor = 1;
  }
  if ("FORCE_COLOR" in env) {
    if (env.FORCE_COLOR === "true") {
      forceColor = 1;
    } else if (env.FORCE_COLOR === "false") {
      forceColor = 0;
    } else {
      forceColor = env.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env.FORCE_COLOR, 10), 3);
    }
  }
  module.exports = {
    supportsColor: getSupportLevel,
    stdout: translateLevel(supportsColor(true, tty.isatty(1))),
    stderr: translateLevel(supportsColor(true, tty.isatty(2)))
  };
});

// node_modules/debug/src/node.js
var require_node = __commonJS((exports, module) => {
  var useColors = function() {
    return "colors" in exports.inspectOpts ? Boolean(exports.inspectOpts.colors) : tty.isatty(process.stderr.fd);
  };
  var formatArgs = function(args) {
    const { namespace: name, useColors: useColors2 } = this;
    if (useColors2) {
      const c = this.color;
      const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
      const prefix = `  ${colorCode};1m${name} \x1B[0m`;
      args[0] = prefix + args[0].split("\n").join("\n" + prefix);
      args.push(colorCode + "m+" + exports.humanize(this.diff) + "\x1B[0m");
    } else {
      args[0] = getDate() + name + " " + args[0];
    }
  };
  var getDate = function() {
    if (exports.inspectOpts.hideDate) {
      return "";
    }
    return new Date().toISOString() + " ";
  };
  var log = function(...args) {
    return process.stderr.write(util.format(...args) + "\n");
  };
  var save = function(namespaces) {
    if (namespaces) {
      process.env.DEBUG = namespaces;
    } else {
      delete process.env.DEBUG;
    }
  };
  var load = function() {
    return process.env.DEBUG;
  };
  var init = function(debug) {
    debug.inspectOpts = {};
    const keys = Object.keys(exports.inspectOpts);
    for (let i = 0;i < keys.length; i++) {
      debug.inspectOpts[keys[i]] = exports.inspectOpts[keys[i]];
    }
  };
  var tty = import.meta.require("tty");
  var util = import.meta.require("util");
  exports.init = init;
  exports.log = log;
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.destroy = util.deprecate(() => {
  }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
  exports.colors = [6, 2, 3, 4, 5, 1];
  try {
    const supportsColor = require_supports_color();
    if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
      exports.colors = [
        20,
        21,
        26,
        27,
        32,
        33,
        38,
        39,
        40,
        41,
        42,
        43,
        44,
        45,
        56,
        57,
        62,
        63,
        68,
        69,
        74,
        75,
        76,
        77,
        78,
        79,
        80,
        81,
        92,
        93,
        98,
        99,
        112,
        113,
        128,
        129,
        134,
        135,
        148,
        149,
        160,
        161,
        162,
        163,
        164,
        165,
        166,
        167,
        168,
        169,
        170,
        171,
        172,
        173,
        178,
        179,
        184,
        185,
        196,
        197,
        198,
        199,
        200,
        201,
        202,
        203,
        204,
        205,
        206,
        207,
        208,
        209,
        214,
        215,
        220,
        221
      ];
    }
  } catch (error) {
  }
  exports.inspectOpts = Object.keys(process.env).filter((key) => {
    return /^debug_/i.test(key);
  }).reduce((obj, key) => {
    const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
      return k.toUpperCase();
    });
    let val = process.env[key];
    if (/^(yes|on|true|enabled)$/i.test(val)) {
      val = true;
    } else if (/^(no|off|false|disabled)$/i.test(val)) {
      val = false;
    } else if (val === "null") {
      val = null;
    } else {
      val = Number(val);
    }
    obj[prop] = val;
    return obj;
  }, {});
  module.exports = require_common()(exports);
  var { formatters } = module.exports;
  formatters.o = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
  };
  formatters.O = function(v) {
    this.inspectOpts.colors = this.useColors;
    return util.inspect(v, this.inspectOpts);
  };
});

// node_modules/debug/src/index.js
var require_src = __commonJS((exports, module) => {
  if (typeof process === "undefined" || process.type === "renderer" || false || process.__nwjs) {
    module.exports = require_browser();
  } else {
    module.exports = require_node();
  }
});

// node_modules/ioredis/built/utils/debug.js
var require_debug = __commonJS((exports) => {
  var getStringValue = function(v) {
    if (v === null) {
      return;
    }
    switch (typeof v) {
      case "boolean":
        return;
      case "number":
        return;
      case "object":
        if (Buffer.isBuffer(v)) {
          return v.toString("hex");
        }
        if (Array.isArray(v)) {
          return v.join(",");
        }
        try {
          return JSON.stringify(v);
        } catch (e) {
          return;
        }
      case "string":
        return v;
    }
  };
  var genRedactedString = function(str, maxLen) {
    const { length } = str;
    return length <= maxLen ? str : str.slice(0, maxLen) + ' ... <REDACTED full-length="' + length + '">';
  };
  var genDebugFunction = function(namespace) {
    const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);
    function wrappedDebug(...args) {
      if (!fn.enabled) {
        return;
      }
      for (let i = 1;i < args.length; i++) {
        const str = getStringValue(args[i]);
        if (typeof str === "string" && str.length > MAX_ARGUMENT_LENGTH) {
          args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);
        }
      }
      return fn.apply(null, args);
    }
    Object.defineProperties(wrappedDebug, {
      namespace: {
        get() {
          return fn.namespace;
        }
      },
      enabled: {
        get() {
          return fn.enabled;
        }
      },
      destroy: {
        get() {
          return fn.destroy;
        }
      },
      log: {
        get() {
          return fn.log;
        },
        set(l) {
          fn.log = l;
        }
      }
    });
    return wrappedDebug;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = undefined;
  var debug_1 = require_src();
  var MAX_ARGUMENT_LENGTH = 200;
  exports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;
  var NAMESPACE_PREFIX = "ioredis";
  exports.getStringValue = getStringValue;
  exports.genRedactedString = genRedactedString;
  exports.default = genDebugFunction;
});

// node_modules/ioredis/built/constants/TLSProfiles.js
var require_TLSProfiles = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var RedisCloudCA = `-----BEGIN CERTIFICATE-----
MIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV
BAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1
dGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP
JnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz
rmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E
QwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2
BDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3
TMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp
4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w
MB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w
DQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta
lbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6
Su8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ
uFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k
BpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp
Z4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx
CzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w
KwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN
MTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG
A1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy
bWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA
A4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv
Tq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4
VuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym
hjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W
P0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN
r0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw
hhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s
UzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u
P1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9
MjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT
t5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID
AQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy
LnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw
AYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G
A1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4
L2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB
hjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr
AP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW
vcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw
7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+
XoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc
AUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1
jQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh
/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z
zDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli
iF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43
iqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo
616pxqo=
-----END CERTIFICATE-----
-----BEGIN CERTIFICATE-----
MIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV
BAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz
TGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y
aXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC
VVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz
MS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw
ggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1
G5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY
Dm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl
pp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT
ULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag
54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ
xeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC
JpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K
2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3
StsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI
SIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B
cS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL
yzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T
AQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg
z5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu
rYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3
3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+
hSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ
D0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj
TY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l
FXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj
mcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf
ybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji
n8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F
UhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM
MSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv
YmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y
NTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu
IG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy
MDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf
8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD
BVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg
ofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK
dZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh
counQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu
jE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG
CCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW
BBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj
move4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw
Mi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1
cmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w
K6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD
VR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC
AQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/
3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY
0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX
y+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3
15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5
ZgKnO/Fx2hBgTxhOTMYaD312kg==
-----END CERTIFICATE-----

-----BEGIN CERTIFICATE-----
MIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G
A1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp
Z24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4
MTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG
A1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI
hvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8
RgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT
gHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm
KPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd
QQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ
XriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw
DgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o
LkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU
RUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp
jjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK
6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX
mcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs
Mx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH
WD9f
-----END CERTIFICATE-----`;
  var TLSProfiles = {
    RedisCloudFixed: { ca: RedisCloudCA },
    RedisCloudFlexible: { ca: RedisCloudCA }
  };
  exports.default = TLSProfiles;
});

// node_modules/ioredis/built/utils/index.js
var require_utils2 = __commonJS((exports) => {
  var convertBufferToString = function(value, encoding) {
    if (value instanceof Buffer) {
      return value.toString(encoding);
    }
    if (Array.isArray(value)) {
      const length = value.length;
      const res = Array(length);
      for (let i = 0;i < length; ++i) {
        res[i] = value[i] instanceof Buffer && encoding === "utf8" ? value[i].toString() : convertBufferToString(value[i], encoding);
      }
      return res;
    }
    return value;
  };
  var wrapMultiResult = function(arr) {
    if (!arr) {
      return null;
    }
    const result = [];
    const length = arr.length;
    for (let i = 0;i < length; ++i) {
      const item = arr[i];
      if (item instanceof Error) {
        result.push([item]);
      } else {
        result.push([null, item]);
      }
    }
    return result;
  };
  var isInt = function(value) {
    const x = parseFloat(value);
    return !isNaN(value) && (x | 0) === x;
  };
  var packObject = function(array) {
    const result = {};
    const length = array.length;
    for (let i = 1;i < length; i += 2) {
      result[array[i - 1]] = array[i];
    }
    return result;
  };
  var timeout = function(callback, timeout2) {
    let timer = null;
    const run = function() {
      if (timer) {
        clearTimeout(timer);
        timer = null;
        callback.apply(this, arguments);
      }
    };
    timer = setTimeout(run, timeout2, new Error("timeout"));
    return run;
  };
  var convertObjectToArray = function(obj) {
    const result = [];
    const keys = Object.keys(obj);
    for (let i = 0, l = keys.length;i < l; i++) {
      result.push(keys[i], obj[keys[i]]);
    }
    return result;
  };
  var convertMapToArray = function(map) {
    const result = [];
    let pos = 0;
    map.forEach(function(value, key) {
      result[pos] = key;
      result[pos + 1] = value;
      pos += 2;
    });
    return result;
  };
  var toArg = function(arg) {
    if (arg === null || typeof arg === "undefined") {
      return "";
    }
    return String(arg);
  };
  var optimizeErrorStack = function(error, friendlyStack, filterPath) {
    const stacks = friendlyStack.split("\n");
    let lines = "";
    let i;
    for (i = 1;i < stacks.length; ++i) {
      if (stacks[i].indexOf(filterPath) === -1) {
        break;
      }
    }
    for (let j = i;j < stacks.length; ++j) {
      lines += "\n" + stacks[j];
    }
    if (error.stack) {
      const pos = error.stack.indexOf("\n");
      error.stack = error.stack.slice(0, pos) + lines;
    }
    return error;
  };
  var parseURL = function(url) {
    if (isInt(url)) {
      return { port: url };
    }
    let parsed = (0, url_1.parse)(url, true, true);
    if (!parsed.slashes && url[0] !== "/") {
      url = "//" + url;
      parsed = (0, url_1.parse)(url, true, true);
    }
    const options = parsed.query || {};
    const result = {};
    if (parsed.auth) {
      const index = parsed.auth.indexOf(":");
      result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);
      result.password = index === -1 ? "" : parsed.auth.slice(index + 1);
    }
    if (parsed.pathname) {
      if (parsed.protocol === "redis:" || parsed.protocol === "rediss:") {
        if (parsed.pathname.length > 1) {
          result.db = parsed.pathname.slice(1);
        }
      } else {
        result.path = parsed.pathname;
      }
    }
    if (parsed.host) {
      result.host = parsed.hostname;
    }
    if (parsed.port) {
      result.port = parsed.port;
    }
    if (typeof options.family === "string") {
      const intFamily = Number.parseInt(options.family, 10);
      if (!Number.isNaN(intFamily)) {
        result.family = intFamily;
      }
    }
    (0, lodash_1.defaults)(result, options);
    return result;
  };
  var resolveTLSProfile = function(options) {
    let tls = options === null || options === undefined ? undefined : options.tls;
    if (typeof tls === "string")
      tls = { profile: tls };
    const profile = TLSProfiles_1.default[tls === null || tls === undefined ? undefined : tls.profile];
    if (profile) {
      tls = Object.assign({}, profile, tls);
      delete tls.profile;
      options = Object.assign({}, options, { tls });
    }
    return options;
  };
  var sample = function(array, from = 0) {
    const length = array.length;
    if (from >= length) {
      return null;
    }
    return array[from + Math.floor(Math.random() * (length - from))];
  };
  var shuffle = function(array) {
    let counter = array.length;
    while (counter > 0) {
      const index = Math.floor(Math.random() * counter);
      counter--;
      [array[counter], array[index]] = [array[index], array[counter]];
    }
    return array;
  };
  var zipMap = function(keys, values) {
    const map = new Map;
    keys.forEach((key, index) => {
      map.set(key, values[index]);
    });
    return map;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.noop = exports.defaults = exports.Debug = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = undefined;
  var url_1 = import.meta.require("url");
  var lodash_1 = require_lodash3();
  Object.defineProperty(exports, "defaults", { enumerable: true, get: function() {
    return lodash_1.defaults;
  } });
  Object.defineProperty(exports, "noop", { enumerable: true, get: function() {
    return lodash_1.noop;
  } });
  var debug_1 = require_debug();
  exports.Debug = debug_1.default;
  var TLSProfiles_1 = require_TLSProfiles();
  exports.convertBufferToString = convertBufferToString;
  exports.wrapMultiResult = wrapMultiResult;
  exports.isInt = isInt;
  exports.packObject = packObject;
  exports.timeout = timeout;
  exports.convertObjectToArray = convertObjectToArray;
  exports.convertMapToArray = convertMapToArray;
  exports.toArg = toArg;
  exports.optimizeErrorStack = optimizeErrorStack;
  exports.parseURL = parseURL;
  exports.resolveTLSProfile = resolveTLSProfile;
  exports.sample = sample;
  exports.shuffle = shuffle;
  exports.CONNECTION_CLOSED_ERROR_MSG = "Connection is closed.";
  exports.zipMap = zipMap;
});

// node_modules/ioredis/built/Command.js
var require_Command = __commonJS((exports) => {
  var __dirname = "/Users/andrej/Flow/mev/node_modules/ioredis/built";
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var calculateSlot = require_lib();
  var standard_as_callback_1 = require_built2();
  var utils_1 = require_utils2();

  class Command {
    constructor(name, args = [], options = {}, callback) {
      this.name = name;
      this.inTransaction = false;
      this.isResolved = false;
      this.transformed = false;
      this.replyEncoding = options.replyEncoding;
      this.errorStack = options.errorStack;
      this.args = args.flat();
      this.callback = callback;
      this.initPromise();
      if (options.keyPrefix) {
        const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;
        let keyPrefixBuffer = isBufferKeyPrefix ? options.keyPrefix : null;
        this._iterateKeys((key) => {
          if (key instanceof Buffer) {
            if (keyPrefixBuffer === null) {
              keyPrefixBuffer = Buffer.from(options.keyPrefix);
            }
            return Buffer.concat([keyPrefixBuffer, key]);
          } else if (isBufferKeyPrefix) {
            return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);
          }
          return options.keyPrefix + key;
        });
      }
      if (options.readOnly) {
        this.isReadOnly = true;
      }
    }
    static checkFlag(flagName, commandName) {
      return !!this.getFlagMap()[flagName][commandName];
    }
    static setArgumentTransformer(name, func) {
      this._transformer.argument[name] = func;
    }
    static setReplyTransformer(name, func) {
      this._transformer.reply[name] = func;
    }
    static getFlagMap() {
      if (!this.flagMap) {
        this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {
          map[flagName] = {};
          Command.FLAGS[flagName].forEach((commandName) => {
            map[flagName][commandName] = true;
          });
          return map;
        }, {});
      }
      return this.flagMap;
    }
    getSlot() {
      if (typeof this.slot === "undefined") {
        const key = this.getKeys()[0];
        this.slot = key == null ? null : calculateSlot(key);
      }
      return this.slot;
    }
    getKeys() {
      return this._iterateKeys();
    }
    toWritable(_socket) {
      let result;
      const commandStr = "*" + (this.args.length + 1) + "\r\n$" + Buffer.byteLength(this.name) + "\r\n" + this.name + "\r\n";
      if (this.bufferMode) {
        const buffers = new MixedBuffers;
        buffers.push(commandStr);
        for (let i = 0;i < this.args.length; ++i) {
          const arg = this.args[i];
          if (arg instanceof Buffer) {
            if (arg.length === 0) {
              buffers.push("$0\r\n\r\n");
            } else {
              buffers.push("$" + arg.length + "\r\n");
              buffers.push(arg);
              buffers.push("\r\n");
            }
          } else {
            buffers.push("$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n");
          }
        }
        result = buffers.toBuffer();
      } else {
        result = commandStr;
        for (let i = 0;i < this.args.length; ++i) {
          const arg = this.args[i];
          result += "$" + Buffer.byteLength(arg) + "\r\n" + arg + "\r\n";
        }
      }
      return result;
    }
    stringifyArguments() {
      for (let i = 0;i < this.args.length; ++i) {
        const arg = this.args[i];
        if (typeof arg === "string") {
        } else if (arg instanceof Buffer) {
          this.bufferMode = true;
        } else {
          this.args[i] = (0, utils_1.toArg)(arg);
        }
      }
    }
    transformReply(result) {
      if (this.replyEncoding) {
        result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);
      }
      const transformer = Command._transformer.reply[this.name];
      if (transformer) {
        result = transformer(result);
      }
      return result;
    }
    setTimeout(ms) {
      if (!this._commandTimeoutTimer) {
        this._commandTimeoutTimer = setTimeout(() => {
          if (!this.isResolved) {
            this.reject(new Error("Command timed out"));
          }
        }, ms);
      }
    }
    initPromise() {
      const promise = new Promise((resolve, reject) => {
        if (!this.transformed) {
          this.transformed = true;
          const transformer = Command._transformer.argument[this.name];
          if (transformer) {
            this.args = transformer(this.args);
          }
          this.stringifyArguments();
        }
        this.resolve = this._convertValue(resolve);
        if (this.errorStack) {
          this.reject = (err) => {
            reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));
          };
        } else {
          this.reject = reject;
        }
      });
      this.promise = (0, standard_as_callback_1.default)(promise, this.callback);
    }
    _iterateKeys(transform = (key) => key) {
      if (typeof this.keys === "undefined") {
        this.keys = [];
        if ((0, commands_1.exists)(this.name)) {
          const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);
          for (const index of keyIndexes) {
            this.args[index] = transform(this.args[index]);
            this.keys.push(this.args[index]);
          }
        }
      }
      return this.keys;
    }
    _convertValue(resolve) {
      return (value) => {
        try {
          const existingTimer = this._commandTimeoutTimer;
          if (existingTimer) {
            clearTimeout(existingTimer);
            delete this._commandTimeoutTimer;
          }
          resolve(this.transformReply(value));
          this.isResolved = true;
        } catch (err) {
          this.reject(err);
        }
        return this.promise;
      };
    }
  }
  exports.default = Command;
  Command.FLAGS = {
    VALID_IN_SUBSCRIBER_MODE: [
      "subscribe",
      "psubscribe",
      "unsubscribe",
      "punsubscribe",
      "ssubscribe",
      "sunsubscribe",
      "ping",
      "quit"
    ],
    VALID_IN_MONITOR_MODE: ["monitor", "auth"],
    ENTER_SUBSCRIBER_MODE: ["subscribe", "psubscribe", "ssubscribe"],
    EXIT_SUBSCRIBER_MODE: ["unsubscribe", "punsubscribe", "sunsubscribe"],
    WILL_DISCONNECT: ["quit"]
  };
  Command._transformer = {
    argument: {},
    reply: {}
  };
  var msetArgumentTransformer = function(args) {
    if (args.length === 1) {
      if (args[0] instanceof Map) {
        return (0, utils_1.convertMapToArray)(args[0]);
      }
      if (typeof args[0] === "object" && args[0] !== null) {
        return (0, utils_1.convertObjectToArray)(args[0]);
      }
    }
    return args;
  };
  var hsetArgumentTransformer = function(args) {
    if (args.length === 2) {
      if (args[1] instanceof Map) {
        return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));
      }
      if (typeof args[1] === "object" && args[1] !== null) {
        return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));
      }
    }
    return args;
  };
  Command.setArgumentTransformer("mset", msetArgumentTransformer);
  Command.setArgumentTransformer("msetnx", msetArgumentTransformer);
  Command.setArgumentTransformer("hset", hsetArgumentTransformer);
  Command.setArgumentTransformer("hmset", hsetArgumentTransformer);
  Command.setReplyTransformer("hgetall", function(result) {
    if (Array.isArray(result)) {
      const obj = {};
      for (let i = 0;i < result.length; i += 2) {
        const key = result[i];
        const value = result[i + 1];
        if (key in obj) {
          Object.defineProperty(obj, key, {
            value,
            configurable: true,
            enumerable: true,
            writable: true
          });
        } else {
          obj[key] = value;
        }
      }
      return obj;
    }
    return result;
  });

  class MixedBuffers {
    constructor() {
      this.length = 0;
      this.items = [];
    }
    push(x) {
      this.length += Buffer.byteLength(x);
      this.items.push(x);
    }
    toBuffer() {
      const result = Buffer.allocUnsafe(this.length);
      let offset = 0;
      for (const item of this.items) {
        const length = Buffer.byteLength(item);
        Buffer.isBuffer(item) ? item.copy(result, offset) : result.write(item, offset, length);
        offset += length;
      }
      return result;
    }
  }
});

// node_modules/ioredis/built/errors/ClusterAllFailedError.js
var require_ClusterAllFailedError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();

  class ClusterAllFailedError extends redis_errors_1.RedisError {
    constructor(message, lastNodeError) {
      super(message);
      this.lastNodeError = lastNodeError;
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
  }
  exports.default = ClusterAllFailedError;
  ClusterAllFailedError.defaultMessage = "Failed to refresh slots cache.";
});

// node_modules/ioredis/built/ScanStream.js
var require_ScanStream = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream_1 = import.meta.require("stream");

  class ScanStream extends stream_1.Readable {
    constructor(opt) {
      super(opt);
      this.opt = opt;
      this._redisCursor = "0";
      this._redisDrained = false;
    }
    _read() {
      if (this._redisDrained) {
        this.push(null);
        return;
      }
      const args = [this._redisCursor];
      if (this.opt.key) {
        args.unshift(this.opt.key);
      }
      if (this.opt.match) {
        args.push("MATCH", this.opt.match);
      }
      if (this.opt.type) {
        args.push("TYPE", this.opt.type);
      }
      if (this.opt.count) {
        args.push("COUNT", String(this.opt.count));
      }
      this.opt.redis[this.opt.command](args, (err, res) => {
        if (err) {
          this.emit("error", err);
          return;
        }
        this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];
        if (this._redisCursor === "0") {
          this._redisDrained = true;
        }
        this.push(res[1]);
      });
    }
    close() {
      this._redisDrained = true;
    }
  }
  exports.default = ScanStream;
});

// node_modules/ioredis/built/autoPipelining.js
var require_autoPipelining = __commonJS((exports) => {
  var executeAutoPipeline = function(client, slotKey) {
    if (client._runningAutoPipelines.has(slotKey)) {
      return;
    }
    if (!client._autoPipelines.has(slotKey)) {
      return;
    }
    client._runningAutoPipelines.add(slotKey);
    const pipeline = client._autoPipelines.get(slotKey);
    client._autoPipelines.delete(slotKey);
    const callbacks = pipeline[exports.kCallbacks];
    pipeline[exports.kCallbacks] = null;
    pipeline.exec(function(err, results) {
      client._runningAutoPipelines.delete(slotKey);
      if (err) {
        for (let i = 0;i < callbacks.length; i++) {
          process.nextTick(callbacks[i], err);
        }
      } else {
        for (let i = 0;i < callbacks.length; i++) {
          process.nextTick(callbacks[i], ...results[i]);
        }
      }
      if (client._autoPipelines.has(slotKey)) {
        executeAutoPipeline(client, slotKey);
      }
    });
  };
  var shouldUseAutoPipelining = function(client, functionName, commandName) {
    return functionName && client.options.enableAutoPipelining && !client.isPipeline && !exports.notAllowedAutoPipelineCommands.includes(commandName) && !client.options.autoPipeliningIgnoredCommands.includes(commandName);
  };
  var getFirstValueInFlattenedArray = function(args) {
    for (let i = 0;i < args.length; i++) {
      const arg = args[i];
      if (typeof arg === "string") {
        return arg;
      } else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {
        if (arg.length === 0) {
          continue;
        }
        return arg[0];
      }
      const flattened = [arg].flat();
      if (flattened.length > 0) {
        return flattened[0];
      }
    }
    return;
  };
  var executeWithAutoPipelining = function(client, functionName, commandName, args, callback) {
    if (client.isCluster && !client.slots.length) {
      if (client.status === "wait")
        client.connect().catch(lodash_1.noop);
      return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {
        client.delayUntilReady((err) => {
          if (err) {
            reject(err);
            return;
          }
          executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);
        });
      }), callback);
    }
    const prefix = client.options.keyPrefix || "";
    const slotKey = client.isCluster ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(",") : "main";
    if (!client._autoPipelines.has(slotKey)) {
      const pipeline2 = client.pipeline();
      pipeline2[exports.kExec] = false;
      pipeline2[exports.kCallbacks] = [];
      client._autoPipelines.set(slotKey, pipeline2);
    }
    const pipeline = client._autoPipelines.get(slotKey);
    if (!pipeline[exports.kExec]) {
      pipeline[exports.kExec] = true;
      setImmediate(executeAutoPipeline, client, slotKey);
    }
    const autoPipelinePromise = new Promise(function(resolve, reject) {
      pipeline[exports.kCallbacks].push(function(err, value) {
        if (err) {
          reject(err);
          return;
        }
        resolve(value);
      });
      if (functionName === "call") {
        args.unshift(commandName);
      }
      pipeline[functionName](...args);
    });
    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = undefined;
  var lodash_1 = require_lodash3();
  var calculateSlot = require_lib();
  var standard_as_callback_1 = require_built2();
  exports.kExec = Symbol("exec");
  exports.kCallbacks = Symbol("callbacks");
  exports.notAllowedAutoPipelineCommands = [
    "auth",
    "info",
    "script",
    "quit",
    "cluster",
    "pipeline",
    "multi",
    "subscribe",
    "psubscribe",
    "unsubscribe",
    "unpsubscribe",
    "select"
  ];
  exports.shouldUseAutoPipelining = shouldUseAutoPipelining;
  exports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;
  exports.executeWithAutoPipelining = executeWithAutoPipelining;
});

// node_modules/ioredis/built/Script.js
var require_Script = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto_1 = import.meta.require("crypto");
  var Command_1 = require_Command();
  var standard_as_callback_1 = require_built2();

  class Script {
    constructor(lua, numberOfKeys = null, keyPrefix = "", readOnly = false) {
      this.lua = lua;
      this.numberOfKeys = numberOfKeys;
      this.keyPrefix = keyPrefix;
      this.readOnly = readOnly;
      this.sha = (0, crypto_1.createHash)("sha1").update(lua).digest("hex");
      const sha = this.sha;
      const socketHasScriptLoaded = new WeakSet;
      this.Command = class CustomScriptCommand extends Command_1.default {
        toWritable(socket) {
          const origReject = this.reject;
          this.reject = (err) => {
            if (err.message.indexOf("NOSCRIPT") !== -1) {
              socketHasScriptLoaded.delete(socket);
            }
            origReject.call(this, err);
          };
          if (!socketHasScriptLoaded.has(socket)) {
            socketHasScriptLoaded.add(socket);
            this.name = "eval";
            this.args[0] = lua;
          } else if (this.name === "eval") {
            this.name = "evalsha";
            this.args[0] = sha;
          }
          return super.toWritable(socket);
        }
      };
    }
    execute(container, args, options, callback) {
      if (typeof this.numberOfKeys === "number") {
        args.unshift(this.numberOfKeys);
      }
      if (this.keyPrefix) {
        options.keyPrefix = this.keyPrefix;
      }
      if (this.readOnly) {
        options.readOnly = true;
      }
      const evalsha = new this.Command("evalsha", [this.sha, ...args], options);
      evalsha.promise = evalsha.promise.catch((err) => {
        if (err.message.indexOf("NOSCRIPT") === -1) {
          throw err;
        }
        const resend = new this.Command("evalsha", [this.sha, ...args], options);
        const client = container.isPipeline ? container.redis : container;
        return client.sendCommand(resend);
      });
      (0, standard_as_callback_1.default)(evalsha.promise, callback);
      return container.sendCommand(evalsha);
    }
  }
  exports.default = Script;
});

// node_modules/ioredis/built/utils/Commander.js
var require_Commander = __commonJS((exports) => {
  var generateFunction = function(functionName, _commandName, _encoding) {
    if (typeof _encoding === "undefined") {
      _encoding = _commandName;
      _commandName = null;
    }
    return function(...args) {
      const commandName = _commandName || args.shift();
      let callback = args[args.length - 1];
      if (typeof callback === "function") {
        args.pop();
      } else {
        callback = undefined;
      }
      const options = {
        errorStack: this.options.showFriendlyErrorStack ? new Error : undefined,
        keyPrefix: this.options.keyPrefix,
        replyEncoding: _encoding
      };
      if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
        return this.sendCommand(new Command_1.default(commandName, args, options, callback));
      }
      return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);
    };
  };
  var generateScriptingFunction = function(functionName, commandName, script, encoding) {
    return function(...args) {
      const callback = typeof args[args.length - 1] === "function" ? args.pop() : undefined;
      const options = {
        replyEncoding: encoding
      };
      if (this.options.showFriendlyErrorStack) {
        options.errorStack = new Error;
      }
      if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {
        return script.execute(this, args, options, callback);
      }
      return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var autoPipelining_1 = require_autoPipelining();
  var Command_1 = require_Command();
  var Script_1 = require_Script();

  class Commander {
    constructor() {
      this.options = {};
      this.scriptsSet = {};
      this.addedBuiltinSet = new Set;
    }
    getBuiltinCommands() {
      return commands.slice(0);
    }
    createBuiltinCommand(commandName) {
      return {
        string: generateFunction(null, commandName, "utf8"),
        buffer: generateFunction(null, commandName, null)
      };
    }
    addBuiltinCommand(commandName) {
      this.addedBuiltinSet.add(commandName);
      this[commandName] = generateFunction(commandName, commandName, "utf8");
      this[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
    }
    defineCommand(name, definition) {
      const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);
      this.scriptsSet[name] = script;
      this[name] = generateScriptingFunction(name, name, script, "utf8");
      this[name + "Buffer"] = generateScriptingFunction(name + "Buffer", name, script, null);
    }
    sendCommand(command, stream, node) {
      throw new Error('"sendCommand" is not implemented');
    }
  }
  var commands = commands_1.list.filter((command) => command !== "monitor");
  commands.push("sentinel");
  commands.forEach(function(commandName) {
    Commander.prototype[commandName] = generateFunction(commandName, commandName, "utf8");
    Commander.prototype[commandName + "Buffer"] = generateFunction(commandName + "Buffer", commandName, null);
  });
  Commander.prototype.call = generateFunction("call", "utf8");
  Commander.prototype.callBuffer = generateFunction("callBuffer", null);
  Commander.prototype.send_command = Commander.prototype.call;
  exports.default = Commander;
});

// node_modules/ioredis/built/Pipeline.js
var require_Pipeline = __commonJS((exports) => {
  var generateMultiWithNodes = function(redis, keys) {
    const slot = calculateSlot(keys[0]);
    const target = redis._groupsBySlot[slot];
    for (let i = 1;i < keys.length; i++) {
      if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {
        return -1;
      }
    }
    return slot;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var calculateSlot = require_lib();
  var commands_1 = require_built();
  var standard_as_callback_1 = require_built2();
  var util_1 = import.meta.require("util");
  var Command_1 = require_Command();
  var utils_1 = require_utils2();
  var Commander_1 = require_Commander();

  class Pipeline extends Commander_1.default {
    constructor(redis) {
      super();
      this.redis = redis;
      this.isPipeline = true;
      this.replyPending = 0;
      this._queue = [];
      this._result = [];
      this._transactions = 0;
      this._shaToScript = {};
      this.isCluster = this.redis.constructor.name === "Cluster" || this.redis.isCluster;
      this.options = redis.options;
      Object.keys(redis.scriptsSet).forEach((name) => {
        const script = redis.scriptsSet[name];
        this._shaToScript[script.sha] = script;
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      redis.addedBuiltinSet.forEach((name) => {
        this[name] = redis[name];
        this[name + "Buffer"] = redis[name + "Buffer"];
      });
      this.promise = new Promise((resolve, reject) => {
        this.resolve = resolve;
        this.reject = reject;
      });
      const _this = this;
      Object.defineProperty(this, "length", {
        get: function() {
          return _this._queue.length;
        }
      });
    }
    fillResult(value, position) {
      if (this._queue[position].name === "exec" && Array.isArray(value[1])) {
        const execLength = value[1].length;
        for (let i = 0;i < execLength; i++) {
          if (value[1][i] instanceof Error) {
            continue;
          }
          const cmd = this._queue[position - (execLength - i)];
          try {
            value[1][i] = cmd.transformReply(value[1][i]);
          } catch (err) {
            value[1][i] = err;
          }
        }
      }
      this._result[position] = value;
      if (--this.replyPending) {
        return;
      }
      if (this.isCluster) {
        let retriable = true;
        let commonError;
        for (let i = 0;i < this._result.length; ++i) {
          const error = this._result[i][0];
          const command = this._queue[i];
          if (error) {
            if (command.name === "exec" && error.message === "EXECABORT Transaction discarded because of previous errors.") {
              continue;
            }
            if (!commonError) {
              commonError = {
                name: error.name,
                message: error.message
              };
            } else if (commonError.name !== error.name || commonError.message !== error.message) {
              retriable = false;
              break;
            }
          } else if (!command.inTransaction) {
            const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "readonly");
            if (!isReadOnly) {
              retriable = false;
              break;
            }
          }
        }
        if (commonError && retriable) {
          const _this = this;
          const errv = commonError.message.split(" ");
          const queue = this._queue;
          let inTransaction = false;
          this._queue = [];
          for (let i = 0;i < queue.length; ++i) {
            if (errv[0] === "ASK" && !inTransaction && queue[i].name !== "asking" && (!queue[i - 1] || queue[i - 1].name !== "asking")) {
              const asking = new Command_1.default("asking");
              asking.ignore = true;
              this.sendCommand(asking);
            }
            queue[i].initPromise();
            this.sendCommand(queue[i]);
            inTransaction = queue[i].inTransaction;
          }
          let matched = true;
          if (typeof this.leftRedirections === "undefined") {
            this.leftRedirections = {};
          }
          const exec = function() {
            _this.exec();
          };
          const cluster = this.redis;
          cluster.handleError(commonError, this.leftRedirections, {
            moved: function(_slot, key) {
              _this.preferKey = key;
              cluster.slots[errv[1]] = [key];
              cluster._groupsBySlot[errv[1]] = cluster._groupsIds[cluster.slots[errv[1]].join(";")];
              cluster.refreshSlotsCache();
              _this.exec();
            },
            ask: function(_slot, key) {
              _this.preferKey = key;
              _this.exec();
            },
            tryagain: exec,
            clusterDown: exec,
            connectionClosed: exec,
            maxRedirections: () => {
              matched = false;
            },
            defaults: () => {
              matched = false;
            }
          });
          if (matched) {
            return;
          }
        }
      }
      let ignoredCount = 0;
      for (let i = 0;i < this._queue.length - ignoredCount; ++i) {
        if (this._queue[i + ignoredCount].ignore) {
          ignoredCount += 1;
        }
        this._result[i] = this._result[i + ignoredCount];
      }
      this.resolve(this._result.slice(0, this._result.length - ignoredCount));
    }
    sendCommand(command) {
      if (this._transactions > 0) {
        command.inTransaction = true;
      }
      const position = this._queue.length;
      command.pipelineIndex = position;
      command.promise.then((result) => {
        this.fillResult([null, result], position);
      }).catch((error) => {
        this.fillResult([error], position);
      });
      this._queue.push(command);
      return this;
    }
    addBatch(commands) {
      let command, commandName, args;
      for (let i = 0;i < commands.length; ++i) {
        command = commands[i];
        commandName = command[0];
        args = command.slice(1);
        this[commandName].apply(this, args);
      }
      return this;
    }
  }
  exports.default = Pipeline;
  var multi = Pipeline.prototype.multi;
  Pipeline.prototype.multi = function() {
    this._transactions += 1;
    return multi.apply(this, arguments);
  };
  var execBuffer = Pipeline.prototype.execBuffer;
  Pipeline.prototype.execBuffer = (0, util_1.deprecate)(function() {
    if (this._transactions > 0) {
      this._transactions -= 1;
    }
    return execBuffer.apply(this, arguments);
  }, "Pipeline#execBuffer: Use Pipeline#exec instead");
  Pipeline.prototype.exec = function(callback) {
    if (this.isCluster && !this.redis.slots.length) {
      if (this.redis.status === "wait")
        this.redis.connect().catch(utils_1.noop);
      if (callback && !this.nodeifiedPromise) {
        this.nodeifiedPromise = true;
        (0, standard_as_callback_1.default)(this.promise, callback);
      }
      this.redis.delayUntilReady((err) => {
        if (err) {
          this.reject(err);
          return;
        }
        this.exec(callback);
      });
      return this.promise;
    }
    if (this._transactions > 0) {
      this._transactions -= 1;
      return execBuffer.apply(this, arguments);
    }
    if (!this.nodeifiedPromise) {
      this.nodeifiedPromise = true;
      (0, standard_as_callback_1.default)(this.promise, callback);
    }
    if (!this._queue.length) {
      this.resolve([]);
    }
    let pipelineSlot;
    if (this.isCluster) {
      const sampleKeys = [];
      for (let i = 0;i < this._queue.length; i++) {
        const keys = this._queue[i].getKeys();
        if (keys.length) {
          sampleKeys.push(keys[0]);
        }
        if (keys.length && calculateSlot.generateMulti(keys) < 0) {
          this.reject(new Error("All the keys in a pipeline command should belong to the same slot"));
          return this.promise;
        }
      }
      if (sampleKeys.length) {
        pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);
        if (pipelineSlot < 0) {
          this.reject(new Error("All keys in the pipeline should belong to the same slots allocation group"));
          return this.promise;
        }
      } else {
        pipelineSlot = Math.random() * 16384 | 0;
      }
    }
    const _this = this;
    execPipeline();
    return this.promise;
    function execPipeline() {
      let writePending = _this.replyPending = _this._queue.length;
      let node;
      if (_this.isCluster) {
        node = {
          slot: pipelineSlot,
          redis: _this.redis.connectionPool.nodes.all[_this.preferKey]
        };
      }
      let data = "";
      let buffers;
      const stream = {
        isPipeline: true,
        destination: _this.isCluster ? node : { redis: _this.redis },
        write(writable) {
          if (typeof writable !== "string") {
            if (!buffers) {
              buffers = [];
            }
            if (data) {
              buffers.push(Buffer.from(data, "utf8"));
              data = "";
            }
            buffers.push(writable);
          } else {
            data += writable;
          }
          if (!--writePending) {
            if (buffers) {
              if (data) {
                buffers.push(Buffer.from(data, "utf8"));
              }
              stream.destination.redis.stream.write(Buffer.concat(buffers));
            } else {
              stream.destination.redis.stream.write(data);
            }
            writePending = _this._queue.length;
            data = "";
            buffers = undefined;
          }
        }
      };
      for (let i = 0;i < _this._queue.length; ++i) {
        _this.redis.sendCommand(_this._queue[i], stream, node);
      }
      return _this.promise;
    }
  };
});

// node_modules/ioredis/built/transaction.js
var require_transaction = __commonJS((exports) => {
  var addTransactionSupport = function(redis) {
    redis.pipeline = function(commands) {
      const pipeline = new Pipeline_1.default(this);
      if (Array.isArray(commands)) {
        pipeline.addBatch(commands);
      }
      return pipeline;
    };
    const { multi } = redis;
    redis.multi = function(commands, options) {
      if (typeof options === "undefined" && !Array.isArray(commands)) {
        options = commands;
        commands = null;
      }
      if (options && options.pipeline === false) {
        return multi.call(this);
      }
      const pipeline = new Pipeline_1.default(this);
      pipeline.multi();
      if (Array.isArray(commands)) {
        pipeline.addBatch(commands);
      }
      const exec2 = pipeline.exec;
      pipeline.exec = function(callback) {
        if (this.isCluster && !this.redis.slots.length) {
          if (this.redis.status === "wait")
            this.redis.connect().catch(utils_1.noop);
          return (0, standard_as_callback_1.default)(new Promise((resolve, reject) => {
            this.redis.delayUntilReady((err) => {
              if (err) {
                reject(err);
                return;
              }
              this.exec(pipeline).then(resolve, reject);
            });
          }), callback);
        }
        if (this._transactions > 0) {
          exec2.call(pipeline);
        }
        if (this.nodeifiedPromise) {
          return exec2.call(pipeline);
        }
        const promise = exec2.call(pipeline);
        return (0, standard_as_callback_1.default)(promise.then(function(result) {
          const execResult = result[result.length - 1];
          if (typeof execResult === "undefined") {
            throw new Error("Pipeline cannot be used to send any commands when the `exec()` has been called on it.");
          }
          if (execResult[0]) {
            execResult[0].previousErrors = [];
            for (let i = 0;i < result.length - 1; ++i) {
              if (result[i][0]) {
                execResult[0].previousErrors.push(result[i][0]);
              }
            }
            throw execResult[0];
          }
          return (0, utils_1.wrapMultiResult)(execResult[1]);
        }), callback);
      };
      const { execBuffer } = pipeline;
      pipeline.execBuffer = function(callback) {
        if (this._transactions > 0) {
          execBuffer.call(pipeline);
        }
        return pipeline.exec(callback);
      };
      return pipeline;
    };
    const { exec } = redis;
    redis.exec = function(callback) {
      return (0, standard_as_callback_1.default)(exec.call(this).then(function(results) {
        if (Array.isArray(results)) {
          results = (0, utils_1.wrapMultiResult)(results);
        }
        return results;
      }), callback);
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addTransactionSupport = undefined;
  var utils_1 = require_utils2();
  var standard_as_callback_1 = require_built2();
  var Pipeline_1 = require_Pipeline();
  exports.addTransactionSupport = addTransactionSupport;
});

// node_modules/ioredis/built/utils/applyMixin.js
var require_applyMixin = __commonJS((exports) => {
  var applyMixin = function(derivedConstructor, mixinConstructor) {
    Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name) => {
      Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.default = applyMixin;
});

// node_modules/ioredis/built/cluster/ClusterOptions.js
var require_ClusterOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_CLUSTER_OPTIONS = undefined;
  var dns_1 = import.meta.require("dns");
  exports.DEFAULT_CLUSTER_OPTIONS = {
    clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2000),
    enableOfflineQueue: true,
    enableReadyCheck: true,
    scaleReads: "master",
    maxRedirections: 16,
    retryDelayOnMoved: 0,
    retryDelayOnFailover: 100,
    retryDelayOnClusterDown: 100,
    retryDelayOnTryAgain: 100,
    slotsRefreshTimeout: 1000,
    useSRVRecords: false,
    resolveSrv: dns_1.resolveSrv,
    dnsLookup: dns_1.lookup,
    enableAutoPipelining: false,
    autoPipeliningIgnoredCommands: []
  };
});

// node_modules/ioredis/built/cluster/util.js
var require_util = __commonJS((exports) => {
  var getNodeKey = function(node) {
    node.port = node.port || 6379;
    node.host = node.host || "127.0.0.1";
    return node.host + ":" + node.port;
  };
  var nodeKeyToRedisOptions = function(nodeKey) {
    const portIndex = nodeKey.lastIndexOf(":");
    if (portIndex === -1) {
      throw new Error(`Invalid node key ${nodeKey}`);
    }
    return {
      host: nodeKey.slice(0, portIndex),
      port: Number(nodeKey.slice(portIndex + 1))
    };
  };
  var normalizeNodeOptions = function(nodes) {
    return nodes.map((node) => {
      const options = {};
      if (typeof node === "object") {
        Object.assign(options, node);
      } else if (typeof node === "string") {
        Object.assign(options, (0, utils_1.parseURL)(node));
      } else if (typeof node === "number") {
        options.port = node;
      } else {
        throw new Error("Invalid argument " + node);
      }
      if (typeof options.port === "string") {
        options.port = parseInt(options.port, 10);
      }
      delete options.db;
      if (!options.port) {
        options.port = 6379;
      }
      if (!options.host) {
        options.host = "127.0.0.1";
      }
      return (0, utils_1.resolveTLSProfile)(options);
    });
  };
  var getUniqueHostnamesFromOptions = function(nodes) {
    const uniqueHostsMap = {};
    nodes.forEach((node) => {
      uniqueHostsMap[node.host] = true;
    });
    return Object.keys(uniqueHostsMap).filter((host) => !(0, net_1.isIP)(host));
  };
  var groupSrvRecords = function(records) {
    const recordsByPriority = {};
    for (const record of records) {
      if (!recordsByPriority.hasOwnProperty(record.priority)) {
        recordsByPriority[record.priority] = {
          totalWeight: record.weight,
          records: [record]
        };
      } else {
        recordsByPriority[record.priority].totalWeight += record.weight;
        recordsByPriority[record.priority].records.push(record);
      }
    }
    return recordsByPriority;
  };
  var weightSrvRecords = function(recordsGroup) {
    if (recordsGroup.records.length === 1) {
      recordsGroup.totalWeight = 0;
      return recordsGroup.records.shift();
    }
    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));
    let total = 0;
    for (const [i, record] of recordsGroup.records.entries()) {
      total += 1 + record.weight;
      if (total > random) {
        recordsGroup.totalWeight -= record.weight;
        recordsGroup.records.splice(i, 1);
        return record;
      }
    }
  };
  var getConnectionName = function(component, nodeConnectionName) {
    const prefix = `ioredis-cluster(${component})`;
    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = undefined;
  var utils_1 = require_utils2();
  var net_1 = import.meta.require("net");
  exports.getNodeKey = getNodeKey;
  exports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;
  exports.normalizeNodeOptions = normalizeNodeOptions;
  exports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;
  exports.groupSrvRecords = groupSrvRecords;
  exports.weightSrvRecords = weightSrvRecords;
  exports.getConnectionName = getConnectionName;
});

// node_modules/ioredis/built/cluster/ClusterSubscriber.js
var require_ClusterSubscriber = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var util_1 = require_util();
  var utils_1 = require_utils2();
  var Redis_1 = require_Redis();
  var debug = (0, utils_1.Debug)("cluster:subscriber");

  class ClusterSubscriber {
    constructor(connectionPool, emitter) {
      this.connectionPool = connectionPool;
      this.emitter = emitter;
      this.started = false;
      this.subscriber = null;
      this.onSubscriberEnd = () => {
        if (!this.started) {
          debug("subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.");
          return;
        }
        debug("subscriber has disconnected, selecting a new one...");
        this.selectSubscriber();
      };
      this.connectionPool.on("-node", (_, key) => {
        if (!this.started || !this.subscriber) {
          return;
        }
        if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {
          debug("subscriber has left, selecting a new one...");
          this.selectSubscriber();
        }
      });
      this.connectionPool.on("+node", () => {
        if (!this.started || this.subscriber) {
          return;
        }
        debug("a new node is discovered and there is no subscriber, selecting a new one...");
        this.selectSubscriber();
      });
    }
    getInstance() {
      return this.subscriber;
    }
    start() {
      this.started = true;
      this.selectSubscriber();
      debug("started");
    }
    stop() {
      this.started = false;
      if (this.subscriber) {
        this.subscriber.disconnect();
        this.subscriber = null;
      }
      debug("stopped");
    }
    selectSubscriber() {
      const lastActiveSubscriber = this.lastActiveSubscriber;
      if (lastActiveSubscriber) {
        lastActiveSubscriber.off("end", this.onSubscriberEnd);
        lastActiveSubscriber.disconnect();
      }
      if (this.subscriber) {
        this.subscriber.off("end", this.onSubscriberEnd);
        this.subscriber.disconnect();
      }
      const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());
      if (!sampleNode) {
        debug("selecting subscriber failed since there is no node discovered in the cluster yet");
        this.subscriber = null;
        return;
      }
      const { options } = sampleNode;
      debug("selected a subscriber %s:%s", options.host, options.port);
      this.subscriber = new Redis_1.default({
        port: options.port,
        host: options.host,
        username: options.username,
        password: options.password,
        enableReadyCheck: true,
        connectionName: (0, util_1.getConnectionName)("subscriber", options.connectionName),
        lazyConnect: true,
        tls: options.tls,
        retryStrategy: null
      });
      this.subscriber.on("error", utils_1.noop);
      this.subscriber.once("end", this.onSubscriberEnd);
      const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };
      if (lastActiveSubscriber) {
        const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;
        if (condition && condition.subscriber) {
          previousChannels.subscribe = condition.subscriber.channels("subscribe");
          previousChannels.psubscribe = condition.subscriber.channels("psubscribe");
          previousChannels.ssubscribe = condition.subscriber.channels("ssubscribe");
        }
      }
      if (previousChannels.subscribe.length || previousChannels.psubscribe.length || previousChannels.ssubscribe.length) {
        let pending = 0;
        for (const type of ["subscribe", "psubscribe", "ssubscribe"]) {
          const channels = previousChannels[type];
          if (channels.length) {
            pending += 1;
            debug("%s %d channels", type, channels.length);
            this.subscriber[type](channels).then(() => {
              if (!--pending) {
                this.lastActiveSubscriber = this.subscriber;
              }
            }).catch(() => {
              debug("failed to %s %d channels", type, channels.length);
            });
          }
        }
      } else {
        this.lastActiveSubscriber = this.subscriber;
      }
      for (const event of [
        "message",
        "messageBuffer",
        "smessage",
        "smessageBuffer"
      ]) {
        this.subscriber.on(event, (arg1, arg2) => {
          this.emitter.emit(event, arg1, arg2);
        });
      }
      for (const event of ["pmessage", "pmessageBuffer"]) {
        this.subscriber.on(event, (arg1, arg2, arg3) => {
          this.emitter.emit(event, arg1, arg2, arg3);
        });
      }
    }
  }
  exports.default = ClusterSubscriber;
});

// node_modules/ioredis/built/cluster/ConnectionPool.js
var require_ConnectionPool = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var events_1 = import.meta.require("events");
  var utils_1 = require_utils2();
  var util_1 = require_util();
  var Redis_1 = require_Redis();
  var debug = (0, utils_1.Debug)("cluster:connectionPool");

  class ConnectionPool extends events_1.EventEmitter {
    constructor(redisOptions) {
      super();
      this.redisOptions = redisOptions;
      this.nodes = {
        all: {},
        master: {},
        slave: {}
      };
      this.specifiedOptions = {};
    }
    getNodes(role = "all") {
      const nodes = this.nodes[role];
      return Object.keys(nodes).map((key) => nodes[key]);
    }
    getInstanceByKey(key) {
      return this.nodes.all[key];
    }
    getSampleInstance(role) {
      const keys = Object.keys(this.nodes[role]);
      const sampleKey = (0, utils_1.sample)(keys);
      return this.nodes[role][sampleKey];
    }
    findOrCreate(node, readOnly = false) {
      const key = (0, util_1.getNodeKey)(node);
      readOnly = Boolean(readOnly);
      if (this.specifiedOptions[key]) {
        Object.assign(node, this.specifiedOptions[key]);
      } else {
        this.specifiedOptions[key] = node;
      }
      let redis;
      if (this.nodes.all[key]) {
        redis = this.nodes.all[key];
        if (redis.options.readOnly !== readOnly) {
          redis.options.readOnly = readOnly;
          debug("Change role of %s to %s", key, readOnly ? "slave" : "master");
          redis[readOnly ? "readonly" : "readwrite"]().catch(utils_1.noop);
          if (readOnly) {
            delete this.nodes.master[key];
            this.nodes.slave[key] = redis;
          } else {
            delete this.nodes.slave[key];
            this.nodes.master[key] = redis;
          }
        }
      } else {
        debug("Connecting to %s as %s", key, readOnly ? "slave" : "master");
        redis = new Redis_1.default((0, utils_1.defaults)({
          retryStrategy: null,
          enableOfflineQueue: true,
          readOnly
        }, node, this.redisOptions, { lazyConnect: true }));
        this.nodes.all[key] = redis;
        this.nodes[readOnly ? "slave" : "master"][key] = redis;
        redis.once("end", () => {
          this.removeNode(key);
          this.emit("-node", redis, key);
          if (!Object.keys(this.nodes.all).length) {
            this.emit("drain");
          }
        });
        this.emit("+node", redis, key);
        redis.on("error", function(error) {
          this.emit("nodeError", error, key);
        });
      }
      return redis;
    }
    reset(nodes) {
      debug("Reset with %O", nodes);
      const newNodes = {};
      nodes.forEach((node) => {
        const key = (0, util_1.getNodeKey)(node);
        if (!(node.readOnly && newNodes[key])) {
          newNodes[key] = node;
        }
      });
      Object.keys(this.nodes.all).forEach((key) => {
        if (!newNodes[key]) {
          debug("Disconnect %s because the node does not hold any slot", key);
          this.nodes.all[key].disconnect();
          this.removeNode(key);
        }
      });
      Object.keys(newNodes).forEach((key) => {
        const node = newNodes[key];
        this.findOrCreate(node, node.readOnly);
      });
    }
    removeNode(key) {
      const { nodes } = this;
      if (nodes.all[key]) {
        debug("Remove %s from the pool", key);
        delete nodes.all[key];
      }
      delete nodes.master[key];
      delete nodes.slave[key];
    }
  }
  exports.default = ConnectionPool;
});

// node_modules/denque/index.js
var require_denque = __commonJS((exports, module) => {
  var Denque = function(array, options) {
    var options = options || {};
    this._capacity = options.capacity;
    this._head = 0;
    this._tail = 0;
    if (Array.isArray(array)) {
      this._fromArray(array);
    } else {
      this._capacityMask = 3;
      this._list = new Array(4);
    }
  };
  Denque.prototype.peekAt = function peekAt(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var len = this.size();
    if (i >= len || i < -len)
      return;
    if (i < 0)
      i += len;
    i = this._head + i & this._capacityMask;
    return this._list[i];
  };
  Denque.prototype.get = function get(i) {
    return this.peekAt(i);
  };
  Denque.prototype.peek = function peek() {
    if (this._head === this._tail)
      return;
    return this._list[this._head];
  };
  Denque.prototype.peekFront = function peekFront() {
    return this.peek();
  };
  Denque.prototype.peekBack = function peekBack() {
    return this.peekAt(-1);
  };
  Object.defineProperty(Denque.prototype, "length", {
    get: function length() {
      return this.size();
    }
  });
  Denque.prototype.size = function size() {
    if (this._head === this._tail)
      return 0;
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.unshift = function unshift(item) {
    if (arguments.length === 0)
      return this.size();
    var len = this._list.length;
    this._head = this._head - 1 + len & this._capacityMask;
    this._list[this._head] = item;
    if (this._tail === this._head)
      this._growArray();
    if (this._capacity && this.size() > this._capacity)
      this.pop();
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.shift = function shift() {
    var head = this._head;
    if (head === this._tail)
      return;
    var item = this._list[head];
    this._list[head] = undefined;
    this._head = head + 1 & this._capacityMask;
    if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.push = function push(item) {
    if (arguments.length === 0)
      return this.size();
    var tail = this._tail;
    this._list[tail] = item;
    this._tail = tail + 1 & this._capacityMask;
    if (this._tail === this._head) {
      this._growArray();
    }
    if (this._capacity && this.size() > this._capacity) {
      this.shift();
    }
    if (this._head < this._tail)
      return this._tail - this._head;
    else
      return this._capacityMask + 1 - (this._head - this._tail);
  };
  Denque.prototype.pop = function pop() {
    var tail = this._tail;
    if (tail === this._head)
      return;
    var len = this._list.length;
    this._tail = tail - 1 + len & this._capacityMask;
    var item = this._list[this._tail];
    this._list[this._tail] = undefined;
    if (this._head < 2 && tail > 1e4 && tail <= len >>> 2)
      this._shrinkArray();
    return item;
  };
  Denque.prototype.removeOne = function removeOne(index) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size)
      return;
    if (i < 0)
      i += size;
    i = this._head + i & this._capacityMask;
    var item = this._list[i];
    var k;
    if (index < size / 2) {
      for (k = index;k > 0; k--) {
        this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._head = this._head + 1 + len & this._capacityMask;
    } else {
      for (k = size - 1 - index;k > 0; k--) {
        this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
      }
      this._list[i] = undefined;
      this._tail = this._tail - 1 + len & this._capacityMask;
    }
    return item;
  };
  Denque.prototype.remove = function remove(index, count) {
    var i = index;
    var removed;
    var del_count = count;
    if (i !== (i | 0)) {
      return;
    }
    if (this._head === this._tail)
      return;
    var size = this.size();
    var len = this._list.length;
    if (i >= size || i < -size || count < 1)
      return;
    if (i < 0)
      i += size;
    if (count === 1 || !count) {
      removed = new Array(1);
      removed[0] = this.removeOne(i);
      return removed;
    }
    if (i === 0 && i + count >= size) {
      removed = this.toArray();
      this.clear();
      return removed;
    }
    if (i + count > size)
      count = size - i;
    var k;
    removed = new Array(count);
    for (k = 0;k < count; k++) {
      removed[k] = this._list[this._head + i + k & this._capacityMask];
    }
    i = this._head + i & this._capacityMask;
    if (index + count === size) {
      this._tail = this._tail - count + len & this._capacityMask;
      for (k = count;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (index === 0) {
      this._head = this._head + count + len & this._capacityMask;
      for (k = count - 1;k > 0; k--) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
      }
      return removed;
    }
    if (i < size / 2) {
      this._head = this._head + index + count + len & this._capacityMask;
      for (k = index;k > 0; k--) {
        this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
      }
      i = this._head - 1 + len & this._capacityMask;
      while (del_count > 0) {
        this._list[i = i - 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
      if (index < 0)
        this._tail = i;
    } else {
      this._tail = i;
      i = i + count + len & this._capacityMask;
      for (k = size - (count + index);k > 0; k--) {
        this.push(this._list[i++]);
      }
      i = this._tail;
      while (del_count > 0) {
        this._list[i = i + 1 + len & this._capacityMask] = undefined;
        del_count--;
      }
    }
    if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2)
      this._shrinkArray();
    return removed;
  };
  Denque.prototype.splice = function splice(index, count) {
    var i = index;
    if (i !== (i | 0)) {
      return;
    }
    var size = this.size();
    if (i < 0)
      i += size;
    if (i > size)
      return;
    if (arguments.length > 2) {
      var k;
      var temp;
      var removed;
      var arg_len = arguments.length;
      var len = this._list.length;
      var arguments_index = 2;
      if (!size || i < size / 2) {
        temp = new Array(i);
        for (k = 0;k < i; k++) {
          temp[k] = this._list[this._head + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i > 0) {
            this._head = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._head = this._head + i + len & this._capacityMask;
        }
        while (arg_len > arguments_index) {
          this.unshift(arguments[--arg_len]);
        }
        for (k = i;k > 0; k--) {
          this.unshift(temp[k - 1]);
        }
      } else {
        temp = new Array(size - (i + count));
        var leng = temp.length;
        for (k = 0;k < leng; k++) {
          temp[k] = this._list[this._head + i + count + k & this._capacityMask];
        }
        if (count === 0) {
          removed = [];
          if (i != size) {
            this._tail = this._head + i + len & this._capacityMask;
          }
        } else {
          removed = this.remove(i, count);
          this._tail = this._tail - leng + len & this._capacityMask;
        }
        while (arguments_index < arg_len) {
          this.push(arguments[arguments_index++]);
        }
        for (k = 0;k < leng; k++) {
          this.push(temp[k]);
        }
      }
      return removed;
    } else {
      return this.remove(i, count);
    }
  };
  Denque.prototype.clear = function clear() {
    this._list = new Array(this._list.length);
    this._head = 0;
    this._tail = 0;
  };
  Denque.prototype.isEmpty = function isEmpty() {
    return this._head === this._tail;
  };
  Denque.prototype.toArray = function toArray() {
    return this._copyArray(false);
  };
  Denque.prototype._fromArray = function _fromArray(array) {
    var length = array.length;
    var capacity = this._nextPowerOf2(length);
    this._list = new Array(capacity);
    this._capacityMask = capacity - 1;
    this._tail = length;
    for (var i = 0;i < length; i++)
      this._list[i] = array[i];
  };
  Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
    var src = this._list;
    var capacity = src.length;
    var length = this.length;
    size = size | length;
    if (size == length && this._head < this._tail) {
      return this._list.slice(this._head, this._tail);
    }
    var dest = new Array(size);
    var k = 0;
    var i;
    if (fullCopy || this._head > this._tail) {
      for (i = this._head;i < capacity; i++)
        dest[k++] = src[i];
      for (i = 0;i < this._tail; i++)
        dest[k++] = src[i];
    } else {
      for (i = this._head;i < this._tail; i++)
        dest[k++] = src[i];
    }
    return dest;
  };
  Denque.prototype._growArray = function _growArray() {
    if (this._head != 0) {
      var newList = this._copyArray(true, this._list.length << 1);
      this._tail = this._list.length;
      this._head = 0;
      this._list = newList;
    } else {
      this._tail = this._list.length;
      this._list.length <<= 1;
    }
    this._capacityMask = this._capacityMask << 1 | 1;
  };
  Denque.prototype._shrinkArray = function _shrinkArray() {
    this._list.length >>>= 1;
    this._capacityMask >>>= 1;
  };
  Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
    var log2 = Math.log(num) / Math.log(2);
    var nextPow2 = 1 << log2 + 1;
    return Math.max(nextPow2, 4);
  };
  module.exports = Denque;
});

// node_modules/ioredis/built/cluster/DelayQueue.js
var require_DelayQueue = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var Deque = require_denque();
  var debug = (0, utils_1.Debug)("delayqueue");

  class DelayQueue {
    constructor() {
      this.queues = {};
      this.timeouts = {};
    }
    push(bucket, item, options) {
      const callback = options.callback || process.nextTick;
      if (!this.queues[bucket]) {
        this.queues[bucket] = new Deque;
      }
      const queue = this.queues[bucket];
      queue.push(item);
      if (!this.timeouts[bucket]) {
        this.timeouts[bucket] = setTimeout(() => {
          callback(() => {
            this.timeouts[bucket] = null;
            this.execute(bucket);
          });
        }, options.timeout);
      }
    }
    execute(bucket) {
      const queue = this.queues[bucket];
      if (!queue) {
        return;
      }
      const { length } = queue;
      if (!length) {
        return;
      }
      debug("send %d commands in %s queue", length, bucket);
      this.queues[bucket] = null;
      while (queue.length > 0) {
        queue.shift()();
      }
    }
  }
  exports.default = DelayQueue;
});

// node_modules/ioredis/built/cluster/index.js
var require_cluster = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var events_1 = import.meta.require("events");
  var redis_errors_1 = require_redis_errors();
  var standard_as_callback_1 = require_built2();
  var Command_1 = require_Command();
  var ClusterAllFailedError_1 = require_ClusterAllFailedError();
  var Redis_1 = require_Redis();
  var ScanStream_1 = require_ScanStream();
  var transaction_1 = require_transaction();
  var utils_1 = require_utils2();
  var applyMixin_1 = require_applyMixin();
  var Commander_1 = require_Commander();
  var ClusterOptions_1 = require_ClusterOptions();
  var ClusterSubscriber_1 = require_ClusterSubscriber();
  var ConnectionPool_1 = require_ConnectionPool();
  var DelayQueue_1 = require_DelayQueue();
  var util_1 = require_util();
  var Deque = require_denque();
  var debug = (0, utils_1.Debug)("cluster");
  var REJECT_OVERWRITTEN_COMMANDS = new WeakSet;

  class Cluster extends Commander_1.default {
    constructor(startupNodes, options = {}) {
      super();
      this.slots = [];
      this._groupsIds = {};
      this._groupsBySlot = Array(16384);
      this.isCluster = true;
      this.retryAttempts = 0;
      this.delayQueue = new DelayQueue_1.default;
      this.offlineQueue = new Deque;
      this.isRefreshing = false;
      this._autoPipelines = new Map;
      this._runningAutoPipelines = new Set;
      this._readyDelayedCallbacks = [];
      this.connectionEpoch = 0;
      events_1.EventEmitter.call(this);
      this.startupNodes = startupNodes;
      this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);
      if (this.options.redisOptions && this.options.redisOptions.keyPrefix && !this.options.keyPrefix) {
        this.options.keyPrefix = this.options.redisOptions.keyPrefix;
      }
      if (typeof this.options.scaleReads !== "function" && ["all", "master", "slave"].indexOf(this.options.scaleReads) === -1) {
        throw new Error('Invalid option scaleReads "' + this.options.scaleReads + '". Expected "all", "master", "slave" or a custom function');
      }
      this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);
      this.connectionPool.on("-node", (redis, key) => {
        this.emit("-node", redis);
      });
      this.connectionPool.on("+node", (redis) => {
        this.emit("+node", redis);
      });
      this.connectionPool.on("drain", () => {
        this.setStatus("close");
      });
      this.connectionPool.on("nodeError", (error, key) => {
        this.emit("node error", error, key);
      });
      this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);
      if (this.options.scripts) {
        Object.entries(this.options.scripts).forEach(([name, definition]) => {
          this.defineCommand(name, definition);
        });
      }
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch((err) => {
          debug("connecting failed: %s", err);
        });
      }
    }
    connect() {
      return new Promise((resolve, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        const epoch = ++this.connectionEpoch;
        this.setStatus("connecting");
        this.resolveStartupNodeHostnames().then((nodes) => {
          if (this.connectionEpoch !== epoch) {
            debug("discard connecting after resolving startup nodes because epoch not match: %d != %d", epoch, this.connectionEpoch);
            reject(new redis_errors_1.RedisError("Connection is discarded because a new connection is made"));
            return;
          }
          if (this.status !== "connecting") {
            debug("discard connecting after resolving startup nodes because the status changed to %s", this.status);
            reject(new redis_errors_1.RedisError("Connection is aborted"));
            return;
          }
          this.connectionPool.reset(nodes);
          const readyHandler = () => {
            this.setStatus("ready");
            this.retryAttempts = 0;
            this.executeOfflineCommands();
            this.resetNodesRefreshInterval();
            resolve();
          };
          let closeListener = undefined;
          const refreshListener = () => {
            this.invokeReadyDelayedCallbacks(undefined);
            this.removeListener("close", closeListener);
            this.manuallyClosing = false;
            this.setStatus("connect");
            if (this.options.enableReadyCheck) {
              this.readyCheck((err, fail) => {
                if (err || fail) {
                  debug("Ready check failed (%s). Reconnecting...", err || fail);
                  if (this.status === "connect") {
                    this.disconnect(true);
                  }
                } else {
                  readyHandler();
                }
              });
            } else {
              readyHandler();
            }
          };
          closeListener = () => {
            const error = new Error("None of startup nodes is available");
            this.removeListener("refresh", refreshListener);
            this.invokeReadyDelayedCallbacks(error);
            reject(error);
          };
          this.once("refresh", refreshListener);
          this.once("close", closeListener);
          this.once("close", this.handleCloseEvent.bind(this));
          this.refreshSlotsCache((err) => {
            if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {
              Redis_1.default.prototype.silentEmit.call(this, "error", err);
              this.connectionPool.reset([]);
            }
          });
          this.subscriber.start();
        }).catch((err) => {
          this.setStatus("close");
          this.handleCloseEvent(err);
          this.invokeReadyDelayedCallbacks(err);
          reject(err);
        });
      });
    }
    disconnect(reconnect = false) {
      const status = this.status;
      this.setStatus("disconnecting");
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
        debug("Canceled reconnecting attempts");
      }
      this.clearNodesRefreshInterval();
      this.subscriber.stop();
      if (status === "wait") {
        this.setStatus("close");
        this.handleCloseEvent();
      } else {
        this.connectionPool.reset([]);
      }
    }
    quit(callback) {
      const status = this.status;
      this.setStatus("disconnecting");
      this.manuallyClosing = true;
      if (this.reconnectTimeout) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      this.clearNodesRefreshInterval();
      this.subscriber.stop();
      if (status === "wait") {
        const ret = (0, standard_as_callback_1.default)(Promise.resolve("OK"), callback);
        setImmediate(function() {
          this.setStatus("close");
          this.handleCloseEvent();
        }.bind(this));
        return ret;
      }
      return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {
        if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {
          return "OK";
        }
        throw err;
      }))).then(() => "OK"), callback);
    }
    duplicate(overrideStartupNodes = [], overrideOptions = {}) {
      const startupNodes = overrideStartupNodes.length > 0 ? overrideStartupNodes : this.startupNodes.slice(0);
      const options = Object.assign({}, this.options, overrideOptions);
      return new Cluster(startupNodes, options);
    }
    nodes(role = "all") {
      if (role !== "all" && role !== "master" && role !== "slave") {
        throw new Error('Invalid role "' + role + '". Expected "all", "master" or "slave"');
      }
      return this.connectionPool.getNodes(role);
    }
    delayUntilReady(callback) {
      this._readyDelayedCallbacks.push(callback);
    }
    get autoPipelineQueueSize() {
      let queued = 0;
      for (const pipeline of this._autoPipelines.values()) {
        queued += pipeline.length;
      }
      return queued;
    }
    refreshSlotsCache(callback) {
      if (this.isRefreshing) {
        if (callback) {
          process.nextTick(callback);
        }
        return;
      }
      this.isRefreshing = true;
      const _this = this;
      const wrapper = (error) => {
        this.isRefreshing = false;
        if (callback) {
          callback(error);
        }
      };
      const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());
      let lastNodeError = null;
      function tryNode(index) {
        if (index === nodes.length) {
          const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);
          return wrapper(error);
        }
        const node = nodes[index];
        const key = `${node.options.host}:${node.options.port}`;
        debug("getting slot cache from %s", key);
        _this.getInfoFromNode(node, function(err) {
          switch (_this.status) {
            case "close":
            case "end":
              return wrapper(new Error("Cluster is disconnected."));
            case "disconnecting":
              return wrapper(new Error("Cluster is disconnecting."));
          }
          if (err) {
            _this.emit("node error", err, key);
            lastNodeError = err;
            tryNode(index + 1);
          } else {
            _this.emit("refresh");
            wrapper();
          }
        });
      }
      tryNode(0);
    }
    sendCommand(command, stream, node) {
      if (this.status === "wait") {
        this.connect().catch(utils_1.noop);
      }
      if (this.status === "end") {
        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
      }
      let to = this.options.scaleReads;
      if (to !== "master") {
        const isCommandReadOnly = command.isReadOnly || (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "readonly");
        if (!isCommandReadOnly) {
          to = "master";
        }
      }
      let targetSlot = node ? node.slot : command.getSlot();
      const ttl = {};
      const _this = this;
      if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {
        REJECT_OVERWRITTEN_COMMANDS.add(command);
        const reject = command.reject;
        command.reject = function(err) {
          const partialTry = tryConnection.bind(null, true);
          _this.handleError(err, ttl, {
            moved: function(slot, key) {
              debug("command %s is moved to %s", command.name, key);
              targetSlot = Number(slot);
              if (_this.slots[slot]) {
                _this.slots[slot][0] = key;
              } else {
                _this.slots[slot] = [key];
              }
              _this._groupsBySlot[slot] = _this._groupsIds[_this.slots[slot].join(";")];
              _this.connectionPool.findOrCreate(_this.natMapper(key));
              tryConnection();
              debug("refreshing slot caches... (triggered by MOVED error)");
              _this.refreshSlotsCache();
            },
            ask: function(slot, key) {
              debug("command %s is required to ask %s:%s", command.name, key);
              const mapped = _this.natMapper(key);
              _this.connectionPool.findOrCreate(mapped);
              tryConnection(false, `${mapped.host}:${mapped.port}`);
            },
            tryagain: partialTry,
            clusterDown: partialTry,
            connectionClosed: partialTry,
            maxRedirections: function(redirectionError) {
              reject.call(command, redirectionError);
            },
            defaults: function() {
              reject.call(command, err);
            }
          });
        };
      }
      tryConnection();
      function tryConnection(random, asking) {
        if (_this.status === "end") {
          command.reject(new redis_errors_1.AbortError("Cluster is ended."));
          return;
        }
        let redis;
        if (_this.status === "ready" || command.name === "cluster") {
          if (node && node.redis) {
            redis = node.redis;
          } else if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", command.name) || Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", command.name)) {
            redis = _this.subscriber.getInstance();
            if (!redis) {
              command.reject(new redis_errors_1.AbortError("No subscriber for the cluster"));
              return;
            }
          } else {
            if (!random) {
              if (typeof targetSlot === "number" && _this.slots[targetSlot]) {
                const nodeKeys = _this.slots[targetSlot];
                if (typeof to === "function") {
                  const nodes = nodeKeys.map(function(key) {
                    return _this.connectionPool.getInstanceByKey(key);
                  });
                  redis = to(nodes, command);
                  if (Array.isArray(redis)) {
                    redis = (0, utils_1.sample)(redis);
                  }
                  if (!redis) {
                    redis = nodes[0];
                  }
                } else {
                  let key;
                  if (to === "all") {
                    key = (0, utils_1.sample)(nodeKeys);
                  } else if (to === "slave" && nodeKeys.length > 1) {
                    key = (0, utils_1.sample)(nodeKeys, 1);
                  } else {
                    key = nodeKeys[0];
                  }
                  redis = _this.connectionPool.getInstanceByKey(key);
                }
              }
              if (asking) {
                redis = _this.connectionPool.getInstanceByKey(asking);
                redis.asking();
              }
            }
            if (!redis) {
              redis = (typeof to === "function" ? null : _this.connectionPool.getSampleInstance(to)) || _this.connectionPool.getSampleInstance("all");
            }
          }
          if (node && !node.redis) {
            node.redis = redis;
          }
        }
        if (redis) {
          redis.sendCommand(command, stream);
        } else if (_this.options.enableOfflineQueue) {
          _this.offlineQueue.push({
            command,
            stream,
            node
          });
        } else {
          command.reject(new Error("Cluster isn't ready and enableOfflineQueue options is false"));
        }
      }
      return command.promise;
    }
    sscanStream(key, options) {
      return this.createScanStream("sscan", { key, options });
    }
    sscanBufferStream(key, options) {
      return this.createScanStream("sscanBuffer", { key, options });
    }
    hscanStream(key, options) {
      return this.createScanStream("hscan", { key, options });
    }
    hscanBufferStream(key, options) {
      return this.createScanStream("hscanBuffer", { key, options });
    }
    zscanStream(key, options) {
      return this.createScanStream("zscan", { key, options });
    }
    zscanBufferStream(key, options) {
      return this.createScanStream("zscanBuffer", { key, options });
    }
    handleError(error, ttl, handlers) {
      if (typeof ttl.value === "undefined") {
        ttl.value = this.options.maxRedirections;
      } else {
        ttl.value -= 1;
      }
      if (ttl.value <= 0) {
        handlers.maxRedirections(new Error("Too many Cluster redirections. Last error: " + error));
        return;
      }
      const errv = error.message.split(" ");
      if (errv[0] === "MOVED") {
        const timeout = this.options.retryDelayOnMoved;
        if (timeout && typeof timeout === "number") {
          this.delayQueue.push("moved", handlers.moved.bind(null, errv[1], errv[2]), { timeout });
        } else {
          handlers.moved(errv[1], errv[2]);
        }
      } else if (errv[0] === "ASK") {
        handlers.ask(errv[1], errv[2]);
      } else if (errv[0] === "TRYAGAIN") {
        this.delayQueue.push("tryagain", handlers.tryagain, {
          timeout: this.options.retryDelayOnTryAgain
        });
      } else if (errv[0] === "CLUSTERDOWN" && this.options.retryDelayOnClusterDown > 0) {
        this.delayQueue.push("clusterdown", handlers.connectionClosed, {
          timeout: this.options.retryDelayOnClusterDown,
          callback: this.refreshSlotsCache.bind(this)
        });
      } else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG && this.options.retryDelayOnFailover > 0 && this.status === "ready") {
        this.delayQueue.push("failover", handlers.connectionClosed, {
          timeout: this.options.retryDelayOnFailover,
          callback: this.refreshSlotsCache.bind(this)
        });
      } else {
        handlers.defaults();
      }
    }
    resetOfflineQueue() {
      this.offlineQueue = new Deque;
    }
    clearNodesRefreshInterval() {
      if (this.slotsTimer) {
        clearTimeout(this.slotsTimer);
        this.slotsTimer = null;
      }
    }
    resetNodesRefreshInterval() {
      if (this.slotsTimer || !this.options.slotsRefreshInterval) {
        return;
      }
      const nextRound = () => {
        this.slotsTimer = setTimeout(() => {
          debug('refreshing slot caches... (triggered by "slotsRefreshInterval" option)');
          this.refreshSlotsCache(() => {
            nextRound();
          });
        }, this.options.slotsRefreshInterval);
      };
      nextRound();
    }
    setStatus(status) {
      debug("status: %s -> %s", this.status || "[empty]", status);
      this.status = status;
      process.nextTick(() => {
        this.emit(status);
      });
    }
    handleCloseEvent(reason) {
      if (reason) {
        debug("closed because %s", reason);
      }
      let retryDelay;
      if (!this.manuallyClosing && typeof this.options.clusterRetryStrategy === "function") {
        retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);
      }
      if (typeof retryDelay === "number") {
        this.setStatus("reconnecting");
        this.reconnectTimeout = setTimeout(() => {
          this.reconnectTimeout = null;
          debug("Cluster is disconnected. Retrying after %dms", retryDelay);
          this.connect().catch(function(err) {
            debug("Got error %s when reconnecting. Ignoring...", err);
          });
        }, retryDelay);
      } else {
        this.setStatus("end");
        this.flushQueue(new Error("None of startup nodes is available"));
      }
    }
    flushQueue(error) {
      let item;
      while (item = this.offlineQueue.shift()) {
        item.command.reject(error);
      }
    }
    executeOfflineCommands() {
      if (this.offlineQueue.length) {
        debug("send %d commands in offline queue", this.offlineQueue.length);
        const offlineQueue = this.offlineQueue;
        this.resetOfflineQueue();
        let item;
        while (item = offlineQueue.shift()) {
          this.sendCommand(item.command, item.stream, item.node);
        }
      }
    }
    natMapper(nodeKey) {
      if (this.options.natMap && typeof this.options.natMap === "object") {
        const key = typeof nodeKey === "string" ? nodeKey : `${nodeKey.host}:${nodeKey.port}`;
        const mapped = this.options.natMap[key];
        if (mapped) {
          debug("NAT mapping %s -> %O", key, mapped);
          return Object.assign({}, mapped);
        }
      }
      return typeof nodeKey === "string" ? (0, util_1.nodeKeyToRedisOptions)(nodeKey) : nodeKey;
    }
    getInfoFromNode(redis, callback) {
      if (!redis) {
        return callback(new Error("Node is disconnected"));
      }
      const duplicatedConnection = redis.duplicate({
        enableOfflineQueue: true,
        enableReadyCheck: false,
        retryStrategy: null,
        connectionName: (0, util_1.getConnectionName)("refresher", this.options.redisOptions && this.options.redisOptions.connectionName)
      });
      duplicatedConnection.on("error", utils_1.noop);
      duplicatedConnection.cluster("SLOTS", (0, utils_1.timeout)((err, result) => {
        duplicatedConnection.disconnect();
        if (err) {
          return callback(err);
        }
        if (this.status === "disconnecting" || this.status === "close" || this.status === "end") {
          debug("ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s", result.length, this.status);
          callback();
          return;
        }
        const nodes = [];
        debug("cluster slots result count: %d", result.length);
        for (let i = 0;i < result.length; ++i) {
          const items = result[i];
          const slotRangeStart = items[0];
          const slotRangeEnd = items[1];
          const keys = [];
          for (let j2 = 2;j2 < items.length; j2++) {
            if (!items[j2][0]) {
              continue;
            }
            const node = this.natMapper({
              host: items[j2][0],
              port: items[j2][1]
            });
            node.readOnly = j2 !== 2;
            nodes.push(node);
            keys.push(node.host + ":" + node.port);
          }
          debug("cluster slots result [%d]: slots %d~%d served by %s", i, slotRangeStart, slotRangeEnd, keys);
          for (let slot = slotRangeStart;slot <= slotRangeEnd; slot++) {
            this.slots[slot] = keys;
          }
        }
        this._groupsIds = Object.create(null);
        let j = 0;
        for (let i = 0;i < 16384; i++) {
          const target = (this.slots[i] || []).join(";");
          if (!target.length) {
            this._groupsBySlot[i] = undefined;
            continue;
          }
          if (!this._groupsIds[target]) {
            this._groupsIds[target] = ++j;
          }
          this._groupsBySlot[i] = this._groupsIds[target];
        }
        this.connectionPool.reset(nodes);
        callback();
      }, this.options.slotsRefreshTimeout));
    }
    invokeReadyDelayedCallbacks(err) {
      for (const c of this._readyDelayedCallbacks) {
        process.nextTick(c, err);
      }
      this._readyDelayedCallbacks = [];
    }
    readyCheck(callback) {
      this.cluster("INFO", (err, res) => {
        if (err) {
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback();
        }
        let state;
        const lines = res.split("\r\n");
        for (let i = 0;i < lines.length; ++i) {
          const parts = lines[i].split(":");
          if (parts[0] === "cluster_state") {
            state = parts[1];
            break;
          }
        }
        if (state === "fail") {
          debug("cluster state not ok (%s)", state);
          callback(null, state);
        } else {
          callback();
        }
      });
    }
    resolveSrv(hostname) {
      return new Promise((resolve, reject) => {
        this.options.resolveSrv(hostname, (err, records) => {
          if (err) {
            return reject(err);
          }
          const self2 = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));
          function tryFirstOne(err2) {
            if (!sortedKeys.length) {
              return reject(err2);
            }
            const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);
            if (!group.records.length) {
              sortedKeys.shift();
            }
            self2.dnsLookup(record.name).then((host) => resolve({
              host,
              port: record.port
            }), tryFirstOne);
          }
          tryFirstOne();
        });
      });
    }
    dnsLookup(hostname) {
      return new Promise((resolve, reject) => {
        this.options.dnsLookup(hostname, (err, address) => {
          if (err) {
            debug("failed to resolve hostname %s to IP: %s", hostname, err.message);
            reject(err);
          } else {
            debug("resolved hostname %s to IP %s", hostname, address);
            resolve(address);
          }
        });
      });
    }
    async resolveStartupNodeHostnames() {
      if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {
        throw new Error("`startupNodes` should contain at least one node.");
      }
      const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);
      const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);
      if (hostnames.length === 0) {
        return startupNodes;
      }
      const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));
      const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);
      return startupNodes.map((node) => {
        const config = hostnameToConfig.get(node.host);
        if (!config) {
          return node;
        }
        if (this.options.useSRVRecords) {
          return Object.assign({}, node, config);
        }
        return Object.assign({}, node, { host: config });
      });
    }
    createScanStream(command, { key, options = {} }) {
      return new ScanStream_1.default({
        objectMode: true,
        key,
        redis: this,
        command,
        ...options
      });
    }
  }
  (0, applyMixin_1.default)(Cluster, events_1.EventEmitter);
  (0, transaction_1.addTransactionSupport)(Cluster.prototype);
  exports.default = Cluster;
});

// node_modules/ioredis/built/connectors/AbstractConnector.js
var require_AbstractConnector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var utils_1 = require_utils2();
  var debug = (0, utils_1.Debug)("AbstractConnector");

  class AbstractConnector {
    constructor(disconnectTimeout) {
      this.connecting = false;
      this.disconnectTimeout = disconnectTimeout;
    }
    check(info) {
      return true;
    }
    disconnect() {
      this.connecting = false;
      if (this.stream) {
        const stream = this.stream;
        const timeout = setTimeout(() => {
          debug("stream %s:%s still open, destroying it", stream.remoteAddress, stream.remotePort);
          stream.destroy();
        }, this.disconnectTimeout);
        stream.on("close", () => clearTimeout(timeout));
        stream.end();
      }
    }
  }
  exports.default = AbstractConnector;
});

// node_modules/ioredis/built/connectors/StandaloneConnector.js
var require_StandaloneConnector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var net_1 = import.meta.require("net");
  var tls_1 = import.meta.require("tls");
  var utils_1 = require_utils2();
  var AbstractConnector_1 = require_AbstractConnector();

  class StandaloneConnector extends AbstractConnector_1.default {
    constructor(options) {
      super(options.disconnectTimeout);
      this.options = options;
    }
    connect(_) {
      const { options } = this;
      this.connecting = true;
      let connectionOptions;
      if ("path" in options && options.path) {
        connectionOptions = {
          path: options.path
        };
      } else {
        connectionOptions = {};
        if ("port" in options && options.port != null) {
          connectionOptions.port = options.port;
        }
        if ("host" in options && options.host != null) {
          connectionOptions.host = options.host;
        }
        if ("family" in options && options.family != null) {
          connectionOptions.family = options.family;
        }
      }
      if (options.tls) {
        Object.assign(connectionOptions, options.tls);
      }
      return new Promise((resolve, reject) => {
        process.nextTick(() => {
          if (!this.connecting) {
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
            return;
          }
          try {
            if (options.tls) {
              this.stream = (0, tls_1.connect)(connectionOptions);
            } else {
              this.stream = (0, net_1.createConnection)(connectionOptions);
            }
          } catch (err) {
            reject(err);
            return;
          }
          this.stream.once("error", (err) => {
            this.firstError = err;
          });
          resolve(this.stream);
        });
      });
    }
  }
  exports.default = StandaloneConnector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js
var require_SentinelIterator = __commonJS((exports) => {
  var isSentinelEql = function(a, b) {
    return (a.host || "127.0.0.1") === (b.host || "127.0.0.1") && (a.port || 26379) === (b.port || 26379);
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class SentinelIterator {
    constructor(sentinels) {
      this.cursor = 0;
      this.sentinels = sentinels.slice(0);
    }
    next() {
      const done = this.cursor >= this.sentinels.length;
      return { done, value: done ? undefined : this.sentinels[this.cursor++] };
    }
    reset(moveCurrentEndpointToFirst) {
      if (moveCurrentEndpointToFirst && this.sentinels.length > 1 && this.cursor !== 1) {
        this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));
      }
      this.cursor = 0;
    }
    add(sentinel) {
      for (let i = 0;i < this.sentinels.length; i++) {
        if (isSentinelEql(sentinel, this.sentinels[i])) {
          return false;
        }
      }
      this.sentinels.push(sentinel);
      return true;
    }
    toString() {
      return `${JSON.stringify(this.sentinels)} @${this.cursor}`;
    }
  }
  exports.default = SentinelIterator;
});

// node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js
var require_FailoverDetector = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.FailoverDetector = undefined;
  var utils_1 = require_utils2();
  var debug = (0, utils_1.Debug)("FailoverDetector");
  var CHANNEL_NAME = "+switch-master";

  class FailoverDetector {
    constructor(connector, sentinels) {
      this.isDisconnected = false;
      this.connector = connector;
      this.sentinels = sentinels;
    }
    cleanup() {
      this.isDisconnected = true;
      for (const sentinel of this.sentinels) {
        sentinel.client.disconnect();
      }
    }
    async subscribe() {
      debug("Starting FailoverDetector");
      const promises = [];
      for (const sentinel of this.sentinels) {
        const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {
          debug("Failed to subscribe to failover messages on sentinel %s:%s (%s)", sentinel.address.host || "127.0.0.1", sentinel.address.port || 26739, err.message);
        });
        promises.push(promise);
        sentinel.client.on("message", (channel) => {
          if (!this.isDisconnected && channel === CHANNEL_NAME) {
            this.disconnect();
          }
        });
      }
      await Promise.all(promises);
    }
    disconnect() {
      this.isDisconnected = true;
      debug("Failover detected, disconnecting");
      this.connector.disconnect();
    }
  }
  exports.FailoverDetector = FailoverDetector;
});

// node_modules/ioredis/built/connectors/SentinelConnector/index.js
var require_SentinelConnector = __commonJS((exports) => {
  var selectPreferredSentinel = function(availableSlaves, preferredSlaves) {
    if (availableSlaves.length === 0) {
      return null;
    }
    let selectedSlave;
    if (typeof preferredSlaves === "function") {
      selectedSlave = preferredSlaves(availableSlaves);
    } else if (preferredSlaves !== null && typeof preferredSlaves === "object") {
      const preferredSlavesArray = Array.isArray(preferredSlaves) ? preferredSlaves : [preferredSlaves];
      preferredSlavesArray.sort((a, b) => {
        if (!a.prio) {
          a.prio = 1;
        }
        if (!b.prio) {
          b.prio = 1;
        }
        if (a.prio < b.prio) {
          return -1;
        }
        if (a.prio > b.prio) {
          return 1;
        }
        return 0;
      });
      for (let p = 0;p < preferredSlavesArray.length; p++) {
        for (let a = 0;a < availableSlaves.length; a++) {
          const slave = availableSlaves[a];
          if (slave.ip === preferredSlavesArray[p].ip) {
            if (slave.port === preferredSlavesArray[p].port) {
              selectedSlave = slave;
              break;
            }
          }
        }
        if (selectedSlave) {
          break;
        }
      }
    }
    if (!selectedSlave) {
      selectedSlave = (0, utils_1.sample)(availableSlaves);
    }
    return addressResponseToAddress(selectedSlave);
  };
  var addressResponseToAddress = function(input) {
    return { host: input.ip, port: Number(input.port) };
  };
  var noop = function() {
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SentinelIterator = undefined;
  var net_1 = import.meta.require("net");
  var utils_1 = require_utils2();
  var tls_1 = import.meta.require("tls");
  var SentinelIterator_1 = require_SentinelIterator();
  exports.SentinelIterator = SentinelIterator_1.default;
  var AbstractConnector_1 = require_AbstractConnector();
  var Redis_1 = require_Redis();
  var FailoverDetector_1 = require_FailoverDetector();
  var debug = (0, utils_1.Debug)("SentinelConnector");

  class SentinelConnector extends AbstractConnector_1.default {
    constructor(options) {
      super(options.disconnectTimeout);
      this.options = options;
      this.emitter = null;
      this.failoverDetector = null;
      if (!this.options.sentinels.length) {
        throw new Error("Requires at least one sentinel to connect to.");
      }
      if (!this.options.name) {
        throw new Error("Requires the name of master.");
      }
      this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);
    }
    check(info) {
      const roleMatches = !info.role || this.options.role === info.role;
      if (!roleMatches) {
        debug("role invalid, expected %s, but got %s", this.options.role, info.role);
        this.sentinelIterator.next();
        this.sentinelIterator.next();
        this.sentinelIterator.reset(true);
      }
      return roleMatches;
    }
    disconnect() {
      super.disconnect();
      if (this.failoverDetector) {
        this.failoverDetector.cleanup();
      }
    }
    connect(eventEmitter) {
      this.connecting = true;
      this.retryAttempts = 0;
      let lastError;
      const connectToNext = async () => {
        const endpoint = this.sentinelIterator.next();
        if (endpoint.done) {
          this.sentinelIterator.reset(false);
          const retryDelay = typeof this.options.sentinelRetryStrategy === "function" ? this.options.sentinelRetryStrategy(++this.retryAttempts) : null;
          let errorMsg = typeof retryDelay !== "number" ? "All sentinels are unreachable and retry is disabled." : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;
          if (lastError) {
            errorMsg += ` Last error: ${lastError.message}`;
          }
          debug(errorMsg);
          const error = new Error(errorMsg);
          if (typeof retryDelay === "number") {
            eventEmitter("error", error);
            await new Promise((resolve) => setTimeout(resolve, retryDelay));
            return connectToNext();
          } else {
            throw error;
          }
        }
        let resolved = null;
        let err = null;
        try {
          resolved = await this.resolve(endpoint.value);
        } catch (error) {
          err = error;
        }
        if (!this.connecting) {
          throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);
        }
        const endpointAddress = endpoint.value.host + ":" + endpoint.value.port;
        if (resolved) {
          debug("resolved: %s:%s from sentinel %s", resolved.host, resolved.port, endpointAddress);
          if (this.options.enableTLSForSentinelMode && this.options.tls) {
            Object.assign(resolved, this.options.tls);
            this.stream = (0, tls_1.connect)(resolved);
            this.stream.once("secureConnect", this.initFailoverDetector.bind(this));
          } else {
            this.stream = (0, net_1.createConnection)(resolved);
            this.stream.once("connect", this.initFailoverDetector.bind(this));
          }
          this.stream.once("error", (err2) => {
            this.firstError = err2;
          });
          return this.stream;
        } else {
          const errorMsg = err ? "failed to connect to sentinel " + endpointAddress + " because " + err.message : "connected to sentinel " + endpointAddress + " successfully, but got an invalid reply: " + resolved;
          debug(errorMsg);
          eventEmitter("sentinelError", new Error(errorMsg));
          if (err) {
            lastError = err;
          }
          return connectToNext();
        }
      };
      return connectToNext();
    }
    async updateSentinels(client) {
      if (!this.options.updateSentinels) {
        return;
      }
      const result = await client.sentinel("sentinels", this.options.name);
      if (!Array.isArray(result)) {
        return;
      }
      result.map(utils_1.packObject).forEach((sentinel) => {
        const flags = sentinel.flags ? sentinel.flags.split(",") : [];
        if (flags.indexOf("disconnected") === -1 && sentinel.ip && sentinel.port) {
          const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));
          if (this.sentinelIterator.add(endpoint)) {
            debug("adding sentinel %s:%s", endpoint.host, endpoint.port);
          }
        }
      });
      debug("Updated internal sentinels: %s", this.sentinelIterator);
    }
    async resolveMaster(client) {
      const result = await client.sentinel("get-master-addr-by-name", this.options.name);
      await this.updateSentinels(client);
      return this.sentinelNatResolve(Array.isArray(result) ? { host: result[0], port: Number(result[1]) } : null);
    }
    async resolveSlave(client) {
      const result = await client.sentinel("slaves", this.options.name);
      if (!Array.isArray(result)) {
        return null;
      }
      const availableSlaves = result.map(utils_1.packObject).filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));
      return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));
    }
    sentinelNatResolve(item) {
      if (!item || !this.options.natMap)
        return item;
      return this.options.natMap[`${item.host}:${item.port}`] || item;
    }
    connectToSentinel(endpoint, options) {
      const redis = new Redis_1.default({
        port: endpoint.port || 26379,
        host: endpoint.host,
        username: this.options.sentinelUsername || null,
        password: this.options.sentinelPassword || null,
        family: endpoint.family || ("path" in this.options && this.options.path ? undefined : this.options.family),
        tls: this.options.sentinelTLS,
        retryStrategy: null,
        enableReadyCheck: false,
        connectTimeout: this.options.connectTimeout,
        commandTimeout: this.options.sentinelCommandTimeout,
        ...options
      });
      return redis;
    }
    async resolve(endpoint) {
      const client = this.connectToSentinel(endpoint);
      client.on("error", noop);
      try {
        if (this.options.role === "slave") {
          return await this.resolveSlave(client);
        } else {
          return await this.resolveMaster(client);
        }
      } finally {
        client.disconnect();
      }
    }
    async initFailoverDetector() {
      var _a;
      if (!this.options.failoverDetector) {
        return;
      }
      this.sentinelIterator.reset(true);
      const sentinels = [];
      while (sentinels.length < this.options.sentinelMaxConnections) {
        const { done, value } = this.sentinelIterator.next();
        if (done) {
          break;
        }
        const client = this.connectToSentinel(value, {
          lazyConnect: true,
          retryStrategy: this.options.sentinelReconnectStrategy
        });
        client.on("reconnecting", () => {
          var _a2;
          (_a2 = this.emitter) === null || _a2 === undefined || _a2.emit("sentinelReconnecting");
        });
        sentinels.push({ address: value, client });
      }
      this.sentinelIterator.reset(false);
      if (this.failoverDetector) {
        this.failoverDetector.cleanup();
      }
      this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);
      await this.failoverDetector.subscribe();
      (_a = this.emitter) === null || _a === undefined || _a.emit("failoverSubscribed");
    }
  }
  exports.default = SentinelConnector;
});

// node_modules/ioredis/built/connectors/index.js
var require_connectors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.SentinelConnector = exports.StandaloneConnector = undefined;
  var StandaloneConnector_1 = require_StandaloneConnector();
  exports.StandaloneConnector = StandaloneConnector_1.default;
  var SentinelConnector_1 = require_SentinelConnector();
  exports.SentinelConnector = SentinelConnector_1.default;
});

// node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js
var require_MaxRetriesPerRequestError = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var redis_errors_1 = require_redis_errors();

  class MaxRetriesPerRequestError extends redis_errors_1.AbortError {
    constructor(maxRetriesPerRequest) {
      const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to "maxRetriesPerRequest" option for details.`;
      super(message);
      Error.captureStackTrace(this, this.constructor);
    }
    get name() {
      return this.constructor.name;
    }
  }
  exports.default = MaxRetriesPerRequestError;
});

// node_modules/ioredis/built/errors/index.js
var require_errors = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MaxRetriesPerRequestError = undefined;
  var MaxRetriesPerRequestError_1 = require_MaxRetriesPerRequestError();
  exports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;
});

// node_modules/redis-parser/lib/parser.js
var require_parser = __commonJS((exports, module) => {
  var parseSimpleNumbers = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number = 0;
    var sign = 1;
    if (parser.buffer[offset] === 45) {
      sign = -1;
      offset++;
    }
    while (offset < length) {
      const c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        return sign * number;
      }
      number = number * 10 + (c1 - 48);
    }
  };
  var parseStringNumbers = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number = 0;
    var res = "";
    if (parser.buffer[offset] === 45) {
      res += "-";
      offset++;
    }
    while (offset < length) {
      var c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        if (number !== 0) {
          res += number;
        }
        return res;
      } else if (number > 429496728) {
        res += number * 10 + (c1 - 48);
        number = 0;
      } else if (c1 === 48 && number === 0) {
        res += 0;
      } else {
        number = number * 10 + (c1 - 48);
      }
    }
  };
  var parseSimpleString = function(parser) {
    const start = parser.offset;
    const buffer = parser.buffer;
    const length = buffer.length - 1;
    var offset = start;
    while (offset < length) {
      if (buffer[offset++] === 13) {
        parser.offset = offset + 1;
        if (parser.optionReturnBuffers === true) {
          return parser.buffer.slice(start, offset - 1);
        }
        return parser.buffer.toString("utf8", start, offset - 1);
      }
    }
  };
  var parseLength = function(parser) {
    const length = parser.buffer.length - 1;
    var offset = parser.offset;
    var number = 0;
    while (offset < length) {
      const c1 = parser.buffer[offset++];
      if (c1 === 13) {
        parser.offset = offset + 1;
        return number;
      }
      number = number * 10 + (c1 - 48);
    }
  };
  var parseInteger = function(parser) {
    if (parser.optionStringNumbers === true) {
      return parseStringNumbers(parser);
    }
    return parseSimpleNumbers(parser);
  };
  var parseBulkString = function(parser) {
    const length = parseLength(parser);
    if (length === undefined) {
      return;
    }
    if (length < 0) {
      return null;
    }
    const offset = parser.offset + length;
    if (offset + 2 > parser.buffer.length) {
      parser.bigStrSize = offset + 2;
      parser.totalChunkSize = parser.buffer.length;
      parser.bufferCache.push(parser.buffer);
      return;
    }
    const start = parser.offset;
    parser.offset = offset + 2;
    if (parser.optionReturnBuffers === true) {
      return parser.buffer.slice(start, offset);
    }
    return parser.buffer.toString("utf8", start, offset);
  };
  var parseError = function(parser) {
    var string = parseSimpleString(parser);
    if (string !== undefined) {
      if (parser.optionReturnBuffers === true) {
        string = string.toString();
      }
      return new ReplyError(string);
    }
  };
  var handleError = function(parser, type) {
    const err = new ParserError("Protocol error, got " + JSON.stringify(String.fromCharCode(type)) + " as reply type byte", JSON.stringify(parser.buffer), parser.offset);
    parser.buffer = null;
    parser.returnFatalError(err);
  };
  var parseArray = function(parser) {
    const length = parseLength(parser);
    if (length === undefined) {
      return;
    }
    if (length < 0) {
      return null;
    }
    const responses = new Array(length);
    return parseArrayElements(parser, responses, 0);
  };
  var pushArrayCache = function(parser, array, pos) {
    parser.arrayCache.push(array);
    parser.arrayPos.push(pos);
  };
  var parseArrayChunks = function(parser) {
    const tmp = parser.arrayCache.pop();
    var pos = parser.arrayPos.pop();
    if (parser.arrayCache.length) {
      const res = parseArrayChunks(parser);
      if (res === undefined) {
        pushArrayCache(parser, tmp, pos);
        return;
      }
      tmp[pos++] = res;
    }
    return parseArrayElements(parser, tmp, pos);
  };
  var parseArrayElements = function(parser, responses, i) {
    const bufferLength = parser.buffer.length;
    while (i < responses.length) {
      const offset = parser.offset;
      if (parser.offset >= bufferLength) {
        pushArrayCache(parser, responses, i);
        return;
      }
      const response = parseType(parser, parser.buffer[parser.offset++]);
      if (response === undefined) {
        if (!(parser.arrayCache.length || parser.bufferCache.length)) {
          parser.offset = offset;
        }
        pushArrayCache(parser, responses, i);
        return;
      }
      responses[i] = response;
      i++;
    }
    return responses;
  };
  var parseType = function(parser, type) {
    switch (type) {
      case 36:
        return parseBulkString(parser);
      case 43:
        return parseSimpleString(parser);
      case 42:
        return parseArray(parser);
      case 58:
        return parseInteger(parser);
      case 45:
        return parseError(parser);
      default:
        return handleError(parser, type);
    }
  };
  var decreaseBufferPool = function() {
    if (bufferPool.length > 50 * 1024) {
      if (counter === 1 || notDecreased > counter * 2) {
        const minSliceLen = Math.floor(bufferPool.length / 10);
        const sliceLength = minSliceLen < bufferOffset ? bufferOffset : minSliceLen;
        bufferOffset = 0;
        bufferPool = bufferPool.slice(sliceLength, bufferPool.length);
      } else {
        notDecreased++;
        counter--;
      }
    } else {
      clearInterval(interval);
      counter = 0;
      notDecreased = 0;
      interval = null;
    }
  };
  var resizeBuffer = function(length) {
    if (bufferPool.length < length + bufferOffset) {
      const multiplier = length > 1024 * 1024 * 75 ? 2 : 3;
      if (bufferOffset > 1024 * 1024 * 111) {
        bufferOffset = 1024 * 1024 * 50;
      }
      bufferPool = Buffer2.allocUnsafe(length * multiplier + bufferOffset);
      bufferOffset = 0;
      counter++;
      if (interval === null) {
        interval = setInterval(decreaseBufferPool, 50);
      }
    }
  };
  var concatBulkString = function(parser) {
    const list = parser.bufferCache;
    const oldOffset = parser.offset;
    var chunks = list.length;
    var offset = parser.bigStrSize - parser.totalChunkSize;
    parser.offset = offset;
    if (offset <= 2) {
      if (chunks === 2) {
        return list[0].toString("utf8", oldOffset, list[0].length + offset - 2);
      }
      chunks--;
      offset = list[list.length - 2].length + offset;
    }
    var res = decoder.write(list[0].slice(oldOffset));
    for (var i = 1;i < chunks - 1; i++) {
      res += decoder.write(list[i]);
    }
    res += decoder.end(list[i].slice(0, offset - 2));
    return res;
  };
  var concatBulkBuffer = function(parser) {
    const list = parser.bufferCache;
    const oldOffset = parser.offset;
    const length = parser.bigStrSize - oldOffset - 2;
    var chunks = list.length;
    var offset = parser.bigStrSize - parser.totalChunkSize;
    parser.offset = offset;
    if (offset <= 2) {
      if (chunks === 2) {
        return list[0].slice(oldOffset, list[0].length + offset - 2);
      }
      chunks--;
      offset = list[list.length - 2].length + offset;
    }
    resizeBuffer(length);
    const start = bufferOffset;
    list[0].copy(bufferPool, start, oldOffset, list[0].length);
    bufferOffset += list[0].length - oldOffset;
    for (var i = 1;i < chunks - 1; i++) {
      list[i].copy(bufferPool, bufferOffset);
      bufferOffset += list[i].length;
    }
    list[i].copy(bufferPool, bufferOffset, 0, offset - 2);
    bufferOffset += offset - 2;
    return bufferPool.slice(start, bufferOffset);
  };
  var Buffer2 = import.meta.require("buffer").Buffer;
  var StringDecoder = import.meta.require("string_decoder").StringDecoder;
  var decoder = new StringDecoder;
  var errors = require_redis_errors();
  var ReplyError = errors.ReplyError;
  var ParserError = errors.ParserError;
  var bufferPool = Buffer2.allocUnsafe(32 * 1024);
  var bufferOffset = 0;
  var interval = null;
  var counter = 0;
  var notDecreased = 0;

  class JavascriptRedisParser {
    constructor(options) {
      if (!options) {
        throw new TypeError("Options are mandatory.");
      }
      if (typeof options.returnError !== "function" || typeof options.returnReply !== "function") {
        throw new TypeError("The returnReply and returnError options have to be functions.");
      }
      this.setReturnBuffers(!!options.returnBuffers);
      this.setStringNumbers(!!options.stringNumbers);
      this.returnError = options.returnError;
      this.returnFatalError = options.returnFatalError || options.returnError;
      this.returnReply = options.returnReply;
      this.reset();
    }
    reset() {
      this.offset = 0;
      this.buffer = null;
      this.bigStrSize = 0;
      this.totalChunkSize = 0;
      this.bufferCache = [];
      this.arrayCache = [];
      this.arrayPos = [];
    }
    setReturnBuffers(returnBuffers) {
      if (typeof returnBuffers !== "boolean") {
        throw new TypeError("The returnBuffers argument has to be a boolean");
      }
      this.optionReturnBuffers = returnBuffers;
    }
    setStringNumbers(stringNumbers) {
      if (typeof stringNumbers !== "boolean") {
        throw new TypeError("The stringNumbers argument has to be a boolean");
      }
      this.optionStringNumbers = stringNumbers;
    }
    execute(buffer) {
      if (this.buffer === null) {
        this.buffer = buffer;
        this.offset = 0;
      } else if (this.bigStrSize === 0) {
        const oldLength = this.buffer.length;
        const remainingLength = oldLength - this.offset;
        const newBuffer = Buffer2.allocUnsafe(remainingLength + buffer.length);
        this.buffer.copy(newBuffer, 0, this.offset, oldLength);
        buffer.copy(newBuffer, remainingLength, 0, buffer.length);
        this.buffer = newBuffer;
        this.offset = 0;
        if (this.arrayCache.length) {
          const arr = parseArrayChunks(this);
          if (arr === undefined) {
            return;
          }
          this.returnReply(arr);
        }
      } else if (this.totalChunkSize + buffer.length >= this.bigStrSize) {
        this.bufferCache.push(buffer);
        var tmp = this.optionReturnBuffers ? concatBulkBuffer(this) : concatBulkString(this);
        this.bigStrSize = 0;
        this.bufferCache = [];
        this.buffer = buffer;
        if (this.arrayCache.length) {
          this.arrayCache[0][this.arrayPos[0]++] = tmp;
          tmp = parseArrayChunks(this);
          if (tmp === undefined) {
            return;
          }
        }
        this.returnReply(tmp);
      } else {
        this.bufferCache.push(buffer);
        this.totalChunkSize += buffer.length;
        return;
      }
      while (this.offset < this.buffer.length) {
        const offset = this.offset;
        const type = this.buffer[this.offset++];
        const response = parseType(this, type);
        if (response === undefined) {
          if (!(this.arrayCache.length || this.bufferCache.length)) {
            this.offset = offset;
          }
          return;
        }
        if (type === 45) {
          this.returnError(response);
        } else {
          this.returnReply(response);
        }
      }
      this.buffer = null;
    }
  }
  module.exports = JavascriptRedisParser;
});

// node_modules/ioredis/built/SubscriptionSet.js
var require_SubscriptionSet = __commonJS((exports) => {
  var mapSet = function(set) {
    if (set === "unsubscribe") {
      return "subscribe";
    }
    if (set === "punsubscribe") {
      return "psubscribe";
    }
    if (set === "sunsubscribe") {
      return "ssubscribe";
    }
    return set;
  };
  Object.defineProperty(exports, "__esModule", { value: true });

  class SubscriptionSet {
    constructor() {
      this.set = {
        subscribe: {},
        psubscribe: {},
        ssubscribe: {}
      };
    }
    add(set, channel) {
      this.set[mapSet(set)][channel] = true;
    }
    del(set, channel) {
      delete this.set[mapSet(set)][channel];
    }
    channels(set) {
      return Object.keys(this.set[mapSet(set)]);
    }
    isEmpty() {
      return this.channels("subscribe").length === 0 && this.channels("psubscribe").length === 0 && this.channels("ssubscribe").length === 0;
    }
  }
  exports.default = SubscriptionSet;
});

// node_modules/ioredis/built/DataHandler.js
var require_DataHandler = __commonJS((exports) => {
  var fillSubCommand = function(command, count) {
    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;
    remainingReplies -= 1;
    if (remainingReplies <= 0) {
      command.resolve(count);
      remainingRepliesMap.delete(command);
      return true;
    }
    remainingRepliesMap.set(command, remainingReplies);
    return false;
  };
  var fillUnsubCommand = function(command, count) {
    let remainingReplies = remainingRepliesMap.has(command) ? remainingRepliesMap.get(command) : command.args.length;
    if (remainingReplies === 0) {
      if (Number(count) === 0) {
        remainingRepliesMap.delete(command);
        command.resolve(count);
        return true;
      }
      return false;
    }
    remainingReplies -= 1;
    if (remainingReplies <= 0) {
      command.resolve(count);
      return true;
    }
    remainingRepliesMap.set(command, remainingReplies);
    return false;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var Command_1 = require_Command();
  var utils_1 = require_utils2();
  var RedisParser = require_parser();
  var SubscriptionSet_1 = require_SubscriptionSet();
  var debug = (0, utils_1.Debug)("dataHandler");

  class DataHandler {
    constructor(redis, parserOptions) {
      this.redis = redis;
      const parser = new RedisParser({
        stringNumbers: parserOptions.stringNumbers,
        returnBuffers: true,
        returnError: (err) => {
          this.returnError(err);
        },
        returnFatalError: (err) => {
          this.returnFatalError(err);
        },
        returnReply: (reply) => {
          this.returnReply(reply);
        }
      });
      redis.stream.on("data", (data) => {
        parser.execute(data);
      });
    }
    returnFatalError(err) {
      err.message += ". Please report this.";
      this.redis.recoverFromFatalError(err, err, { offlineQueue: false });
    }
    returnError(err) {
      const item = this.shiftCommand(err);
      if (!item) {
        return;
      }
      err.command = {
        name: item.command.name,
        args: item.command.args
      };
      this.redis.handleReconnection(err, item);
    }
    returnReply(reply) {
      if (this.handleMonitorReply(reply)) {
        return;
      }
      if (this.handleSubscriberReply(reply)) {
        return;
      }
      const item = this.shiftCommand(reply);
      if (!item) {
        return;
      }
      if (Command_1.default.checkFlag("ENTER_SUBSCRIBER_MODE", item.command.name)) {
        this.redis.condition.subscriber = new SubscriptionSet_1.default;
        this.redis.condition.subscriber.add(item.command.name, reply[1].toString());
        if (!fillSubCommand(item.command, reply[2])) {
          this.redis.commandQueue.unshift(item);
        }
      } else if (Command_1.default.checkFlag("EXIT_SUBSCRIBER_MODE", item.command.name)) {
        if (!fillUnsubCommand(item.command, reply[2])) {
          this.redis.commandQueue.unshift(item);
        }
      } else {
        item.command.resolve(reply);
      }
    }
    handleSubscriberReply(reply) {
      if (!this.redis.condition.subscriber) {
        return false;
      }
      const replyType = Array.isArray(reply) ? reply[0].toString() : null;
      debug('receive reply "%s" in subscriber mode', replyType);
      switch (replyType) {
        case "message":
          if (this.redis.listeners("message").length > 0) {
            this.redis.emit("message", reply[1].toString(), reply[2] ? reply[2].toString() : "");
          }
          this.redis.emit("messageBuffer", reply[1], reply[2]);
          break;
        case "pmessage": {
          const pattern = reply[1].toString();
          if (this.redis.listeners("pmessage").length > 0) {
            this.redis.emit("pmessage", pattern, reply[2].toString(), reply[3].toString());
          }
          this.redis.emit("pmessageBuffer", pattern, reply[2], reply[3]);
          break;
        }
        case "smessage": {
          if (this.redis.listeners("smessage").length > 0) {
            this.redis.emit("smessage", reply[1].toString(), reply[2] ? reply[2].toString() : "");
          }
          this.redis.emit("smessageBuffer", reply[1], reply[2]);
          break;
        }
        case "ssubscribe":
        case "subscribe":
        case "psubscribe": {
          const channel = reply[1].toString();
          this.redis.condition.subscriber.add(replyType, channel);
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          if (!fillSubCommand(item.command, reply[2])) {
            this.redis.commandQueue.unshift(item);
          }
          break;
        }
        case "sunsubscribe":
        case "unsubscribe":
        case "punsubscribe": {
          const channel = reply[1] ? reply[1].toString() : null;
          if (channel) {
            this.redis.condition.subscriber.del(replyType, channel);
          }
          const count = reply[2];
          if (Number(count) === 0) {
            this.redis.condition.subscriber = false;
          }
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          if (!fillUnsubCommand(item.command, count)) {
            this.redis.commandQueue.unshift(item);
          }
          break;
        }
        default: {
          const item = this.shiftCommand(reply);
          if (!item) {
            return;
          }
          item.command.resolve(reply);
        }
      }
      return true;
    }
    handleMonitorReply(reply) {
      if (this.redis.status !== "monitoring") {
        return false;
      }
      const replyStr = reply.toString();
      if (replyStr === "OK") {
        return false;
      }
      const len = replyStr.indexOf(" ");
      const timestamp = replyStr.slice(0, len);
      const argIndex = replyStr.indexOf('"');
      const args = replyStr.slice(argIndex + 1, -1).split('" "').map((elem) => elem.replace(/\\"/g, '"'));
      const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(" ");
      this.redis.emit("monitor", timestamp, args, dbAndSource[1], dbAndSource[0]);
      return true;
    }
    shiftCommand(reply) {
      const item = this.redis.commandQueue.shift();
      if (!item) {
        const message = "Command queue state error. If you can reproduce this, please report it.";
        const error = new Error(message + (reply instanceof Error ? ` Last error: ${reply.message}` : ` Last reply: ${reply.toString()}`));
        this.redis.emit("error", error);
        return null;
      }
      return item;
    }
  }
  exports.default = DataHandler;
  var remainingRepliesMap = new WeakMap;
});

// node_modules/ioredis/built/redis/event_handler.js
var require_event_handler = __commonJS((exports) => {
  var connectHandler = function(self2) {
    return function() {
      self2.setStatus("connect");
      self2.resetCommandQueue();
      let flushed = false;
      const { connectionEpoch } = self2;
      if (self2.condition.auth) {
        self2.auth(self2.condition.auth, function(err) {
          if (connectionEpoch !== self2.connectionEpoch) {
            return;
          }
          if (err) {
            if (err.message.indexOf("no password is set") !== -1) {
              console.warn("[WARN] Redis server does not require a password, but a password was supplied.");
            } else if (err.message.indexOf("without any password configured for the default user") !== -1) {
              console.warn("[WARN] This Redis server's `default` user does not require a password, but a password was supplied");
            } else if (err.message.indexOf("wrong number of arguments for 'auth' command") !== -1) {
              console.warn(`[ERROR] The server returned "wrong number of arguments for 'auth' command". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);
            } else {
              flushed = true;
              self2.recoverFromFatalError(err, err);
            }
          }
        });
      }
      if (self2.condition.select) {
        self2.select(self2.condition.select).catch((err) => {
          self2.silentEmit("error", err);
        });
      }
      if (!self2.options.enableReadyCheck) {
        exports.readyHandler(self2)();
      }
      new DataHandler_1.default(self2, {
        stringNumbers: self2.options.stringNumbers
      });
      if (self2.options.enableReadyCheck) {
        self2._readyCheck(function(err, info) {
          if (connectionEpoch !== self2.connectionEpoch) {
            return;
          }
          if (err) {
            if (!flushed) {
              self2.recoverFromFatalError(new Error("Ready check failed: " + err.message), err);
            }
          } else {
            if (self2.connector.check(info)) {
              exports.readyHandler(self2)();
            } else {
              self2.disconnect(true);
            }
          }
        });
      }
    };
  };
  var abortError = function(command) {
    const err = new redis_errors_1.AbortError("Command aborted due to connection close");
    err.command = {
      name: command.name,
      args: command.args
    };
    return err;
  };
  var abortIncompletePipelines = function(commandQueue) {
    var _a;
    let expectedIndex = 0;
    for (let i = 0;i < commandQueue.length; ) {
      const command = (_a = commandQueue.peekAt(i)) === null || _a === undefined ? undefined : _a.command;
      const pipelineIndex = command.pipelineIndex;
      if (pipelineIndex === undefined || pipelineIndex === 0) {
        expectedIndex = 0;
      }
      if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
        continue;
      }
      i++;
    }
  };
  var abortTransactionFragments = function(commandQueue) {
    var _a;
    for (let i = 0;i < commandQueue.length; ) {
      const command = (_a = commandQueue.peekAt(i)) === null || _a === undefined ? undefined : _a.command;
      if (command.name === "multi") {
        break;
      }
      if (command.name === "exec") {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
        break;
      }
      if (command.inTransaction) {
        commandQueue.remove(i, 1);
        command.reject(abortError(command));
      } else {
        i++;
      }
    }
  };
  var closeHandler = function(self2) {
    return function() {
      const prevStatus = self2.status;
      self2.setStatus("close");
      if (self2.commandQueue.length) {
        abortIncompletePipelines(self2.commandQueue);
      }
      if (self2.offlineQueue.length) {
        abortTransactionFragments(self2.offlineQueue);
      }
      if (prevStatus === "ready") {
        if (!self2.prevCondition) {
          self2.prevCondition = self2.condition;
        }
        if (self2.commandQueue.length) {
          self2.prevCommandQueue = self2.commandQueue;
        }
      }
      if (self2.manuallyClosing) {
        self2.manuallyClosing = false;
        debug("skip reconnecting since the connection is manually closed.");
        return close();
      }
      if (typeof self2.options.retryStrategy !== "function") {
        debug("skip reconnecting because `retryStrategy` is not a function");
        return close();
      }
      const retryDelay = self2.options.retryStrategy(++self2.retryAttempts);
      if (typeof retryDelay !== "number") {
        debug("skip reconnecting because `retryStrategy` doesn't return a number");
        return close();
      }
      debug("reconnect in %sms", retryDelay);
      self2.setStatus("reconnecting", retryDelay);
      self2.reconnectTimeout = setTimeout(function() {
        self2.reconnectTimeout = null;
        self2.connect().catch(utils_1.noop);
      }, retryDelay);
      const { maxRetriesPerRequest } = self2.options;
      if (typeof maxRetriesPerRequest === "number") {
        if (maxRetriesPerRequest < 0) {
          debug("maxRetriesPerRequest is negative, ignoring...");
        } else {
          const remainder = self2.retryAttempts % (maxRetriesPerRequest + 1);
          if (remainder === 0) {
            debug("reach maxRetriesPerRequest limitation, flushing command queue...");
            self2.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));
          }
        }
      }
    };
    function close() {
      self2.setStatus("end");
      self2.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
    }
  };
  var errorHandler = function(self2) {
    return function(error) {
      debug("error: %s", error);
      self2.silentEmit("error", error);
    };
  };
  var readyHandler = function(self2) {
    return function() {
      self2.setStatus("ready");
      self2.retryAttempts = 0;
      if (self2.options.monitor) {
        self2.call("monitor").then(() => self2.setStatus("monitoring"), (error) => self2.emit("error", error));
        const { sendCommand } = self2;
        self2.sendCommand = function(command) {
          if (Command_1.default.checkFlag("VALID_IN_MONITOR_MODE", command.name)) {
            return sendCommand.call(self2, command);
          }
          command.reject(new Error("Connection is in monitoring mode, can't process commands."));
          return command.promise;
        };
        self2.once("close", function() {
          delete self2.sendCommand;
        });
        return;
      }
      const finalSelect = self2.prevCondition ? self2.prevCondition.select : self2.condition.select;
      if (self2.options.connectionName) {
        debug("set the connection name [%s]", self2.options.connectionName);
        self2.client("setname", self2.options.connectionName).catch(utils_1.noop);
      }
      if (self2.options.readOnly) {
        debug("set the connection to readonly mode");
        self2.readonly().catch(utils_1.noop);
      }
      if (self2.prevCondition) {
        const condition = self2.prevCondition;
        self2.prevCondition = null;
        if (condition.subscriber && self2.options.autoResubscribe) {
          if (self2.condition.select !== finalSelect) {
            debug("connect to db [%d]", finalSelect);
            self2.select(finalSelect);
          }
          const subscribeChannels = condition.subscriber.channels("subscribe");
          if (subscribeChannels.length) {
            debug("subscribe %d channels", subscribeChannels.length);
            self2.subscribe(subscribeChannels);
          }
          const psubscribeChannels = condition.subscriber.channels("psubscribe");
          if (psubscribeChannels.length) {
            debug("psubscribe %d channels", psubscribeChannels.length);
            self2.psubscribe(psubscribeChannels);
          }
          const ssubscribeChannels = condition.subscriber.channels("ssubscribe");
          if (ssubscribeChannels.length) {
            debug("ssubscribe %d channels", ssubscribeChannels.length);
            self2.ssubscribe(ssubscribeChannels);
          }
        }
      }
      if (self2.prevCommandQueue) {
        if (self2.options.autoResendUnfulfilledCommands) {
          debug("resend %d unfulfilled commands", self2.prevCommandQueue.length);
          while (self2.prevCommandQueue.length > 0) {
            const item = self2.prevCommandQueue.shift();
            if (item.select !== self2.condition.select && item.command.name !== "select") {
              self2.select(item.select);
            }
            self2.sendCommand(item.command, item.stream);
          }
        } else {
          self2.prevCommandQueue = null;
        }
      }
      if (self2.offlineQueue.length) {
        debug("send %d commands in offline queue", self2.offlineQueue.length);
        const offlineQueue = self2.offlineQueue;
        self2.resetOfflineQueue();
        while (offlineQueue.length > 0) {
          const item = offlineQueue.shift();
          if (item.select !== self2.condition.select && item.command.name !== "select") {
            self2.select(item.select);
          }
          self2.sendCommand(item.command, item.stream);
        }
      }
      if (self2.condition.select !== finalSelect) {
        debug("connect to db [%d]", finalSelect);
        self2.select(finalSelect);
      }
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = undefined;
  var redis_errors_1 = require_redis_errors();
  var Command_1 = require_Command();
  var errors_1 = require_errors();
  var utils_1 = require_utils2();
  var DataHandler_1 = require_DataHandler();
  var debug = (0, utils_1.Debug)("connection");
  exports.connectHandler = connectHandler;
  exports.closeHandler = closeHandler;
  exports.errorHandler = errorHandler;
  exports.readyHandler = readyHandler;
});

// node_modules/ioredis/built/redis/RedisOptions.js
var require_RedisOptions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DEFAULT_REDIS_OPTIONS = undefined;
  exports.DEFAULT_REDIS_OPTIONS = {
    port: 6379,
    host: "localhost",
    family: 4,
    connectTimeout: 1e4,
    disconnectTimeout: 2000,
    retryStrategy: function(times) {
      return Math.min(times * 50, 2000);
    },
    keepAlive: 0,
    noDelay: true,
    connectionName: null,
    sentinels: null,
    name: null,
    role: "master",
    sentinelRetryStrategy: function(times) {
      return Math.min(times * 10, 1000);
    },
    sentinelReconnectStrategy: function() {
      return 60000;
    },
    natMap: null,
    enableTLSForSentinelMode: false,
    updateSentinels: true,
    failoverDetector: false,
    username: null,
    password: null,
    db: 0,
    enableOfflineQueue: true,
    enableReadyCheck: true,
    autoResubscribe: true,
    autoResendUnfulfilledCommands: true,
    lazyConnect: false,
    keyPrefix: "",
    reconnectOnError: null,
    readOnly: false,
    stringNumbers: false,
    maxRetriesPerRequest: 20,
    maxLoadingRetryTime: 1e4,
    enableAutoPipelining: false,
    autoPipeliningIgnoredCommands: [],
    sentinelMaxConnections: 10
  };
});

// node_modules/ioredis/built/Redis.js
var require_Redis = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var commands_1 = require_built();
  var events_1 = import.meta.require("events");
  var standard_as_callback_1 = require_built2();
  var cluster_1 = require_cluster();
  var Command_1 = require_Command();
  var connectors_1 = require_connectors();
  var SentinelConnector_1 = require_SentinelConnector();
  var eventHandler = require_event_handler();
  var RedisOptions_1 = require_RedisOptions();
  var ScanStream_1 = require_ScanStream();
  var transaction_1 = require_transaction();
  var utils_1 = require_utils2();
  var applyMixin_1 = require_applyMixin();
  var Commander_1 = require_Commander();
  var lodash_1 = require_lodash3();
  var Deque = require_denque();
  var debug = (0, utils_1.Debug)("redis");

  class Redis extends Commander_1.default {
    constructor(arg1, arg2, arg3) {
      super();
      this.status = "wait";
      this.isCluster = false;
      this.reconnectTimeout = null;
      this.connectionEpoch = 0;
      this.retryAttempts = 0;
      this.manuallyClosing = false;
      this._autoPipelines = new Map;
      this._runningAutoPipelines = new Set;
      this.parseOptions(arg1, arg2, arg3);
      events_1.EventEmitter.call(this);
      this.resetCommandQueue();
      this.resetOfflineQueue();
      if (this.options.Connector) {
        this.connector = new this.options.Connector(this.options);
      } else if (this.options.sentinels) {
        const sentinelConnector = new SentinelConnector_1.default(this.options);
        sentinelConnector.emitter = this;
        this.connector = sentinelConnector;
      } else {
        this.connector = new connectors_1.StandaloneConnector(this.options);
      }
      if (this.options.scripts) {
        Object.entries(this.options.scripts).forEach(([name, definition]) => {
          this.defineCommand(name, definition);
        });
      }
      if (this.options.lazyConnect) {
        this.setStatus("wait");
      } else {
        this.connect().catch(lodash_1.noop);
      }
    }
    static createClient(...args) {
      return new Redis(...args);
    }
    get autoPipelineQueueSize() {
      let queued = 0;
      for (const pipeline of this._autoPipelines.values()) {
        queued += pipeline.length;
      }
      return queued;
    }
    connect(callback) {
      const promise = new Promise((resolve, reject) => {
        if (this.status === "connecting" || this.status === "connect" || this.status === "ready") {
          reject(new Error("Redis is already connecting/connected"));
          return;
        }
        this.connectionEpoch += 1;
        this.setStatus("connecting");
        const { options } = this;
        this.condition = {
          select: options.db,
          auth: options.username ? [options.username, options.password] : options.password,
          subscriber: false
        };
        const _this = this;
        (0, standard_as_callback_1.default)(this.connector.connect(function(type, err) {
          _this.silentEmit(type, err);
        }), function(err, stream) {
          if (err) {
            _this.flushQueue(err);
            _this.silentEmit("error", err);
            reject(err);
            _this.setStatus("end");
            return;
          }
          let CONNECT_EVENT = options.tls ? "secureConnect" : "connect";
          if ("sentinels" in options && options.sentinels && !options.enableTLSForSentinelMode) {
            CONNECT_EVENT = "connect";
          }
          _this.stream = stream;
          if (options.noDelay) {
            stream.setNoDelay(true);
          }
          if (typeof options.keepAlive === "number") {
            if (stream.connecting) {
              stream.once(CONNECT_EVENT, () => {
                stream.setKeepAlive(true, options.keepAlive);
              });
            } else {
              stream.setKeepAlive(true, options.keepAlive);
            }
          }
          if (stream.connecting) {
            stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));
            if (options.connectTimeout) {
              let connectTimeoutCleared = false;
              stream.setTimeout(options.connectTimeout, function() {
                if (connectTimeoutCleared) {
                  return;
                }
                stream.setTimeout(0);
                stream.destroy();
                const err2 = new Error("connect ETIMEDOUT");
                err2.errorno = "ETIMEDOUT";
                err2.code = "ETIMEDOUT";
                err2.syscall = "connect";
                eventHandler.errorHandler(_this)(err2);
              });
              stream.once(CONNECT_EVENT, function() {
                connectTimeoutCleared = true;
                stream.setTimeout(0);
              });
            }
          } else if (stream.destroyed) {
            const firstError = _this.connector.firstError;
            if (firstError) {
              process.nextTick(() => {
                eventHandler.errorHandler(_this)(firstError);
              });
            }
            process.nextTick(eventHandler.closeHandler(_this));
          } else {
            process.nextTick(eventHandler.connectHandler(_this));
          }
          if (!stream.destroyed) {
            stream.once("error", eventHandler.errorHandler(_this));
            stream.once("close", eventHandler.closeHandler(_this));
          }
          const connectionReadyHandler = function() {
            _this.removeListener("close", connectionCloseHandler);
            resolve();
          };
          var connectionCloseHandler = function() {
            _this.removeListener("ready", connectionReadyHandler);
            reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
          };
          _this.once("ready", connectionReadyHandler);
          _this.once("close", connectionCloseHandler);
        });
      });
      return (0, standard_as_callback_1.default)(promise, callback);
    }
    disconnect(reconnect = false) {
      if (!reconnect) {
        this.manuallyClosing = true;
      }
      if (this.reconnectTimeout && !reconnect) {
        clearTimeout(this.reconnectTimeout);
        this.reconnectTimeout = null;
      }
      if (this.status === "wait") {
        eventHandler.closeHandler(this)();
      } else {
        this.connector.disconnect();
      }
    }
    end() {
      this.disconnect();
    }
    duplicate(override) {
      return new Redis({ ...this.options, ...override });
    }
    get mode() {
      var _a;
      return this.options.monitor ? "monitor" : ((_a = this.condition) === null || _a === undefined ? undefined : _a.subscriber) ? "subscriber" : "normal";
    }
    monitor(callback) {
      const monitorInstance = this.duplicate({
        monitor: true,
        lazyConnect: false
      });
      return (0, standard_as_callback_1.default)(new Promise(function(resolve, reject) {
        monitorInstance.once("error", reject);
        monitorInstance.once("monitoring", function() {
          resolve(monitorInstance);
        });
      }), callback);
    }
    sendCommand(command, stream) {
      var _a, _b;
      if (this.status === "wait") {
        this.connect().catch(lodash_1.noop);
      }
      if (this.status === "end") {
        command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));
        return command.promise;
      }
      if (((_a = this.condition) === null || _a === undefined ? undefined : _a.subscriber) && !Command_1.default.checkFlag("VALID_IN_SUBSCRIBER_MODE", command.name)) {
        command.reject(new Error("Connection in subscriber mode, only subscriber commands may be used"));
        return command.promise;
      }
      if (typeof this.options.commandTimeout === "number") {
        command.setTimeout(this.options.commandTimeout);
      }
      let writable = this.status === "ready" || !stream && this.status === "connect" && (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, "loading");
      if (!this.stream) {
        writable = false;
      } else if (!this.stream.writable) {
        writable = false;
      } else if (this.stream._writableState && this.stream._writableState.ended) {
        writable = false;
      }
      if (!writable) {
        if (!this.options.enableOfflineQueue) {
          command.reject(new Error("Stream isn't writeable and enableOfflineQueue options is false"));
          return command.promise;
        }
        if (command.name === "quit" && this.offlineQueue.length === 0) {
          this.disconnect();
          command.resolve(Buffer.from("OK"));
          return command.promise;
        }
        if (debug.enabled) {
          debug("queue command[%s]: %d -> %s(%o)", this._getDescription(), this.condition.select, command.name, command.args);
        }
        this.offlineQueue.push({
          command,
          stream,
          select: this.condition.select
        });
      } else {
        if (debug.enabled) {
          debug("write command[%s]: %d -> %s(%o)", this._getDescription(), (_b = this.condition) === null || _b === undefined ? undefined : _b.select, command.name, command.args);
        }
        if (stream) {
          if ("isPipeline" in stream && stream.isPipeline) {
            stream.write(command.toWritable(stream.destination.redis.stream));
          } else {
            stream.write(command.toWritable(stream));
          }
        } else {
          this.stream.write(command.toWritable(this.stream));
        }
        this.commandQueue.push({
          command,
          stream,
          select: this.condition.select
        });
        if (Command_1.default.checkFlag("WILL_DISCONNECT", command.name)) {
          this.manuallyClosing = true;
        }
      }
      if (command.name === "select" && (0, utils_1.isInt)(command.args[0])) {
        const db = parseInt(command.args[0], 10);
        if (this.condition.select !== db) {
          this.condition.select = db;
          this.emit("select", db);
          debug("switch to db [%d]", this.condition.select);
        }
      }
      return command.promise;
    }
    scanStream(options) {
      return this.createScanStream("scan", { options });
    }
    scanBufferStream(options) {
      return this.createScanStream("scanBuffer", { options });
    }
    sscanStream(key, options) {
      return this.createScanStream("sscan", { key, options });
    }
    sscanBufferStream(key, options) {
      return this.createScanStream("sscanBuffer", { key, options });
    }
    hscanStream(key, options) {
      return this.createScanStream("hscan", { key, options });
    }
    hscanBufferStream(key, options) {
      return this.createScanStream("hscanBuffer", { key, options });
    }
    zscanStream(key, options) {
      return this.createScanStream("zscan", { key, options });
    }
    zscanBufferStream(key, options) {
      return this.createScanStream("zscanBuffer", { key, options });
    }
    silentEmit(eventName, arg) {
      let error;
      if (eventName === "error") {
        error = arg;
        if (this.status === "end") {
          return;
        }
        if (this.manuallyClosing) {
          if (error instanceof Error && (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG || error.syscall === "connect" || error.syscall === "read")) {
            return;
          }
        }
      }
      if (this.listeners(eventName).length > 0) {
        return this.emit.apply(this, arguments);
      }
      if (error && error instanceof Error) {
        console.error("[ioredis] Unhandled error event:", error.stack);
      }
      return false;
    }
    recoverFromFatalError(_commandError, err, options) {
      this.flushQueue(err, options);
      this.silentEmit("error", err);
      this.disconnect(true);
    }
    handleReconnection(err, item) {
      var _a;
      let needReconnect = false;
      if (this.options.reconnectOnError) {
        needReconnect = this.options.reconnectOnError(err);
      }
      switch (needReconnect) {
        case 1:
        case true:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          item.command.reject(err);
          break;
        case 2:
          if (this.status !== "reconnecting") {
            this.disconnect(true);
          }
          if (((_a = this.condition) === null || _a === undefined ? undefined : _a.select) !== item.select && item.command.name !== "select") {
            this.select(item.select);
          }
          this.sendCommand(item.command);
          break;
        default:
          item.command.reject(err);
      }
    }
    _getDescription() {
      let description;
      if ("path" in this.options && this.options.path) {
        description = this.options.path;
      } else if (this.stream && this.stream.remoteAddress && this.stream.remotePort) {
        description = this.stream.remoteAddress + ":" + this.stream.remotePort;
      } else if ("host" in this.options && this.options.host) {
        description = this.options.host + ":" + this.options.port;
      } else {
        description = "";
      }
      if (this.options.connectionName) {
        description += ` (${this.options.connectionName})`;
      }
      return description;
    }
    resetCommandQueue() {
      this.commandQueue = new Deque;
    }
    resetOfflineQueue() {
      this.offlineQueue = new Deque;
    }
    parseOptions(...args) {
      const options = {};
      let isTls = false;
      for (let i = 0;i < args.length; ++i) {
        const arg = args[i];
        if (arg === null || typeof arg === "undefined") {
          continue;
        }
        if (typeof arg === "object") {
          (0, lodash_1.defaults)(options, arg);
        } else if (typeof arg === "string") {
          (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));
          if (arg.startsWith("rediss://")) {
            isTls = true;
          }
        } else if (typeof arg === "number") {
          options.port = arg;
        } else {
          throw new Error("Invalid argument " + arg);
        }
      }
      if (isTls) {
        (0, lodash_1.defaults)(options, { tls: true });
      }
      (0, lodash_1.defaults)(options, Redis.defaultOptions);
      if (typeof options.port === "string") {
        options.port = parseInt(options.port, 10);
      }
      if (typeof options.db === "string") {
        options.db = parseInt(options.db, 10);
      }
      this.options = (0, utils_1.resolveTLSProfile)(options);
    }
    setStatus(status, arg) {
      if (debug.enabled) {
        debug("status[%s]: %s -> %s", this._getDescription(), this.status || "[empty]", status);
      }
      this.status = status;
      process.nextTick(this.emit.bind(this, status, arg));
    }
    createScanStream(command, { key, options = {} }) {
      return new ScanStream_1.default({
        objectMode: true,
        key,
        redis: this,
        command,
        ...options
      });
    }
    flushQueue(error, options) {
      options = (0, lodash_1.defaults)({}, options, {
        offlineQueue: true,
        commandQueue: true
      });
      let item;
      if (options.offlineQueue) {
        while (item = this.offlineQueue.shift()) {
          item.command.reject(error);
        }
      }
      if (options.commandQueue) {
        if (this.commandQueue.length > 0) {
          if (this.stream) {
            this.stream.removeAllListeners("data");
          }
          while (item = this.commandQueue.shift()) {
            item.command.reject(error);
          }
        }
      }
    }
    _readyCheck(callback) {
      const _this = this;
      this.info(function(err, res) {
        if (err) {
          if (err.message && err.message.includes("NOPERM")) {
            console.warn(`Skipping the ready check because INFO command fails: "${err.message}". You can disable ready check with "enableReadyCheck". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);
            return callback(null, {});
          }
          return callback(err);
        }
        if (typeof res !== "string") {
          return callback(null, res);
        }
        const info = {};
        const lines = res.split("\r\n");
        for (let i = 0;i < lines.length; ++i) {
          const [fieldName, ...fieldValueParts] = lines[i].split(":");
          const fieldValue = fieldValueParts.join(":");
          if (fieldValue) {
            info[fieldName] = fieldValue;
          }
        }
        if (!info.loading || info.loading === "0") {
          callback(null, info);
        } else {
          const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;
          const retryTime = _this.options.maxLoadingRetryTime && _this.options.maxLoadingRetryTime < loadingEtaMs ? _this.options.maxLoadingRetryTime : loadingEtaMs;
          debug("Redis server still loading, trying again in " + retryTime + "ms");
          setTimeout(function() {
            _this._readyCheck(callback);
          }, retryTime);
        }
      }).catch(lodash_1.noop);
    }
  }
  Redis.Cluster = cluster_1.default;
  Redis.Command = Command_1.default;
  Redis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;
  (0, applyMixin_1.default)(Redis, events_1.EventEmitter);
  (0, transaction_1.addTransactionSupport)(Redis.prototype);
  exports.default = Redis;
});

// node_modules/ioredis/built/index.js
var require_built3 = __commonJS((exports, module) => {
  var print = function(err, reply) {
    if (err) {
      console.log("Error: " + err);
    } else {
      console.log("Reply: " + reply);
    }
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports.default = undefined;
  exports = module.exports = require_Redis().default;
  var Redis_1 = require_Redis();
  Object.defineProperty(exports, "default", { enumerable: true, get: function() {
    return Redis_1.default;
  } });
  var Redis_2 = require_Redis();
  Object.defineProperty(exports, "Redis", { enumerable: true, get: function() {
    return Redis_2.default;
  } });
  var cluster_1 = require_cluster();
  Object.defineProperty(exports, "Cluster", { enumerable: true, get: function() {
    return cluster_1.default;
  } });
  var Command_1 = require_Command();
  Object.defineProperty(exports, "Command", { enumerable: true, get: function() {
    return Command_1.default;
  } });
  var ScanStream_1 = require_ScanStream();
  Object.defineProperty(exports, "ScanStream", { enumerable: true, get: function() {
    return ScanStream_1.default;
  } });
  var Pipeline_1 = require_Pipeline();
  Object.defineProperty(exports, "Pipeline", { enumerable: true, get: function() {
    return Pipeline_1.default;
  } });
  var AbstractConnector_1 = require_AbstractConnector();
  Object.defineProperty(exports, "AbstractConnector", { enumerable: true, get: function() {
    return AbstractConnector_1.default;
  } });
  var SentinelConnector_1 = require_SentinelConnector();
  Object.defineProperty(exports, "SentinelConnector", { enumerable: true, get: function() {
    return SentinelConnector_1.default;
  } });
  Object.defineProperty(exports, "SentinelIterator", { enumerable: true, get: function() {
    return SentinelConnector_1.SentinelIterator;
  } });
  exports.ReplyError = require_redis_errors().ReplyError;
  Object.defineProperty(exports, "Promise", {
    get() {
      console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.");
      return Promise;
    },
    set(_lib) {
      console.warn("ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.");
    }
  });
  exports.print = print;
});

// node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS((exports, module) => {
  var Events = function() {
  };
  var EE = function(fn, context, once) {
    this.fn = fn;
    this.context = context;
    this.once = once || false;
  };
  var addListener = function(emitter, event, fn, context, once) {
    if (typeof fn !== "function") {
      throw new TypeError("The listener must be a function");
    }
    var listener = new EE(fn, context || emitter, once), evt = prefix ? prefix + event : event;
    if (!emitter._events[evt])
      emitter._events[evt] = listener, emitter._eventsCount++;
    else if (!emitter._events[evt].fn)
      emitter._events[evt].push(listener);
    else
      emitter._events[evt] = [emitter._events[evt], listener];
    return emitter;
  };
  var clearEvent = function(emitter, evt) {
    if (--emitter._eventsCount === 0)
      emitter._events = new Events;
    else
      delete emitter._events[evt];
  };
  var EventEmitter = function() {
    this._events = new Events;
    this._eventsCount = 0;
  };
  var has = Object.prototype.hasOwnProperty;
  var prefix = "~";
  if (Object.create) {
    Events.prototype = Object.create(null);
    if (!new Events().__proto__)
      prefix = false;
  }
  EventEmitter.prototype.eventNames = function eventNames() {
    var names = [], events, name;
    if (this._eventsCount === 0)
      return names;
    for (name in events = this._events) {
      if (has.call(events, name))
        names.push(prefix ? name.slice(1) : name);
    }
    if (Object.getOwnPropertySymbols) {
      return names.concat(Object.getOwnPropertySymbols(events));
    }
    return names;
  };
  EventEmitter.prototype.listeners = function listeners(event) {
    var evt = prefix ? prefix + event : event, handlers = this._events[evt];
    if (!handlers)
      return [];
    if (handlers.fn)
      return [handlers.fn];
    for (var i = 0, l = handlers.length, ee = new Array(l);i < l; i++) {
      ee[i] = handlers[i].fn;
    }
    return ee;
  };
  EventEmitter.prototype.listenerCount = function listenerCount(event) {
    var evt = prefix ? prefix + event : event, listeners = this._events[evt];
    if (!listeners)
      return 0;
    if (listeners.fn)
      return 1;
    return listeners.length;
  };
  EventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return false;
    var listeners = this._events[evt], len = arguments.length, args, i;
    if (listeners.fn) {
      if (listeners.once)
        this.removeListener(event, listeners.fn, undefined, true);
      switch (len) {
        case 1:
          return listeners.fn.call(listeners.context), true;
        case 2:
          return listeners.fn.call(listeners.context, a1), true;
        case 3:
          return listeners.fn.call(listeners.context, a1, a2), true;
        case 4:
          return listeners.fn.call(listeners.context, a1, a2, a3), true;
        case 5:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;
        case 6:
          return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;
      }
      for (i = 1, args = new Array(len - 1);i < len; i++) {
        args[i - 1] = arguments[i];
      }
      listeners.fn.apply(listeners.context, args);
    } else {
      var length = listeners.length, j;
      for (i = 0;i < length; i++) {
        if (listeners[i].once)
          this.removeListener(event, listeners[i].fn, undefined, true);
        switch (len) {
          case 1:
            listeners[i].fn.call(listeners[i].context);
            break;
          case 2:
            listeners[i].fn.call(listeners[i].context, a1);
            break;
          case 3:
            listeners[i].fn.call(listeners[i].context, a1, a2);
            break;
          case 4:
            listeners[i].fn.call(listeners[i].context, a1, a2, a3);
            break;
          default:
            if (!args)
              for (j = 1, args = new Array(len - 1);j < len; j++) {
                args[j - 1] = arguments[j];
              }
            listeners[i].fn.apply(listeners[i].context, args);
        }
      }
    }
    return true;
  };
  EventEmitter.prototype.on = function on(event, fn, context) {
    return addListener(this, event, fn, context, false);
  };
  EventEmitter.prototype.once = function once(event, fn, context) {
    return addListener(this, event, fn, context, true);
  };
  EventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {
    var evt = prefix ? prefix + event : event;
    if (!this._events[evt])
      return this;
    if (!fn) {
      clearEvent(this, evt);
      return this;
    }
    var listeners = this._events[evt];
    if (listeners.fn) {
      if (listeners.fn === fn && (!once || listeners.once) && (!context || listeners.context === context)) {
        clearEvent(this, evt);
      }
    } else {
      for (var i = 0, events = [], length = listeners.length;i < length; i++) {
        if (listeners[i].fn !== fn || once && !listeners[i].once || context && listeners[i].context !== context) {
          events.push(listeners[i]);
        }
      }
      if (events.length)
        this._events[evt] = events.length === 1 ? events[0] : events;
      else
        clearEvent(this, evt);
    }
    return this;
  };
  EventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {
    var evt;
    if (event) {
      evt = prefix ? prefix + event : event;
      if (this._events[evt])
        clearEvent(this, evt);
    } else {
      this._events = new Events;
      this._eventsCount = 0;
    }
    return this;
  };
  EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
  EventEmitter.prototype.addListener = EventEmitter.prototype.on;
  EventEmitter.prefixed = prefix;
  EventEmitter.EventEmitter = EventEmitter;
  if (typeof module !== "undefined") {
    module.exports = EventEmitter;
  }
});

// node_modules/cross-fetch/dist/node-ponyfill.js
var require_node_ponyfill = __commonJS((exports, module) => {
  var nodeFetch = import.meta.require("node-fetch");
  var realFetch = nodeFetch.default || nodeFetch;
  var fetch2 = function(url, options) {
    if (/^\/\//.test(url)) {
      url = "https:" + url;
    }
    return realFetch.call(this, url, options);
  };
  fetch2.ponyfill = true;
  module.exports = exports = fetch2;
  exports.fetch = fetch2;
  exports.Headers = nodeFetch.Headers;
  exports.Request = nodeFetch.Request;
  exports.Response = nodeFetch.Response;
  exports.default = fetch2;
});

// node_modules/@ethereumjs/rlp/dist/index.js
var require_dist = __commonJS((exports) => {
  var encode = function(input) {
    if (Array.isArray(input)) {
      const output2 = [];
      let outputLength = 0;
      for (let i = 0;i < input.length; i++) {
        const encoded = encode(input[i]);
        output2.push(encoded);
        outputLength += encoded.length;
      }
      return concatBytes3(encodeLength(outputLength, 192), ...output2);
    }
    const inputBuf = toBytes2(input);
    if (inputBuf.length === 1 && inputBuf[0] < 128) {
      return inputBuf;
    }
    return concatBytes3(encodeLength(inputBuf.length, 128), inputBuf);
  };
  var safeSlice = function(input, start, end) {
    if (end > input.length) {
      throw new Error("invalid RLP (safeSlice): end slice of Uint8Array out-of-bounds");
    }
    return input.slice(start, end);
  };
  var decodeLength = function(v) {
    if (v[0] === 0) {
      throw new Error("invalid RLP: extra zeros");
    }
    return parseHexByte(bytesToHex4(v));
  };
  var encodeLength = function(len, offset) {
    if (len < 56) {
      return Uint8Array.from([len + offset]);
    }
    const hexLength = numberToHex3(len);
    const lLength = hexLength.length / 2;
    const firstByte = numberToHex3(offset + 55 + lLength);
    return Uint8Array.from(hexToBytes3(firstByte + hexLength));
  };
  var decode = function(input, stream = false) {
    if (typeof input === "undefined" || input === null || input.length === 0) {
      return Uint8Array.from([]);
    }
    const inputBytes = toBytes2(input);
    const decoded = _decode(inputBytes);
    if (stream) {
      return decoded;
    }
    if (decoded.remainder.length !== 0) {
      throw new Error("invalid RLP: remainder must be zero");
    }
    return decoded.data;
  };
  var _decode = function(input) {
    let length, llength, data, innerRemainder, d;
    const decoded = [];
    const firstByte = input[0];
    if (firstByte <= 127) {
      return {
        data: input.slice(0, 1),
        remainder: input.slice(1)
      };
    } else if (firstByte <= 183) {
      length = firstByte - 127;
      if (firstByte === 128) {
        data = Uint8Array.from([]);
      } else {
        data = safeSlice(input, 1, length);
      }
      if (length === 2 && data[0] < 128) {
        throw new Error("invalid RLP encoding: invalid prefix, single byte < 0x80 are not prefixed");
      }
      return {
        data,
        remainder: input.slice(length)
      };
    } else if (firstByte <= 191) {
      llength = firstByte - 182;
      if (input.length - 1 < llength) {
        throw new Error("invalid RLP: not enough bytes for string length");
      }
      length = decodeLength(safeSlice(input, 1, llength));
      if (length <= 55) {
        throw new Error("invalid RLP: expected string length to be greater than 55");
      }
      data = safeSlice(input, llength, length + llength);
      return {
        data,
        remainder: input.slice(length + llength)
      };
    } else if (firstByte <= 247) {
      length = firstByte - 191;
      innerRemainder = safeSlice(input, 1, length);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input.slice(length)
      };
    } else {
      llength = firstByte - 246;
      length = decodeLength(safeSlice(input, 1, llength));
      if (length < 56) {
        throw new Error("invalid RLP: encoded list too short");
      }
      const totalLength = llength + length;
      if (totalLength > input.length) {
        throw new Error("invalid RLP: total length is larger than the data");
      }
      innerRemainder = safeSlice(input, llength, totalLength);
      while (innerRemainder.length) {
        d = _decode(innerRemainder);
        decoded.push(d.data);
        innerRemainder = d.remainder;
      }
      return {
        data: decoded,
        remainder: input.slice(totalLength)
      };
    }
  };
  var bytesToHex4 = function(uint8a) {
    let hex = "";
    for (let i = 0;i < uint8a.length; i++) {
      hex += cachedHexes[uint8a[i]];
    }
    return hex;
  };
  var parseHexByte = function(hexByte) {
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte))
      throw new Error("Invalid byte sequence");
    return byte;
  };
  var hexToBytes3 = function(hex) {
    if (typeof hex !== "string") {
      throw new TypeError("hexToBytes: expected string, got " + typeof hex);
    }
    if (hex.length % 2)
      throw new Error("hexToBytes: received invalid unpadded hex");
    const array = new Uint8Array(hex.length / 2);
    for (let i = 0;i < array.length; i++) {
      const j = i * 2;
      array[i] = parseHexByte(hex.slice(j, j + 2));
    }
    return array;
  };
  var concatBytes3 = function(...arrays) {
    if (arrays.length === 1)
      return arrays[0];
    const length = arrays.reduce((a, arr) => a + arr.length, 0);
    const result = new Uint8Array(length);
    for (let i = 0, pad = 0;i < arrays.length; i++) {
      const arr = arrays[i];
      result.set(arr, pad);
      pad += arr.length;
    }
    return result;
  };
  var utf8ToBytes4 = function(utf) {
    return new TextEncoder().encode(utf);
  };
  var numberToHex3 = function(integer) {
    if (integer < 0) {
      throw new Error("Invalid integer as argument, must be unsigned!");
    }
    const hex = integer.toString(16);
    return hex.length % 2 ? `0${hex}` : hex;
  };
  var padToEven2 = function(a) {
    return a.length % 2 ? `0${a}` : a;
  };
  var isHexPrefixed2 = function(str) {
    return str.length >= 2 && str[0] === "0" && str[1] === "x";
  };
  var stripHexPrefix2 = function(str) {
    if (typeof str !== "string") {
      return str;
    }
    return isHexPrefixed2(str) ? str.slice(2) : str;
  };
  var toBytes2 = function(v) {
    if (v instanceof Uint8Array) {
      return v;
    }
    if (typeof v === "string") {
      if (isHexPrefixed2(v)) {
        return hexToBytes3(padToEven2(stripHexPrefix2(v)));
      }
      return utf8ToBytes4(v);
    }
    if (typeof v === "number" || typeof v === "bigint") {
      if (!v) {
        return Uint8Array.from([]);
      }
      return hexToBytes3(numberToHex3(v));
    }
    if (v === null || v === undefined) {
      return Uint8Array.from([]);
    }
    throw new Error("toBytes: received unsupported type " + typeof v);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RLP = exports.utils = exports.decode = exports.encode = undefined;
  exports.encode = encode;
  exports.decode = decode;
  var cachedHexes = Array.from({ length: 256 }, (_v, i) => i.toString(16).padStart(2, "0"));
  exports.utils = {
    bytesToHex: bytesToHex4,
    concatBytes: concatBytes3,
    hexToBytes: hexToBytes3,
    utf8ToBytes: utf8ToBytes4
  };
  exports.RLP = { encode, decode };
});

// node_modules/crc-32/crc32.js
var require_crc32 = __commonJS((exports) => {
  /*! crc32.js (C) 2014-present SheetJS -- http://sheetjs.com */
  var CRC32;
  (function(factory) {
    if (typeof DO_NOT_EXPORT_CRC === "undefined") {
      if (typeof exports === "object") {
        factory(exports);
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          var module2 = {};
          factory(module2);
          return module2;
        });
      } else {
        factory(CRC32 = {});
      }
    } else {
      factory(CRC32 = {});
    }
  })(function(CRC322) {
    CRC322.version = "1.2.2";
    function signed_crc_table() {
      var c = 0, table = new Array(256);
      for (var n = 0;n != 256; ++n) {
        c = n;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        c = c & 1 ? -306674912 ^ c >>> 1 : c >>> 1;
        table[n] = c;
      }
      return typeof Int32Array !== "undefined" ? new Int32Array(table) : table;
    }
    var T0 = signed_crc_table();
    function slice_by_16_tables(T) {
      var c = 0, v = 0, n = 0, table = typeof Int32Array !== "undefined" ? new Int32Array(4096) : new Array(4096);
      for (n = 0;n != 256; ++n)
        table[n] = T[n];
      for (n = 0;n != 256; ++n) {
        v = T[n];
        for (c = 256 + n;c < 4096; c += 256)
          v = table[c] = v >>> 8 ^ T[v & 255];
      }
      var out = [];
      for (n = 1;n != 16; ++n)
        out[n - 1] = typeof Int32Array !== "undefined" ? table.subarray(n * 256, n * 256 + 256) : table.slice(n * 256, n * 256 + 256);
      return out;
    }
    var TT = slice_by_16_tables(T0);
    var T1 = TT[0], T2 = TT[1], T3 = TT[2], T4 = TT[3], T5 = TT[4];
    var T6 = TT[5], T7 = TT[6], T8 = TT[7], T9 = TT[8], Ta = TT[9];
    var Tb = TT[10], Tc = TT[11], Td = TT[12], Te = TT[13], Tf = TT[14];
    function crc32_bstr(bstr, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = bstr.length;i < L; )
        C = C >>> 8 ^ T0[(C ^ bstr.charCodeAt(i++)) & 255];
      return ~C;
    }
    function crc32_buf(B, seed) {
      var C = seed ^ -1, L = B.length - 15, i = 0;
      for (;i < L; )
        C = Tf[B[i++] ^ C & 255] ^ Te[B[i++] ^ C >> 8 & 255] ^ Td[B[i++] ^ C >> 16 & 255] ^ Tc[B[i++] ^ C >>> 24] ^ Tb[B[i++]] ^ Ta[B[i++]] ^ T9[B[i++]] ^ T8[B[i++]] ^ T7[B[i++]] ^ T6[B[i++]] ^ T5[B[i++]] ^ T4[B[i++]] ^ T3[B[i++]] ^ T2[B[i++]] ^ T1[B[i++]] ^ T0[B[i++]];
      L += 15;
      while (i < L)
        C = C >>> 8 ^ T0[(C ^ B[i++]) & 255];
      return ~C;
    }
    function crc32_str(str, seed) {
      var C = seed ^ -1;
      for (var i = 0, L = str.length, c = 0, d = 0;i < L; ) {
        c = str.charCodeAt(i++);
        if (c < 128) {
          C = C >>> 8 ^ T0[(C ^ c) & 255];
        } else if (c < 2048) {
          C = C >>> 8 ^ T0[(C ^ (192 | c >> 6 & 31)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        } else if (c >= 55296 && c < 57344) {
          c = (c & 1023) + 64;
          d = str.charCodeAt(i++) & 1023;
          C = C >>> 8 ^ T0[(C ^ (240 | c >> 8 & 7)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 2 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d >> 6 & 15 | (c & 3) << 4)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | d & 63)) & 255];
        } else {
          C = C >>> 8 ^ T0[(C ^ (224 | c >> 12 & 15)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c >> 6 & 63)) & 255];
          C = C >>> 8 ^ T0[(C ^ (128 | c & 63)) & 255];
        }
      }
      return ~C;
    }
    CRC322.table = T0;
    CRC322.bstr = crc32_bstr;
    CRC322.buf = crc32_buf;
    CRC322.str = crc32_str;
  });
});

// node_modules/setimmediate/setImmediate.js
var require_setImmediate = __commonJS((exports) => {
  (function(global2, undefined2) {
    if (global2.setImmediate) {
      return;
    }
    var nextHandle = 1;
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global2.document;
    var registerImmediate;
    function setImmediate2(callback) {
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      var args = new Array(arguments.length - 1);
      for (var i = 0;i < args.length; i++) {
        args[i] = arguments[i + 1];
      }
      var task = { callback, args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }
    function clearImmediate(handle) {
      delete tasksByHandle[handle];
    }
    function run(task) {
      var callback = task.callback;
      var args = task.args;
      switch (args.length) {
        case 0:
          callback();
          break;
        case 1:
          callback(args[0]);
          break;
        case 2:
          callback(args[0], args[1]);
          break;
        case 3:
          callback(args[0], args[1], args[2]);
          break;
        default:
          callback.apply(undefined2, args);
          break;
      }
    }
    function runIfPresent(handle) {
      if (currentlyRunningATask) {
        setTimeout(runIfPresent, 0, handle);
      } else {
        var task = tasksByHandle[handle];
        if (task) {
          currentlyRunningATask = true;
          try {
            run(task);
          } finally {
            clearImmediate(handle);
            currentlyRunningATask = false;
          }
        }
      }
    }
    function installNextTickImplementation() {
      registerImmediate = function(handle) {
        process.nextTick(function() {
          runIfPresent(handle);
        });
      };
    }
    function canUsePostMessage() {
      if (global2.postMessage && !global2.importScripts) {
        var postMessageIsAsynchronous = true;
        var oldOnMessage = global2.onmessage;
        global2.onmessage = function() {
          postMessageIsAsynchronous = false;
        };
        global2.postMessage("", "*");
        global2.onmessage = oldOnMessage;
        return postMessageIsAsynchronous;
      }
    }
    function installPostMessageImplementation() {
      var messagePrefix = "setImmediate$" + Math.random() + "$";
      var onGlobalMessage = function(event) {
        if (event.source === global2 && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
          runIfPresent(+event.data.slice(messagePrefix.length));
        }
      };
      if (global2.addEventListener) {
        global2.addEventListener("message", onGlobalMessage, false);
      } else {
        global2.attachEvent("onmessage", onGlobalMessage);
      }
      registerImmediate = function(handle) {
        global2.postMessage(messagePrefix + handle, "*");
      };
    }
    function installMessageChannelImplementation() {
      var channel = new MessageChannel;
      channel.port1.onmessage = function(event) {
        var handle = event.data;
        runIfPresent(handle);
      };
      registerImmediate = function(handle) {
        channel.port2.postMessage(handle);
      };
    }
    function installReadyStateChangeImplementation() {
      var html = doc.documentElement;
      registerImmediate = function(handle) {
        var script = doc.createElement("script");
        script.onreadystatechange = function() {
          runIfPresent(handle);
          script.onreadystatechange = null;
          html.removeChild(script);
          script = null;
        };
        html.appendChild(script);
      };
    }
    function installSetTimeoutImplementation() {
      registerImmediate = function(handle) {
        setTimeout(runIfPresent, 0, handle);
      };
    }
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global2);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global2;
    if ({}.toString.call(global2.process) === "[object process]") {
      installNextTickImplementation();
    } else if (canUsePostMessage()) {
      installPostMessageImplementation();
    } else if (global2.MessageChannel) {
      installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
      installReadyStateChangeImplementation();
    } else {
      installSetTimeoutImplementation();
    }
    attachTo.setImmediate = setImmediate2;
    attachTo.clearImmediate = clearImmediate;
  })(typeof self === "undefined" ? typeof global === "undefined" ? exports : global : self);
});

// node_modules/abitype/dist/chunk-O6V2CMEF.js
var require_chunk_O6V2CMEF = __commonJS((exports) => {
  var _optionalChain = function(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  };
  var execTyped = function(regex, string9) {
    const match = regex.exec(string9);
    return _optionalChain([match, "optionalAccess", (_) => _.groups]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var bytesRegex = /^bytes([1-9]|1[0-9]|2[0-9]|3[0-2])?$/;
  var integerRegex = /^u?int(8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?$/;
  var isTupleRegex = /^\(.+?\).*?$/;
  exports.execTyped = execTyped;
  exports.bytesRegex = bytesRegex;
  exports.integerRegex = integerRegex;
  exports.isTupleRegex = isTupleRegex;
});

// node_modules/abitype/dist/chunk-XXPGZHWZ.js
var require_chunk_XXPGZHWZ = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  var __defProp2 = Object.defineProperty;
  var __defNormalProp = (obj, key, value) => (key in obj) ? __defProp2(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
  var __publicField = (obj, key, value) => {
    __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
    return value;
  };
  exports.__publicField = __publicField;
});

// node_modules/abitype/dist/index.js
var require_dist2 = __commonJS((exports) => {
  var _nullishCoalesce = function(lhs, rhsFn) {
    if (lhs != null) {
      return lhs;
    } else {
      return rhsFn();
    }
  };
  var _optionalChain = function(ops) {
    let lastAccessLHS = undefined;
    let value = ops[0];
    let i = 1;
    while (i < ops.length) {
      const op = ops[i];
      const fn = ops[i + 1];
      i += 2;
      if ((op === "optionalAccess" || op === "optionalCall") && value == null) {
        return;
      }
      if (op === "access" || op === "optionalAccess") {
        lastAccessLHS = value;
        value = fn(value);
      } else if (op === "call" || op === "optionalCall") {
        value = fn((...args) => value.call(lastAccessLHS, ...args));
        lastAccessLHS = undefined;
      }
    }
    return value;
  };
  var narrow = function(value) {
    return value;
  };
  var isErrorSignature = function(signature) {
    return errorSignatureRegex.test(signature);
  };
  var execErrorSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, errorSignatureRegex, signature);
  };
  var isEventSignature = function(signature) {
    return eventSignatureRegex.test(signature);
  };
  var execEventSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, eventSignatureRegex, signature);
  };
  var isFunctionSignature = function(signature) {
    return functionSignatureRegex.test(signature);
  };
  var execFunctionSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, functionSignatureRegex, signature);
  };
  var isStructSignature = function(signature) {
    return structSignatureRegex.test(signature);
  };
  var execStructSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, structSignatureRegex, signature);
  };
  var isConstructorSignature = function(signature) {
    return constructorSignatureRegex.test(signature);
  };
  var execConstructorSignature = function(signature) {
    return _chunkO6V2CMEFjs.execTyped.call(undefined, constructorSignatureRegex, signature);
  };
  var isFallbackSignature = function(signature) {
    return fallbackSignatureRegex.test(signature);
  };
  var isReceiveSignature = function(signature) {
    return receiveSignatureRegex.test(signature);
  };
  var getParameterCacheKey = function(param, type) {
    if (type)
      return `${type}:${param}`;
    return param;
  };
  var parseSignature = function(signature, structs = {}) {
    if (isFunctionSignature(signature)) {
      const match = execFunctionSignature(signature);
      if (!match)
        throw new BaseError("Invalid function signature.", {
          details: signature
        });
      const inputParams = splitParameters(match.parameters);
      const inputs = [];
      const inputLength = inputParams.length;
      for (let i = 0;i < inputLength; i++) {
        inputs.push(parseAbiParameter(inputParams[i], {
          modifiers: functionModifiers,
          structs,
          type: "function"
        }));
      }
      const outputs = [];
      if (match.returns) {
        const outputParams = splitParameters(match.returns);
        const outputLength = outputParams.length;
        for (let i = 0;i < outputLength; i++) {
          outputs.push(parseAbiParameter(outputParams[i], {
            modifiers: functionModifiers,
            structs,
            type: "function"
          }));
        }
      }
      return {
        name: match.name,
        type: "function",
        stateMutability: _nullishCoalesce(match.stateMutability, () => "nonpayable"),
        inputs,
        outputs
      };
    }
    if (isEventSignature(signature)) {
      const match = execEventSignature(signature);
      if (!match)
        throw new BaseError("Invalid event signature.", {
          details: signature
        });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], {
          modifiers: eventModifiers,
          structs,
          type: "event"
        }));
      }
      return { name: match.name, type: "event", inputs: abiParameters };
    }
    if (isErrorSignature(signature)) {
      const match = execErrorSignature(signature);
      if (!match)
        throw new BaseError("Invalid error signature.", {
          details: signature
        });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], { structs, type: "error" }));
      }
      return { name: match.name, type: "error", inputs: abiParameters };
    }
    if (isConstructorSignature(signature)) {
      const match = execConstructorSignature(signature);
      if (!match)
        throw new BaseError("Invalid constructor signature.", {
          details: signature
        });
      const params = splitParameters(match.parameters);
      const abiParameters = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(params[i], { structs, type: "constructor" }));
      }
      return {
        type: "constructor",
        stateMutability: _nullishCoalesce(match.stateMutability, () => "nonpayable"),
        inputs: abiParameters
      };
    }
    if (isFallbackSignature(signature))
      return { type: "fallback" };
    if (isReceiveSignature(signature))
      return {
        type: "receive",
        stateMutability: "payable"
      };
    throw new BaseError("Unknown signature.", {
      details: signature
    });
  };
  var parseAbiParameter = function(param, options) {
    const parameterCacheKey = getParameterCacheKey(param, _optionalChain([options, "optionalAccess", (_3) => _3.type]));
    if (parameterCache.has(parameterCacheKey))
      return parameterCache.get(parameterCacheKey);
    const isTuple = _chunkO6V2CMEFjs.isTupleRegex.test(param);
    const match = _chunkO6V2CMEFjs.execTyped.call(undefined, isTuple ? abiParameterWithTupleRegex : abiParameterWithoutTupleRegex, param);
    if (!match)
      throw new BaseError("Invalid ABI parameter.", {
        details: param
      });
    if (match.name && isSolidityKeyword(match.name))
      throw new BaseError("Invalid ABI parameter.", {
        details: param,
        metaMessages: [
          `"${match.name}" is a protected Solidity keyword. More info: https://docs.soliditylang.org/en/latest/cheatsheet.html`
        ]
      });
    const name2 = match.name ? { name: match.name } : {};
    const indexed = match.modifier === "indexed" ? { indexed: true } : {};
    const structs = _nullishCoalesce(_optionalChain([options, "optionalAccess", (_4) => _4.structs]), () => ({}));
    let type;
    let components = {};
    if (isTuple) {
      type = "tuple";
      const params = splitParameters(match.type);
      const components_ = [];
      const length = params.length;
      for (let i = 0;i < length; i++) {
        components_.push(parseAbiParameter(params[i], { structs }));
      }
      components = { components: components_ };
    } else if (match.type in structs) {
      type = "tuple";
      components = { components: structs[match.type] };
    } else if (dynamicIntegerRegex.test(match.type)) {
      type = `${match.type}256`;
    } else {
      type = match.type;
      if (!(_optionalChain([options, "optionalAccess", (_5) => _5.type]) === "struct") && !isSolidityType(type))
        throw new BaseError("Unknown type.", {
          metaMessages: [`Type "${type}" is not a valid ABI type.`]
        });
    }
    if (match.modifier) {
      if (!_optionalChain([options, "optionalAccess", (_6) => _6.modifiers, "optionalAccess", (_7) => _7.has, "optionalCall", (_8) => _8(match.modifier)]))
        throw new BaseError("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${match.modifier}" not allowed${_optionalChain([options, "optionalAccess", (_9) => _9.type]) ? ` in "${options.type}" type` : ""}.`
          ]
        });
      if (functionModifiers.has(match.modifier) && !isValidDataLocation(type, !!match.array))
        throw new BaseError("Invalid ABI parameter.", {
          details: param,
          metaMessages: [
            `Modifier "${match.modifier}" not allowed${_optionalChain([options, "optionalAccess", (_10) => _10.type]) ? ` in "${options.type}" type` : ""}.`,
            `Data location can only be specified for array, struct, or mapping types, but "${match.modifier}" was given.`
          ]
        });
    }
    const abiParameter = {
      type: `${type}${_nullishCoalesce(match.array, () => "")}`,
      ...name2,
      ...indexed,
      ...components
    };
    parameterCache.set(parameterCacheKey, abiParameter);
    return abiParameter;
  };
  var splitParameters = function(params, result = [], current = "", depth = 0) {
    if (params === "") {
      if (current === "")
        return result;
      if (depth !== 0)
        throw new BaseError("Unbalanced parentheses.", {
          metaMessages: [
            `"${current.trim()}" has too many ${depth > 0 ? "opening" : "closing"} parentheses.`
          ],
          details: `Depth "${depth}"`
        });
      return [...result, current.trim()];
    }
    const length = params.length;
    for (let i = 0;i < length; i++) {
      const char = params[i];
      const tail = params.slice(i + 1);
      switch (char) {
        case ",":
          return depth === 0 ? splitParameters(tail, [...result, current.trim()]) : splitParameters(tail, result, `${current}${char}`, depth);
        case "(":
          return splitParameters(tail, result, `${current}${char}`, depth + 1);
        case ")":
          return splitParameters(tail, result, `${current}${char}`, depth - 1);
        default:
          return splitParameters(tail, result, `${current}${char}`, depth);
      }
    }
    return [];
  };
  var isSolidityType = function(type) {
    return type === "address" || type === "bool" || type === "function" || type === "string" || _chunkO6V2CMEFjs.bytesRegex.test(type) || _chunkO6V2CMEFjs.integerRegex.test(type);
  };
  var isSolidityKeyword = function(name2) {
    return name2 === "address" || name2 === "bool" || name2 === "function" || name2 === "string" || name2 === "tuple" || _chunkO6V2CMEFjs.bytesRegex.test(name2) || _chunkO6V2CMEFjs.integerRegex.test(name2) || protectedKeywordsRegex.test(name2);
  };
  var isValidDataLocation = function(type, isArray) {
    return isArray || type === "bytes" || type === "string" || type === "tuple";
  };
  var parseStructs = function(signatures) {
    const shallowStructs = {};
    const signaturesLength = signatures.length;
    for (let i = 0;i < signaturesLength; i++) {
      const signature = signatures[i];
      if (!isStructSignature(signature))
        continue;
      const match = execStructSignature(signature);
      if (!match)
        throw new BaseError("Invalid struct signature.", {
          details: signature
        });
      const properties = match.properties.split(";");
      const components = [];
      const propertiesLength = properties.length;
      for (let k = 0;k < propertiesLength; k++) {
        const property = properties[k];
        const trimmed = property.trim();
        if (!trimmed)
          continue;
        const abiParameter = parseAbiParameter(trimmed, {
          type: "struct"
        });
        components.push(abiParameter);
      }
      if (!components.length)
        throw new BaseError("Invalid struct signature.", {
          details: signature,
          metaMessages: ["No properties exist."]
        });
      shallowStructs[match.name] = components;
    }
    const resolvedStructs = {};
    const entries = Object.entries(shallowStructs);
    const entriesLength = entries.length;
    for (let i = 0;i < entriesLength; i++) {
      const [name2, parameters] = entries[i];
      resolvedStructs[name2] = resolveStructs(parameters, shallowStructs);
    }
    return resolvedStructs;
  };
  var resolveStructs = function(abiParameters, structs, ancestors = new Set) {
    const components = [];
    const length = abiParameters.length;
    for (let i = 0;i < length; i++) {
      const abiParameter = abiParameters[i];
      const isTuple = _chunkO6V2CMEFjs.isTupleRegex.test(abiParameter.type);
      if (isTuple)
        components.push(abiParameter);
      else {
        const match = _chunkO6V2CMEFjs.execTyped.call(undefined, typeWithoutTupleRegex, abiParameter.type);
        if (!_optionalChain([match, "optionalAccess", (_11) => _11.type]))
          throw new BaseError("Invalid ABI parameter.", {
            details: JSON.stringify(abiParameter, null, 2),
            metaMessages: ["ABI parameter type is invalid."]
          });
        const { array, type } = match;
        if (type in structs) {
          if (ancestors.has(type))
            throw new BaseError("Circular reference detected.", {
              metaMessages: [`Struct "${type}" is a circular reference.`]
            });
          components.push({
            ...abiParameter,
            type: `tuple${_nullishCoalesce(array, () => "")}`,
            components: resolveStructs(_nullishCoalesce(structs[type], () => []), structs, new Set([...ancestors, type]))
          });
        } else {
          if (isSolidityType(type))
            components.push(abiParameter);
          else
            throw new BaseError("Unknown type.", {
              metaMessages: [
                `Type "${type}" is not a valid ABI type. Perhaps you forgot to include a struct signature?`
              ]
            });
        }
      }
    }
    return components;
  };
  var parseAbi = function(signatures) {
    const structs = parseStructs(signatures);
    const abi2 = [];
    const length = signatures.length;
    for (let i = 0;i < length; i++) {
      const signature = signatures[i];
      if (isStructSignature(signature))
        continue;
      abi2.push(parseSignature(signature, structs));
    }
    return abi2;
  };
  var parseAbiItem = function(signature) {
    let abiItem;
    if (typeof signature === "string")
      abiItem = parseSignature(signature);
    else {
      const structs = parseStructs(signature);
      const length = signature.length;
      for (let i = 0;i < length; i++) {
        const signature_ = signature[i];
        if (isStructSignature(signature_))
          continue;
        abiItem = parseSignature(signature_, structs);
        break;
      }
    }
    if (!abiItem)
      throw new BaseError("Failed to parse ABI item.", {
        details: `parseAbiItem(${JSON.stringify(signature, null, 2)})`,
        docsPath: "/api/human.html#parseabiitem-1"
      });
    return abiItem;
  };
  var parseAbiParameter2 = function(param) {
    let abiParameter;
    if (typeof param === "string")
      abiParameter = parseAbiParameter(param, {
        modifiers
      });
    else {
      const structs = parseStructs(param);
      const length = param.length;
      for (let i = 0;i < length; i++) {
        const signature = param[i];
        if (isStructSignature(signature))
          continue;
        abiParameter = parseAbiParameter(signature, { modifiers, structs });
        break;
      }
    }
    if (!abiParameter)
      throw new BaseError("Failed to parse ABI parameter.", {
        details: `parseAbiParameter(${JSON.stringify(param, null, 2)})`,
        docsPath: "/api/human.html#parseabiparameter-1"
      });
    return abiParameter;
  };
  var parseAbiParameters = function(params) {
    const abiParameters = [];
    if (typeof params === "string") {
      const parameters = splitParameters(params);
      const length = parameters.length;
      for (let i = 0;i < length; i++) {
        abiParameters.push(parseAbiParameter(parameters[i], { modifiers }));
      }
    } else {
      const structs = parseStructs(params);
      const length = params.length;
      for (let i = 0;i < length; i++) {
        const signature = params[i];
        if (isStructSignature(signature))
          continue;
        const parameters = splitParameters(signature);
        const length2 = parameters.length;
        for (let k = 0;k < length2; k++) {
          abiParameters.push(parseAbiParameter(parameters[k], { modifiers, structs }));
        }
      }
    }
    if (abiParameters.length === 0)
      throw new BaseError("Failed to parse ABI parameters.", {
        details: `parseAbiParameters(${JSON.stringify(params, null, 2)})`,
        docsPath: "/api/human.html#parseabiparameters-1"
      });
    return abiParameters;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var _chunkO6V2CMEFjs = require_chunk_O6V2CMEF();
  var _chunkXXPGZHWZjs = require_chunk_XXPGZHWZ();
  var name = "abitype";
  var version = "0.7.1";
  var BaseError = class extends Error {
    constructor(shortMessage, args = {}) {
      const details = args.cause instanceof BaseError ? args.cause.details : _optionalChain([args, "access", (_) => _.cause, "optionalAccess", (_2) => _2.message]) ? args.cause.message : args.details;
      const docsPath = args.cause instanceof BaseError ? args.cause.docsPath || args.docsPath : args.docsPath;
      const message = [
        shortMessage || "An error occurred.",
        "",
        ...args.metaMessages ? [...args.metaMessages, ""] : [],
        ...docsPath ? [`Docs: https://abitype.dev${docsPath}`] : [],
        ...details ? [`Details: ${details}`] : [],
        `Version: ${name}@${version}`
      ].join("\n");
      super(message);
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "details");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "docsPath");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "metaMessages");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "shortMessage");
      _chunkXXPGZHWZjs.__publicField.call(undefined, this, "name", "AbiTypeError");
      if (args.cause)
        this.cause = args.cause;
      this.details = details;
      this.docsPath = docsPath;
      this.metaMessages = args.metaMessages;
      this.shortMessage = shortMessage;
    }
  };
  var errorSignatureRegex = /^error (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)$/;
  var eventSignatureRegex = /^event (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)$/;
  var functionSignatureRegex = /^function (?<name>[a-zA-Z0-9_]+)\((?<parameters>.*?)\)(?: (?<scope>external|public{1}))?(?: (?<stateMutability>pure|view|nonpayable|payable{1}))?(?: returns \((?<returns>.*?)\))?$/;
  var structSignatureRegex = /^struct (?<name>[a-zA-Z0-9_]+) \{(?<properties>.*?)\}$/;
  var constructorSignatureRegex = /^constructor\((?<parameters>.*?)\)(?:\s(?<stateMutability>payable{1}))?$/;
  var fallbackSignatureRegex = /^fallback\(\)$/;
  var receiveSignatureRegex = /^receive\(\) external payable$/;
  var modifiers = new Set([
    "memory",
    "indexed",
    "storage",
    "calldata"
  ]);
  var eventModifiers = new Set(["indexed"]);
  var functionModifiers = new Set([
    "calldata",
    "memory",
    "storage"
  ]);
  var parameterCache = new Map([
    ["address", { type: "address" }],
    ["bool", { type: "bool" }],
    ["bytes", { type: "bytes" }],
    ["bytes32", { type: "bytes32" }],
    ["int", { type: "int256" }],
    ["int256", { type: "int256" }],
    ["string", { type: "string" }],
    ["uint", { type: "uint256" }],
    ["uint8", { type: "uint8" }],
    ["uint16", { type: "uint16" }],
    ["uint24", { type: "uint24" }],
    ["uint32", { type: "uint32" }],
    ["uint64", { type: "uint64" }],
    ["uint96", { type: "uint96" }],
    ["uint112", { type: "uint112" }],
    ["uint160", { type: "uint160" }],
    ["uint192", { type: "uint192" }],
    ["uint256", { type: "uint256" }],
    ["address owner", { type: "address", name: "owner" }],
    ["address to", { type: "address", name: "to" }],
    ["bool approved", { type: "bool", name: "approved" }],
    ["bytes _data", { type: "bytes", name: "_data" }],
    ["bytes data", { type: "bytes", name: "data" }],
    ["bytes signature", { type: "bytes", name: "signature" }],
    ["bytes32 hash", { type: "bytes32", name: "hash" }],
    ["bytes32 r", { type: "bytes32", name: "r" }],
    ["bytes32 root", { type: "bytes32", name: "root" }],
    ["bytes32 s", { type: "bytes32", name: "s" }],
    ["string name", { type: "string", name: "name" }],
    ["string symbol", { type: "string", name: "symbol" }],
    ["string tokenURI", { type: "string", name: "tokenURI" }],
    ["uint tokenId", { type: "uint256", name: "tokenId" }],
    ["uint8 v", { type: "uint8", name: "v" }],
    ["uint256 balance", { type: "uint256", name: "balance" }],
    ["uint256 tokenId", { type: "uint256", name: "tokenId" }],
    ["uint256 value", { type: "uint256", name: "value" }],
    [
      "event:address indexed from",
      { type: "address", name: "from", indexed: true }
    ],
    ["event:address indexed to", { type: "address", name: "to", indexed: true }],
    [
      "event:uint indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ],
    [
      "event:uint256 indexed tokenId",
      { type: "uint256", name: "tokenId", indexed: true }
    ]
  ]);
  var abiParameterWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
  var abiParameterWithTupleRegex = /^\((?<type>.+?)\)(?<array>(?:\[\d*?\])+?)?(?:\s(?<modifier>calldata|indexed|memory|storage{1}))?(?:\s(?<name>[a-zA-Z0-9_]+))?$/;
  var dynamicIntegerRegex = /^u?int$/;
  var protectedKeywordsRegex = /^(?:after|alias|anonymous|apply|auto|byte|calldata|case|catch|constant|copyof|default|defined|error|event|external|false|final|function|immutable|implements|in|indexed|inline|internal|let|mapping|match|memory|mutable|null|of|override|partial|private|promise|public|pure|reference|relocatable|return|returns|sizeof|static|storage|struct|super|supports|switch|this|true|try|typedef|typeof|var|view|virtual)$/;
  var typeWithoutTupleRegex = /^(?<type>[a-zA-Z0-9_]+?)(?<array>(?:\[\d*?\])+?)?$/;
  exports.BaseError = BaseError;
  exports.narrow = narrow;
  exports.parseAbi = parseAbi;
  exports.parseAbiItem = parseAbiItem;
  exports.parseAbiParameter = parseAbiParameter2;
  exports.parseAbiParameters = parseAbiParameters;
});

// node_modules/telegraf/lib/core/helpers/util.js
var require_util2 = __commonJS((exports) => {
  var fmtCaption = function(extra) {
    if (!extra)
      return;
    const caption = extra.caption;
    if (!caption || typeof caption === "string")
      return extra;
    const { text, entities } = caption;
    return {
      ...extra,
      caption: text,
      ...entities && {
        caption_entities: entities,
        parse_mode: undefined
      }
    };
  };
  function* zip(xs, ys) {
    const x = xs[Symbol.iterator]();
    const y = ys[Symbol.iterator]();
    let x1 = x.next();
    let y1 = y.next();
    while (!x1.done) {
      yield x1.value;
      if (!y1.done)
        yield y1.value;
      x1 = x.next();
      y1 = y.next();
    }
    while (!y1.done) {
      yield y1.value;
      y1 = y.next();
    }
  }
  var indexed = function(target, indexer) {
    return new Proxy(target, {
      get: function(target2, prop, receiver) {
        if ((typeof prop === "string" || typeof prop === "number") && !isNaN(+prop))
          return indexer.call(target2, +prop);
        return Reflect.get(target2, prop, receiver);
      }
    });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.indexed = exports.zip = exports.fmtCaption = exports.env = undefined;
  exports.env = process.env;
  exports.fmtCaption = fmtCaption;
  exports.zip = zip;
  exports.indexed = indexed;
});

// node_modules/telegraf/lib/reactions.js
var require_reactions = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.MessageReactions = exports.ReactionList = exports.Digit = undefined;
  var util_1 = require_util2();
  exports.Digit = new Set(["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"]);
  var inspectReaction = (reaction) => {
    if (reaction.type === "custom_emoji")
      return `Custom(${reaction.custom_emoji_id})`;
    else
      return reaction.emoji;
  };

  class ReactionList {
    constructor(list) {
      this.list = list;
    }
    static fromArray(list = []) {
      return (0, util_1.indexed)(new ReactionList(list), function(index) {
        return this.list[index];
      });
    }
    static has(reactions, reaction) {
      if (typeof reaction === "string")
        if (exports.Digit.has(reaction[0]))
          return reactions.some((r2) => r2.custom_emoji_id === reaction);
        else
          return reactions.some((r2) => r2.emoji === reaction);
      return reactions.some((r2) => {
        if (r2.type === "custom_emoji")
          return r2.custom_emoji_id === reaction.custom_emoji_id;
        else if (r2.type === "emoji")
          return r2.emoji === reaction.emoji;
      });
    }
    toArray() {
      return [...this.list];
    }
    filter(filterFn) {
      return ReactionList.fromArray(this.list.filter(filterFn));
    }
    has(reaction) {
      return ReactionList.has(this.list, reaction);
    }
    get count() {
      return this.list.length;
    }
    [Symbol.iterator]() {
      return this.list[Symbol.iterator]();
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      const flattened = this.list.map(inspectReaction).join(", ");
      return ["ReactionList {", flattened, "}"].join(" ");
    }
  }
  exports.ReactionList = ReactionList;

  class MessageReactions extends ReactionList {
    constructor(ctx) {
      var _a4, _b;
      super((_b = (_a4 = ctx.update.message_reaction) === null || _a4 === undefined ? undefined : _a4.new_reaction) !== null && _b !== undefined ? _b : []);
      this.ctx = ctx;
    }
    static from(ctx) {
      return (0, util_1.indexed)(new MessageReactions(ctx), function(index) {
        return this.list[index];
      });
    }
    get old() {
      var _a4;
      return ReactionList.fromArray((_a4 = this.ctx.update.message_reaction) === null || _a4 === undefined ? undefined : _a4.old_reaction);
    }
    get new() {
      var _a4;
      return ReactionList.fromArray((_a4 = this.ctx.update.message_reaction) === null || _a4 === undefined ? undefined : _a4.new_reaction);
    }
    get added() {
      return this.new.filter((reaction) => !this.old.has(reaction));
    }
    get removed() {
      return this.old.filter((reaction) => !this.new.has(reaction));
    }
    get kept() {
      return this.new.filter((reaction) => this.old.has(reaction));
    }
  }
  exports.MessageReactions = MessageReactions;
});

// node_modules/telegraf/lib/context.js
var require_context = __commonJS((exports) => {
  var getMessageFromAnySource = function(ctx) {
    var _a4, _b, _c, _d, _e;
    const msg = (_e = (_d = (_b = (_a4 = ctx.message) !== null && _a4 !== undefined ? _a4 : ctx.editedMessage) !== null && _b !== undefined ? _b : (_c = ctx.callbackQuery) === null || _c === undefined ? undefined : _c.message) !== null && _d !== undefined ? _d : ctx.channelPost) !== null && _e !== undefined ? _e : ctx.editedChannelPost;
    if (msg)
      return Object.assign(Object.create(Msg), msg);
  };
  var getUserFromAnySource = function(ctx) {
    var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
    if (ctx.callbackQuery)
      return ctx.callbackQuery.from;
    const msg = ctx.msg;
    if (msg === null || msg === undefined ? undefined : msg.has("from"))
      return msg.from;
    return (_h = (_g = (_f = (_e = (_d = (_c = (_b = (_a4 = ctx.inlineQuery) !== null && _a4 !== undefined ? _a4 : ctx.shippingQuery) !== null && _b !== undefined ? _b : ctx.preCheckoutQuery) !== null && _c !== undefined ? _c : ctx.chosenInlineResult) !== null && _d !== undefined ? _d : ctx.chatMember) !== null && _e !== undefined ? _e : ctx.myChatMember) !== null && _f !== undefined ? _f : ctx.chatJoinRequest) === null || _g === undefined ? undefined : _g.from) !== null && _h !== undefined ? _h : (_m = (_k = (_j = ctx.messageReaction) !== null && _j !== undefined ? _j : ctx.pollAnswer) !== null && _k !== undefined ? _k : (_l = ctx.chatBoost) === null || _l === undefined ? undefined : _l.boost.source) === null || _m === undefined ? undefined : _m.user;
  };
  var getMsgIdFromAnySource = function(ctx) {
    var _a4, _b;
    const msg = getMessageFromAnySource(ctx);
    return (_b = (_a4 = msg !== null && msg !== undefined ? msg : ctx.messageReaction) !== null && _a4 !== undefined ? _a4 : ctx.messageReactionCount) === null || _b === undefined ? undefined : _b.message_id;
  };
  var getTextAndEntitiesFromAnySource = function(ctx) {
    const msg = ctx.msg;
    let text, entities;
    if (msg) {
      if ("text" in msg)
        text = msg.text, entities = msg.entities;
      else if ("caption" in msg)
        text = msg.caption, entities = msg.caption_entities;
      else if ("game" in msg)
        text = msg.game.text, entities = msg.game.text_entities;
    } else if (ctx.poll)
      text = ctx.poll.explanation, entities = ctx.poll.explanation_entities;
    return [text, entities];
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Context = undefined;
  var debug_1 = __importDefault(require_src());
  var reactions_1 = require_reactions();
  var debug = (0, debug_1.default)("telegraf:context");

  class Context {
    constructor(update, telegram, botInfo) {
      this.update = update;
      this.telegram = telegram;
      this.botInfo = botInfo;
      this.state = {};
    }
    get updateType() {
      for (const key in this.update) {
        if (typeof this.update[key] === "object")
          return key;
      }
      throw new Error(`Cannot determine \`updateType\` of ${JSON.stringify(this.update)}`);
    }
    get me() {
      var _a4;
      return (_a4 = this.botInfo) === null || _a4 === undefined ? undefined : _a4.username;
    }
    get tg() {
      return this.telegram;
    }
    get message() {
      return this.update.message;
    }
    get editedMessage() {
      return this.update.edited_message;
    }
    get inlineQuery() {
      return this.update.inline_query;
    }
    get shippingQuery() {
      return this.update.shipping_query;
    }
    get preCheckoutQuery() {
      return this.update.pre_checkout_query;
    }
    get chosenInlineResult() {
      return this.update.chosen_inline_result;
    }
    get channelPost() {
      return this.update.channel_post;
    }
    get editedChannelPost() {
      return this.update.edited_channel_post;
    }
    get messageReaction() {
      return this.update.message_reaction;
    }
    get messageReactionCount() {
      return this.update.message_reaction_count;
    }
    get callbackQuery() {
      return this.update.callback_query;
    }
    get poll() {
      return this.update.poll;
    }
    get pollAnswer() {
      return this.update.poll_answer;
    }
    get myChatMember() {
      return this.update.my_chat_member;
    }
    get chatMember() {
      return this.update.chat_member;
    }
    get chatJoinRequest() {
      return this.update.chat_join_request;
    }
    get chatBoost() {
      return this.update.chat_boost;
    }
    get removedChatBoost() {
      return this.update.removed_chat_boost;
    }
    get msg() {
      return getMessageFromAnySource(this);
    }
    get msgId() {
      return getMsgIdFromAnySource(this);
    }
    get chat() {
      var _a4, _b, _c, _d, _e, _f, _g;
      return (_g = (_f = (_e = (_d = (_c = (_b = (_a4 = this.msg) !== null && _a4 !== undefined ? _a4 : this.messageReaction) !== null && _b !== undefined ? _b : this.messageReactionCount) !== null && _c !== undefined ? _c : this.chatJoinRequest) !== null && _d !== undefined ? _d : this.chatMember) !== null && _e !== undefined ? _e : this.myChatMember) !== null && _f !== undefined ? _f : this.removedChatBoost) === null || _g === undefined ? undefined : _g.chat;
    }
    get senderChat() {
      const msg = this.msg;
      return (msg === null || msg === undefined ? undefined : msg.has("sender_chat")) && msg.sender_chat;
    }
    get from() {
      return getUserFromAnySource(this);
    }
    get inlineMessageId() {
      var _a4, _b;
      return (_b = (_a4 = this.callbackQuery) !== null && _a4 !== undefined ? _a4 : this.chosenInlineResult) === null || _b === undefined ? undefined : _b.inline_message_id;
    }
    get passportData() {
      var _a4;
      if (this.message == null)
        return;
      if (!("passport_data" in this.message))
        return;
      return (_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.passport_data;
    }
    get webAppData() {
      if (!(this.message && ("web_app_data" in this.message)))
        return;
      const { data: data15, button_text } = this.message.web_app_data;
      return {
        data: {
          json() {
            return JSON.parse(data15);
          },
          text() {
            return data15;
          }
        },
        button_text
      };
    }
    get webhookReply() {
      return this.telegram.webhookReply;
    }
    set webhookReply(enable) {
      this.telegram.webhookReply = enable;
    }
    get reactions() {
      return reactions_1.MessageReactions.from(this);
    }
    assert(value, method) {
      if (value === undefined) {
        throw new TypeError(`Telegraf: "${method}" isn't available for "${this.updateType}"`);
      }
    }
    has(filters) {
      if (!Array.isArray(filters))
        filters = [filters];
      for (const filter3 of filters)
        if (typeof filter3 !== "string" ? filter3(this.update) : (filter3 in this.update))
          return true;
      return false;
    }
    get text() {
      return getTextAndEntitiesFromAnySource(this)[0];
    }
    entities(...types15) {
      const [text = "", entities = []] = getTextAndEntitiesFromAnySource(this);
      return (types15.length ? entities.filter((entity) => types15.includes(entity.type)) : entities).map((entity) => ({
        ...entity,
        fragment: text.slice(entity.offset, entity.offset + entity.length)
      }));
    }
    answerInlineQuery(...args) {
      this.assert(this.inlineQuery, "answerInlineQuery");
      return this.telegram.answerInlineQuery(this.inlineQuery.id, ...args);
    }
    answerCbQuery(...args) {
      this.assert(this.callbackQuery, "answerCbQuery");
      return this.telegram.answerCbQuery(this.callbackQuery.id, ...args);
    }
    answerGameQuery(...args) {
      this.assert(this.callbackQuery, "answerGameQuery");
      return this.telegram.answerGameQuery(this.callbackQuery.id, ...args);
    }
    getUserChatBoosts() {
      this.assert(this.chat, "getUserChatBoosts");
      this.assert(this.from, "getUserChatBoosts");
      return this.telegram.getUserChatBoosts(this.chat.id, this.from.id);
    }
    answerShippingQuery(...args) {
      this.assert(this.shippingQuery, "answerShippingQuery");
      return this.telegram.answerShippingQuery(this.shippingQuery.id, ...args);
    }
    answerPreCheckoutQuery(...args) {
      this.assert(this.preCheckoutQuery, "answerPreCheckoutQuery");
      return this.telegram.answerPreCheckoutQuery(this.preCheckoutQuery.id, ...args);
    }
    editMessageText(text, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageText");
      return this.telegram.editMessageText((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, text, extra);
    }
    editMessageCaption(caption, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageCaption");
      return this.telegram.editMessageCaption((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, caption, extra);
    }
    editMessageMedia(media, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageMedia");
      return this.telegram.editMessageMedia((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, media, extra);
    }
    editMessageReplyMarkup(markup) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageReplyMarkup");
      return this.telegram.editMessageReplyMarkup((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, markup);
    }
    editMessageLiveLocation(latitude, longitude, extra) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "editMessageLiveLocation");
      return this.telegram.editMessageLiveLocation((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, latitude, longitude, extra);
    }
    stopMessageLiveLocation(markup) {
      var _a4, _b;
      this.assert((_a4 = this.msgId) !== null && _a4 !== undefined ? _a4 : this.inlineMessageId, "stopMessageLiveLocation");
      return this.telegram.stopMessageLiveLocation((_b = this.chat) === null || _b === undefined ? undefined : _b.id, this.msgId, this.inlineMessageId, markup);
    }
    sendMessage(text, extra) {
      this.assert(this.chat, "sendMessage");
      return this.telegram.sendMessage(this.chat.id, text, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    reply(...args) {
      return this.sendMessage(...args);
    }
    getChat(...args) {
      this.assert(this.chat, "getChat");
      return this.telegram.getChat(this.chat.id, ...args);
    }
    exportChatInviteLink(...args) {
      this.assert(this.chat, "exportChatInviteLink");
      return this.telegram.exportChatInviteLink(this.chat.id, ...args);
    }
    createChatInviteLink(...args) {
      this.assert(this.chat, "createChatInviteLink");
      return this.telegram.createChatInviteLink(this.chat.id, ...args);
    }
    editChatInviteLink(...args) {
      this.assert(this.chat, "editChatInviteLink");
      return this.telegram.editChatInviteLink(this.chat.id, ...args);
    }
    revokeChatInviteLink(...args) {
      this.assert(this.chat, "revokeChatInviteLink");
      return this.telegram.revokeChatInviteLink(this.chat.id, ...args);
    }
    banChatMember(...args) {
      this.assert(this.chat, "banChatMember");
      return this.telegram.banChatMember(this.chat.id, ...args);
    }
    get kickChatMember() {
      return this.banChatMember;
    }
    unbanChatMember(...args) {
      this.assert(this.chat, "unbanChatMember");
      return this.telegram.unbanChatMember(this.chat.id, ...args);
    }
    restrictChatMember(...args) {
      this.assert(this.chat, "restrictChatMember");
      return this.telegram.restrictChatMember(this.chat.id, ...args);
    }
    promoteChatMember(...args) {
      this.assert(this.chat, "promoteChatMember");
      return this.telegram.promoteChatMember(this.chat.id, ...args);
    }
    setChatAdministratorCustomTitle(...args) {
      this.assert(this.chat, "setChatAdministratorCustomTitle");
      return this.telegram.setChatAdministratorCustomTitle(this.chat.id, ...args);
    }
    setChatPhoto(...args) {
      this.assert(this.chat, "setChatPhoto");
      return this.telegram.setChatPhoto(this.chat.id, ...args);
    }
    deleteChatPhoto(...args) {
      this.assert(this.chat, "deleteChatPhoto");
      return this.telegram.deleteChatPhoto(this.chat.id, ...args);
    }
    setChatTitle(...args) {
      this.assert(this.chat, "setChatTitle");
      return this.telegram.setChatTitle(this.chat.id, ...args);
    }
    setChatDescription(...args) {
      this.assert(this.chat, "setChatDescription");
      return this.telegram.setChatDescription(this.chat.id, ...args);
    }
    pinChatMessage(...args) {
      this.assert(this.chat, "pinChatMessage");
      return this.telegram.pinChatMessage(this.chat.id, ...args);
    }
    unpinChatMessage(...args) {
      this.assert(this.chat, "unpinChatMessage");
      return this.telegram.unpinChatMessage(this.chat.id, ...args);
    }
    unpinAllChatMessages(...args) {
      this.assert(this.chat, "unpinAllChatMessages");
      return this.telegram.unpinAllChatMessages(this.chat.id, ...args);
    }
    leaveChat(...args) {
      this.assert(this.chat, "leaveChat");
      return this.telegram.leaveChat(this.chat.id, ...args);
    }
    setChatPermissions(...args) {
      this.assert(this.chat, "setChatPermissions");
      return this.telegram.setChatPermissions(this.chat.id, ...args);
    }
    getChatAdministrators(...args) {
      this.assert(this.chat, "getChatAdministrators");
      return this.telegram.getChatAdministrators(this.chat.id, ...args);
    }
    getChatMember(...args) {
      this.assert(this.chat, "getChatMember");
      return this.telegram.getChatMember(this.chat.id, ...args);
    }
    getChatMembersCount(...args) {
      this.assert(this.chat, "getChatMembersCount");
      return this.telegram.getChatMembersCount(this.chat.id, ...args);
    }
    setPassportDataErrors(errors14) {
      this.assert(this.from, "setPassportDataErrors");
      return this.telegram.setPassportDataErrors(this.from.id, errors14);
    }
    sendPhoto(photo, extra) {
      this.assert(this.chat, "sendPhoto");
      return this.telegram.sendPhoto(this.chat.id, photo, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithPhoto(...args) {
      return this.sendPhoto(...args);
    }
    sendMediaGroup(media, extra) {
      this.assert(this.chat, "sendMediaGroup");
      return this.telegram.sendMediaGroup(this.chat.id, media, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithMediaGroup(...args) {
      return this.sendMediaGroup(...args);
    }
    sendAudio(audio, extra) {
      this.assert(this.chat, "sendAudio");
      return this.telegram.sendAudio(this.chat.id, audio, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithAudio(...args) {
      return this.sendAudio(...args);
    }
    sendDice(extra) {
      this.assert(this.chat, "sendDice");
      return this.telegram.sendDice(this.chat.id, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithDice(...args) {
      return this.sendDice(...args);
    }
    sendDocument(document2, extra) {
      this.assert(this.chat, "sendDocument");
      return this.telegram.sendDocument(this.chat.id, document2, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithDocument(...args) {
      return this.sendDocument(...args);
    }
    sendSticker(sticker, extra) {
      this.assert(this.chat, "sendSticker");
      return this.telegram.sendSticker(this.chat.id, sticker, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithSticker(...args) {
      return this.sendSticker(...args);
    }
    sendVideo(video, extra) {
      this.assert(this.chat, "sendVideo");
      return this.telegram.sendVideo(this.chat.id, video, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVideo(...args) {
      return this.sendVideo(...args);
    }
    sendAnimation(animation, extra) {
      this.assert(this.chat, "sendAnimation");
      return this.telegram.sendAnimation(this.chat.id, animation, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithAnimation(...args) {
      return this.sendAnimation(...args);
    }
    sendVideoNote(videoNote, extra) {
      this.assert(this.chat, "sendVideoNote");
      return this.telegram.sendVideoNote(this.chat.id, videoNote, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVideoNote(...args) {
      return this.sendVideoNote(...args);
    }
    sendInvoice(invoice, extra) {
      this.assert(this.chat, "sendInvoice");
      return this.telegram.sendInvoice(this.chat.id, invoice, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithInvoice(...args) {
      return this.sendInvoice(...args);
    }
    sendGame(game, extra) {
      this.assert(this.chat, "sendGame");
      return this.telegram.sendGame(this.chat.id, game, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithGame(...args) {
      return this.sendGame(...args);
    }
    sendVoice(voice, extra) {
      this.assert(this.chat, "sendVoice");
      return this.telegram.sendVoice(this.chat.id, voice, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithVoice(...args) {
      return this.sendVoice(...args);
    }
    sendPoll(poll, options, extra) {
      this.assert(this.chat, "sendPoll");
      return this.telegram.sendPoll(this.chat.id, poll, options, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithPoll(...args) {
      return this.sendPoll(...args);
    }
    sendQuiz(quiz, options, extra) {
      this.assert(this.chat, "sendQuiz");
      return this.telegram.sendQuiz(this.chat.id, quiz, options, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithQuiz(...args) {
      return this.sendQuiz(...args);
    }
    stopPoll(...args) {
      this.assert(this.chat, "stopPoll");
      return this.telegram.stopPoll(this.chat.id, ...args);
    }
    sendChatAction(action, extra) {
      this.assert(this.chat, "sendChatAction");
      return this.telegram.sendChatAction(this.chat.id, action, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    async persistentChatAction(action, callback, { intervalDuration, ...extra } = {}) {
      await this.sendChatAction(action, { ...extra });
      const timer = setInterval(() => this.sendChatAction(action, { ...extra }).catch((err) => {
        debug("Ignored error while persisting sendChatAction:", err);
      }), intervalDuration !== null && intervalDuration !== undefined ? intervalDuration : 4000);
      try {
        await callback();
      } finally {
        clearInterval(timer);
      }
    }
    replyWithChatAction(...args) {
      return this.sendChatAction(...args);
    }
    react(reaction, is_big) {
      this.assert(this.chat, "setMessageReaction");
      this.assert(this.msgId, "setMessageReaction");
      const emojis = reaction ? Array.isArray(reaction) ? reaction : [reaction] : undefined;
      const reactions = emojis === null || emojis === undefined ? undefined : emojis.map((emoji) => typeof emoji === "string" ? reactions_1.Digit.has(emoji[0]) ? { type: "custom_emoji", custom_emoji_id: emoji } : { type: "emoji", emoji } : emoji);
      return this.telegram.setMessageReaction(this.chat.id, this.msgId, reactions, is_big);
    }
    sendLocation(latitude, longitude, extra) {
      this.assert(this.chat, "sendLocation");
      return this.telegram.sendLocation(this.chat.id, latitude, longitude, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithLocation(...args) {
      return this.sendLocation(...args);
    }
    sendVenue(latitude, longitude, title, address28, extra) {
      this.assert(this.chat, "sendVenue");
      return this.telegram.sendVenue(this.chat.id, latitude, longitude, title, address28, { message_thread_id: getThreadId(this), ...extra });
    }
    replyWithVenue(...args) {
      return this.sendVenue(...args);
    }
    sendContact(phoneNumber, firstName, extra) {
      this.assert(this.chat, "sendContact");
      return this.telegram.sendContact(this.chat.id, phoneNumber, firstName, {
        message_thread_id: getThreadId(this),
        ...extra
      });
    }
    replyWithContact(...args) {
      return this.sendContact(...args);
    }
    getStickerSet(setName) {
      return this.telegram.getStickerSet(setName);
    }
    setChatStickerSet(setName) {
      this.assert(this.chat, "setChatStickerSet");
      return this.telegram.setChatStickerSet(this.chat.id, setName);
    }
    deleteChatStickerSet() {
      this.assert(this.chat, "deleteChatStickerSet");
      return this.telegram.deleteChatStickerSet(this.chat.id);
    }
    createForumTopic(...args) {
      this.assert(this.chat, "createForumTopic");
      return this.telegram.createForumTopic(this.chat.id, ...args);
    }
    editForumTopic(extra) {
      var _a4;
      this.assert(this.chat, "editForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "editForumTopic");
      return this.telegram.editForumTopic(this.chat.id, this.message.message_thread_id, extra);
    }
    closeForumTopic() {
      var _a4;
      this.assert(this.chat, "closeForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "closeForumTopic");
      return this.telegram.closeForumTopic(this.chat.id, this.message.message_thread_id);
    }
    reopenForumTopic() {
      var _a4;
      this.assert(this.chat, "reopenForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "reopenForumTopic");
      return this.telegram.reopenForumTopic(this.chat.id, this.message.message_thread_id);
    }
    deleteForumTopic() {
      var _a4;
      this.assert(this.chat, "deleteForumTopic");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "deleteForumTopic");
      return this.telegram.deleteForumTopic(this.chat.id, this.message.message_thread_id);
    }
    unpinAllForumTopicMessages() {
      var _a4;
      this.assert(this.chat, "unpinAllForumTopicMessages");
      this.assert((_a4 = this.message) === null || _a4 === undefined ? undefined : _a4.message_thread_id, "unpinAllForumTopicMessages");
      return this.telegram.unpinAllForumTopicMessages(this.chat.id, this.message.message_thread_id);
    }
    editGeneralForumTopic(name) {
      this.assert(this.chat, "editGeneralForumTopic");
      return this.telegram.editGeneralForumTopic(this.chat.id, name);
    }
    closeGeneralForumTopic() {
      this.assert(this.chat, "closeGeneralForumTopic");
      return this.telegram.closeGeneralForumTopic(this.chat.id);
    }
    reopenGeneralForumTopic() {
      this.assert(this.chat, "reopenGeneralForumTopic");
      return this.telegram.reopenGeneralForumTopic(this.chat.id);
    }
    hideGeneralForumTopic() {
      this.assert(this.chat, "hideGeneralForumTopic");
      return this.telegram.hideGeneralForumTopic(this.chat.id);
    }
    unhideGeneralForumTopic() {
      this.assert(this.chat, "unhideGeneralForumTopic");
      return this.telegram.unhideGeneralForumTopic(this.chat.id);
    }
    unpinAllGeneralForumTopicMessages() {
      this.assert(this.chat, "unpinAllGeneralForumTopicMessages");
      return this.telegram.unpinAllGeneralForumTopicMessages(this.chat.id);
    }
    setStickerPositionInSet(sticker, position) {
      return this.telegram.setStickerPositionInSet(sticker, position);
    }
    setStickerSetThumb(...args) {
      return this.telegram.setStickerSetThumbnail(...args);
    }
    setStickerSetThumbnail(...args) {
      return this.telegram.setStickerSetThumbnail(...args);
    }
    setStickerMaskPosition(...args) {
      return this.telegram.setStickerMaskPosition(...args);
    }
    setStickerKeywords(...args) {
      return this.telegram.setStickerKeywords(...args);
    }
    setStickerEmojiList(...args) {
      return this.telegram.setStickerEmojiList(...args);
    }
    deleteStickerSet(...args) {
      return this.telegram.deleteStickerSet(...args);
    }
    setStickerSetTitle(...args) {
      return this.telegram.setStickerSetTitle(...args);
    }
    setCustomEmojiStickerSetThumbnail(...args) {
      return this.telegram.setCustomEmojiStickerSetThumbnail(...args);
    }
    deleteStickerFromSet(sticker) {
      return this.telegram.deleteStickerFromSet(sticker);
    }
    uploadStickerFile(...args) {
      this.assert(this.from, "uploadStickerFile");
      return this.telegram.uploadStickerFile(this.from.id, ...args);
    }
    createNewStickerSet(...args) {
      this.assert(this.from, "createNewStickerSet");
      return this.telegram.createNewStickerSet(this.from.id, ...args);
    }
    addStickerToSet(...args) {
      this.assert(this.from, "addStickerToSet");
      return this.telegram.addStickerToSet(this.from.id, ...args);
    }
    getMyCommands() {
      return this.telegram.getMyCommands();
    }
    setMyCommands(commands) {
      return this.telegram.setMyCommands(commands);
    }
    replyWithMarkdown(markdown, extra) {
      return this.reply(markdown, { parse_mode: "Markdown", ...extra });
    }
    replyWithMarkdownV2(markdown, extra) {
      return this.reply(markdown, { parse_mode: "MarkdownV2", ...extra });
    }
    replyWithHTML(html, extra) {
      return this.reply(html, { parse_mode: "HTML", ...extra });
    }
    deleteMessage(messageId) {
      this.assert(this.chat, "deleteMessage");
      if (typeof messageId !== "undefined")
        return this.telegram.deleteMessage(this.chat.id, messageId);
      this.assert(this.msgId, "deleteMessage");
      return this.telegram.deleteMessage(this.chat.id, this.msgId);
    }
    deleteMessages(messageIds) {
      this.assert(this.chat, "deleteMessages");
      return this.telegram.deleteMessages(this.chat.id, messageIds);
    }
    forwardMessage(chatId, extra) {
      this.assert(this.chat, "forwardMessage");
      this.assert(this.msgId, "forwardMessage");
      return this.telegram.forwardMessage(chatId, this.chat.id, this.msgId, extra);
    }
    forwardMessages(chatId, messageIds, extra) {
      this.assert(this.chat, "forwardMessages");
      return this.telegram.forwardMessages(chatId, this.chat.id, messageIds, extra);
    }
    copyMessage(chatId, extra) {
      this.assert(this.chat, "copyMessage");
      this.assert(this.msgId, "copyMessage");
      return this.telegram.copyMessage(chatId, this.chat.id, this.msgId, extra);
    }
    copyMessages(chatId, messageIds, extra) {
      var _a4;
      this.assert(this.chat, "copyMessages");
      return this.telegram.copyMessages(chatId, (_a4 = this.chat) === null || _a4 === undefined ? undefined : _a4.id, messageIds, extra);
    }
    approveChatJoinRequest(userId) {
      this.assert(this.chat, "approveChatJoinRequest");
      return this.telegram.approveChatJoinRequest(this.chat.id, userId);
    }
    declineChatJoinRequest(userId) {
      this.assert(this.chat, "declineChatJoinRequest");
      return this.telegram.declineChatJoinRequest(this.chat.id, userId);
    }
    banChatSenderChat(senderChatId) {
      this.assert(this.chat, "banChatSenderChat");
      return this.telegram.banChatSenderChat(this.chat.id, senderChatId);
    }
    unbanChatSenderChat(senderChatId) {
      this.assert(this.chat, "unbanChatSenderChat");
      return this.telegram.unbanChatSenderChat(this.chat.id, senderChatId);
    }
    setChatMenuButton(menuButton) {
      this.assert(this.chat, "setChatMenuButton");
      return this.telegram.setChatMenuButton({ chatId: this.chat.id, menuButton });
    }
    getChatMenuButton() {
      this.assert(this.chat, "getChatMenuButton");
      return this.telegram.getChatMenuButton({ chatId: this.chat.id });
    }
    setMyDefaultAdministratorRights(extra) {
      return this.telegram.setMyDefaultAdministratorRights(extra);
    }
    getMyDefaultAdministratorRights(extra) {
      return this.telegram.getMyDefaultAdministratorRights(extra);
    }
  }
  exports.Context = Context;
  exports.default = Context;
  var Msg = {
    isAccessible() {
      return "date" in this && this.date !== 0;
    },
    has(...keys) {
      return keys.some((key) => this[key] != null);
    }
  };
  var getThreadId = (ctx) => {
    const msg = ctx.msg;
    return (msg === null || msg === undefined ? undefined : msg.isAccessible()) ? msg.is_topic_message ? msg.message_thread_id : undefined : undefined;
  };
});

// node_modules/telegraf/lib/filters.js
var require_filters = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.allOf = exports.anyOf = exports.callbackQuery = exports.editedChannelPost = exports.channelPost = exports.editedMessage = exports.message = undefined;
  var message = (...keys) => (update) => {
    if (!("message" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.message))
        return false;
    }
    return true;
  };
  exports.message = message;
  var editedMessage = (...keys) => (update) => {
    if (!("edited_message" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.edited_message))
        return false;
    }
    return true;
  };
  exports.editedMessage = editedMessage;
  var channelPost = (...keys) => (update) => {
    if (!("channel_post" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.channel_post))
        return false;
    }
    return true;
  };
  exports.channelPost = channelPost;
  var editedChannelPost = (...keys) => (update) => {
    if (!("edited_channel_post" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.edited_channel_post))
        return false;
    }
    return true;
  };
  exports.editedChannelPost = editedChannelPost;
  var callbackQuery = (...keys) => (update) => {
    if (!("callback_query" in update))
      return false;
    for (const key of keys) {
      if (!(key in update.callback_query))
        return false;
    }
    return true;
  };
  exports.callbackQuery = callbackQuery;
  var anyOf = (...filters) => (update) => {
    for (const filter3 of filters)
      if (filter3(update))
        return true;
    return false;
  };
  exports.anyOf = anyOf;
  var allOf = (...filters) => (update) => {
    for (const filter3 of filters)
      if (!filter3(update))
        return false;
    return true;
  };
  exports.allOf = allOf;
});

// node_modules/telegraf/lib/core/helpers/args.js
var require_args = __commonJS((exports) => {
  var argsParser = function(str, entities = [], entityOffset = 0) {
    const mentions = {};
    for (const entity of entities)
      if (entity.type === "text_mention" || entity.type === "text_link")
        mentions[entity.offset - entityOffset] = entity.length;
    const args = [];
    let done = 0;
    let inside = undefined;
    let buf = "";
    function flush(to) {
      if (done !== to)
        args.push(buf + str.slice(done, to)), inside = undefined;
      buf = "";
      done = to + 1;
    }
    for (let i = 0;i < str.length; i++) {
      const char = str[i];
      const mention = mentions[i];
      if (mention) {
        flush(i);
        done--;
        i += mention;
        flush(i);
      } else if (char === SINGLE_QUOTE || char === DOUBLE_QUOTE)
        if (inside)
          if (inside === char)
            flush(i);
          else
            continue;
        else
          flush(i), inside = char;
      else if (char === " ")
        if (inside)
          continue;
        else
          flush(i);
      else if (char === "\n")
        flush(i);
      else if (char === "\\")
        buf += str.slice(done, i), done = ++i;
      else
        continue;
    }
    if (done < str.length)
      flush(str.length);
    return args;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.argsParser = undefined;
  var SINGLE_QUOTE = "'";
  var DOUBLE_QUOTE = '"';
  exports.argsParser = argsParser;
});

// node_modules/telegraf/lib/composer.js
var require_composer = __commonJS((exports) => {
  var always = function(x) {
    return () => x;
  };
  var escapeRegExp = function(s) {
    return s.replace(/[.*+\-?^${}()|[\]\\]/g, "\\$&");
  };
  var normaliseTriggers = function(triggers) {
    if (!Array.isArray(triggers))
      triggers = [triggers];
    return triggers.map((trigger) => {
      if (!trigger)
        throw new Error("Invalid trigger");
      if (typeof trigger === "function")
        return trigger;
      if (trigger instanceof RegExp)
        return (value = "") => {
          trigger.lastIndex = 0;
          return trigger.exec(value);
        };
      const regex = new RegExp(`^${escapeRegExp(trigger)}\$`);
      return (value) => regex.exec(value);
    });
  };
  var getEntities = function(msg) {
    var _a4, _b;
    if (msg == null)
      return [];
    if ("caption_entities" in msg)
      return (_a4 = msg.caption_entities) !== null && _a4 !== undefined ? _a4 : [];
    if ("entities" in msg)
      return (_b = msg.entities) !== null && _b !== undefined ? _b : [];
    return [];
  };
  var getText = function(msg) {
    if (msg == null)
      return;
    if ("caption" in msg)
      return msg.caption;
    if ("text" in msg)
      return msg.text;
    if ("data" in msg)
      return msg.data;
    if ("game_short_name" in msg)
      return msg.game_short_name;
    return;
  };
  var normaliseTextArguments = function(argument, prefix = "") {
    const args = Array.isArray(argument) ? argument : [argument];
    return args.filter(Boolean).map((arg) => prefix && typeof arg === "string" && !arg.startsWith(prefix) ? `${prefix}${arg}` : arg);
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Composer = undefined;
  var context_1 = __importDefault(require_context());
  var filters_1 = require_filters();
  var args_1 = require_args();
  var anoop = always(Promise.resolve());

  class Composer {
    constructor(...fns) {
      this.handler = Composer.compose(fns);
    }
    use(...fns) {
      this.handler = Composer.compose([this.handler, ...fns]);
      return this;
    }
    guard(guardFn, ...fns) {
      return this.use(Composer.guard(guardFn, ...fns));
    }
    on(filters, ...fns) {
      return this.use(Composer.on(filters, ...fns));
    }
    hears(triggers, ...fns) {
      return this.use(Composer.hears(triggers, ...fns));
    }
    command(command, ...fns) {
      return this.use(Composer.command(command, ...fns));
    }
    action(triggers, ...fns) {
      return this.use(Composer.action(triggers, ...fns));
    }
    inlineQuery(triggers, ...fns) {
      return this.use(Composer.inlineQuery(triggers, ...fns));
    }
    gameQuery(...fns) {
      return this.use(Composer.gameQuery(...fns));
    }
    reaction(reaction, ...fns) {
      return this.use(Composer.reaction(reaction, ...fns));
    }
    drop(predicate) {
      return this.use(Composer.drop(predicate));
    }
    filter(predicate) {
      return this.use(Composer.filter(predicate));
    }
    entity(predicate, ...fns) {
      return this.use(Composer.entity(predicate, ...fns));
    }
    email(email, ...fns) {
      return this.use(Composer.email(email, ...fns));
    }
    url(url, ...fns) {
      return this.use(Composer.url(url, ...fns));
    }
    textLink(link, ...fns) {
      return this.use(Composer.textLink(link, ...fns));
    }
    textMention(mention, ...fns) {
      return this.use(Composer.textMention(mention, ...fns));
    }
    mention(mention, ...fns) {
      return this.use(Composer.mention(mention, ...fns));
    }
    phone(number10, ...fns) {
      return this.use(Composer.phone(number10, ...fns));
    }
    hashtag(hashtag, ...fns) {
      return this.use(Composer.hashtag(hashtag, ...fns));
    }
    cashtag(cashtag, ...fns) {
      return this.use(Composer.cashtag(cashtag, ...fns));
    }
    spoiler(text, ...fns) {
      return this.use(Composer.spoiler(text, ...fns));
    }
    start(...fns) {
      const handler = Composer.compose(fns);
      return this.command("start", (ctx, next) => handler(Object.assign(ctx, { startPayload: ctx.payload }), next));
    }
    help(...fns) {
      return this.command("help", ...fns);
    }
    settings(...fns) {
      return this.command("settings", ...fns);
    }
    middleware() {
      return this.handler;
    }
    static reply(...args) {
      return (ctx) => ctx.reply(...args);
    }
    static catch(errorHandler, ...fns) {
      const handler = Composer.compose(fns);
      return (ctx, next) => Promise.resolve(handler(ctx, next)).catch((err) => errorHandler(err, ctx));
    }
    static fork(middleware) {
      const handler = Composer.unwrap(middleware);
      return async (ctx, next) => {
        await Promise.all([handler(ctx, anoop), next()]);
      };
    }
    static tap(middleware) {
      const handler = Composer.unwrap(middleware);
      return (ctx, next) => Promise.resolve(handler(ctx, anoop)).then(() => next());
    }
    static passThru() {
      return (ctx, next) => next();
    }
    static lazy(factoryFn) {
      if (typeof factoryFn !== "function") {
        throw new Error("Argument must be a function");
      }
      return (ctx, next) => Promise.resolve(factoryFn(ctx)).then((middleware) => Composer.unwrap(middleware)(ctx, next));
    }
    static log(logFn = console.log) {
      return (ctx, next) => {
        logFn(JSON.stringify(ctx.update, null, 2));
        return next();
      };
    }
    static branch(predicate, trueMiddleware, falseMiddleware) {
      if (typeof predicate !== "function") {
        return Composer.unwrap(predicate ? trueMiddleware : falseMiddleware);
      }
      return Composer.lazy((ctx) => Promise.resolve(predicate(ctx)).then((value) => value ? trueMiddleware : falseMiddleware));
    }
    static optional(predicate, ...fns) {
      return Composer.branch(predicate, Composer.compose(fns), Composer.passThru());
    }
    static filter(predicate) {
      return Composer.branch(predicate, Composer.passThru(), anoop);
    }
    static drop(predicate) {
      return Composer.branch(predicate, anoop, Composer.passThru());
    }
    static dispatch(routeFn, handlers) {
      return Composer.lazy((ctx) => Promise.resolve(routeFn(ctx)).then((value) => handlers[value]));
    }
    static guard(guardFn, ...fns) {
      return Composer.optional((ctx) => guardFn(ctx.update), ...fns);
    }
    static on(updateType, ...fns) {
      const filters = Array.isArray(updateType) ? updateType : [updateType];
      const predicate = (update) => {
        for (const filter3 of filters) {
          if (typeof filter3 !== "string" ? filter3(update) : (filter3 in update) || ("message" in update) && (filter3 in update.message)) {
            return true;
          }
        }
        return false;
      };
      return Composer.optional((ctx) => predicate(ctx.update), ...fns);
    }
    static entity(predicate, ...fns) {
      if (typeof predicate !== "function") {
        const entityTypes = normaliseTextArguments(predicate);
        return Composer.entity(({ type }) => entityTypes.includes(type), ...fns);
      }
      return Composer.optional((ctx) => {
        var _a4;
        const msg = (_a4 = ctx.message) !== null && _a4 !== undefined ? _a4 : ctx.channelPost;
        if (msg === undefined) {
          return false;
        }
        const text = getText(msg);
        const entities = getEntities(msg);
        if (text === undefined)
          return false;
        return entities.some((entity) => predicate(entity, text.substring(entity.offset, entity.offset + entity.length), ctx));
      }, ...fns);
    }
    static entityText(entityType, predicate, ...fns) {
      if (fns.length === 0) {
        return Array.isArray(predicate) ? Composer.entity(entityType, ...predicate) : Composer.entity(entityType, predicate);
      }
      const triggers = normaliseTriggers(predicate);
      return Composer.entity(({ type }, value, ctx) => {
        if (type !== entityType) {
          return false;
        }
        for (const trigger of triggers) {
          if (ctx.match = trigger(value, ctx)) {
            return true;
          }
        }
        return false;
      }, ...fns);
    }
    static email(email, ...fns) {
      return Composer.entityText("email", email, ...fns);
    }
    static phone(number10, ...fns) {
      return Composer.entityText("phone_number", number10, ...fns);
    }
    static url(url, ...fns) {
      return Composer.entityText("url", url, ...fns);
    }
    static textLink(link, ...fns) {
      return Composer.entityText("text_link", link, ...fns);
    }
    static textMention(mention, ...fns) {
      return Composer.entityText("text_mention", mention, ...fns);
    }
    static mention(mention, ...fns) {
      return Composer.entityText("mention", normaliseTextArguments(mention, "@"), ...fns);
    }
    static hashtag(hashtag, ...fns) {
      return Composer.entityText("hashtag", normaliseTextArguments(hashtag, "#"), ...fns);
    }
    static cashtag(cashtag, ...fns) {
      return Composer.entityText("cashtag", normaliseTextArguments(cashtag, "$"), ...fns);
    }
    static spoiler(text, ...fns) {
      return Composer.entityText("spoiler", text, ...fns);
    }
    static match(triggers, ...fns) {
      const handler = Composer.compose(fns);
      return (ctx, next) => {
        var _a4, _b, _c, _d;
        const text = (_c = (_b = (_a4 = getText(ctx.message)) !== null && _a4 !== undefined ? _a4 : getText(ctx.channelPost)) !== null && _b !== undefined ? _b : getText(ctx.callbackQuery)) !== null && _c !== undefined ? _c : (_d = ctx.inlineQuery) === null || _d === undefined ? undefined : _d.query;
        if (text === undefined)
          return next();
        for (const trigger of triggers) {
          const match = trigger(text, ctx);
          if (match)
            return handler(Object.assign(ctx, { match }), next);
        }
        return next();
      };
    }
    static hears(triggers, ...fns) {
      return Composer.on("text", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static command(command, ...fns) {
      if (fns.length === 0)
        return Composer.entity("bot_command", command);
      const triggers = normaliseTriggers(command);
      const filter3 = (0, filters_1.message)("text");
      const handler = Composer.compose(fns);
      return Composer.on(filter3, (ctx, next) => {
        const { entities } = ctx.message;
        const cmdEntity = entities === null || entities === undefined ? undefined : entities[0];
        if ((cmdEntity === null || cmdEntity === undefined ? undefined : cmdEntity.type) !== "bot_command")
          return next();
        if (cmdEntity.offset > 0)
          return next();
        const len = cmdEntity.length;
        const text = ctx.message.text;
        const [cmdPart, to] = text.slice(0, len).split("@");
        if (!cmdPart)
          return next();
        if (to && to.toLowerCase() !== ctx.me.toLowerCase())
          return next();
        const command2 = cmdPart.slice(1);
        for (const trigger of triggers) {
          const match = trigger(command2, ctx);
          if (match) {
            const payloadOffset = len + 1;
            const payload = text.slice(payloadOffset);
            const c = Object.assign(ctx, { match, command: command2, payload, args: [] });
            let _args = undefined;
            Object.defineProperty(c, "args", {
              enumerable: true,
              configurable: true,
              get() {
                if (_args != null)
                  return _args;
                return _args = (0, args_1.argsParser)(payload, entities, payloadOffset);
              },
              set(args) {
                _args = args;
              }
            });
            return handler(c, next);
          }
        }
        return next();
      });
    }
    static action(triggers, ...fns) {
      return Composer.on("callback_query", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static inlineQuery(triggers, ...fns) {
      return Composer.on("inline_query", Composer.match(normaliseTriggers(triggers), ...fns));
    }
    static reaction(reaction, ...fns) {
      const reactions = Array.isArray(reaction) ? reaction : [reaction];
      const handler = Composer.compose(fns);
      return Composer.on("message_reaction", (ctx, next) => {
        const match = reactions.find((r2) => typeof r2 === "string" && r2.startsWith("-") ? ctx.reactions.removed.has(r2.slice(1)) : ctx.reactions.added.has(r2));
        if (match)
          return handler(Object.assign(ctx, { match }), next);
        return next();
      });
    }
    static acl(userId, ...fns) {
      if (typeof userId === "function") {
        return Composer.optional(userId, ...fns);
      }
      const allowed = Array.isArray(userId) ? userId : [userId];
      return Composer.optional((ctx) => !ctx.from || allowed.includes(ctx.from.id), ...fns);
    }
    static memberStatus(status, ...fns) {
      const statuses = Array.isArray(status) ? status : [status];
      return Composer.optional(async (ctx) => {
        if (ctx.message === undefined)
          return false;
        const member = await ctx.getChatMember(ctx.message.from.id);
        return statuses.includes(member.status);
      }, ...fns);
    }
    static admin(...fns) {
      return Composer.memberStatus(["administrator", "creator"], ...fns);
    }
    static creator(...fns) {
      return Composer.memberStatus("creator", ...fns);
    }
    static chatType(type, ...fns) {
      const types15 = Array.isArray(type) ? type : [type];
      return Composer.optional((ctx) => {
        const chat = ctx.chat;
        return chat !== undefined && types15.includes(chat.type);
      }, ...fns);
    }
    static privateChat(...fns) {
      return Composer.chatType("private", ...fns);
    }
    static groupChat(...fns) {
      return Composer.chatType(["group", "supergroup"], ...fns);
    }
    static gameQuery(...fns) {
      return Composer.guard((0, filters_1.callbackQuery)("game_short_name"), ...fns);
    }
    static unwrap(handler) {
      if (!handler) {
        throw new Error("Handler is undefined");
      }
      return "middleware" in handler ? handler.middleware() : handler;
    }
    static compose(middlewares) {
      if (!Array.isArray(middlewares)) {
        throw new Error("Middlewares must be an array");
      }
      if (middlewares.length === 0) {
        return Composer.passThru();
      }
      if (middlewares.length === 1) {
        return Composer.unwrap(middlewares[0]);
      }
      return (ctx, next) => {
        let index = -1;
        return execute(0, ctx);
        async function execute(i, context) {
          var _a4;
          if (!(context instanceof context_1.default)) {
            throw new Error("next(ctx) called with invalid context");
          }
          if (i <= index) {
            throw new Error("next() called multiple times");
          }
          index = i;
          const handler = Composer.unwrap((_a4 = middlewares[i]) !== null && _a4 !== undefined ? _a4 : next);
          await handler(context, async (ctx2 = context) => {
            await execute(i + 1, ctx2);
          });
        }
      };
    }
  }
  exports.Composer = Composer;
  Composer.mount = Composer.on;
  exports.default = Composer;
});

// node_modules/telegraf/lib/core/helpers/compact.js
var require_compact = __commonJS((exports) => {
  var compactOptions = function(options) {
    if (!options) {
      return options;
    }
    const compacted = {};
    for (const key in options)
      if (Object.prototype.hasOwnProperty.call(options, key) && options[key] !== undefined)
        compacted[key] = options[key];
    return compacted;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.compactOptions = undefined;
  exports.compactOptions = compactOptions;
});

// node_modules/telegraf/lib/core/network/webhook.js
var require_webhook = __commonJS((exports) => {
  var generateWebhook = function(filter3, updateHandler) {
    return async (req, res, next = () => {
      res.statusCode = 403;
      debug("Replying with status code", res.statusCode);
      res.end();
    }) => {
      debug("Incoming request", req.method, req.url);
      if (!filter3(req)) {
        debug("Webhook filter failed", req.method, req.url);
        return next();
      }
      let update;
      try {
        if (req.body != null) {
          let body = req.body;
          if (body instanceof Buffer)
            body = String(req.body);
          if (typeof body === "string")
            body = JSON.parse(body);
          update = body;
        } else {
          let body = "";
          for await (const chunk of req)
            body += String(chunk);
          update = JSON.parse(body);
        }
      } catch (error) {
        res.writeHead(415).end();
        debug("Failed to parse request body:", error);
        return;
      }
      return await updateHandler(update, res);
    };
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:webhook");
  exports.default = generateWebhook;
});

// node_modules/telegraf/lib/core/network/error.js
var require_error = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.TelegramError = undefined;

  class TelegramError extends Error {
    constructor(response, on = {}) {
      super(`${response.error_code}: ${response.description}`);
      this.response = response;
      this.on = on;
    }
    get code() {
      return this.response.error_code;
    }
    get description() {
      return this.response.description;
    }
    get parameters() {
      return this.response.parameters;
    }
  }
  exports.TelegramError = TelegramError;
  exports.default = TelegramError;
});

// node_modules/telegraf/lib/core/network/polling.js
var require_polling = __commonJS((exports) => {
  var always = function(x) {
    return () => x;
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Polling = undefined;
  var abort_controller_1 = __importDefault(import.meta.require("abort-controller"));
  var debug_1 = __importDefault(require_src());
  var util_1 = import.meta.require("util");
  var error_1 = require_error();
  var debug = (0, debug_1.default)("telegraf:polling");
  var wait2 = (0, util_1.promisify)(setTimeout);
  var noop = always(Promise.resolve());

  class Polling {
    constructor(telegram, allowedUpdates) {
      this.telegram = telegram;
      this.allowedUpdates = allowedUpdates;
      this.abortController = new abort_controller_1.default;
      this.skipOffsetSync = false;
      this.offset = 0;
    }
    async* [Symbol.asyncIterator]() {
      var _a4, _b;
      debug("Starting long polling");
      do {
        try {
          const updates = await this.telegram.callApi("getUpdates", {
            timeout: 50,
            offset: this.offset,
            allowed_updates: this.allowedUpdates
          }, this.abortController);
          const last = updates[updates.length - 1];
          if (last !== undefined) {
            this.offset = last.update_id + 1;
          }
          yield updates;
        } catch (error) {
          const err = error;
          if (err.name === "AbortError")
            return;
          if (err.name === "FetchError" || err instanceof error_1.TelegramError && err.code === 429 || err instanceof error_1.TelegramError && err.code >= 500) {
            const retryAfter = (_b = (_a4 = err.parameters) === null || _a4 === undefined ? undefined : _a4.retry_after) !== null && _b !== undefined ? _b : 5;
            debug("Failed to fetch updates, retrying after %ds.", retryAfter, err);
            await wait2(retryAfter * 1000);
            continue;
          }
          if (err instanceof error_1.TelegramError && (err.code === 401 || err.code === 409)) {
            this.skipOffsetSync = true;
            throw err;
          }
          throw err;
        }
      } while (!this.abortController.signal.aborted);
    }
    async syncUpdateOffset() {
      if (this.skipOffsetSync)
        return;
      debug("Syncing update offset...");
      await this.telegram.callApi("getUpdates", { offset: this.offset, limit: 1 });
    }
    async loop(handleUpdate) {
      if (this.abortController.signal.aborted)
        throw new Error("Polling instances must not be reused!");
      try {
        for await (const updates of this)
          await Promise.all(updates.map(handleUpdate));
      } finally {
        debug("Long polling stopped");
        this.stop();
        await this.syncUpdateOffset().catch(noop);
      }
    }
    stop() {
      this.abortController.abort();
    }
  }
  exports.Polling = Polling;
});

// node_modules/p-timeout/index.js
var require_p_timeout = __commonJS((exports, module) => {
  class TimeoutError extends Error {
    constructor(message) {
      super(message);
      this.name = "TimeoutError";
    }
  }
  var pTimeout = (promise, milliseconds, fallback, options) => {
    let timer;
    const cancelablePromise = new Promise((resolve, reject) => {
      if (typeof milliseconds !== "number" || milliseconds < 0) {
        throw new TypeError("Expected `milliseconds` to be a positive number");
      }
      if (milliseconds === Infinity) {
        resolve(promise);
        return;
      }
      options = {
        customTimers: { setTimeout, clearTimeout },
        ...options
      };
      timer = options.customTimers.setTimeout.call(undefined, () => {
        if (typeof fallback === "function") {
          try {
            resolve(fallback());
          } catch (error) {
            reject(error);
          }
          return;
        }
        const message = typeof fallback === "string" ? fallback : `Promise timed out after ${milliseconds} milliseconds`;
        const timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);
        if (typeof promise.cancel === "function") {
          promise.cancel();
        }
        reject(timeoutError);
      }, milliseconds);
      (async () => {
        try {
          resolve(await promise);
        } catch (error) {
          reject(error);
        } finally {
          options.customTimers.clearTimeout.call(undefined, timer);
        }
      })();
    });
    cancelablePromise.clear = () => {
      clearTimeout(timer);
      timer = undefined;
    };
    return cancelablePromise;
  };
  module.exports = pTimeout;
  module.exports.default = pTimeout;
  module.exports.TimeoutError = TimeoutError;
});

// node_modules/telegraf/lib/core/helpers/check.js
var require_check = __commonJS((exports) => {
  var hasProp = function(obj, prop) {
    return obj !== undefined && prop in obj;
  };
  var hasPropType = function(obj, prop, type) {
    return hasProp(obj, prop) && type === typeof obj[prop];
  };
  var is2D = function(arr) {
    return Array.isArray(arr[0]);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.is2D = exports.hasPropType = exports.hasProp = undefined;
  exports.hasProp = hasProp;
  exports.hasPropType = hasPropType;
  exports.is2D = is2D;
});

// node_modules/sandwich-stream/dist/sandwich-stream.js
var require_sandwich_stream = __commonJS((exports) => {
  var __rest2 = function(s, e) {
    var t = {};
    for (var p in s)
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function") {
      for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++)
        if (e.indexOf(p[i]) < 0)
          t[p[i]] = s[p[i]];
    }
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = import.meta.require("stream");
  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0
  
  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.
  
  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  class SandwichStream extends stream.Readable {
    constructor(_a4) {
      var { head, tail, separator } = _a4, remaining = __rest2(_a4, ["head", "tail", "separator"]);
      super(remaining);
      this.streamsActive = false;
      this.streams = [];
      this.newStreams = [];
      this.currentStream = null;
      this.head = head !== null && head !== undefined ? head : null;
      this.tail = tail !== null && tail !== undefined ? tail : null;
      this.separator = separator !== null && separator !== undefined ? separator : null;
    }
    add(newStream) {
      if (this.streamsActive === false) {
        this.streams.push(newStream);
        newStream.on("error", this.subStreamOnError.bind(this));
      } else {
        this.newStreams.push(newStream);
      }
      return this;
    }
    _read() {
      if (this.streamsActive === false) {
        this.streamsActive = true;
        this.pushHead();
        this.streamNextStream();
      }
    }
    subStreamOnError(err) {
      this.emit("error", err);
    }
    streamNextStream() {
      if (this.nextStream() === true) {
        this.bindCurrentStreamEvents();
      } else {
        this.pushTail();
        this.push(null);
      }
    }
    nextStream() {
      const tmp = this.streams.shift();
      this.currentStream = tmp !== undefined ? tmp : null;
      return this.currentStream !== null;
    }
    bindCurrentStreamEvents() {
      this.currentStream.on("readable", this.currentStreamOnReadable.bind(this));
      this.currentStream.on("end", this.currentStreamOnEnd.bind(this));
    }
    currentStreamOnReadable() {
      const tmp = this.currentStream.read();
      const data15 = tmp !== undefined && tmp !== null ? tmp : "";
      this.push(data15);
    }
    currentStreamOnEnd() {
      this.pushSeparator();
      this.streams.concat(this.newStreams);
      this.newStreams = [];
      this.streamNextStream();
    }
    pushHead() {
      if (this.head !== null) {
        this.push(this.head);
      }
    }
    pushSeparator() {
      if (0 < this.streams.length && this.separator !== null) {
        this.push(this.separator);
      }
    }
    pushTail() {
      if (this.tail !== null) {
        this.push(this.tail);
      }
    }
  }
  exports.SandwichStream = SandwichStream;
  exports.default = SandwichStream;
});

// node_modules/telegraf/lib/core/network/multipart-stream.js
var require_multipart_stream = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod3) {
    if (mod3 && mod3.__esModule)
      return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k in mod3)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
          __createBinding(result, mod3, k);
    }
    __setModuleDefault(result, mod3);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var stream = __importStar(import.meta.require("stream"));
  var check_1 = require_check();
  var sandwich_stream_1 = __importDefault(require_sandwich_stream());
  var CRNL = "\r\n";

  class MultipartStream extends sandwich_stream_1.default {
    constructor(boundary) {
      super({
        head: `--${boundary}${CRNL}`,
        tail: `${CRNL}--${boundary}--`,
        separator: `${CRNL}--${boundary}${CRNL}`
      });
    }
    addPart(part) {
      const partStream = new stream.PassThrough;
      for (const [key, header] of Object.entries(part.headers)) {
        partStream.write(`${key}:${header}${CRNL}`);
      }
      partStream.write(CRNL);
      if (MultipartStream.isStream(part.body)) {
        part.body.pipe(partStream);
      } else {
        partStream.end(part.body);
      }
      this.add(partStream);
    }
    static isStream(stream2) {
      return typeof stream2 === "object" && stream2 !== null && (0, check_1.hasPropType)(stream2, "pipe", "function");
    }
  }
  exports.default = MultipartStream;
});

// node_modules/telegraf/lib/core/network/client.js
var require_client = __commonJS((exports) => {
  var includesMedia = function(payload) {
    return Object.entries(payload).some(([key, value]) => {
      if (key === "link_preview_options")
        return false;
      if (Array.isArray(value)) {
        return value.some(({ media }) => media && typeof media === "object" && (media.source || media.url));
      }
      return value && typeof value === "object" && ((0, check_1.hasProp)(value, "source") && value.source || (0, check_1.hasProp)(value, "url") && value.url || (0, check_1.hasPropType)(value, "media", "object") && ((0, check_1.hasProp)(value.media, "source") && value.media.source || (0, check_1.hasProp)(value.media, "url") && value.media.url));
    });
  };
  var replacer2 = function(_, value) {
    if (value == null)
      return;
    return value;
  };
  var buildJSONConfig = function(payload) {
    return Promise.resolve({
      method: "POST",
      compress: true,
      headers: { "content-type": "application/json", connection: "keep-alive" },
      body: JSON.stringify(payload, replacer2)
    });
  };
  async function buildFormDataConfig(payload, agent) {
    for (const field of FORM_DATA_JSON_FIELDS) {
      if ((0, check_1.hasProp)(payload, field) && typeof payload[field] !== "string") {
        payload[field] = JSON.stringify(payload[field]);
      }
    }
    const boundary = crypto29.randomBytes(32).toString("hex");
    const formData = new multipart_stream_1.default(boundary);
    await Promise.all(Object.keys(payload).map((key) => attachFormValue(formData, key, payload[key], agent)));
    return {
      method: "POST",
      compress: true,
      headers: {
        "content-type": `multipart/form-data; boundary=${boundary}`,
        connection: "keep-alive"
      },
      body: formData
    };
  }
  async function attachFormValue(form, id3, value, agent) {
    if (value == null) {
      return;
    }
    if (typeof value === "string" || typeof value === "boolean" || typeof value === "number") {
      form.addPart({
        headers: { "content-disposition": `form-data; name="${id3}"` },
        body: `${value}`
      });
      return;
    }
    if (id3 === "thumb" || id3 === "thumbnail") {
      const attachmentId = crypto29.randomBytes(16).toString("hex");
      await attachFormMedia(form, value, attachmentId, agent);
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id3}"` },
        body: `attach://${attachmentId}`
      });
    }
    if (Array.isArray(value)) {
      const items = await Promise.all(value.map(async (item) => {
        var _a4;
        if (typeof item.media !== "object") {
          return await Promise.resolve(item);
        }
        const attachmentId = crypto29.randomBytes(16).toString("hex");
        await attachFormMedia(form, item.media, attachmentId, agent);
        const thumb = (_a4 = item.thumb) !== null && _a4 !== undefined ? _a4 : item.thumbnail;
        if (typeof thumb === "object") {
          const thumbAttachmentId = crypto29.randomBytes(16).toString("hex");
          await attachFormMedia(form, thumb, thumbAttachmentId, agent);
          return {
            ...item,
            media: `attach://${attachmentId}`,
            thumbnail: `attach://${thumbAttachmentId}`
          };
        }
        return { ...item, media: `attach://${attachmentId}` };
      }));
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id3}"` },
        body: JSON.stringify(items)
      });
    }
    if (value && typeof value === "object" && (0, check_1.hasProp)(value, "media") && (0, check_1.hasProp)(value, "type") && typeof value.media !== "undefined" && typeof value.type !== "undefined") {
      const attachmentId = crypto29.randomBytes(16).toString("hex");
      await attachFormMedia(form, value.media, attachmentId, agent);
      return form.addPart({
        headers: { "content-disposition": `form-data; name="${id3}"` },
        body: JSON.stringify({
          ...value,
          media: `attach://${attachmentId}`
        })
      });
    }
    return await attachFormMedia(form, value, id3, agent);
  }
  async function attachFormMedia(form, media, id3, agent) {
    var _a4, _b, _c;
    let fileName = (_a4 = media.filename) !== null && _a4 !== undefined ? _a4 : `${id3}.${(_b = DEFAULT_EXTENSIONS[id3]) !== null && _b !== undefined ? _b : "dat"}`;
    if ("url" in media && media.url !== undefined) {
      const timeout = 500000;
      const res = await (0, node_fetch_1.default)(media.url, { agent, timeout });
      return form.addPart({
        headers: {
          "content-disposition": `form-data; name="${id3}"; filename="${fileName}"`
        },
        body: res.body
      });
    }
    if ("source" in media && media.source) {
      let mediaSource = media.source;
      if (typeof media.source === "string") {
        const source = await (0, promises_1.realpath)(media.source);
        if ((await (0, promises_1.stat)(source)).isFile()) {
          fileName = (_c = media.filename) !== null && _c !== undefined ? _c : path.basename(media.source);
          mediaSource = await fs.createReadStream(media.source);
        } else {
          throw new TypeError(`Unable to upload '${media.source}', not a file`);
        }
      }
      if (isStream(mediaSource) || Buffer.isBuffer(mediaSource)) {
        form.addPart({
          headers: {
            "content-disposition": `form-data; name="${id3}"; filename="${fileName}"`
          },
          body: mediaSource
        });
      }
    }
  }
  async function answerToWebhook(response, payload, options) {
    if (!includesMedia(payload)) {
      if (!response.headersSent) {
        response.setHeader("content-type", "application/json");
      }
      response.end(JSON.stringify(payload), "utf-8");
      return true;
    }
    const { headers, body } = await buildFormDataConfig(payload, options.attachmentAgent);
    if (!response.headersSent) {
      for (const [key, value] of Object.entries(headers)) {
        response.setHeader(key, value);
      }
    }
    await new Promise((resolve) => {
      response.on("finish", resolve);
      body.pipe(response);
    });
    return true;
  }
  var redactToken = function(error) {
    error.message = error.message.replace(/\/(bot|user)(\d+):[^/]+\//, "/$1$2:[REDACTED]/");
    throw error;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod3) {
    if (mod3 && mod3.__esModule)
      return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k in mod3)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
          __createBinding(result, mod3, k);
    }
    __setModuleDefault(result, mod3);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var crypto29 = __importStar(import.meta.require("crypto"));
  var fs = __importStar(import.meta.require("fs"));
  var promises_1 = import.meta.require("fs/promises");
  var https2 = __importStar(import.meta.require("https"));
  var path = __importStar(import.meta.require("path"));
  var node_fetch_1 = __importDefault(import.meta.require("node-fetch"));
  var check_1 = require_check();
  var compact_1 = require_compact();
  var multipart_stream_1 = __importDefault(require_multipart_stream());
  var error_1 = __importDefault(require_error());
  var url_1 = import.meta.require("url");
  var debug = require_src()("telegraf:client");
  var { isStream } = multipart_stream_1.default;
  var WEBHOOK_REPLY_METHOD_ALLOWLIST = new Set([
    "answerCallbackQuery",
    "answerInlineQuery",
    "deleteMessage",
    "leaveChat",
    "sendChatAction"
  ]);
  var DEFAULT_EXTENSIONS = {
    audio: "mp3",
    photo: "jpg",
    sticker: "webp",
    video: "mp4",
    animation: "mp4",
    video_note: "mp4",
    voice: "ogg"
  };
  var DEFAULT_OPTIONS = {
    apiRoot: "https://api.telegram.org",
    apiMode: "bot",
    webhookReply: true,
    agent: new https2.Agent({
      keepAlive: true,
      keepAliveMsecs: 1e4
    }),
    attachmentAgent: undefined,
    testEnv: false
  };
  var FORM_DATA_JSON_FIELDS = [
    "results",
    "reply_markup",
    "mask_position",
    "shipping_options",
    "errors"
  ];

  class ApiClient {
    constructor(token, options, response) {
      this.token = token;
      this.response = response;
      this.options = {
        ...DEFAULT_OPTIONS,
        ...(0, compact_1.compactOptions)(options)
      };
      if (this.options.apiRoot.startsWith("http://")) {
        this.options.agent = undefined;
      }
    }
    set webhookReply(enable) {
      this.options.webhookReply = enable;
    }
    get webhookReply() {
      return this.options.webhookReply;
    }
    async callApi(method, payload, { signal } = {}) {
      const { token, options, response } = this;
      if (options.webhookReply && (response === null || response === undefined ? undefined : response.writableEnded) === false && WEBHOOK_REPLY_METHOD_ALLOWLIST.has(method)) {
        debug("Call via webhook", method, payload);
        return await answerToWebhook(response, { method, ...payload }, options);
      }
      if (!token) {
        throw new error_1.default({
          error_code: 401,
          description: "Bot Token is required"
        });
      }
      debug("HTTP call", method, payload);
      const config5 = includesMedia(payload) ? await buildFormDataConfig({ method, ...payload }, options.attachmentAgent) : await buildJSONConfig(payload);
      const apiUrl = new url_1.URL(`./${options.apiMode}${token}${options.testEnv ? "/test" : ""}/${method}`, options.apiRoot);
      config5.agent = options.agent;
      config5.signal = signal;
      config5.timeout = 500000;
      const res = await (0, node_fetch_1.default)(apiUrl, config5).catch(redactToken);
      if (res.status >= 500) {
        const errorPayload = {
          error_code: res.status,
          description: res.statusText
        };
        throw new error_1.default(errorPayload, { method, payload });
      }
      const data15 = await res.json();
      if (!data15.ok) {
        debug("API call failed", data15);
        throw new error_1.default(data15, { method, payload });
      }
      return data15.result;
    }
  }
  exports.default = ApiClient;
});

// node_modules/telegraf/lib/core/helpers/formatting.js
var require_formatting = __commonJS((exports) => {
  var createFmt = function(kind, opts) {
    return function fmt(parts, ...items) {
      var _a4;
      parts = isArray(parts) ? parts : [parts];
      const result = (0, exports.join)((0, util_1.zip)(parts, items));
      if (kind) {
        (_a4 = result.entities) !== null && _a4 !== undefined || (result.entities = []);
        result.entities.unshift({
          type: kind,
          offset: 0,
          length: result.text.length,
          ...opts
        });
        result.parse_mode = undefined;
      }
      return result;
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.linkOrMention = exports.createFmt = exports.join = exports.FmtString = undefined;
  var util_1 = require_util2();

  class FmtString {
    constructor(text, entities) {
      this.text = text;
      if (entities) {
        this.entities = entities;
        this.parse_mode = undefined;
      }
    }
    static normalise(content) {
      if (content instanceof FmtString)
        return content;
      return new FmtString(String(content));
    }
  }
  exports.FmtString = FmtString;
  var isArray = Array.isArray;
  var _add = (base3, next) => {
    var _a4;
    const len = base3.text.length;
    if (next instanceof FmtString) {
      base3.text = `${base3.text}${next.text}`;
      for (let i = 0;i < (((_a4 = next.entities) === null || _a4 === undefined ? undefined : _a4.length) || 0); i++) {
        const entity = next.entities[i];
        base3.entities.push({ ...entity, offset: entity.offset + len });
      }
    } else
      base3.text = `${base3.text}${next}`;
  };
  var join = (fragments3, separator) => {
    const result = new FmtString("");
    result.entities = [];
    const iter = fragments3[Symbol.iterator]();
    let curr = iter.next();
    while (!curr.done) {
      _add(result, curr.value);
      curr = iter.next();
      if (separator && !curr.done)
        _add(result, separator);
    }
    if (result.entities.length)
      result.parse_mode = undefined;
    else
      delete result.entities;
    return result;
  };
  exports.join = join;
  exports.createFmt = createFmt;
  var linkOrMention = (content, data15) => {
    const { text, entities = [] } = FmtString.normalise(content);
    entities.unshift(Object.assign(data15, { offset: 0, length: text.length }));
    return new FmtString(text, entities);
  };
  exports.linkOrMention = linkOrMention;
});

// node_modules/telegraf/lib/format.js
var require_format = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mention = exports.link = exports.pre = exports.code = exports.quote = exports.underline = exports.strikethrough = exports.spoiler = exports.italic = exports.bold = exports.fmt = exports.join = exports.FmtString = undefined;
  var formatting_1 = require_formatting();
  Object.defineProperty(exports, "FmtString", { enumerable: true, get: function() {
    return formatting_1.FmtString;
  } });
  exports.join = formatting_1.join;
  exports.fmt = (0, formatting_1.createFmt)();
  exports.bold = (0, formatting_1.createFmt)("bold");
  exports.italic = (0, formatting_1.createFmt)("italic");
  exports.spoiler = (0, formatting_1.createFmt)("spoiler");
  exports.strikethrough = (0, formatting_1.createFmt)("strikethrough");
  exports.underline = (0, formatting_1.createFmt)("underline");
  exports.quote = (0, formatting_1.createFmt)("blockquote");
  exports.code = (0, formatting_1.createFmt)("code");
  var pre = (language) => (0, formatting_1.createFmt)("pre", { language });
  exports.pre = pre;
  var link = (content, url) => (0, formatting_1.linkOrMention)(content, { type: "text_link", url });
  exports.link = link;
  var mention = (name, user) => typeof user === "number" ? (0, exports.link)(name, "tg://user?id=" + user) : (0, formatting_1.linkOrMention)(name, {
    type: "text_mention",
    user
  });
  exports.mention = mention;
});

// node_modules/telegraf/lib/telegram.js
var require_telegram = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Telegram = undefined;
  var client_1 = __importDefault(require_client());
  var path_1 = import.meta.require("path");
  var url_1 = import.meta.require("url");
  var format_1 = require_format();
  var util_1 = require_util2();

  class Telegram extends client_1.default {
    getMe() {
      return this.callApi("getMe", {});
    }
    getFile(fileId) {
      return this.callApi("getFile", { file_id: fileId });
    }
    async getFileLink(fileId) {
      if (typeof fileId === "string") {
        fileId = await this.getFile(fileId);
      } else if (fileId.file_path === undefined) {
        fileId = await this.getFile(fileId.file_id);
      }
      if (fileId.file_path !== undefined && (0, path_1.isAbsolute)(fileId.file_path)) {
        const url = new url_1.URL(this.options.apiRoot);
        url.port = "";
        url.pathname = fileId.file_path;
        url.protocol = "file:";
        return url;
      }
      return new url_1.URL(`./file/${this.options.apiMode}${this.token}${this.options.testEnv ? "/test" : ""}/${fileId.file_path}`, this.options.apiRoot);
    }
    getUpdates(timeout, limit, offset, allowedUpdates) {
      return this.callApi("getUpdates", {
        allowed_updates: allowedUpdates,
        limit,
        offset,
        timeout
      });
    }
    getWebhookInfo() {
      return this.callApi("getWebhookInfo", {});
    }
    getGameHighScores(userId, inlineMessageId, chatId, messageId) {
      return this.callApi("getGameHighScores", {
        user_id: userId,
        inline_message_id: inlineMessageId,
        chat_id: chatId,
        message_id: messageId
      });
    }
    setGameScore(userId, score, inlineMessageId, chatId, messageId, editMessage = true, force = false) {
      return this.callApi("setGameScore", {
        force,
        score,
        user_id: userId,
        inline_message_id: inlineMessageId,
        chat_id: chatId,
        message_id: messageId,
        disable_edit_message: !editMessage
      });
    }
    setWebhook(url, extra) {
      return this.callApi("setWebhook", {
        url,
        ...extra
      });
    }
    deleteWebhook(extra) {
      return this.callApi("deleteWebhook", {
        ...extra
      });
    }
    sendMessage(chatId, text, extra) {
      const t = format_1.FmtString.normalise(text);
      return this.callApi("sendMessage", { chat_id: chatId, ...extra, ...t });
    }
    forwardMessage(chatId, fromChatId, messageId, extra) {
      return this.callApi("forwardMessage", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_id: messageId,
        ...extra
      });
    }
    forwardMessages(chatId, fromChatId, messageIds, extra) {
      return this.callApi("forwardMessages", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_ids: messageIds,
        ...extra
      });
    }
    sendChatAction(chat_id, action, extra) {
      return this.callApi("sendChatAction", { chat_id, action, ...extra });
    }
    setMessageReaction(chat_id, message_id, reaction, is_big) {
      return this.callApi("setMessageReaction", {
        chat_id,
        message_id,
        reaction,
        is_big
      });
    }
    getUserProfilePhotos(userId, offset, limit) {
      return this.callApi("getUserProfilePhotos", {
        user_id: userId,
        offset,
        limit
      });
    }
    sendLocation(chatId, latitude, longitude, extra) {
      return this.callApi("sendLocation", {
        chat_id: chatId,
        latitude,
        longitude,
        ...extra
      });
    }
    sendVenue(chatId, latitude, longitude, title, address28, extra) {
      return this.callApi("sendVenue", {
        latitude,
        longitude,
        title,
        address: address28,
        chat_id: chatId,
        ...extra
      });
    }
    sendInvoice(chatId, invoice, extra) {
      return this.callApi("sendInvoice", {
        chat_id: chatId,
        ...invoice,
        ...extra
      });
    }
    sendContact(chatId, phoneNumber, firstName, extra) {
      return this.callApi("sendContact", {
        chat_id: chatId,
        phone_number: phoneNumber,
        first_name: firstName,
        ...extra
      });
    }
    sendPhoto(chatId, photo, extra) {
      return this.callApi("sendPhoto", {
        chat_id: chatId,
        photo,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendDice(chatId, extra) {
      return this.callApi("sendDice", { chat_id: chatId, ...extra });
    }
    sendDocument(chatId, document2, extra) {
      return this.callApi("sendDocument", {
        chat_id: chatId,
        document: document2,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendAudio(chatId, audio, extra) {
      return this.callApi("sendAudio", {
        chat_id: chatId,
        audio,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendSticker(chatId, sticker, extra) {
      return this.callApi("sendSticker", { chat_id: chatId, sticker, ...extra });
    }
    sendVideo(chatId, video, extra) {
      return this.callApi("sendVideo", {
        chat_id: chatId,
        video,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendAnimation(chatId, animation, extra) {
      return this.callApi("sendAnimation", {
        chat_id: chatId,
        animation,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendVideoNote(chatId, videoNote, extra) {
      return this.callApi("sendVideoNote", {
        chat_id: chatId,
        video_note: videoNote,
        ...extra
      });
    }
    sendVoice(chatId, voice, extra) {
      return this.callApi("sendVoice", {
        chat_id: chatId,
        voice,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    sendGame(chatId, gameName, extra) {
      return this.callApi("sendGame", {
        chat_id: chatId,
        game_short_name: gameName,
        ...extra
      });
    }
    sendMediaGroup(chatId, media, extra) {
      return this.callApi("sendMediaGroup", { chat_id: chatId, media, ...extra });
    }
    sendPoll(chatId, question, options, extra) {
      return this.callApi("sendPoll", {
        chat_id: chatId,
        type: "regular",
        question,
        options,
        ...extra
      });
    }
    sendQuiz(chatId, question, options, extra) {
      return this.callApi("sendPoll", {
        chat_id: chatId,
        type: "quiz",
        question,
        options,
        ...extra
      });
    }
    stopPoll(chatId, messageId, extra) {
      return this.callApi("stopPoll", {
        chat_id: chatId,
        message_id: messageId,
        ...extra
      });
    }
    getChat(chatId) {
      return this.callApi("getChat", { chat_id: chatId });
    }
    getChatAdministrators(chatId) {
      return this.callApi("getChatAdministrators", { chat_id: chatId });
    }
    getChatMember(chatId, userId) {
      return this.callApi("getChatMember", { chat_id: chatId, user_id: userId });
    }
    getChatMembersCount(chatId) {
      return this.callApi("getChatMembersCount", { chat_id: chatId });
    }
    answerInlineQuery(inlineQueryId, results, extra) {
      return this.callApi("answerInlineQuery", {
        inline_query_id: inlineQueryId,
        results,
        ...extra
      });
    }
    setChatPermissions(chatId, permissions, extra) {
      return this.callApi("setChatPermissions", {
        chat_id: chatId,
        permissions,
        ...extra
      });
    }
    banChatMember(chatId, userId, untilDate, extra) {
      return this.callApi("banChatMember", {
        chat_id: chatId,
        user_id: userId,
        until_date: untilDate,
        ...extra
      });
    }
    get kickChatMember() {
      return this.banChatMember;
    }
    promoteChatMember(chatId, userId, extra) {
      return this.callApi("promoteChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    restrictChatMember(chatId, userId, extra) {
      return this.callApi("restrictChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    setChatAdministratorCustomTitle(chatId, userId, title) {
      return this.callApi("setChatAdministratorCustomTitle", {
        chat_id: chatId,
        user_id: userId,
        custom_title: title
      });
    }
    exportChatInviteLink(chatId) {
      return this.callApi("exportChatInviteLink", { chat_id: chatId });
    }
    createChatInviteLink(chatId, extra) {
      return this.callApi("createChatInviteLink", {
        chat_id: chatId,
        ...extra
      });
    }
    createInvoiceLink(invoice) {
      return this.callApi("createInvoiceLink", {
        ...invoice
      });
    }
    editChatInviteLink(chatId, inviteLink, extra) {
      return this.callApi("editChatInviteLink", {
        chat_id: chatId,
        invite_link: inviteLink,
        ...extra
      });
    }
    revokeChatInviteLink(chatId, inviteLink) {
      return this.callApi("revokeChatInviteLink", {
        chat_id: chatId,
        invite_link: inviteLink
      });
    }
    setChatPhoto(chatId, photo) {
      return this.callApi("setChatPhoto", { chat_id: chatId, photo });
    }
    deleteChatPhoto(chatId) {
      return this.callApi("deleteChatPhoto", { chat_id: chatId });
    }
    setChatTitle(chatId, title) {
      return this.callApi("setChatTitle", { chat_id: chatId, title });
    }
    setChatDescription(chatId, description) {
      return this.callApi("setChatDescription", { chat_id: chatId, description });
    }
    pinChatMessage(chatId, messageId, extra) {
      return this.callApi("pinChatMessage", {
        chat_id: chatId,
        message_id: messageId,
        ...extra
      });
    }
    unpinChatMessage(chatId, messageId) {
      return this.callApi("unpinChatMessage", {
        chat_id: chatId,
        message_id: messageId
      });
    }
    unpinAllChatMessages(chatId) {
      return this.callApi("unpinAllChatMessages", { chat_id: chatId });
    }
    leaveChat(chatId) {
      return this.callApi("leaveChat", { chat_id: chatId });
    }
    unbanChatMember(chatId, userId, extra) {
      return this.callApi("unbanChatMember", {
        chat_id: chatId,
        user_id: userId,
        ...extra
      });
    }
    answerCbQuery(callbackQueryId, text, extra) {
      return this.callApi("answerCallbackQuery", {
        text,
        callback_query_id: callbackQueryId,
        ...extra
      });
    }
    answerGameQuery(callbackQueryId, url) {
      return this.callApi("answerCallbackQuery", {
        url,
        callback_query_id: callbackQueryId
      });
    }
    getUserChatBoosts(chat_id, user_id) {
      return this.callApi("getUserChatBoosts", {
        chat_id,
        user_id
      });
    }
    answerShippingQuery(shippingQueryId, ok, shippingOptions, errorMessage) {
      return this.callApi("answerShippingQuery", {
        ok,
        shipping_query_id: shippingQueryId,
        shipping_options: shippingOptions,
        error_message: errorMessage
      });
    }
    answerPreCheckoutQuery(preCheckoutQueryId, ok, errorMessage) {
      return this.callApi("answerPreCheckoutQuery", {
        ok,
        pre_checkout_query_id: preCheckoutQueryId,
        error_message: errorMessage
      });
    }
    answerWebAppQuery(webAppQueryId, result) {
      return this.callApi("answerWebAppQuery", {
        web_app_query_id: webAppQueryId,
        result
      });
    }
    editMessageText(chatId, messageId, inlineMessageId, text, extra) {
      const t = format_1.FmtString.normalise(text);
      return this.callApi("editMessageText", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra,
        ...t
      });
    }
    editMessageCaption(chatId, messageId, inlineMessageId, caption, extra) {
      return this.callApi("editMessageCaption", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra,
        ...(0, util_1.fmtCaption)({ caption })
      });
    }
    editMessageMedia(chatId, messageId, inlineMessageId, media, extra) {
      return this.callApi("editMessageMedia", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        media: (0, util_1.fmtCaption)(media),
        ...extra
      });
    }
    editMessageReplyMarkup(chatId, messageId, inlineMessageId, markup) {
      return this.callApi("editMessageReplyMarkup", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        reply_markup: markup
      });
    }
    editMessageLiveLocation(chatId, messageId, inlineMessageId, latitude, longitude, extra) {
      return this.callApi("editMessageLiveLocation", {
        latitude,
        longitude,
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        ...extra
      });
    }
    stopMessageLiveLocation(chatId, messageId, inlineMessageId, markup) {
      return this.callApi("stopMessageLiveLocation", {
        chat_id: chatId,
        message_id: messageId,
        inline_message_id: inlineMessageId,
        reply_markup: markup
      });
    }
    deleteMessage(chatId, messageId) {
      return this.callApi("deleteMessage", {
        chat_id: chatId,
        message_id: messageId
      });
    }
    deleteMessages(chatId, messageIds) {
      return this.callApi("deleteMessages", {
        chat_id: chatId,
        message_ids: messageIds
      });
    }
    setChatStickerSet(chatId, setName) {
      return this.callApi("setChatStickerSet", {
        chat_id: chatId,
        sticker_set_name: setName
      });
    }
    deleteChatStickerSet(chatId) {
      return this.callApi("deleteChatStickerSet", { chat_id: chatId });
    }
    getForumTopicIconStickers() {
      return this.callApi("getForumTopicIconStickers", {});
    }
    createForumTopic(chat_id, name, extra) {
      return this.callApi("createForumTopic", {
        chat_id,
        name,
        ...extra
      });
    }
    editForumTopic(chat_id, message_thread_id, extra) {
      return this.callApi("editForumTopic", {
        chat_id,
        message_thread_id,
        ...extra
      });
    }
    closeForumTopic(chat_id, message_thread_id) {
      return this.callApi("closeForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    reopenForumTopic(chat_id, message_thread_id) {
      return this.callApi("reopenForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    deleteForumTopic(chat_id, message_thread_id) {
      return this.callApi("deleteForumTopic", {
        chat_id,
        message_thread_id
      });
    }
    unpinAllForumTopicMessages(chat_id, message_thread_id) {
      return this.callApi("unpinAllForumTopicMessages", {
        chat_id,
        message_thread_id
      });
    }
    editGeneralForumTopic(chat_id, name) {
      return this.callApi("editGeneralForumTopic", { chat_id, name });
    }
    closeGeneralForumTopic(chat_id) {
      return this.callApi("closeGeneralForumTopic", { chat_id });
    }
    reopenGeneralForumTopic(chat_id) {
      return this.callApi("reopenGeneralForumTopic", { chat_id });
    }
    hideGeneralForumTopic(chat_id) {
      return this.callApi("hideGeneralForumTopic", { chat_id });
    }
    unhideGeneralForumTopic(chat_id) {
      return this.callApi("unhideGeneralForumTopic", { chat_id });
    }
    unpinAllGeneralForumTopicMessages(chat_id) {
      return this.callApi("unpinAllGeneralForumTopicMessages", { chat_id });
    }
    getStickerSet(name) {
      return this.callApi("getStickerSet", { name });
    }
    uploadStickerFile(ownerId, sticker, sticker_format) {
      return this.callApi("uploadStickerFile", {
        user_id: ownerId,
        sticker_format,
        sticker
      });
    }
    createNewStickerSet(ownerId, name, title, stickerData) {
      return this.callApi("createNewStickerSet", {
        name,
        title,
        user_id: ownerId,
        ...stickerData
      });
    }
    addStickerToSet(ownerId, name, stickerData) {
      return this.callApi("addStickerToSet", {
        name,
        user_id: ownerId,
        ...stickerData
      });
    }
    setStickerPositionInSet(sticker, position) {
      return this.callApi("setStickerPositionInSet", {
        sticker,
        position
      });
    }
    get setStickerSetThumb() {
      return this.setStickerSetThumbnail;
    }
    setStickerSetThumbnail(name, userId, thumbnail) {
      return this.callApi("setStickerSetThumbnail", {
        name,
        user_id: userId,
        thumbnail
      });
    }
    setStickerMaskPosition(sticker, mask_position) {
      return this.callApi("setStickerMaskPosition", { sticker, mask_position });
    }
    setStickerKeywords(sticker, keywords) {
      return this.callApi("setStickerKeywords", { sticker, keywords });
    }
    setStickerEmojiList(sticker, emoji_list) {
      return this.callApi("setStickerEmojiList", { sticker, emoji_list });
    }
    deleteStickerSet(name) {
      return this.callApi("deleteStickerSet", { name });
    }
    setStickerSetTitle(name, title) {
      return this.callApi("setStickerSetTitle", { name, title });
    }
    setCustomEmojiStickerSetThumbnail(name, custom_emoji_id) {
      return this.callApi("setCustomEmojiStickerSetThumbnail", {
        name,
        custom_emoji_id
      });
    }
    deleteStickerFromSet(sticker) {
      return this.callApi("deleteStickerFromSet", { sticker });
    }
    getCustomEmojiStickers(custom_emoji_ids) {
      return this.callApi("getCustomEmojiStickers", { custom_emoji_ids });
    }
    setMyCommands(commands, extra) {
      return this.callApi("setMyCommands", { commands, ...extra });
    }
    deleteMyCommands(extra = {}) {
      return this.callApi("deleteMyCommands", extra);
    }
    getMyCommands(extra = {}) {
      return this.callApi("getMyCommands", extra);
    }
    setMyDescription(description, language_code) {
      return this.callApi("setMyDescription", { description, language_code });
    }
    setMyName(name, language_code) {
      return this.callApi("setMyName", { name, language_code });
    }
    getMyName(language_code) {
      return this.callApi("getMyName", { language_code });
    }
    getMyDescription(language_code) {
      return this.callApi("getMyDescription", { language_code });
    }
    setMyShortDescription(short_description, language_code) {
      return this.callApi("setMyShortDescription", {
        short_description,
        language_code
      });
    }
    getMyShortDescription(language_code) {
      return this.callApi("getMyShortDescription", { language_code });
    }
    setPassportDataErrors(userId, errors14) {
      return this.callApi("setPassportDataErrors", {
        user_id: userId,
        errors: errors14
      });
    }
    sendCopy(chatId, message, extra) {
      return this.copyMessage(chatId, message.chat.id, message.message_id, extra);
    }
    copyMessage(chatId, fromChatId, messageId, extra) {
      return this.callApi("copyMessage", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_id: messageId,
        ...(0, util_1.fmtCaption)(extra)
      });
    }
    copyMessages(chatId, fromChatId, messageIds, extra) {
      return this.callApi("copyMessages", {
        chat_id: chatId,
        from_chat_id: fromChatId,
        message_ids: messageIds,
        ...extra
      });
    }
    approveChatJoinRequest(chatId, userId) {
      return this.callApi("approveChatJoinRequest", {
        chat_id: chatId,
        user_id: userId
      });
    }
    declineChatJoinRequest(chatId, userId) {
      return this.callApi("declineChatJoinRequest", {
        chat_id: chatId,
        user_id: userId
      });
    }
    banChatSenderChat(chatId, senderChatId, extra) {
      return this.callApi("banChatSenderChat", {
        chat_id: chatId,
        sender_chat_id: senderChatId,
        ...extra
      });
    }
    unbanChatSenderChat(chatId, senderChatId) {
      return this.callApi("unbanChatSenderChat", {
        chat_id: chatId,
        sender_chat_id: senderChatId
      });
    }
    setChatMenuButton({ chatId, menuButton } = {}) {
      return this.callApi("setChatMenuButton", {
        chat_id: chatId,
        menu_button: menuButton
      });
    }
    getChatMenuButton({ chatId } = {}) {
      return this.callApi("getChatMenuButton", {
        chat_id: chatId
      });
    }
    setMyDefaultAdministratorRights({ rights, forChannels } = {}) {
      return this.callApi("setMyDefaultAdministratorRights", {
        rights,
        for_channels: forChannels
      });
    }
    getMyDefaultAdministratorRights({ forChannels } = {}) {
      return this.callApi("getMyDefaultAdministratorRights", {
        for_channels: forChannels
      });
    }
    logOut() {
      return this.callApi("logOut", {});
    }
    close() {
      return this.callApi("close", {});
    }
  }
  exports.Telegram = Telegram;
  exports.default = Telegram;
});

// node_modules/buffer-fill/index.js
var require_buffer_fill = __commonJS((exports, module) => {
  var isSingleByte = function(val) {
    return val.length === 1 && val.charCodeAt(0) < 256;
  };
  var fillWithNumber = function(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) {
      throw new RangeError("Out of range index");
    }
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    if (end > start) {
      buffer.fill(val, start, end);
    }
    return buffer;
  };
  var fillWithBuffer = function(buffer, val, start, end) {
    if (start < 0 || end > buffer.length) {
      throw new RangeError("Out of range index");
    }
    if (end <= start) {
      return buffer;
    }
    start = start >>> 0;
    end = end === undefined ? buffer.length : end >>> 0;
    var pos = start;
    var len = val.length;
    while (pos <= end - len) {
      val.copy(buffer, pos);
      pos += len;
    }
    if (pos !== end) {
      val.copy(buffer, pos, 0, end - pos);
    }
    return buffer;
  };
  var fill = function(buffer, val, start, end, encoding4) {
    if (hasFullSupport) {
      return buffer.fill(val, start, end, encoding4);
    }
    if (typeof val === "number") {
      return fillWithNumber(buffer, val, start, end);
    }
    if (typeof val === "string") {
      if (typeof start === "string") {
        encoding4 = start;
        start = 0;
        end = buffer.length;
      } else if (typeof end === "string") {
        encoding4 = end;
        end = buffer.length;
      }
      if (encoding4 !== undefined && typeof encoding4 !== "string") {
        throw new TypeError("encoding must be a string");
      }
      if (encoding4 === "latin1") {
        encoding4 = "binary";
      }
      if (typeof encoding4 === "string" && !Buffer.isEncoding(encoding4)) {
        throw new TypeError("Unknown encoding: " + encoding4);
      }
      if (val === "") {
        return fillWithNumber(buffer, 0, start, end);
      }
      if (isSingleByte(val)) {
        return fillWithNumber(buffer, val.charCodeAt(0), start, end);
      }
      val = new Buffer(val, encoding4);
    }
    if (Buffer.isBuffer(val)) {
      return fillWithBuffer(buffer, val, start, end);
    }
    return fillWithNumber(buffer, 0, start, end);
  };
  var hasFullSupport = function() {
    try {
      if (!Buffer.isEncoding("latin1")) {
        return false;
      }
      var buf = Buffer.alloc ? Buffer.alloc(4) : new Buffer(4);
      buf.fill("ab", "ucs2");
      return buf.toString("hex") === "61006200";
    } catch (_) {
      return false;
    }
  }();
  module.exports = fill;
});

// node_modules/buffer-alloc-unsafe/index.js
var require_buffer_alloc_unsafe = __commonJS((exports, module) => {
  var allocUnsafe = function(size) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    }
    if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
    if (Buffer.allocUnsafe) {
      return Buffer.allocUnsafe(size);
    } else {
      return new Buffer(size);
    }
  };
  module.exports = allocUnsafe;
});

// node_modules/buffer-alloc/index.js
var require_buffer_alloc = __commonJS((exports, module) => {
  var bufferFill = require_buffer_fill();
  var allocUnsafe = require_buffer_alloc_unsafe();
  module.exports = function alloc(size, fill, encoding4) {
    if (typeof size !== "number") {
      throw new TypeError('"size" argument must be a number');
    }
    if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
    if (Buffer.alloc) {
      return Buffer.alloc(size, fill, encoding4);
    }
    var buffer = allocUnsafe(size);
    if (size === 0) {
      return buffer;
    }
    if (fill === undefined) {
      return bufferFill(buffer, 0);
    }
    if (typeof encoding4 !== "string") {
      encoding4 = undefined;
    }
    return bufferFill(buffer, fill, encoding4);
  };
});

// node_modules/safe-compare/index.js
var require_safe_compare = __commonJS((exports, module) => {
  var crypto29 = import.meta.require("crypto");
  var bufferAlloc = require_buffer_alloc();
  var safeCompare = function safeCompare(a, b2) {
    var strA = String(a);
    var strB = String(b2);
    var lenA = strA.length;
    var result = 0;
    if (lenA !== strB.length) {
      strB = strA;
      result = 1;
    }
    for (var i = 0;i < lenA; i++) {
      result |= strA.charCodeAt(i) ^ strB.charCodeAt(i);
    }
    return result === 0;
  };
  var nativeTimingSafeEqual = function nativeTimingSafeEqual(a, b2) {
    var strA = String(a);
    var strB = String(b2);
    var aLen = Buffer.byteLength(strA);
    var bLen = Buffer.byteLength(strB);
    var bufA = bufferAlloc(aLen, 0, "utf8");
    bufA.write(strA);
    var bufB = bufferAlloc(aLen, 0, "utf8");
    bufB.write(strB);
    return crypto29.timingSafeEqual(bufA, bufB) && aLen === bLen;
  };
  module.exports = typeof crypto29.timingSafeEqual !== "undefined" ? nativeTimingSafeEqual : safeCompare;
});

// node_modules/telegraf/lib/telegraf.js
var require_telegraf = __commonJS((exports) => {
  var always = function(x) {
    return () => x;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod3) {
    if (mod3 && mod3.__esModule)
      return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k in mod3)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
          __createBinding(result, mod3, k);
    }
    __setModuleDefault(result, mod3);
    return result;
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Telegraf = undefined;
  var crypto29 = __importStar(import.meta.require("crypto"));
  var http2 = __importStar(import.meta.require("http"));
  var https2 = __importStar(import.meta.require("https"));
  var composer_1 = require_composer();
  var compact_1 = require_compact();
  var context_1 = __importDefault(require_context());
  var debug_1 = __importDefault(require_src());
  var webhook_1 = __importDefault(require_webhook());
  var polling_1 = require_polling();
  var p_timeout_1 = __importDefault(require_p_timeout());
  var telegram_1 = __importDefault(require_telegram());
  var url_1 = import.meta.require("url");
  var safeCompare = require_safe_compare();
  var debug = (0, debug_1.default)("telegraf:main");
  var DEFAULT_OPTIONS = {
    telegram: {},
    handlerTimeout: 90000,
    contextType: context_1.default
  };
  var anoop = always(Promise.resolve());
  var TOKEN_HEADER = "x-telegram-bot-api-secret-token";

  class Telegraf extends composer_1.Composer {
    constructor(token, options) {
      super();
      this.context = {};
      this.webhookFilter = function(req) {
        const debug2 = (0, debug_1.default)("telegraf:webhook");
        if (req.method === "POST") {
          if (safeCompare(this.path, req.url)) {
            if (!this.secretToken)
              return true;
            else {
              const token2 = req.headers[TOKEN_HEADER];
              if (safeCompare(this.secretToken, token2))
                return true;
              else
                debug2("Secret token does not match:", token2, this.secretToken);
            }
          } else
            debug2("Path does not match:", req.url, this.path);
        } else
          debug2("Unexpected request method, not POST. Received:", req.method);
        return false;
      };
      this.handleError = (err, ctx) => {
        process.exitCode = 1;
        console.error("Unhandled error while processing", ctx.update);
        throw err;
      };
      this.options = {
        ...DEFAULT_OPTIONS,
        ...(0, compact_1.compactOptions)(options)
      };
      this.telegram = new telegram_1.default(token, this.options.telegram);
      debug("Created a `Telegraf` instance");
    }
    get token() {
      return this.telegram.token;
    }
    set webhookReply(webhookReply) {
      this.telegram.webhookReply = webhookReply;
    }
    get webhookReply() {
      return this.telegram.webhookReply;
    }
    catch(handler) {
      this.handleError = handler;
      return this;
    }
    webhookCallback(path = "/", opts = {}) {
      const { secretToken } = opts;
      return (0, webhook_1.default)(this.webhookFilter.bind({ hookPath: path, path, secretToken }), (update, res) => this.handleUpdate(update, res));
    }
    getDomainOpts(opts) {
      var _a4;
      const protocol = opts.domain.startsWith("https://") || opts.domain.startsWith("http://");
      if (protocol)
        debug("Unexpected protocol in domain, telegraf will use https:", opts.domain);
      const domain = protocol ? new url_1.URL(opts.domain).host : opts.domain;
      const path = (_a4 = opts.path) !== null && _a4 !== undefined ? _a4 : `/telegraf/${this.secretPathComponent()}`;
      const url = `https://${domain}${path}`;
      return { domain, path, url };
    }
    async createWebhook(opts) {
      const { domain, path, ...extra } = opts;
      const domainOpts = this.getDomainOpts({ domain, path });
      await this.telegram.setWebhook(domainOpts.url, extra);
      debug(`Webhook set to ${domainOpts.url}`);
      return this.webhookCallback(domainOpts.path, {
        secretToken: extra.secret_token
      });
    }
    startPolling(allowedUpdates = []) {
      this.polling = new polling_1.Polling(this.telegram, allowedUpdates);
      return this.polling.loop(async (update) => {
        await this.handleUpdate(update);
      });
    }
    startWebhook(path, tlsOptions, port, host, cb, secretToken) {
      const webhookCb = this.webhookCallback(path, { secretToken });
      const callback = typeof cb === "function" ? (req, res) => webhookCb(req, res, () => cb(req, res)) : webhookCb;
      this.webhookServer = tlsOptions != null ? https2.createServer(tlsOptions, callback) : http2.createServer(callback);
      this.webhookServer.listen(port, host, () => {
        debug("Webhook listening on port: %s", port);
      });
      return this;
    }
    secretPathComponent() {
      return crypto29.createHash("sha3-256").update(this.token).update(process.version).digest("hex");
    }
    async launch(config5 = {}, onLaunch) {
      var _a4, _b;
      const [cfg, onMe] = typeof config5 === "function" ? [{}, config5] : [config5, onLaunch];
      const drop_pending_updates = cfg.dropPendingUpdates;
      const allowed_updates = cfg.allowedUpdates;
      const webhook = cfg.webhook;
      debug("Connecting to Telegram");
      (_a4 = this.botInfo) !== null && _a4 !== undefined || (this.botInfo = await this.telegram.getMe());
      onMe === null || onMe === undefined || onMe();
      debug(`Launching @${this.botInfo.username}`);
      if (webhook === undefined) {
        await this.telegram.deleteWebhook({ drop_pending_updates });
        debug("Bot started with long polling");
        await this.startPolling(allowed_updates);
        return;
      }
      const domainOpts = this.getDomainOpts({
        domain: webhook.domain,
        path: (_b = webhook.path) !== null && _b !== undefined ? _b : webhook.hookPath
      });
      const { tlsOptions, port, host, cb, secretToken } = webhook;
      this.startWebhook(domainOpts.path, tlsOptions, port, host, cb, secretToken);
      await this.telegram.setWebhook(domainOpts.url, {
        drop_pending_updates,
        allowed_updates,
        ip_address: webhook.ipAddress,
        max_connections: webhook.maxConnections,
        secret_token: webhook.secretToken,
        certificate: webhook.certificate
      });
      debug(`Bot started with webhook @ ${domainOpts.url}`);
    }
    stop(reason = "unspecified") {
      var _a4, _b;
      debug("Stopping bot... Reason:", reason);
      if (this.polling === undefined && this.webhookServer === undefined) {
        throw new Error("Bot is not running!");
      }
      (_a4 = this.webhookServer) === null || _a4 === undefined || _a4.close();
      (_b = this.polling) === null || _b === undefined || _b.stop();
    }
    async handleUpdate(update, webhookResponse) {
      var _a4, _b;
      (_a4 = this.botInfo) !== null && _a4 !== undefined || (this.botInfo = (debug("Update %d is waiting for `botInfo` to be initialized", update.update_id), await ((_b = this.botInfoCall) !== null && _b !== undefined ? _b : this.botInfoCall = this.telegram.getMe())));
      debug("Processing update", update.update_id);
      const tg = new telegram_1.default(this.token, this.telegram.options, webhookResponse);
      const TelegrafContext = this.options.contextType;
      const ctx = new TelegrafContext(update, tg, this.botInfo);
      Object.assign(ctx, this.context);
      try {
        await (0, p_timeout_1.default)(Promise.resolve(this.middleware()(ctx, anoop)), this.options.handlerTimeout);
      } catch (err) {
        return await this.handleError(err, ctx);
      } finally {
        if ((webhookResponse === null || webhookResponse === undefined ? undefined : webhookResponse.writableEnded) === false) {
          webhookResponse.end();
        }
        debug("Finished processing update", update.update_id);
      }
    }
  }
  exports.Telegraf = Telegraf;
});

// node_modules/telegraf/lib/router.js
var require_router = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Router = undefined;
  var composer_1 = __importDefault(require_composer());

  class Router {
    constructor(routeFn, handlers = new Map) {
      this.routeFn = routeFn;
      this.handlers = handlers;
      this.otherwiseHandler = composer_1.default.passThru();
      if (typeof routeFn !== "function") {
        throw new Error("Missing routing function");
      }
    }
    on(route, ...fns) {
      if (fns.length === 0) {
        throw new TypeError("At least one handler must be provided");
      }
      this.handlers.set(route, composer_1.default.compose(fns));
      return this;
    }
    otherwise(...fns) {
      if (fns.length === 0) {
        throw new TypeError("At least one otherwise handler must be provided");
      }
      this.otherwiseHandler = composer_1.default.compose(fns);
      return this;
    }
    middleware() {
      return composer_1.default.lazy((ctx) => {
        var _a4;
        const result = this.routeFn(ctx);
        if (result == null) {
          return this.otherwiseHandler;
        }
        Object.assign(ctx, result.context);
        Object.assign(ctx.state, result.state);
        return (_a4 = this.handlers.get(result.route)) !== null && _a4 !== undefined ? _a4 : this.otherwiseHandler;
      });
    }
  }
  exports.Router = Router;
});

// node_modules/telegraf/lib/button.js
var require_button = __commonJS((exports) => {
  var text = function(text2, hide = false) {
    return { text: text2, hide };
  };
  var contactRequest = function(text2, hide = false) {
    return { text: text2, request_contact: true, hide };
  };
  var locationRequest = function(text2, hide = false) {
    return { text: text2, request_location: true, hide };
  };
  var pollRequest = function(text2, type, hide = false) {
    return { text: text2, request_poll: { type }, hide };
  };
  var userRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_users: { request_id, ...extra },
      hide
    };
  };
  var botRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_users: { request_id, user_is_bot: true, ...extra },
      hide
    };
  };
  var groupRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_chat: { request_id, chat_is_channel: false, ...extra },
      hide
    };
  };
  var channelRequest = function(text2, request_id, extra, hide = false) {
    return {
      text: text2,
      request_chat: { request_id, chat_is_channel: true, ...extra },
      hide
    };
  };
  var url = function(text2, url2, hide = false) {
    return { text: text2, url: url2, hide };
  };
  var callback = function(text2, data15, hide = false) {
    return { text: text2, callback_data: data15, hide };
  };
  var switchToChat = function(text2, value, hide = false) {
    return { text: text2, switch_inline_query: value, hide };
  };
  var switchToCurrentChat = function(text2, value, hide = false) {
    return { text: text2, switch_inline_query_current_chat: value, hide };
  };
  var game = function(text2, hide = false) {
    return { text: text2, callback_game: {}, hide };
  };
  var pay = function(text2, hide = false) {
    return { text: text2, pay: true, hide };
  };
  var login = function(text2, url2, opts = {}, hide = false) {
    return {
      text: text2,
      login_url: { ...opts, url: url2 },
      hide
    };
  };
  var webApp = function(text2, url2, hide = false) {
    return {
      text: text2,
      web_app: { url: url2 },
      hide
    };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.webApp = exports.login = exports.pay = exports.game = exports.switchToCurrentChat = exports.switchToChat = exports.callback = exports.url = exports.channelRequest = exports.groupRequest = exports.botRequest = exports.userRequest = exports.pollRequest = exports.locationRequest = exports.contactRequest = exports.text = undefined;
  exports.text = text;
  exports.contactRequest = contactRequest;
  exports.locationRequest = locationRequest;
  exports.pollRequest = pollRequest;
  exports.userRequest = userRequest;
  exports.botRequest = botRequest;
  exports.groupRequest = groupRequest;
  exports.channelRequest = channelRequest;
  exports.url = url;
  exports.callback = callback;
  exports.switchToChat = switchToChat;
  exports.switchToCurrentChat = switchToCurrentChat;
  exports.game = game;
  exports.pay = pay;
  exports.login = login;
  exports.webApp = webApp;
});

// node_modules/telegraf/lib/markup.js
var require_markup = __commonJS((exports) => {
  var removeKeyboard = function() {
    return new Markup({ remove_keyboard: true });
  };
  var forceReply = function() {
    return new Markup({ force_reply: true });
  };
  var keyboard = function(buttons, options) {
    const keyboard2 = buildKeyboard(buttons, {
      columns: 1,
      ...options
    });
    return new Markup({ keyboard: keyboard2 });
  };
  var inlineKeyboard = function(buttons, options) {
    const inlineKeyboard2 = buildKeyboard(buttons, {
      columns: buttons.length,
      ...options
    });
    return new Markup({ inline_keyboard: inlineKeyboard2 });
  };
  var buildKeyboard = function(buttons, options) {
    const result = [];
    if (!Array.isArray(buttons)) {
      return result;
    }
    if ((0, check_1.is2D)(buttons)) {
      return buttons.map((row) => row.filter((button) => !button.hide));
    }
    const wrapFn = options.wrap !== undefined ? options.wrap : (_btn, _index, currentRow2) => currentRow2.length >= options.columns;
    let currentRow = [];
    let index = 0;
    for (const btn of buttons.filter((button) => !button.hide)) {
      if (wrapFn(btn, index, currentRow) && currentRow.length > 0) {
        result.push(currentRow);
        currentRow = [];
      }
      currentRow.push(btn);
      index++;
    }
    if (currentRow.length > 0) {
      result.push(currentRow);
    }
    return result;
  };
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod3) {
    if (mod3 && mod3.__esModule)
      return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k in mod3)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
          __createBinding(result, mod3, k);
    }
    __setModuleDefault(result, mod3);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.inlineKeyboard = exports.keyboard = exports.forceReply = exports.removeKeyboard = exports.button = exports.Markup = undefined;
  var check_1 = require_check();

  class Markup {
    constructor(reply_markup) {
      this.reply_markup = reply_markup;
    }
    selective(value = true) {
      return new Markup({ ...this.reply_markup, selective: value });
    }
    placeholder(placeholder) {
      return new Markup({
        ...this.reply_markup,
        input_field_placeholder: placeholder
      });
    }
    resize(value = true) {
      return new Markup({
        ...this.reply_markup,
        resize_keyboard: value
      });
    }
    oneTime(value = true) {
      return new Markup({
        ...this.reply_markup,
        one_time_keyboard: value
      });
    }
    persistent(value = true) {
      return new Markup({
        ...this.reply_markup,
        is_persistent: value
      });
    }
  }
  exports.Markup = Markup;
  exports.button = __importStar(require_button());
  exports.removeKeyboard = removeKeyboard;
  exports.forceReply = forceReply;
  exports.keyboard = keyboard;
  exports.inlineKeyboard = inlineKeyboard;
});

// node_modules/telegraf/lib/telegram-types.js
var require_telegram_types = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Markup = undefined;
  var markup_1 = require_markup();
  Object.defineProperty(exports, "Markup", { enumerable: true, get: function() {
    return markup_1.Markup;
  } });
});

// node_modules/telegraf/lib/input.js
var require_input = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.fromFileId = exports.fromURL = exports.fromURLStream = exports.fromReadableStream = exports.fromBuffer = exports.fromLocalFile = undefined;
  var fromLocalFile = (path, filename) => ({ source: path, filename });
  exports.fromLocalFile = fromLocalFile;
  var fromBuffer = (buffer, filename) => ({ source: buffer, filename });
  exports.fromBuffer = fromBuffer;
  var fromReadableStream = (stream, filename) => ({ source: stream, filename });
  exports.fromReadableStream = fromReadableStream;
  var fromURLStream = (url, filename) => ({ url: url.toString(), filename });
  exports.fromURLStream = fromURLStream;
  var fromURL = (url) => url.toString();
  exports.fromURL = fromURL;
  var fromFileId = (fileId) => fileId;
  exports.fromFileId = fromFileId;
});

// node_modules/telegraf/lib/core/helpers/deunionize.js
var require_deunionize = __commonJS((exports) => {
  var deunionize = function(t) {
    return t;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.deunionize = undefined;
  exports.deunionize = deunionize;
});

// node_modules/telegraf/lib/session.js
var require_session = __commonJS((exports) => {
  var session = function(options) {
    var _a4, _b, _c;
    const prop = (_a4 = options === null || options === undefined ? undefined : options.property) !== null && _a4 !== undefined ? _a4 : "session";
    const getSessionKey = (_b = options === null || options === undefined ? undefined : options.getSessionKey) !== null && _b !== undefined ? _b : defaultGetSessionKey;
    const store = (_c = options === null || options === undefined ? undefined : options.store) !== null && _c !== undefined ? _c : new MemorySessionStore;
    const cache = new Map;
    const concurrents = new Map;
    return async (ctx, next) => {
      var _a5;
      const updId = ctx.update.update_id;
      let released = false;
      function releaseChecks() {
        if (released && process.env.EXPERIMENTAL_SESSION_CHECKS)
          throw new Error("Session was accessed or assigned to after the middleware chain exhausted. This is a bug in your code. You're probably accessing session asynchronously and missing awaits.");
      }
      const key = await getSessionKey(ctx);
      if (!key) {
        ctx[prop] = undefined;
        return await next();
      }
      let cached = cache.get(key);
      if (cached) {
        debug(`(${updId}) found cached session, reusing from cache`);
        ++cached.counter;
      } else {
        debug(`(${updId}) did not find cached session`);
        let promise = concurrents.get(key);
        if (promise)
          debug(`(${updId}) found a concurrent request, reusing promise`);
        else {
          debug(`(${updId}) fetching from upstream store`);
          promise = store.get(key);
        }
        concurrents.set(key, promise);
        const upstream = await promise;
        concurrents.delete(key);
        debug(`(${updId}) updating cache`);
        const c2 = cache.get(key);
        if (c2) {
          c2.counter++;
          cached = c2;
        } else {
          cached = { ref: upstream !== null && upstream !== undefined ? upstream : (_a5 = options === null || options === undefined ? undefined : options.defaultSession) === null || _a5 === undefined ? undefined : _a5.call(options, ctx), counter: 1 };
          cache.set(key, cached);
        }
      }
      const c = cached;
      let touched = false;
      Object.defineProperty(ctx, prop, {
        get() {
          releaseChecks();
          touched = true;
          return c.ref;
        },
        set(value) {
          releaseChecks();
          touched = true;
          c.ref = value;
        }
      });
      try {
        await next();
        released = true;
      } finally {
        if (--c.counter === 0) {
          debug(`(${updId}) refcounter reached 0, removing cached`);
          cache.delete(key);
        }
        debug(`(${updId}) middlewares completed, checking session`);
        if (touched)
          if (c.ref == null) {
            debug(`(${updId}) ctx.${prop} missing, removing from store`);
            await store.delete(key);
          } else {
            debug(`(${updId}) ctx.${prop} found, updating store`);
            await store.set(key, c.ref);
          }
      }
    };
  };
  var defaultGetSessionKey = function(ctx) {
    var _a4, _b;
    const fromId = (_a4 = ctx.from) === null || _a4 === undefined ? undefined : _a4.id;
    const chatId = (_b = ctx.chat) === null || _b === undefined ? undefined : _b.id;
    if (fromId == null || chatId == null)
      return;
    return `${fromId}:${chatId}`;
  };
  var isSessionContext = function(ctx) {
    return "session" in ctx;
  };
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.isSessionContext = exports.MemorySessionStore = exports.session = undefined;
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:session");
  exports.session = session;

  class MemorySessionStore {
    constructor(ttl = Infinity) {
      this.ttl = ttl;
      this.store = new Map;
    }
    get(name) {
      const entry = this.store.get(name);
      if (entry == null) {
        return;
      } else if (entry.expires < Date.now()) {
        this.delete(name);
        return;
      }
      return entry.session;
    }
    set(name, value) {
      const now = Date.now();
      this.store.set(name, { session: value, expires: now + this.ttl });
    }
    delete(name) {
      this.store.delete(name);
    }
  }
  exports.MemorySessionStore = MemorySessionStore;
  exports.isSessionContext = isSessionContext;
});

// node_modules/telegraf/lib/scenes/context.js
var require_context2 = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  var composer_1 = __importDefault(require_composer());
  var debug_1 = __importDefault(require_src());
  var debug = (0, debug_1.default)("telegraf:scenes:context");
  var noop = () => Promise.resolve();
  var now = () => Math.floor(Date.now() / 1000);

  class SceneContextScene {
    constructor(ctx, scenes, options) {
      this.ctx = ctx;
      this.scenes = scenes;
      this.leaving = false;
      const fallbackSessionDefault = {};
      this.options = { defaultSession: fallbackSessionDefault, ...options };
    }
    get session() {
      var _a4, _b;
      const defaultSession = Object.assign({}, this.options.defaultSession);
      let session = (_b = (_a4 = this.ctx.session) === null || _a4 === undefined ? undefined : _a4.__scenes) !== null && _b !== undefined ? _b : defaultSession;
      if (session.expires !== undefined && session.expires < now()) {
        session = defaultSession;
      }
      if (this.ctx.session === undefined) {
        this.ctx.session = { __scenes: session };
      } else {
        this.ctx.session.__scenes = session;
      }
      return session;
    }
    get state() {
      var _a4;
      var _b;
      return (_a4 = (_b = this.session).state) !== null && _a4 !== undefined ? _a4 : _b.state = {};
    }
    set state(value) {
      this.session.state = { ...value };
    }
    get current() {
      var _a4;
      const sceneId = (_a4 = this.session.current) !== null && _a4 !== undefined ? _a4 : this.options.default;
      return sceneId === undefined || !this.scenes.has(sceneId) ? undefined : this.scenes.get(sceneId);
    }
    reset() {
      if (this.ctx.session !== undefined)
        this.ctx.session.__scenes = Object.assign({}, this.options.defaultSession);
    }
    async enter(sceneId, initialState = {}, silent = false) {
      var _a4, _b;
      if (!this.scenes.has(sceneId)) {
        throw new Error(`Can't find scene: ${sceneId}`);
      }
      if (!silent) {
        await this.leave();
      }
      debug("Entering scene", sceneId, initialState, silent);
      this.session.current = sceneId;
      this.state = initialState;
      const ttl = (_b = (_a4 = this.current) === null || _a4 === undefined ? undefined : _a4.ttl) !== null && _b !== undefined ? _b : this.options.ttl;
      if (ttl !== undefined) {
        this.session.expires = now() + ttl;
      }
      if (this.current === undefined || silent) {
        return;
      }
      const handler = "enterMiddleware" in this.current && typeof this.current.enterMiddleware === "function" ? this.current.enterMiddleware() : this.current.middleware();
      return await handler(this.ctx, noop);
    }
    reenter() {
      return this.session.current === undefined ? undefined : this.enter(this.session.current, this.state);
    }
    async leave() {
      if (this.leaving)
        return;
      debug("Leaving scene");
      try {
        this.leaving = true;
        if (this.current === undefined) {
          return;
        }
        const handler = "leaveMiddleware" in this.current && typeof this.current.leaveMiddleware === "function" ? this.current.leaveMiddleware() : composer_1.default.passThru();
        await handler(this.ctx, noop);
        return this.reset();
      } finally {
        this.leaving = false;
      }
    }
  }
  exports.default = SceneContextScene;
});

// node_modules/telegraf/lib/scenes/stage.js
var require_stage = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Stage = undefined;
  var session_1 = require_session();
  var context_1 = __importDefault(require_context2());
  var composer_1 = require_composer();

  class Stage extends composer_1.Composer {
    constructor(scenes = [], options) {
      super();
      this.options = { ...options };
      this.scenes = new Map;
      scenes.forEach((scene) => this.register(scene));
    }
    register(...scenes) {
      scenes.forEach((scene) => {
        if ((scene === null || scene === undefined ? undefined : scene.id) == null || typeof scene.middleware !== "function") {
          throw new Error("telegraf: Unsupported scene");
        }
        this.scenes.set(scene.id, scene);
      });
      return this;
    }
    middleware() {
      const handler = composer_1.Composer.compose([
        (ctx, next) => {
          const scenes = this.scenes;
          const scene = new context_1.default(ctx, scenes, this.options);
          ctx.scene = scene;
          return next();
        },
        super.middleware(),
        composer_1.Composer.lazy((ctx) => {
          var _a4;
          return (_a4 = ctx.scene.current) !== null && _a4 !== undefined ? _a4 : composer_1.Composer.passThru();
        })
      ]);
      return composer_1.Composer.optional(session_1.isSessionContext, handler);
    }
    static enter(...args) {
      return (ctx) => ctx.scene.enter(...args);
    }
    static reenter(...args) {
      return (ctx) => ctx.scene.reenter(...args);
    }
    static leave(...args) {
      return (ctx) => ctx.scene.leave(...args);
    }
  }
  exports.Stage = Stage;
});

// node_modules/telegraf/lib/scenes/base.js
var require_base = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.BaseScene = undefined;
  var composer_1 = __importDefault(require_composer());
  var { compose } = composer_1.default;

  class BaseScene extends composer_1.default {
    constructor(id3, options) {
      const opts = {
        handlers: [],
        enterHandlers: [],
        leaveHandlers: [],
        ...options
      };
      super(...opts.handlers);
      this.id = id3;
      this.ttl = opts.ttl;
      this.enterHandler = compose(opts.enterHandlers);
      this.leaveHandler = compose(opts.leaveHandlers);
    }
    enter(...fns) {
      this.enterHandler = compose([this.enterHandler, ...fns]);
      return this;
    }
    leave(...fns) {
      this.leaveHandler = compose([this.leaveHandler, ...fns]);
      return this;
    }
    enterMiddleware() {
      return this.enterHandler;
    }
    leaveMiddleware() {
      return this.leaveHandler;
    }
  }
  exports.BaseScene = BaseScene;
  exports.default = BaseScene;
});

// node_modules/telegraf/lib/scenes/wizard/context.js
var require_context3 = __commonJS((exports) => {
  Object.defineProperty(exports, "__esModule", { value: true });

  class WizardContextWizard {
    constructor(ctx, steps) {
      var _a4;
      this.ctx = ctx;
      this.steps = steps;
      this.state = ctx.scene.state;
      this.cursor = (_a4 = ctx.scene.session.cursor) !== null && _a4 !== undefined ? _a4 : 0;
    }
    get step() {
      return this.steps[this.cursor];
    }
    get cursor() {
      return this.ctx.scene.session.cursor;
    }
    set cursor(cursor) {
      this.ctx.scene.session.cursor = cursor;
    }
    selectStep(index) {
      this.cursor = index;
      return this;
    }
    next() {
      return this.selectStep(this.cursor + 1);
    }
    back() {
      return this.selectStep(this.cursor - 1);
    }
  }
  exports.default = WizardContextWizard;
});

// node_modules/telegraf/lib/scenes/wizard/index.js
var require_wizard = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WizardScene = undefined;
  var base_1 = __importDefault(require_base());
  var context_1 = __importDefault(require_context3());
  var composer_1 = __importDefault(require_composer());

  class WizardScene extends base_1.default {
    constructor(id3, options, ...steps) {
      let opts;
      let s;
      if (typeof options === "function" || "middleware" in options) {
        opts = undefined;
        s = [options, ...steps];
      } else {
        opts = options;
        s = steps;
      }
      super(id3, opts);
      this.steps = s;
    }
    middleware() {
      return composer_1.default.compose([
        (ctx, next) => {
          ctx.wizard = new context_1.default(ctx, this.steps);
          return next();
        },
        super.middleware(),
        (ctx, next) => {
          if (ctx.wizard.step === undefined) {
            ctx.wizard.selectStep(0);
            return ctx.scene.leave();
          }
          return composer_1.default.unwrap(ctx.wizard.step)(ctx, next);
        }
      ]);
    }
    enterMiddleware() {
      return composer_1.default.compose([this.enterHandler, this.middleware()]);
    }
  }
  exports.WizardScene = WizardScene;
});

// node_modules/telegraf/lib/scenes/index.js
var require_scenes = __commonJS((exports) => {
  var __importDefault = exports && exports.__importDefault || function(mod3) {
    return mod3 && mod3.__esModule ? mod3 : { default: mod3 };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.WizardContextWizard = exports.WizardScene = exports.BaseScene = exports.SceneContextScene = exports.Stage = undefined;
  var stage_1 = require_stage();
  Object.defineProperty(exports, "Stage", { enumerable: true, get: function() {
    return stage_1.Stage;
  } });
  var context_1 = require_context2();
  Object.defineProperty(exports, "SceneContextScene", { enumerable: true, get: function() {
    return __importDefault(context_1).default;
  } });
  var base_1 = require_base();
  Object.defineProperty(exports, "BaseScene", { enumerable: true, get: function() {
    return base_1.BaseScene;
  } });
  var wizard_1 = require_wizard();
  Object.defineProperty(exports, "WizardScene", { enumerable: true, get: function() {
    return wizard_1.WizardScene;
  } });
  var context_2 = require_context3();
  Object.defineProperty(exports, "WizardContextWizard", { enumerable: true, get: function() {
    return __importDefault(context_2).default;
  } });
});

// node_modules/telegraf/lib/scenes.js
var require_scenes2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __exportStar = exports && exports.__exportStar || function(m, exports2) {
    for (var p in m)
      if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p))
        __createBinding(exports2, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require_scenes(), exports);
});

// node_modules/telegraf/lib/index.js
var require_lib2 = __commonJS((exports) => {
  var __createBinding = exports && exports.__createBinding || (Object.create ? function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() {
        return m[k];
      } };
    }
    Object.defineProperty(o, k2, desc);
  } : function(o, m, k, k2) {
    if (k2 === undefined)
      k2 = k;
    o[k2] = m[k];
  });
  var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
  } : function(o, v) {
    o["default"] = v;
  });
  var __importStar = exports && exports.__importStar || function(mod3) {
    if (mod3 && mod3.__esModule)
      return mod3;
    var result = {};
    if (mod3 != null) {
      for (var k in mod3)
        if (k !== "default" && Object.prototype.hasOwnProperty.call(mod3, k))
          __createBinding(result, mod3, k);
    }
    __setModuleDefault(result, mod3);
    return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Scenes = exports.MemorySessionStore = exports.session = exports.deunionize = exports.Format = exports.Input = exports.Markup = exports.Types = exports.Telegram = exports.TelegramError = exports.Router = exports.Composer = exports.Context = exports.Telegraf = undefined;
  var telegraf_1 = require_telegraf();
  Object.defineProperty(exports, "Telegraf", { enumerable: true, get: function() {
    return telegraf_1.Telegraf;
  } });
  var context_1 = require_context();
  Object.defineProperty(exports, "Context", { enumerable: true, get: function() {
    return context_1.Context;
  } });
  var composer_1 = require_composer();
  Object.defineProperty(exports, "Composer", { enumerable: true, get: function() {
    return composer_1.Composer;
  } });
  var router_1 = require_router();
  Object.defineProperty(exports, "Router", { enumerable: true, get: function() {
    return router_1.Router;
  } });
  var error_1 = require_error();
  Object.defineProperty(exports, "TelegramError", { enumerable: true, get: function() {
    return error_1.TelegramError;
  } });
  var telegram_1 = require_telegram();
  Object.defineProperty(exports, "Telegram", { enumerable: true, get: function() {
    return telegram_1.Telegram;
  } });
  exports.Types = __importStar(require_telegram_types());
  exports.Markup = __importStar(require_markup());
  exports.Input = __importStar(require_input());
  exports.Format = __importStar(require_format());
  var deunionize_1 = require_deunionize();
  Object.defineProperty(exports, "deunionize", { enumerable: true, get: function() {
    return deunionize_1.deunionize;
  } });
  var session_1 = require_session();
  Object.defineProperty(exports, "session", { enumerable: true, get: function() {
    return session_1.session;
  } });
  Object.defineProperty(exports, "MemorySessionStore", { enumerable: true, get: function() {
    return session_1.MemorySessionStore;
  } });
  exports.Scenes = __importStar(require_scenes2());
});

// packages/compound-v2-liquidator/src/cache/cache.service.ts
var import_ioredis = __toESM(require_built3(), 1);

// common/helpers/delay.ts
async function delay(timeout = 1000) {
  return new Promise((resolve) => setTimeout(resolve, timeout));
}

// common/helpers/addRetries.ts
var addRetries = async (someFunction, ...args) => {
  for (let retries = 15;retries > 0; retries--) {
    try {
      return await someFunction(...args.filter(Boolean));
    } catch (e) {
      console.error(e, `arguments: ${JSON.stringify(args)}`);
      console.warn(`retrying function -> ${someFunction.name}`);
      await delay();
    }
  }
  throw new Error(`Failed to execute function -> ${someFunction.name}`);
};

// common/helpers/replacer.ts
var replacer_default = (key, value) => {
  if (value instanceof Map) {
    return Array.from(value);
  }
  if (typeof value === "bigint") {
    return value + "n";
  }
  if (value instanceof Set) {
    return Array.from(value);
  }
  return value;
};

// common/types/enums.ts
var ProtocolType;
(function(ProtocolType2) {
  ProtocolType2["COMPOUND_V2"] = "compound_v2";
  ProtocolType2["TEST_V1"] = "test_v1";
  ProtocolType2["TEST_V2"] = "test_v2";
})(ProtocolType || (ProtocolType = {}));
var NetworkNameType;
(function(NetworkNameType2) {
  NetworkNameType2["ETH"] = "eth";
})(NetworkNameType || (NetworkNameType = {}));
var NetworkType;
(function(NetworkType2) {
  NetworkType2["MAINNET"] = "mainnet";
  NetworkType2["SEPOLIA"] = "sepolia";
  NetworkType2["ROPSTEN"] = "ropsten";
  NetworkType2["KOVAN"] = "kovan";
  NetworkType2["RINKEBY"] = "rinkeby";
  NetworkType2["GOERLI"] = "goerli";
  NetworkType2["LOCAL"] = "local";
})(NetworkType || (NetworkType = {}));

// common/env-common.ts
class EnvCommon {
  NETWORK;
  NETWORK_NAME;
  PROTOCOL;
  HTTPS_RPC_URL;
  WSS_RPC_URL;
  constructor() {
    this.NETWORK = process.env.NETWORK;
    this.NETWORK_NAME = process.env.NETWORK_NAME;
    this.HTTPS_RPC_URL = process.env.HTTPS_RPC_URL;
    this.WSS_RPC_URL = process.env.WSS_RPC_URL;
    this.PROTOCOL = process.env.PROTOCOL;
    this.validateCommon();
  }
  validateCommon() {
    if (!this.HTTPS_RPC_URL) {
      throw new Error("Wrong HTTPS_RPC_URL env variable");
    }
    if (!this.WSS_RPC_URL) {
      throw new Error("Wrong WSS_RPC_URL env variable");
    }
    if (!this.NETWORK || !Object.values(NetworkType).some((v) => v === this.NETWORK)) {
      throw new Error("Wrong NETWORK env variable");
    }
    if (!this.NETWORK_NAME || !Object.values(NetworkNameType).some((v) => v === this.NETWORK_NAME)) {
      throw new Error("Wrong NETWORK_NAME env variable");
    }
    if (!this.PROTOCOL || !Object.values(ProtocolType).some((v) => v === this.PROTOCOL)) {
      throw new Error("Wrong PROTOCOL env variable");
    }
  }
}

// packages/compound-v2-liquidator/utils/constants/env.ts
class Env extends EnvCommon {
  COMPTROLLER_PROXY_ADDRESS;
  PRICE_ORACLE_ADDRESS;
  SHOULD_FETCH_EXCHANGE_RATES;
  NORMAL_PRICE_ORACLE_START_BLOCK;
  BLOCK_FILTER_BATCH;
  UNITROLLER_DEPLOYMENT_BLOCK;
  LIQUIDATOR_CONTRACT_ADDRESS;
  BLOXROUTE_WS_URL;
  BLOXROUTE_HTTPS_URL;
  BLOXROUTE_AUTH_HEADER;
  FROM_ADDRESS;
  PRIVATE_KEY;
  FLASHBOTS_HTTPS_URL;
  MINIMUM_LIQUIDATION_VALUE;
  TG_BOT_TOKEN;
  CHAT_ID;
  constructor() {
    super();
    this.COMPTROLLER_PROXY_ADDRESS = process.env.COMPTROLLER_PROXY_ADDRESS;
    this.PRICE_ORACLE_ADDRESS = process.env.PRICE_ORACLE_ADDRESS;
    this.SHOULD_FETCH_EXCHANGE_RATES = process.env.SHOULD_FETCH_EXCHANGE_RATES === "true";
    this.NORMAL_PRICE_ORACLE_START_BLOCK = parseInt(process.env.NORMAL_PRICE_ORACLE_START_BLOCK);
    this.BLOCK_FILTER_BATCH = parseInt(process.env.BLOCK_FILTER_BATCH);
    this.UNITROLLER_DEPLOYMENT_BLOCK = parseInt(process.env.UNITROLLER_DEPLOYMENT_BLOCK);
    this.LIQUIDATOR_CONTRACT_ADDRESS = process.env.LIQUIDATOR_CONTRACT_ADDRESS;
    this.BLOXROUTE_WS_URL = process.env.BLOXROUTE_WS_URL;
    this.BLOXROUTE_HTTPS_URL = process.env.BLOXROUTE_HTTPS_URL;
    this.BLOXROUTE_AUTH_HEADER = process.env.BLOXROUTE_AUTH_HEADER;
    this.FROM_ADDRESS = process.env.FROM_ADDRESS;
    this.PRIVATE_KEY = process.env.PRIVATE_KEY;
    this.FLASHBOTS_HTTPS_URL = process.env.FLASHBOTS_HTTPS_URL;
    this.MINIMUM_LIQUIDATION_VALUE = Number(process.env.MINIMUM_LIQUIDATION_VALUE);
    this.TG_BOT_TOKEN = process.env.TG_BOT_TOKEN;
    this.CHAT_ID = process.env.CHAT_ID;
    this.validate();
  }
  validate() {
    if (!this.COMPTROLLER_PROXY_ADDRESS || !this.COMPTROLLER_PROXY_ADDRESS.startsWith("0x")) {
      throw new Error("Wrong COMPTROLLER_PROXY_ADDRESS env variable");
    }
    if (!this.PRICE_ORACLE_ADDRESS || !this.PRICE_ORACLE_ADDRESS.startsWith("0x")) {
      throw new Error("Wrong PRICE_ORACLE_ADDRESS env variable");
    }
    if (isNaN(this.NORMAL_PRICE_ORACLE_START_BLOCK)) {
      throw new Error("Wrong NORMAL_PRICE_ORACLE_START_BLOCK env variable");
    }
    if (isNaN(this.BLOCK_FILTER_BATCH)) {
      throw new Error("Wrong BLOCK_FILTER_BATCH env variable");
    }
    if (isNaN(this.UNITROLLER_DEPLOYMENT_BLOCK)) {
      throw new Error("Wrong UNITROLLER_DEPLOYMENT_BLOCK env variable");
    }
    if (!this.LIQUIDATOR_CONTRACT_ADDRESS || !this.LIQUIDATOR_CONTRACT_ADDRESS.startsWith("0x")) {
      throw new Error("Wrong LIQUIDATOR_CONTRACT_ADDRESS env variable");
    }
    if (!this.BLOXROUTE_WS_URL) {
      throw new Error("Wrong BLOXROUTE_WS_URL env variable");
    }
    if (!this.BLOXROUTE_HTTPS_URL) {
      throw new Error("Wrong BLOXROUTE_HTTPS_URL env variable");
    }
    if (!this.BLOXROUTE_AUTH_HEADER) {
      throw new Error("Wrong BLOXROUTE_AUTH_HEADER env variable");
    }
    if (!this.FROM_ADDRESS) {
      throw new Error("Wrong FROM_ADDRESS env variable");
    }
    if (!this.PRIVATE_KEY) {
      throw new Error("Wrong PRIVATE_KEY env variable");
    }
    if (!this.FLASHBOTS_HTTPS_URL) {
      throw new Error("Wrong FLASHBOTS_HTTPS_URL env variable");
    }
    if (isNaN(this.MINIMUM_LIQUIDATION_VALUE)) {
      throw new Error("Wrong MINIMUN_LIQUIDATION_VALUE env variable");
    }
    if (!this.TG_BOT_TOKEN) {
      throw new Error("Wrong TG_BOT_TOKEN env variable");
    }
    if (!this.CHAT_ID) {
      throw new Error("Wrong CHAT_ID env variable");
    }
  }
}
var env_default = new Env;

// common/helpers/reviver.ts
function reviver(key, value) {
  if (Array.isArray(value) && Array.isArray(value[0])) {
    return new Map(value);
  }
  if (typeof value === "string") {
    const bigintMatch = value.match(/^(-?\d+)n$/);
    if (bigintMatch) {
      return BigInt(bigintMatch[1]);
    }
  }
  if (key === "allMarkets" || key === "accounts") {
    return new Set(value);
  }
  return value;
}

// packages/compound-v2-liquidator/src/cache/cache.service.ts
class CacheService {
  redis = new import_ioredis.default;
  prefix = [
    `${env_default.NETWORK}`,
    `${env_default.NETWORK_NAME}`,
    `${env_default.PROTOCOL}`
  ].join(":");
  constructor() {
  }
  init() {
  }
  async set(key, value) {
    const normalizedKey = `${this.prefix}:${key}`;
    await this.redis.set(normalizedKey, JSON.stringify(value, replacer_default, 2));
  }
  async get(key) {
    const normalizedKey = `${this.prefix}:${key}`;
    const method = this.redis.get.bind(this.redis);
    const value = await addRetries(method, normalizedKey);
    return JSON.parse(value, reviver);
  }
  async setEntries(entries) {
    const pipeline = this.redis.pipeline();
    entries.forEach(([key, value]) => {
      const normalizedKey = `${this.prefix}:${key}`;
      pipeline.set(normalizedKey, JSON.stringify(value, replacer_default, 2));
    });
    try {
      const result = await pipeline.exec();
      if (!result || result.some(([error]) => error)) {
        throw new Error("Failed to set entries.\n" + JSON.stringify(result));
      }
    } catch (error) {
      console.error(error);
      await delay(1000);
      await this.setEntries(entries);
    }
  }
  async getValues(keys) {
    console.debug("method -> cacheService.getValues");
    const pipeline = this.redis.pipeline();
    for (const key of keys) {
      pipeline.get(key);
    }
    let values = [];
    await pipeline.exec((err, results) => {
      if (err) {
        console.error(err);
        return;
      }
      if (!results) {
        return {};
      }
      values = results.map(([error, value]) => {
        return error || !value ? undefined : JSON.parse(value);
      });
    });
    return values;
  }
  async delete(key) {
    const normalizedKey = `${this.prefix}:${key}`;
    await this.redis.del(normalizedKey);
  }
  async cacheClear() {
    await this.delete("accounts");
    await this.delete("markets");
    await this.delete("comptroller");
    await this.delete("pointerHeight");
    await this.delete("tokenConfigs");
  }
}

// packages/compound-v2-liquidator/utils/classes/module.class.ts
class Module {
  services = {};
  imports = {};
  registerService(serviceName, service) {
    this.services[serviceName] = service;
  }
  getService(serviceName) {
    const service = this.services[serviceName];
    if (!service)
      throw new Error(`Service ${serviceName} not found`);
    return service;
  }
}

// packages/compound-v2-liquidator/src/cache/cache.module.ts
class CacheModule extends Module {
  constructor() {
    super();
    const cacheService = new CacheService;
    this.registerService("cacheService", cacheService);
  }
}

// packages/compound-v2-liquidator/utils/classes/service.ts
class Service {
  constructor() {
  }
}

// packages/compound-v2-liquidator/src/price-oracle/price-oracle.constants.ts
var PriceOracleEventName;
(function(PriceOracleEventName2) {
  PriceOracleEventName2["PriceUpdated"] = "PriceUpdated";
  PriceOracleEventName2["PriceGuarded"] = "PriceGuarded";
  PriceOracleEventName2["FailoverActivated"] = "FailoverActivated";
  PriceOracleEventName2["FailoverDeactivated"] = "FailoverDeactivated";
  PriceOracleEventName2["PricePosted"] = "PricePosted";
})(PriceOracleEventName || (PriceOracleEventName = {}));
var PriceSource;
(function(PriceSource2) {
  PriceSource2[PriceSource2["FIXED_ETH"] = 0] = "FIXED_ETH";
  PriceSource2[PriceSource2["FIXED_USD"] = 1] = "FIXED_USD";
  PriceSource2[PriceSource2["REPORTER"] = 2] = "REPORTER";
})(PriceSource || (PriceSource = {}));
var PriceOracleEventToOutput = {
  [PriceOracleEventName.PricePosted]: "asset,newPriceMantissa",
  [PriceOracleEventName.PriceUpdated]: "symbolHash,price",
  [PriceOracleEventName.PriceGuarded]: "symbolHash,anchorPrice",
  [PriceOracleEventName.FailoverActivated]: "symbolHash",
  [PriceOracleEventName.FailoverDeactivated]: "symbolHash"
};

// packages/compound-v2-liquidator/src/mempool/mempool.constants.ts
var EthSymbolHash = "0xaaaebeba3810b1e6b70781f14b2d72c1cb89c0b2b320c43bb67ff79f562f5ff4";
var CSaiSymbolHash = "0xF5DCe57282A584D2746FaF1593d3121Fcac444dC";
var AllowedBorrowMarkets = [
  "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
  "0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5",
  "0x39AA39c021dfbaE8faC545936693aC917d5E7563",
  "0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9",
  "0xccF4429DB6322D5C611ee964527D42E5d685DD6a",
  "0x95b4eF2869eBD94BEb4eEE400a99824BF5DC325b"
];

// packages/compound-v2-liquidator/src/storage/storage.service.ts
class StorageService extends Service {
  cacheService;
  pointerHeight = 0;
  networkHeight = 0;
  baseFeePerGas = 0n;
  comptroller = {};
  markets = {};
  accounts = new Map;
  tokenConfigs = {};
  constructor(cacheService) {
    super();
    this.cacheService = cacheService;
  }
  async init() {
    await this.initPointerHeight();
    await this.initComptroller();
    await this.initAccounts();
    await this.initMarkets();
    await this.initTokenConfigs();
  }
  async initAccounts() {
    this.accounts = new Map(await this.cacheService.get("accounts"));
  }
  async initMarkets() {
    this.markets = await this.cacheService.get("markets") || {};
  }
  async initTokenConfigs() {
    this.tokenConfigs = await this.cacheService.get("tokenConfigs") || {};
  }
  async initComptroller() {
    this.comptroller = await this.cacheService.get("comptroller") || {
      allMarkets: new Set([]),
      closeFactorMantissa: 0n,
      priceOracle: "",
      liquidationIncentiveMantissa: 0n
    };
  }
  async initPointerHeight() {
    this.pointerHeight = await this.cacheService.get("pointerHeight") || env_default.UNITROLLER_DEPLOYMENT_BLOCK;
  }
  getEthTokenConfig() {
    return Object.values(this.tokenConfigs).find((tC) => tC.symbolHash === EthSymbolHash);
  }
  getFixedEthTokenConfigs() {
    return Object.values(this.tokenConfigs).filter((tC) => tC.priceSource === PriceSource.FIXED_ETH);
  }
  getTokenConfigsBySymbolHash(symbolHash) {
    return Object.values(this.tokenConfigs).filter((tC) => tC.symbolHash === symbolHash);
  }
  getTokenConfigByCToken(cToken) {
    return this.tokenConfigs[cToken];
  }
  getTokenConfigsByPriceSource(priceSource) {
    return Object.values(this.tokenConfigs).filter((tC) => tC.priceSource === priceSource);
  }
  getTokenConfigByReporter(reporter) {
    return Object.values(this.tokenConfigs).find((tC) => tC.reporter === reporter);
  }
  getTokenConfig(cToken) {
    return this.tokenConfigs[cToken];
  }
  getTokenConfigs() {
    return this.tokenConfigs;
  }
  setTokenConfig(cToken, tokenConfig) {
    this.tokenConfigs[cToken] = tokenConfig;
  }
  setTokenConfigs(tokenConfigs) {
    this.tokenConfigs = tokenConfigs;
  }
  async cacheMarkets() {
    await this.cacheService.set("markets", this.markets);
  }
  async cacheMemory() {
    await this.cacheService.setEntries([
      ["pointerHeight", this.pointerHeight],
      ["comptroller", this.comptroller],
      ["markets", this.markets],
      ["accounts", this.accounts],
      ["tokenConfigs", this.tokenConfigs]
    ]);
  }
  async cacheTokenConfigs() {
    await this.cacheService.set("tokenConfigs", this.tokenConfigs);
  }
  async cachePointerHeight() {
    await this.cacheService.set("pointerHeight", this.pointerHeight);
  }
  getMarket(address) {
    return this.markets[address];
  }
  setMarket(address, market) {
    this.markets[address] = market;
  }
  getPointerHeight() {
    return this.pointerHeight;
  }
  setPointerHeight(value) {
    const pointerHeight = Number(value);
    if (Number.isNaN(pointerHeight)) {
      throw new Error(`Invalid value for pointerHeight - ${value}`);
    }
    this.pointerHeight = pointerHeight;
  }
  getNetworkHeight() {
    return this.networkHeight;
  }
  getMarkets() {
    return this.markets;
  }
  getMarketsBySymbolHash(symbolHash) {
    return this.getTokenConfigsBySymbolHash(symbolHash).map(({ marketAddress }) => this.getMarket(marketAddress));
  }
  getAccounts() {
    return this.accounts;
  }
  setNetworkHeight(value) {
    const networkHeight = Number(value);
    if (Number.isNaN(networkHeight)) {
      throw new Error(`Invalid value for networkHeight - ${value}`);
    }
    this.networkHeight = networkHeight;
  }
  setComptroller(_comptroller) {
    Object.assign(this.comptroller, _comptroller);
  }
  getComptroller() {
    return this.comptroller;
  }
  getAccount(address) {
    return this.accounts.get(address);
  }
  setAccount(address, account) {
    this.accounts.set(address, account);
  }
  getBaseFeePerGas() {
    return this.baseFeePerGas;
  }
  setBaseFeePerGas(value) {
    this.baseFeePerGas = BigInt(value);
  }
}

// packages/compound-v2-liquidator/src/storage/storage.module.ts
class StorageModule extends Module {
  constructor(cacheModule) {
    super();
    const cacheService = cacheModule.getService("cacheService");
    const storageService = new StorageService(cacheService);
    this.registerService("storageService", storageService);
  }
}

// node_modules/web3-errors/lib/esm/error_codes.js
var ERR_RESPONSE = 100;
var ERR_INVALID_RESPONSE = 101;
var ERR_FORMATTERS = 201;
var ERR_METHOD_NOT_IMPLEMENTED = 202;
var ERR_OPERATION_TIMEOUT = 203;
var ERR_OPERATION_ABORT = 204;
var ERR_ABI_ENCODING = 205;
var ERR_EXISTING_PLUGIN_NAMESPACE = 206;
var ERR_INVALID_METHOD_PARAMS = 207;
var ERR_CONTRACT = 300;
var ERR_CONTRACT_RESOLVER_MISSING = 301;
var ERR_CONTRACT_EXECUTION_REVERTED = 310;
var ERR_CONTRACT_TX_DATA_AND_INPUT = 311;
var ERR_TX = 400;
var ERR_TX_REVERT_TRANSACTION = 402;
var ERR_TX_REVERT_WITHOUT_REASON = 405;
var ERR_RAW_TX_UNDEFINED = 407;
var ERR_TX_INVALID_SENDER = 408;
var ERR_TX_MISSING_CUSTOM_CHAIN = 410;
var ERR_TX_MISSING_CUSTOM_CHAIN_ID = 411;
var ERR_TX_CHAIN_ID_MISMATCH = 412;
var ERR_TX_INVALID_CHAIN_INFO = 413;
var ERR_TX_MISSING_CHAIN_INFO = 414;
var ERR_TX_MISSING_GAS = 415;
var ERR_TX_INVALID_LEGACY_GAS = 416;
var ERR_TX_INVALID_FEE_MARKET_GAS = 417;
var ERR_TX_INVALID_FEE_MARKET_GAS_PRICE = 418;
var ERR_TX_INVALID_LEGACY_FEE_MARKET = 419;
var ERR_TX_INVALID_OBJECT = 420;
var ERR_TX_INVALID_NONCE_OR_CHAIN_ID = 421;
var ERR_TX_UNABLE_TO_POPULATE_NONCE = 422;
var ERR_TX_UNSUPPORTED_EIP_1559 = 423;
var ERR_TX_UNSUPPORTED_TYPE = 424;
var ERR_TX_DATA_AND_INPUT = 425;
var ERR_TX_POLLING_TIMEOUT = 426;
var ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL = 427;
var ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER = 428;
var ERR_TX_LOCAL_WALLET_NOT_AVAILABLE = 429;
var ERR_TX_NOT_FOUND = 430;
var ERR_TX_SEND_TIMEOUT = 431;
var ERR_TX_BLOCK_TIMEOUT = 432;
var ERR_TX_SIGNING = 433;
var ERR_TX_GAS_MISMATCH = 434;
var ERR_TX_CHAIN_MISMATCH = 435;
var ERR_TX_HARDFORK_MISMATCH = 436;
var ERR_TX_INVALID_RECEIVER = 437;
var ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR = 438;
var ERR_TX_INVALID_PROPERTIES_FOR_TYPE = 439;
var ERR_TX_MISSING_GAS_INNER_ERROR = 440;
var ERR_TX_GAS_MISMATCH_INNER_ERROR = 441;
var ERR_CONN = 500;
var ERR_CONN_NOT_OPEN = 503;
var ERR_CONN_MAX_ATTEMPTS = 505;
var ERR_CONN_PENDING_REQUESTS = 506;
var ERR_REQ_ALREADY_SENT = 507;
var ERR_PROVIDER = 600;
var ERR_INVALID_CLIENT = 602;
var ERR_SUBSCRIPTION = 603;
var ERR_WS_PROVIDER = 604;
var ERR_PRIVATE_KEY_LENGTH = 701;
var ERR_INVALID_PRIVATE_KEY = 702;
var ERR_UNSUPPORTED_KDF = 703;
var ERR_KEY_DERIVATION_FAIL = 704;
var ERR_KEY_VERSION_UNSUPPORTED = 705;
var ERR_INVALID_PASSWORD = 706;
var ERR_IV_LENGTH = 707;
var ERR_PBKDF2_ITERATIONS = 709;
var ERR_SIGNATURE_FAILED = 801;
var ERR_INVALID_SIGNATURE = 802;
var JSONRPC_ERR_REJECTED_REQUEST = 4001;
var JSONRPC_ERR_UNAUTHORIZED = 4100;
var JSONRPC_ERR_UNSUPPORTED_METHOD = 4200;
var JSONRPC_ERR_DISCONNECTED = 4900;
var JSONRPC_ERR_CHAIN_DISCONNECTED = 4901;
var ERR_ENS_UNSUPPORTED_NETWORK = 902;
var ERR_ENS_NETWORK_NOT_SYNCED = 903;
var ERR_INVALID_STRING = 1001;
var ERR_INVALID_BYTES = 1002;
var ERR_INVALID_NUMBER = 1003;
var ERR_INVALID_UNIT = 1004;
var ERR_INVALID_ADDRESS = 1005;
var ERR_INVALID_HEX = 1006;
var ERR_INVALID_BOOLEAN = 1008;
var ERR_INVALID_UNSIGNED_INTEGER = 1009;
var ERR_INVALID_SIZE = 1010;
var ERR_INVALID_LARGE_VALUE = 1011;
var ERR_INVALID_BLOCK = 1012;
var ERR_INVALID_NIBBLE_WIDTH = 1014;
var ERR_VALIDATION = 1100;
var ERR_CORE_HARDFORK_MISMATCH = 1101;
var ERR_SCHEMA_FORMAT = 1200;
var ERR_RPC_INVALID_JSON = -32700;
var ERR_RPC_INVALID_REQUEST = -32600;
var ERR_RPC_INVALID_METHOD = -32601;
var ERR_RPC_INVALID_PARAMS = -32602;
var ERR_RPC_INTERNAL_ERROR = -32603;
var ERR_RPC_INVALID_INPUT = -32000;
var ERR_RPC_MISSING_RESOURCE = -32001;
var ERR_RPC_UNAVAILABLE_RESOURCE = -32002;
var ERR_RPC_TRANSACTION_REJECTED = -32003;
var ERR_RPC_UNSUPPORTED_METHOD = -32004;
var ERR_RPC_LIMIT_EXCEEDED = -32005;
var ERR_RPC_NOT_SUPPORTED = -32006;
// node_modules/web3-errors/lib/esm/web3_error_base.js
class BaseWeb3Error extends Error {
  constructor(msg, innerError) {
    super(msg);
    this.innerError = innerError;
    this.name = this.constructor.name;
    if (typeof Error.captureStackTrace === "function") {
      Error.captureStackTrace(new.target.constructor);
    } else {
      this.stack = new Error().stack;
    }
  }
  static convertToString(value, unquotValue = false) {
    if (value === null || value === undefined)
      return "undefined";
    const result = JSON.stringify(value, (_, v) => typeof v === "bigint" ? v.toString() : v);
    return unquotValue && ["bigint", "string"].includes(typeof value) ? result.replace(/['\\"]+/g, "") : result;
  }
  toJSON() {
    return {
      name: this.name,
      code: this.code,
      message: this.message,
      innerError: this.innerError
    };
  }
}

class InvalidValueError extends BaseWeb3Error {
  constructor(value, msg) {
    super(`Invalid value given "${BaseWeb3Error.convertToString(value, true)}". Error: ${msg}.`);
    this.name = this.constructor.name;
  }
}
// node_modules/web3-errors/lib/esm/errors/account_errors.js
class PrivateKeyLengthError extends BaseWeb3Error {
  constructor() {
    super(`Private key must be 32 bytes.`);
    this.code = ERR_PRIVATE_KEY_LENGTH;
  }
}

class InvalidPrivateKeyError extends BaseWeb3Error {
  constructor() {
    super(`Invalid Private Key, Not a valid string or uint8Array`);
    this.code = ERR_INVALID_PRIVATE_KEY;
  }
}

class InvalidSignatureError extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`"${errorDetails}"`);
    this.code = ERR_INVALID_SIGNATURE;
  }
}

class InvalidKdfError extends BaseWeb3Error {
  constructor() {
    super(`Invalid key derivation function`);
    this.code = ERR_UNSUPPORTED_KDF;
  }
}

class KeyDerivationError extends BaseWeb3Error {
  constructor() {
    super(`Key derivation failed - possibly wrong password`);
    this.code = ERR_KEY_DERIVATION_FAIL;
  }
}

class KeyStoreVersionError extends BaseWeb3Error {
  constructor() {
    super("Unsupported key store version");
    this.code = ERR_KEY_VERSION_UNSUPPORTED;
  }
}

class InvalidPasswordError extends BaseWeb3Error {
  constructor() {
    super("Password cannot be empty");
    this.code = ERR_INVALID_PASSWORD;
  }
}

class IVLengthError extends BaseWeb3Error {
  constructor() {
    super("Initialization vector must be 16 bytes");
    this.code = ERR_IV_LENGTH;
  }
}

class PBKDF2IterationsError extends BaseWeb3Error {
  constructor() {
    super("c > 1000, pbkdf2 is less secure with less iterations");
    this.code = ERR_PBKDF2_ITERATIONS;
  }
}
// node_modules/web3-errors/lib/esm/errors/connection_errors.js
class ConnectionError extends BaseWeb3Error {
  constructor(message, event) {
    super(message);
    this.code = ERR_CONN;
    if (event) {
      this.errorCode = event.code;
      this.errorReason = event.reason;
    }
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { errorCode: this.errorCode, errorReason: this.errorReason });
  }
}
class ConnectionNotOpenError extends ConnectionError {
  constructor(event) {
    super("Connection not open", event);
    this.code = ERR_CONN_NOT_OPEN;
  }
}
class MaxAttemptsReachedOnReconnectingError extends ConnectionError {
  constructor(numberOfAttempts) {
    super(`Maximum number of reconnect attempts reached! (${numberOfAttempts})`);
    this.code = ERR_CONN_MAX_ATTEMPTS;
  }
}

class PendingRequestsOnReconnectingError extends ConnectionError {
  constructor() {
    super("CONNECTION ERROR: Provider started to reconnect before the response got received!");
    this.code = ERR_CONN_PENDING_REQUESTS;
  }
}

class RequestAlreadySentError extends ConnectionError {
  constructor(id) {
    super(`Request already sent with following id: ${id}`);
    this.code = ERR_REQ_ALREADY_SENT;
  }
}
// node_modules/web3-errors/lib/esm/errors/contract_errors.js
class Web3ContractError extends BaseWeb3Error {
  constructor(message, receipt) {
    super(message);
    this.code = ERR_CONTRACT;
    this.receipt = receipt;
  }
}

class ResolverMethodMissingError extends BaseWeb3Error {
  constructor(address, name) {
    super(`The resolver at ${address} does not implement requested method: "${name}".`);
    this.address = address;
    this.name = name;
    this.code = ERR_CONTRACT_RESOLVER_MISSING;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { address: this.address, name: this.name });
  }
}
class Eip838ExecutionError extends Web3ContractError {
  constructor(error) {
    super(error.message || "Error");
    this.name = "name" in error && error.name || this.constructor.name;
    this.stack = "stack" in error && error.stack || undefined;
    this.code = error.code;
    if (typeof error.data === "object") {
      let originalError;
      if ("originalError" in error.data) {
        originalError = error.data.originalError;
      } else {
        originalError = error.data;
      }
      this.data = originalError.data;
      this.innerError = new Eip838ExecutionError(originalError);
    } else {
      this.data = error.data;
    }
  }
  setDecodedProperties(errorName, errorSignature, errorArgs) {
    this.errorName = errorName;
    this.errorSignature = errorSignature;
    this.errorArgs = errorArgs;
  }
  toJSON() {
    let json = Object.assign(Object.assign({}, super.toJSON()), { data: this.data });
    if (this.errorName) {
      json = Object.assign(Object.assign({}, json), { errorName: this.errorName, errorSignature: this.errorSignature, errorArgs: this.errorArgs });
    }
    return json;
  }
}

class ContractExecutionError extends Web3ContractError {
  constructor(rpcError) {
    super("Error happened while trying to execute a function inside a smart contract");
    this.code = ERR_CONTRACT_EXECUTION_REVERTED;
    this.innerError = new Eip838ExecutionError(rpcError);
  }
}

class ContractTransactionDataAndInputError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`data: ${(_a = value.data) !== null && _a !== undefined ? _a : "undefined"}, input: ${(_b = value.input) !== null && _b !== undefined ? _b : "undefined"}`, 'You can\'t have "data" and "input" as properties of a contract at the same time, please use either "data" or "input" instead.');
    this.code = ERR_CONTRACT_TX_DATA_AND_INPUT;
  }
}
// node_modules/web3-errors/lib/esm/errors/ens_errors.js
class ENSUnsupportedNetworkError extends BaseWeb3Error {
  constructor(networkType) {
    super(`ENS is not supported on network ${networkType}`);
    this.code = ERR_ENS_UNSUPPORTED_NETWORK;
  }
}

class ENSNetworkNotSyncedError extends BaseWeb3Error {
  constructor() {
    super(`Network not synced`);
    this.code = ERR_ENS_NETWORK_NOT_SYNCED;
  }
}
// node_modules/web3-errors/lib/esm/errors/generic_errors.js
class InvalidMethodParamsError extends BaseWeb3Error {
  constructor(hint) {
    super(`Invalid parameters passed. "${typeof hint !== "undefined" ? hint : ""}"`);
    this.hint = hint;
    this.code = ERR_INVALID_METHOD_PARAMS;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { hint: this.hint });
  }
}

class FormatterError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_FORMATTERS;
  }
}

class MethodNotImplementedError extends BaseWeb3Error {
  constructor() {
    super("The method you're trying to call is not implemented.");
    this.code = ERR_METHOD_NOT_IMPLEMENTED;
  }
}

class OperationTimeoutError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_OPERATION_TIMEOUT;
  }
}

class OperationAbortError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_OPERATION_ABORT;
  }
}

class AbiError extends BaseWeb3Error {
  constructor(message, props) {
    super(message);
    this.code = ERR_ABI_ENCODING;
    this.props = props !== null && props !== undefined ? props : {};
  }
}

class ExistingPluginNamespaceError extends BaseWeb3Error {
  constructor(pluginNamespace) {
    super(`A plugin with the namespace: ${pluginNamespace} has already been registered.`);
    this.code = ERR_EXISTING_PLUGIN_NAMESPACE;
  }
}
// node_modules/web3-errors/lib/esm/errors/provider_errors.js
class ProviderError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_PROVIDER;
  }
}
class InvalidClientError extends BaseWeb3Error {
  constructor(clientUrl) {
    super(`Client URL "${clientUrl}" is invalid.`);
    this.code = ERR_INVALID_CLIENT;
  }
}

class SubscriptionError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_SUBSCRIPTION;
  }
}

class Web3WSProviderError extends BaseWeb3Error {
  constructor() {
    super(...arguments);
    this.code = ERR_WS_PROVIDER;
  }
}
// node_modules/web3-errors/lib/esm/errors/signature_errors.js
class SignatureError extends InvalidValueError {
  constructor() {
    super(...arguments);
    this.code = ERR_SIGNATURE_FAILED;
  }
}
// node_modules/web3-errors/lib/esm/errors/transaction_errors.js
var transactionTimeoutHint = function(transactionHash) {
  return `Please make sure your transaction was properly sent and there are no previous pending transaction for the same account. However, be aware that it might still be mined!\n\tTransaction Hash: ${transactionHash ? transactionHash.toString() : "not available"}`;
};

class TransactionError extends BaseWeb3Error {
  constructor(message, receipt) {
    super(message);
    this.receipt = receipt;
    this.code = ERR_TX;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { receipt: this.receipt });
  }
}
class TransactionRevertInstructionError extends BaseWeb3Error {
  constructor(reason, signature, receipt, data) {
    super(`Transaction has been reverted by the EVM${receipt === undefined ? "" : `:\n ${BaseWeb3Error.convertToString(receipt)}`}`);
    this.reason = reason;
    this.signature = signature;
    this.receipt = receipt;
    this.data = data;
    this.code = ERR_TX_REVERT_TRANSACTION;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, signature: this.signature, receipt: this.receipt, data: this.data });
  }
}

class TransactionRevertWithCustomError extends TransactionRevertInstructionError {
  constructor(reason, customErrorName, customErrorDecodedSignature, customErrorArguments, signature, receipt, data) {
    super(reason);
    this.reason = reason;
    this.customErrorName = customErrorName;
    this.customErrorDecodedSignature = customErrorDecodedSignature;
    this.customErrorArguments = customErrorArguments;
    this.signature = signature;
    this.receipt = receipt;
    this.data = data;
    this.code = ERR_TX_REVERT_TRANSACTION_CUSTOM_ERROR;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { reason: this.reason, customErrorName: this.customErrorName, customErrorDecodedSignature: this.customErrorDecodedSignature, customErrorArguments: this.customErrorArguments, signature: this.signature, receipt: this.receipt, data: this.data });
  }
}
class TransactionRevertedWithoutReasonError extends TransactionError {
  constructor(receipt) {
    super(`Transaction has been reverted by the EVM${receipt === undefined ? "" : `:\n ${BaseWeb3Error.convertToString(receipt)}`}`, receipt);
    this.code = ERR_TX_REVERT_WITHOUT_REASON;
  }
}
class UndefinedRawTransactionError extends TransactionError {
  constructor() {
    super(`Raw transaction undefined`);
    this.code = ERR_RAW_TX_UNDEFINED;
  }
}

class TransactionNotFound extends TransactionError {
  constructor() {
    super("Transaction not found");
    this.code = ERR_TX_NOT_FOUND;
  }
}

class InvalidTransactionWithSender extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction with invalid sender");
    this.code = ERR_TX_INVALID_SENDER;
  }
}

class InvalidTransactionWithReceiver extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction with invalid receiver");
    this.code = ERR_TX_INVALID_RECEIVER;
  }
}
class MissingCustomChainError extends InvalidValueError {
  constructor() {
    super("MissingCustomChainError", "If tx.common is provided it must have tx.common.customChain");
    this.code = ERR_TX_MISSING_CUSTOM_CHAIN;
  }
}

class MissingCustomChainIdError extends InvalidValueError {
  constructor() {
    super("MissingCustomChainIdError", "If tx.common is provided it must have tx.common.customChain and tx.common.customChain.chainId");
    this.code = ERR_TX_MISSING_CUSTOM_CHAIN_ID;
  }
}

class ChainIdMismatchError extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "Chain Id doesnt match in tx.chainId tx.common.customChain.chainId");
    this.code = ERR_TX_CHAIN_ID_MISMATCH;
  }
}

class ChainMismatchError extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "Chain doesnt match in tx.chain tx.common.basechain");
    this.code = ERR_TX_CHAIN_MISMATCH;
  }
}

class HardforkMismatchError extends InvalidValueError {
  constructor(value) {
    super(JSON.stringify(value), "hardfork doesnt match in tx.hardfork tx.common.hardfork");
    this.code = ERR_TX_HARDFORK_MISMATCH;
  }
}

class CommonOrChainAndHardforkError extends InvalidValueError {
  constructor() {
    super("CommonOrChainAndHardforkError", "Please provide the common object or the chain and hardfork property but not all together.");
    this.code = ERR_TX_INVALID_CHAIN_INFO;
  }
}

class MissingChainOrHardforkError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super("MissingChainOrHardforkError", `When specifying chain and hardfork, both values must be defined. Received "chain": ${(_a = value.chain) !== null && _a !== undefined ? _a : "undefined"}, "hardfork": ${(_b = value.hardfork) !== null && _b !== undefined ? _b : "undefined"}`);
    this.code = ERR_TX_MISSING_CHAIN_INFO;
  }
}

class MissingGasInnerError extends BaseWeb3Error {
  constructor() {
    super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions');
    this.code = ERR_TX_MISSING_GAS_INNER_ERROR;
  }
}

class MissingGasError extends InvalidValueError {
  constructor(value) {
    var _a, _b, _c, _d;
    super(`gas: ${(_a = value.gas) !== null && _a !== undefined ? _a : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== undefined ? _b : "undefined"}, maxPriorityFeePerGas: ${(_c = value.maxPriorityFeePerGas) !== null && _c !== undefined ? _c : "undefined"}, maxFeePerGas: ${(_d = value.maxFeePerGas) !== null && _d !== undefined ? _d : "undefined"}`, '"gas" is missing');
    this.code = ERR_TX_MISSING_GAS;
    this.innerError = new MissingGasInnerError;
  }
}

class TransactionGasMismatchInnerError extends BaseWeb3Error {
  constructor() {
    super('Missing properties in transaction, either define "gas" and "gasPrice" for type 0 transactions or "gas", "maxPriorityFeePerGas" and "maxFeePerGas" for type 2 transactions, not both');
    this.code = ERR_TX_GAS_MISMATCH_INNER_ERROR;
  }
}

class TransactionGasMismatchError extends InvalidValueError {
  constructor(value) {
    var _a, _b, _c, _d;
    super(`gas: ${(_a = value.gas) !== null && _a !== undefined ? _a : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== undefined ? _b : "undefined"}, maxPriorityFeePerGas: ${(_c = value.maxPriorityFeePerGas) !== null && _c !== undefined ? _c : "undefined"}, maxFeePerGas: ${(_d = value.maxFeePerGas) !== null && _d !== undefined ? _d : "undefined"}`, "transaction must specify legacy or fee market gas properties, not both");
    this.code = ERR_TX_GAS_MISMATCH;
    this.innerError = new TransactionGasMismatchInnerError;
  }
}

class InvalidGasOrGasPrice extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`gas: ${(_a = value.gas) !== null && _a !== undefined ? _a : "undefined"}, gasPrice: ${(_b = value.gasPrice) !== null && _b !== undefined ? _b : "undefined"}`, "Gas or gasPrice is lower than 0");
    this.code = ERR_TX_INVALID_LEGACY_GAS;
  }
}

class InvalidMaxPriorityFeePerGasOrMaxFeePerGas extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`maxPriorityFeePerGas: ${(_a = value.maxPriorityFeePerGas) !== null && _a !== undefined ? _a : "undefined"}, maxFeePerGas: ${(_b = value.maxFeePerGas) !== null && _b !== undefined ? _b : "undefined"}`, "maxPriorityFeePerGas or maxFeePerGas is lower than 0");
    this.code = ERR_TX_INVALID_FEE_MARKET_GAS;
  }
}

class Eip1559GasPriceError extends InvalidValueError {
  constructor(value) {
    super(value, "eip-1559 transactions don't support gasPrice");
    this.code = ERR_TX_INVALID_FEE_MARKET_GAS_PRICE;
  }
}

class UnsupportedFeeMarketError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`maxPriorityFeePerGas: ${(_a = value.maxPriorityFeePerGas) !== null && _a !== undefined ? _a : "undefined"}, maxFeePerGas: ${(_b = value.maxFeePerGas) !== null && _b !== undefined ? _b : "undefined"}`, "pre-eip-1559 transaction don't support maxFeePerGas/maxPriorityFeePerGas");
    this.code = ERR_TX_INVALID_LEGACY_FEE_MARKET;
  }
}

class InvalidTransactionObjectError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid transaction object");
    this.code = ERR_TX_INVALID_OBJECT;
  }
}

class InvalidNonceOrChainIdError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`nonce: ${(_a = value.nonce) !== null && _a !== undefined ? _a : "undefined"}, chainId: ${(_b = value.chainId) !== null && _b !== undefined ? _b : "undefined"}`, "Nonce or chainId is lower than 0");
    this.code = ERR_TX_INVALID_NONCE_OR_CHAIN_ID;
  }
}

class UnableToPopulateNonceError extends InvalidValueError {
  constructor() {
    super("UnableToPopulateNonceError", "unable to populate nonce, no from address available");
    this.code = ERR_TX_UNABLE_TO_POPULATE_NONCE;
  }
}

class Eip1559NotSupportedError extends InvalidValueError {
  constructor() {
    super("Eip1559NotSupportedError", "Network doesn't support eip-1559");
    this.code = ERR_TX_UNSUPPORTED_EIP_1559;
  }
}

class UnsupportedTransactionTypeError extends InvalidValueError {
  constructor(value) {
    super(value, "unsupported transaction type");
    this.code = ERR_TX_UNSUPPORTED_TYPE;
  }
}

class TransactionDataAndInputError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`data: ${(_a = value.data) !== null && _a !== undefined ? _a : "undefined"}, input: ${(_b = value.input) !== null && _b !== undefined ? _b : "undefined"}`, 'You can\'t have "data" and "input" as properties of transactions at the same time, please use either "data" or "input" instead.');
    this.code = ERR_TX_DATA_AND_INPUT;
  }
}

class TransactionSendTimeoutError extends BaseWeb3Error {
  constructor(value) {
    super(`The connected Ethereum Node did not respond within ${value.numberOfSeconds} seconds, please make sure your transaction was properly sent and you are connected to a healthy Node. Be aware that transaction might still be pending or mined!\n\tTransaction Hash: ${value.transactionHash ? value.transactionHash.toString() : "not available"}`);
    this.code = ERR_TX_SEND_TIMEOUT;
  }
}

class TransactionPollingTimeoutError extends BaseWeb3Error {
  constructor(value) {
    super(`Transaction was not mined within ${value.numberOfSeconds} seconds. ${transactionTimeoutHint(value.transactionHash)}`);
    this.code = ERR_TX_POLLING_TIMEOUT;
  }
}

class TransactionBlockTimeoutError extends BaseWeb3Error {
  constructor(value) {
    super(`Transaction started at ${value.starterBlockNumber} but was not mined within ${value.numberOfBlocks} blocks. ${transactionTimeoutHint(value.transactionHash)}`);
    this.code = ERR_TX_BLOCK_TIMEOUT;
  }
}

class TransactionMissingReceiptOrBlockHashError extends InvalidValueError {
  constructor(value) {
    var _a, _b;
    super(`receipt: ${JSON.stringify(value.receipt)}, blockHash: ${(_a = value.blockHash) === null || _a === undefined ? undefined : _a.toString()}, transactionHash: ${(_b = value.transactionHash) === null || _b === undefined ? undefined : _b.toString()}`, `Receipt missing or blockHash null`);
    this.code = ERR_TX_RECEIPT_MISSING_OR_BLOCKHASH_NULL;
  }
}

class TransactionReceiptMissingBlockNumberError extends InvalidValueError {
  constructor(value) {
    super(`receipt: ${JSON.stringify(value.receipt)}`, `Receipt missing block number`);
    this.code = ERR_TX_RECEIPT_MISSING_BLOCK_NUMBER;
  }
}

class TransactionSigningError extends BaseWeb3Error {
  constructor(errorDetails) {
    super(`Invalid signature. "${errorDetails}"`);
    this.code = ERR_TX_SIGNING;
  }
}

class LocalWalletNotAvailableError extends InvalidValueError {
  constructor() {
    super("LocalWalletNotAvailableError", `Attempted to index account in local wallet, but no wallet is available`);
    this.code = ERR_TX_LOCAL_WALLET_NOT_AVAILABLE;
  }
}

class InvalidPropertiesForTransactionTypeError extends BaseWeb3Error {
  constructor(validationError, txType) {
    const invalidPropertyNames = [];
    validationError.forEach((error) => invalidPropertyNames.push(error.keyword));
    super(`The following properties are invalid for the transaction type ${txType}: ${invalidPropertyNames.join(", ")}`);
    this.code = ERR_TX_INVALID_PROPERTIES_FOR_TYPE;
  }
}
// node_modules/web3-errors/lib/esm/errors/utils_errors.js
class InvalidBytesError extends InvalidValueError {
  constructor(value) {
    super(value, "can not parse as byte data");
    this.code = ERR_INVALID_BYTES;
  }
}

class InvalidNumberError extends InvalidValueError {
  constructor(value) {
    super(value, "can not parse as number data");
    this.code = ERR_INVALID_NUMBER;
  }
}

class InvalidAddressError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid ethereum address");
    this.code = ERR_INVALID_ADDRESS;
  }
}

class InvalidStringError extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid string");
    this.code = ERR_INVALID_STRING;
  }
}

class InvalidUnitError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid unit");
    this.code = ERR_INVALID_UNIT;
  }
}

class HexProcessingError extends InvalidValueError {
  constructor(value) {
    super(value, "can not be converted to hex");
    this.code = ERR_INVALID_HEX;
  }
}

class NibbleWidthError extends InvalidValueError {
  constructor(value) {
    super(value, "value greater than the nibble width");
    this.code = ERR_INVALID_NIBBLE_WIDTH;
  }
}
class InvalidBooleanError extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid boolean.");
    this.code = ERR_INVALID_BOOLEAN;
  }
}

class InvalidUnsignedIntegerError extends InvalidValueError {
  constructor(value) {
    super(value, "not a valid unsigned integer.");
    this.code = ERR_INVALID_UNSIGNED_INTEGER;
  }
}

class InvalidSizeError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid size given.");
    this.code = ERR_INVALID_SIZE;
  }
}

class InvalidLargeValueError extends InvalidValueError {
  constructor(value) {
    super(value, "value is larger than size.");
    this.code = ERR_INVALID_LARGE_VALUE;
  }
}

class InvalidBlockError extends InvalidValueError {
  constructor(value) {
    super(value, "invalid string given");
    this.code = ERR_INVALID_BLOCK;
  }
}
// node_modules/web3-errors/lib/esm/errors/response_errors.js
var isResponseWithError = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && (response.result === undefined || response.result === null) && ("error" in response) && (typeof response.id === "number" || typeof response.id === "string");
var buildErrorMessage = (response) => isResponseWithError(response) ? response.error.message : "";

class ResponseError extends BaseWeb3Error {
  constructor(response, message, request) {
    var _a;
    super(message !== null && message !== undefined ? message : `Returned error: ${Array.isArray(response) ? response.map((r) => buildErrorMessage(r)).join(",") : buildErrorMessage(response)}`);
    this.code = ERR_RESPONSE;
    if (!message) {
      this.data = Array.isArray(response) ? response.map((r) => {
        var _a2;
        return (_a2 = r.error) === null || _a2 === undefined ? undefined : _a2.data;
      }) : (_a = response === null || response === undefined ? undefined : response.error) === null || _a === undefined ? undefined : _a.data;
    }
    this.request = request;
    let errorOrErrors;
    if (`error` in response) {
      errorOrErrors = response.error;
    } else if (response instanceof Array) {
      errorOrErrors = response.map((r) => r.error);
    }
    this.innerError = errorOrErrors;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { data: this.data, request: this.request });
  }
}

class InvalidResponseError extends ResponseError {
  constructor(result, request) {
    super(result, undefined, request);
    this.code = ERR_INVALID_RESPONSE;
    let errorOrErrors;
    if (`error` in result) {
      errorOrErrors = result.error;
    } else if (result instanceof Array) {
      errorOrErrors = result.map((r) => r.error);
    }
    this.innerError = errorOrErrors;
  }
}
// node_modules/web3-errors/lib/esm/errors/core_errors.js
class ConfigHardforkMismatchError extends BaseWeb3Error {
  constructor(defaultHardfork, commonHardFork) {
    super(`Web3Config hardfork doesnt match in defaultHardfork ${defaultHardfork} and common.hardfork ${commonHardFork}`);
    this.code = ERR_CORE_HARDFORK_MISMATCH;
  }
}

class ConfigChainMismatchError extends BaseWeb3Error {
  constructor(defaultHardfork, commonHardFork) {
    super(`Web3Config chain doesnt match in defaultHardfork ${defaultHardfork} and common.hardfork ${commonHardFork}`);
    this.code = ERR_CORE_HARDFORK_MISMATCH;
  }
}
// node_modules/web3-errors/lib/esm/errors/rpc_error_messages.js
var genericRpcErrorMessageTemplate = "An Rpc error has occured with a code of *code*";
var RpcErrorMessages = {
  [ERR_RPC_INVALID_JSON]: {
    message: "Parse error",
    description: "Invalid JSON"
  },
  [ERR_RPC_INVALID_REQUEST]: {
    message: "Invalid request",
    description: "JSON is not a valid request object	"
  },
  [ERR_RPC_INVALID_METHOD]: {
    message: "Method not found",
    description: "Method does not exist	"
  },
  [ERR_RPC_INVALID_PARAMS]: {
    message: "Invalid params",
    description: "Invalid method parameters"
  },
  [ERR_RPC_INTERNAL_ERROR]: {
    message: "Internal error",
    description: "Internal JSON-RPC error"
  },
  [ERR_RPC_INVALID_INPUT]: {
    message: "Invalid input",
    description: "Missing or invalid parameters"
  },
  [ERR_RPC_MISSING_RESOURCE]: {
    message: "Resource not found",
    description: "Requested resource not found"
  },
  [ERR_RPC_UNAVAILABLE_RESOURCE]: {
    message: "Resource unavailable",
    description: "Requested resource not available"
  },
  [ERR_RPC_TRANSACTION_REJECTED]: {
    message: "Transaction rejected",
    description: "Transaction creation failed"
  },
  [ERR_RPC_UNSUPPORTED_METHOD]: {
    message: "Method not supported",
    description: "Method is not implemented"
  },
  [ERR_RPC_LIMIT_EXCEEDED]: {
    message: "Limit exceeded",
    description: "Request exceeds defined limit"
  },
  [ERR_RPC_NOT_SUPPORTED]: {
    message: "JSON-RPC version not supported",
    description: "Version of JSON-RPC protocol is not supported"
  },
  [JSONRPC_ERR_REJECTED_REQUEST]: {
    name: "User Rejected Request",
    message: "The user rejected the request."
  },
  [JSONRPC_ERR_UNAUTHORIZED]: {
    name: "Unauthorized",
    message: "The requested method and/or account has not been authorized by the user."
  },
  [JSONRPC_ERR_UNSUPPORTED_METHOD]: {
    name: "Unsupported Method",
    message: "The Provider does not support the requested method."
  },
  [JSONRPC_ERR_DISCONNECTED]: {
    name: "Disconnected",
    message: "The Provider is disconnected from all chains."
  },
  [JSONRPC_ERR_CHAIN_DISCONNECTED]: {
    name: "Chain Disconnected",
    message: "The Provider is not connected to the requested chain."
  },
  "0-999": {
    name: "",
    message: "Not used."
  },
  1000: {
    name: "Normal Closure",
    message: "The connection successfully completed the purpose for which it was created."
  },
  1001: {
    name: "Going Away",
    message: "The endpoint is going away, either because of a server failure or because the browser is navigating away from the page that opened the connection."
  },
  1002: {
    name: "Protocol error",
    message: "The endpoint is terminating the connection due to a protocol error."
  },
  1003: {
    name: "Unsupported Data",
    message: "The connection is being terminated because the endpoint received data of a type it cannot accept. (For example, a text-only endpoint received binary data.)"
  },
  1004: {
    name: "Reserved",
    message: "Reserved. A meaning might be defined in the future."
  },
  1005: {
    name: "No Status Rcvd",
    message: "Reserved. Indicates that no status code was provided even though one was expected."
  },
  1006: {
    name: "Abnormal Closure",
    message: "Reserved. Indicates that a connection was closed abnormally (that is, with no close frame being sent) when a status code is expected."
  },
  1007: {
    name: "Invalid frame payload data",
    message: "The endpoint is terminating the connection because a message was received that contained inconsistent data (e.g., non-UTF-8 data within a text message)."
  },
  1008: {
    name: "Policy Violation",
    message: "The endpoint is terminating the connection because it received a message that violates its policy. This is a generic status code, used when codes 1003 and 1009 are not suitable."
  },
  1009: {
    name: "Message Too Big",
    message: "The endpoint is terminating the connection because a data frame was received that is too large."
  },
  1010: {
    name: "Mandatory Ext.",
    message: "The client is terminating the connection because it expected the server to negotiate one or more extension, but the server didn't."
  },
  1011: {
    name: "Internal Error",
    message: "The server is terminating the connection because it encountered an unexpected condition that prevented it from fulfilling the request."
  },
  1012: {
    name: "Service Restart",
    message: "The server is terminating the connection because it is restarting."
  },
  1013: {
    name: "Try Again Later",
    message: "The server is terminating the connection due to a temporary condition, e.g. it is overloaded and is casting off some of its clients."
  },
  1014: {
    name: "Bad Gateway",
    message: "The server was acting as a gateway or proxy and received an invalid response from the upstream server. This is similar to 502 HTTP Status Code."
  },
  1015: {
    name: "TLS handshake",
    message: "Reserved. Indicates that the connection was closed due to a failure to perform a TLS handshake (e.g., the server certificate can't be verified)."
  },
  "1016-2999": {
    name: "",
    message: "For definition by future revisions of the WebSocket Protocol specification, and for definition by extension specifications."
  },
  "3000-3999": {
    name: "",
    message: "For use by libraries, frameworks, and applications. These status codes are registered directly with IANA. The interpretation of these codes is undefined by the WebSocket protocol."
  },
  "4000-4999": {
    name: "",
    message: "For private use, and thus can't be registered. Such codes can be used by prior agreements between WebSocket applications. The interpretation of these codes is undefined by the WebSocket protocol."
  }
};

// node_modules/web3-errors/lib/esm/errors/rpc_errors.js
class RpcError extends BaseWeb3Error {
  constructor(rpcError, message) {
    super(message !== null && message !== undefined ? message : genericRpcErrorMessageTemplate.replace("*code*", rpcError.error.code.toString()));
    this.code = rpcError.error.code;
    this.id = rpcError.id;
    this.jsonrpc = rpcError.jsonrpc;
    this.jsonRpcError = rpcError.error;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { error: this.jsonRpcError, id: this.id, jsonRpc: this.jsonrpc });
  }
}

class EIP1193ProviderRpcError extends BaseWeb3Error {
  constructor(code, data) {
    var _a, _b, _c, _d;
    if (!code) {
      super();
    } else if ((_a = RpcErrorMessages[code]) === null || _a === undefined ? undefined : _a.message) {
      super(RpcErrorMessages[code].message);
    } else {
      const statusCodeRange = Object.keys(RpcErrorMessages).find((statusCode) => typeof statusCode === "string" && code >= parseInt(statusCode.split("-")[0], 10) && code <= parseInt(statusCode.split("-")[1], 10));
      super((_c = (_b = RpcErrorMessages[statusCodeRange !== null && statusCodeRange !== undefined ? statusCodeRange : ""]) === null || _b === undefined ? undefined : _b.message) !== null && _c !== undefined ? _c : genericRpcErrorMessageTemplate.replace("*code*", (_d = code === null || code === undefined ? undefined : code.toString()) !== null && _d !== undefined ? _d : '""'));
    }
    this.code = code;
    this.data = data;
  }
}

class ParseError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_JSON].message);
    this.code = ERR_RPC_INVALID_JSON;
  }
}

class InvalidRequestError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_REQUEST].message);
    this.code = ERR_RPC_INVALID_REQUEST;
  }
}

class MethodNotFoundError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_METHOD].message);
    this.code = ERR_RPC_INVALID_METHOD;
  }
}

class InvalidParamsError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_PARAMS].message);
    this.code = ERR_RPC_INVALID_PARAMS;
  }
}

class InternalError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INTERNAL_ERROR].message);
    this.code = ERR_RPC_INTERNAL_ERROR;
  }
}

class InvalidInputError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_INVALID_INPUT].message);
    this.code = ERR_RPC_INVALID_INPUT;
  }
}

class MethodNotSupported extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNSUPPORTED_METHOD].message);
    this.code = ERR_RPC_UNSUPPORTED_METHOD;
  }
}

class ResourceUnavailableError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_UNAVAILABLE_RESOURCE].message);
    this.code = ERR_RPC_UNAVAILABLE_RESOURCE;
  }
}

class ResourcesNotFoundError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_MISSING_RESOURCE].message);
    this.code = ERR_RPC_MISSING_RESOURCE;
  }
}

class VersionNotSupportedError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_NOT_SUPPORTED].message);
    this.code = ERR_RPC_NOT_SUPPORTED;
  }
}

class TransactionRejectedError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_TRANSACTION_REJECTED].message);
    this.code = ERR_RPC_TRANSACTION_REJECTED;
  }
}

class LimitExceededError extends RpcError {
  constructor(rpcError) {
    super(rpcError, RpcErrorMessages[ERR_RPC_LIMIT_EXCEEDED].message);
    this.code = ERR_RPC_LIMIT_EXCEEDED;
  }
}
var rpcErrorsMap = new Map;
rpcErrorsMap.set(ERR_RPC_INVALID_JSON, { error: ParseError });
rpcErrorsMap.set(ERR_RPC_INVALID_REQUEST, {
  error: InvalidRequestError
});
rpcErrorsMap.set(ERR_RPC_INVALID_METHOD, {
  error: MethodNotFoundError
});
rpcErrorsMap.set(ERR_RPC_INVALID_PARAMS, { error: InvalidParamsError });
rpcErrorsMap.set(ERR_RPC_INTERNAL_ERROR, { error: InternalError });
rpcErrorsMap.set(ERR_RPC_INVALID_INPUT, { error: InvalidInputError });
rpcErrorsMap.set(ERR_RPC_UNSUPPORTED_METHOD, {
  error: MethodNotSupported
});
rpcErrorsMap.set(ERR_RPC_UNAVAILABLE_RESOURCE, {
  error: ResourceUnavailableError
});
rpcErrorsMap.set(ERR_RPC_TRANSACTION_REJECTED, {
  error: TransactionRejectedError
});
rpcErrorsMap.set(ERR_RPC_MISSING_RESOURCE, {
  error: ResourcesNotFoundError
});
rpcErrorsMap.set(ERR_RPC_NOT_SUPPORTED, {
  error: VersionNotSupportedError
});
rpcErrorsMap.set(ERR_RPC_LIMIT_EXCEEDED, { error: LimitExceededError });
// node_modules/web3-errors/lib/esm/errors/schema_errors.js
class SchemaFormatError extends BaseWeb3Error {
  constructor(type) {
    super(`Format for the type ${type} is unsupported`);
    this.type = type;
    this.code = ERR_SCHEMA_FORMAT;
  }
  toJSON() {
    return Object.assign(Object.assign({}, super.toJSON()), { type: this.type });
  }
}
// node_modules/web3-utils/lib/esm/index.js
var exports_esm = {};
__export(exports_esm, {
  waitWithTimeout: () => {
    {
      return waitWithTimeout;
    }
  },
  validateResponse: () => {
    {
      return validateResponse;
    }
  },
  uuidV4: () => {
    {
      return uuidV4;
    }
  },
  utf8ToHex: () => {
    {
      return utf8ToHex;
    }
  },
  utf8ToBytes: () => {
    {
      return utf8ToBytes2;
    }
  },
  uint8ArrayEquals: () => {
    {
      return uint8ArrayEquals;
    }
  },
  uint8ArrayConcat: () => {
    {
      return uint8ArrayConcat;
    }
  },
  toWei: () => {
    {
      return toWei;
    }
  },
  toUtf8: () => {
    {
      return toUtf8;
    }
  },
  toTwosComplement: () => {
    {
      return toTwosComplement;
    }
  },
  toPayload: () => {
    {
      return toPayload;
    }
  },
  toNumber: () => {
    {
      return toNumber;
    }
  },
  toHex: () => {
    {
      return toHex;
    }
  },
  toDecimal: () => {
    {
      return toDecimal;
    }
  },
  toChecksumAddress: () => {
    {
      return toChecksumAddress;
    }
  },
  toBool: () => {
    {
      return toBool;
    }
  },
  toBigInt: () => {
    {
      return toBigInt;
    }
  },
  toBatchPayload: () => {
    {
      return toBatchPayload;
    }
  },
  toAscii: () => {
    {
      return toAscii;
    }
  },
  stringToHex: () => {
    {
      return stringToHex;
    }
  },
  soliditySha3Raw: () => {
    {
      return soliditySha3Raw;
    }
  },
  soliditySha3: () => {
    {
      return soliditySha3;
    }
  },
  sha3Raw: () => {
    {
      return sha3Raw;
    }
  },
  sha3: () => {
    {
      return sha32;
    }
  },
  setRequestIdStart: () => {
    {
      return setRequestIdStart;
    }
  },
  rightPad: () => {
    {
      return rightPad;
    }
  },
  rejectIfTimeout: () => {
    {
      return rejectIfTimeout;
    }
  },
  rejectIfConditionAtInterval: () => {
    {
      return rejectIfConditionAtInterval;
    }
  },
  randomHex: () => {
    {
      return randomHex;
    }
  },
  randomBytes: () => {
    {
      return randomBytes2;
    }
  },
  processSolidityEncodePackedArgs: () => {
    {
      return processSolidityEncodePackedArgs;
    }
  },
  pollTillDefinedAndReturnIntervalId: () => {
    {
      return pollTillDefinedAndReturnIntervalId;
    }
  },
  pollTillDefined: () => {
    {
      return pollTillDefined;
    }
  },
  padRight: () => {
    {
      return padRight;
    }
  },
  padLeft: () => {
    {
      return padLeft2;
    }
  },
  numberToHex: () => {
    {
      return numberToHex2;
    }
  },
  mergeDeep: () => {
    {
      return mergeDeep;
    }
  },
  leftPad: () => {
    {
      return leftPad;
    }
  },
  keccak256Wrapper: () => {
    {
      return keccak256Wrapper;
    }
  },
  keccak256: () => {
    {
      return keccak256Wrapper;
    }
  },
  jsonRpc: () => {
    {
      return exports_json_rpc;
    }
  },
  isValidResponse: () => {
    {
      return isValidResponse;
    }
  },
  isUserEthereumAddressInBloom: () => {
    {
      return isUserEthereumAddressInBloom2;
    }
  },
  isUint8Array: () => {
    {
      return isUint8Array2;
    }
  },
  isTopicInBloom: () => {
    {
      return isTopicInBloom2;
    }
  },
  isTopic: () => {
    {
      return isTopic2;
    }
  },
  isSubscriptionResult: () => {
    {
      return isSubscriptionResult;
    }
  },
  isResponseWithResult: () => {
    {
      return isResponseWithResult;
    }
  },
  isResponseWithNotification: () => {
    {
      return isResponseWithNotification;
    }
  },
  isResponseWithError: () => {
    {
      return isResponseWithError2;
    }
  },
  isResponseRpcError: () => {
    {
      return isResponseRpcError;
    }
  },
  isPromise: () => {
    {
      return isPromise;
    }
  },
  isNullish: () => {
    {
      return isNullish2;
    }
  },
  isInBloom: () => {
    {
      return isInBloom2;
    }
  },
  isHexStrict: () => {
    {
      return isHexStrict2;
    }
  },
  isHex: () => {
    {
      return isHex2;
    }
  },
  isDataFormat: () => {
    {
      return isDataFormat;
    }
  },
  isContractInitOptions: () => {
    {
      return isContractInitOptions;
    }
  },
  isContractAddressInBloom: () => {
    {
      return isContractAddressInBloom2;
    }
  },
  isBloom: () => {
    {
      return isBloom2;
    }
  },
  isBatchResponse: () => {
    {
      return isBatchResponse;
    }
  },
  isBatchRequest: () => {
    {
      return isBatchRequest;
    }
  },
  isAddress: () => {
    {
      return isAddress2;
    }
  },
  hexToUtf8: () => {
    {
      return hexToUtf8;
    }
  },
  hexToString: () => {
    {
      return hexToString;
    }
  },
  hexToNumberString: () => {
    {
      return hexToNumberString;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber2;
    }
  },
  hexToBytes: () => {
    {
      return hexToBytes;
    }
  },
  hexToAscii: () => {
    {
      return hexToAscii;
    }
  },
  getStorageSlotNumForLongString: () => {
    {
      return getStorageSlotNumForLongString;
    }
  },
  fromWei: () => {
    {
      return fromWei;
    }
  },
  fromUtf8: () => {
    {
      return fromUtf8;
    }
  },
  fromTwosComplement: () => {
    {
      return fromTwosComplement;
    }
  },
  fromDecimal: () => {
    {
      return fromDecimal;
    }
  },
  fromAscii: () => {
    {
      return fromAscii;
    }
  },
  format: () => {
    {
      return format;
    }
  },
  ethUnitMap: () => {
    {
      return ethUnitMap;
    }
  },
  encodePacked: () => {
    {
      return encodePacked;
    }
  },
  convertScalarValue: () => {
    {
      return convertScalarValue;
    }
  },
  convert: () => {
    {
      return convert;
    }
  },
  compareBlockNumbers: () => {
    {
      return compareBlockNumbers;
    }
  },
  checkAddressCheckSum: () => {
    {
      return checkAddressCheckSum2;
    }
  },
  bytesToUint8Array: () => {
    {
      return bytesToUint8Array;
    }
  },
  bytesToHex: () => {
    {
      return bytesToHex2;
    }
  },
  asciiToHex: () => {
    {
      return asciiToHex;
    }
  },
  Web3DeferredPromise: () => {
    {
      return Web3DeferredPromise;
    }
  },
  SocketProvider: () => {
    {
      return SocketProvider;
    }
  },
  EventEmitter: () => {
    {
      return EventEmitter2;
    }
  },
  Eip1193Provider: () => {
    {
      return Eip1193Provider;
    }
  },
  ChunkResponseParser: () => {
    {
      return ChunkResponseParser;
    }
  }
});

// node_modules/@noble/hashes/esm/_assert.js
var number = function(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
};
var bool = function(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
};
var isBytes = function(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
};
var bytes = function(b, ...lengths) {
  if (!isBytes(b))
    throw new Error("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
};
var hash = function(hash2) {
  if (typeof hash2 !== "function" || typeof hash2.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number(hash2.outputLen);
  number(hash2.blockLen);
};
var exists = function(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
};
var output = function(out, instance) {
  bytes(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
};
var assert = { number, bool, bytes, hash, exists, output };
var _assert_default = assert;

// node_modules/@noble/hashes/esm/_u64.js
var fromBig = function(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK64), l: Number(n >> _32n & U32_MASK64) };
  return { h: Number(n >> _32n & U32_MASK64) | 0, l: Number(n & U32_MASK64) | 0 };
};
var split = function(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
};
var add = function(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
};
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
var toBig = (h, l) => BigInt(h >>> 0) << _32n | BigInt(l >>> 0);
var shrSH = (h, _l, s) => h >>> s;
var shrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H = (_h, l) => l;
var rotr32L = (h, _l) => h;
var rotlSH = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL = (h, l, s) => h << s - 32 | l >>> 64 - s;
var add3L = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig,
  split,
  toBig,
  shrSH,
  shrSL,
  rotrSH,
  rotrSL,
  rotrBH,
  rotrBL,
  rotr32H,
  rotr32L,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add,
  add3L,
  add3H,
  add4L,
  add4H,
  add5H,
  add5L
};
var _u64_default = u64;

// node_modules/@noble/hashes/esm/cryptoNode.js
import * as nc from "crypto";
var crypto = nc && typeof nc === "object" && "webcrypto" in nc ? nc.webcrypto : undefined;

// node_modules/@noble/hashes/esm/utils.js
var isBytes2 = function(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
};
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  if (!isBytes2(data))
    throw new Error(`expected Uint8Array, got ${typeof data}`);
  return data;
}
function concatBytes(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes2(a))
      throw new Error("Uint8Array expected");
    sum += a.length;
  }
  const res = new Uint8Array(sum);
  for (let i = 0, pad = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function checkOpts(defaults, opts) {
  if (opts !== undefined && toStr.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function wrapXOFConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
function randomBytes(bytesLength = 32) {
  if (crypto && typeof crypto.getRandomValues === "function") {
    return crypto.getRandomValues(new Uint8Array(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u32 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr = (word, shift) => word << 32 - shift | word >>> shift;
var isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE)
  throw new Error("Non little-endian hardware is not supported");
class Hash {
  clone() {
    return this._cloneInto();
  }
}
var toStr = {}.toString;

// node_modules/@noble/hashes/esm/sha3.js
function keccakP(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL[t];
      const Th = rotlH(curH, curL, shift);
      const Tl = rotlL(curH, curL, shift);
      const PI = SHA3_PI[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H[round];
    s[1] ^= SHA3_IOTA_L[round];
  }
  B.fill(0);
}
var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _7n = BigInt(7);
var _256n = BigInt(256);
var _0x71n = BigInt(113);
for (let round = 0, R = _1n, x = 1, y = 0;round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI.push(2 * (5 * y + x));
  SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n ^ (R >> _7n) * _0x71n) % _256n;
    if (R & _2n)
      t ^= _1n << (_1n << BigInt(j)) - _1n;
  }
  _SHA3_IOTA.push(t);
}
var [SHA3_IOTA_H, SHA3_IOTA_L] = split(_SHA3_IOTA, true);
var rotlH = (h, l, s) => s > 32 ? rotlBH(h, l, s) : rotlSH(h, l, s);
var rotlL = (h, l, s) => s > 32 ? rotlBL(h, l, s) : rotlSL(h, l, s);

class Keccak extends Hash {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u32(this.state);
  }
  keccak() {
    keccakP(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data) {
    exists(this);
    const { blockLen, state } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    exists(this, false);
    bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes2) {
    number(bytes2);
    return this.xofInto(new Uint8Array(bytes2));
  }
  digestInto(out) {
    output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen = (suffix, blockLen, outputLen) => wrapConstructor(() => new Keccak(blockLen, suffix, outputLen));
var sha3_224 = gen(6, 144, 224 / 8);
var sha3_256 = gen(6, 136, 256 / 8);
var sha3_384 = gen(6, 104, 384 / 8);
var sha3_512 = gen(6, 72, 512 / 8);
var keccak_224 = gen(1, 144, 224 / 8);
var keccak_256 = gen(1, 136, 256 / 8);
var keccak_384 = gen(1, 104, 384 / 8);
var keccak_512 = gen(1, 72, 512 / 8);
var genShake = (suffix, blockLen, outputLen) => wrapXOFConstructorWithOpts((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake128 = genShake(31, 168, 128 / 8);
var shake256 = genShake(31, 136, 256 / 8);

// node_modules/ethereum-cryptography/esm/utils.js
function bytesToUtf8(data) {
  if (!(data instanceof Uint8Array)) {
    throw new TypeError(`bytesToUtf8 expected Uint8Array, got ${typeof data}`);
  }
  return new TextDecoder().decode(data);
}
function equalsBytes(a, b) {
  if (a.length !== b.length) {
    return false;
  }
  for (let i = 0;i < a.length; i++) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}
function wrapHash(hash2) {
  return (msg) => {
    _assert_default.bytes(msg);
    return hash2(msg);
  };
}
var assertBool = _assert_default.bool;
var assertBytes = _assert_default.bytes;
var crypto3 = (() => {
  const webCrypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : undefined;
  const nodeRequire = typeof module_utils !== "undefined" && typeof module_utils.require === "function" && module_utils.require.bind(module_utils);
  return {
    node: nodeRequire && !webCrypto ? nodeRequire("crypto") : undefined,
    web: webCrypto
  };
})();

// node_modules/ethereum-cryptography/esm/keccak.js
var keccak224 = wrapHash(keccak_224);
var keccak256 = (() => {
  const k = wrapHash(keccak_256);
  k.create = keccak_256.create;
  return k;
})();
var keccak384 = wrapHash(keccak_384);
var keccak512 = wrapHash(keccak_512);

// node_modules/zod/lib/index.mjs
var setErrorMap = function(map) {
  overrideErrorMap = map;
};
var getErrorMap = function() {
  return overrideErrorMap;
};
var addIssueToContext = function(ctx, issueData) {
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      ctx.schemaErrorMap,
      getErrorMap(),
      errorMap
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
};
var processCreateParams = function(params) {
  if (!params)
    return {};
  const { errorMap, invalid_type_error, required_error, description } = params;
  if (errorMap && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap)
    return { errorMap, description };
  const customMap = (iss, ctx) => {
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    if (typeof ctx.data === "undefined") {
      return { message: required_error !== null && required_error !== undefined ? required_error : ctx.defaultError };
    }
    return { message: invalid_type_error !== null && invalid_type_error !== undefined ? invalid_type_error : ctx.defaultError };
  };
  return { errorMap: customMap, description };
};
var isValidIP = function(ip, version) {
  if ((version === "v4" || !version) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version === "v6" || !version) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
};
var floatSafeRemainder = function(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
};
var deepPartialify = function(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: () => newShape
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
};
var mergeValues = function(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0;index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
};
var createZodEnum = function(values, params) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params)
  });
};
var util;
(function(util2) {
  util2.assertEqual = (val) => val;
  function assertIs(_arg) {
  }
  util2.assertIs = assertIs;
  function assertNever(_x) {
    throw new Error;
  }
  util2.assertNever = assertNever;
  util2.arrayToEnum = (items) => {
    const obj = {};
    for (const item of items) {
      obj[item] = item;
    }
    return obj;
  };
  util2.getValidEnumValues = (obj) => {
    const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
    const filtered = {};
    for (const k of validKeys) {
      filtered[k] = obj[k];
    }
    return util2.objectValues(filtered);
  };
  util2.objectValues = (obj) => {
    return util2.objectKeys(obj).map(function(e) {
      return obj[e];
    });
  };
  util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
    const keys = [];
    for (const key in object) {
      if (Object.prototype.hasOwnProperty.call(object, key)) {
        keys.push(key);
      }
    }
    return keys;
  };
  util2.find = (arr, checker) => {
    for (const item of arr) {
      if (checker(item))
        return item;
    }
    return;
  };
  util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
  function joinValues(array, separator = " | ") {
    return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
  }
  util2.joinValues = joinValues;
  util2.jsonStringifyReplacer = (_, value) => {
    if (typeof value === "bigint") {
      return value.toString();
    }
    return value;
  };
})(util || (util = {}));
var objectUtil;
(function(objectUtil2) {
  objectUtil2.mergeShapes = (first, second) => {
    return {
      ...first,
      ...second
    };
  };
})(objectUtil || (objectUtil = {}));
var ZodParsedType = util.arrayToEnum([
  "string",
  "nan",
  "number",
  "integer",
  "float",
  "boolean",
  "date",
  "bigint",
  "symbol",
  "function",
  "undefined",
  "null",
  "array",
  "object",
  "unknown",
  "promise",
  "void",
  "never",
  "map",
  "set"
]);
var getParsedType = (data) => {
  const t = typeof data;
  switch (t) {
    case "undefined":
      return ZodParsedType.undefined;
    case "string":
      return ZodParsedType.string;
    case "number":
      return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
    case "boolean":
      return ZodParsedType.boolean;
    case "function":
      return ZodParsedType.function;
    case "bigint":
      return ZodParsedType.bigint;
    case "symbol":
      return ZodParsedType.symbol;
    case "object":
      if (Array.isArray(data)) {
        return ZodParsedType.array;
      }
      if (data === null) {
        return ZodParsedType.null;
      }
      if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
        return ZodParsedType.promise;
      }
      if (typeof Map !== "undefined" && data instanceof Map) {
        return ZodParsedType.map;
      }
      if (typeof Set !== "undefined" && data instanceof Set) {
        return ZodParsedType.set;
      }
      if (typeof Date !== "undefined" && data instanceof Date) {
        return ZodParsedType.date;
      }
      return ZodParsedType.object;
    default:
      return ZodParsedType.unknown;
  }
};
var ZodIssueCode = util.arrayToEnum([
  "invalid_type",
  "invalid_literal",
  "custom",
  "invalid_union",
  "invalid_union_discriminator",
  "invalid_enum_value",
  "unrecognized_keys",
  "invalid_arguments",
  "invalid_return_type",
  "invalid_date",
  "invalid_string",
  "too_small",
  "too_big",
  "invalid_intersection_types",
  "not_multiple_of",
  "not_finite"
]);
var quotelessJson = (obj) => {
  const json = JSON.stringify(obj, null, 2);
  return json.replace(/"([^"]+)":/g, "$1:");
};

class ZodError extends Error {
  constructor(issues) {
    super();
    this.issues = [];
    this.addIssue = (sub) => {
      this.issues = [...this.issues, sub];
    };
    this.addIssues = (subs = []) => {
      this.issues = [...this.issues, ...subs];
    };
    const actualProto = new.target.prototype;
    if (Object.setPrototypeOf) {
      Object.setPrototypeOf(this, actualProto);
    } else {
      this.__proto__ = actualProto;
    }
    this.name = "ZodError";
    this.issues = issues;
  }
  get errors() {
    return this.issues;
  }
  format(_mapper) {
    const mapper = _mapper || function(issue) {
      return issue.message;
    };
    const fieldErrors = { _errors: [] };
    const processError = (error) => {
      for (const issue of error.issues) {
        if (issue.code === "invalid_union") {
          issue.unionErrors.map(processError);
        } else if (issue.code === "invalid_return_type") {
          processError(issue.returnTypeError);
        } else if (issue.code === "invalid_arguments") {
          processError(issue.argumentsError);
        } else if (issue.path.length === 0) {
          fieldErrors._errors.push(mapper(issue));
        } else {
          let curr = fieldErrors;
          let i = 0;
          while (i < issue.path.length) {
            const el = issue.path[i];
            const terminal = i === issue.path.length - 1;
            if (!terminal) {
              curr[el] = curr[el] || { _errors: [] };
            } else {
              curr[el] = curr[el] || { _errors: [] };
              curr[el]._errors.push(mapper(issue));
            }
            curr = curr[el];
            i++;
          }
        }
      }
    };
    processError(this);
    return fieldErrors;
  }
  toString() {
    return this.message;
  }
  get message() {
    return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
  }
  get isEmpty() {
    return this.issues.length === 0;
  }
  flatten(mapper = (issue) => issue.message) {
    const fieldErrors = {};
    const formErrors = [];
    for (const sub of this.issues) {
      if (sub.path.length > 0) {
        fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
        fieldErrors[sub.path[0]].push(mapper(sub));
      } else {
        formErrors.push(mapper(sub));
      }
    }
    return { formErrors, fieldErrors };
  }
  get formErrors() {
    return this.flatten();
  }
}
ZodError.create = (issues) => {
  const error = new ZodError(issues);
  return error;
};
var errorMap = (issue, _ctx) => {
  let message;
  switch (issue.code) {
    case ZodIssueCode.invalid_type:
      if (issue.received === ZodParsedType.undefined) {
        message = "Required";
      } else {
        message = `Expected ${issue.expected}, received ${issue.received}`;
      }
      break;
    case ZodIssueCode.invalid_literal:
      message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
      break;
    case ZodIssueCode.unrecognized_keys:
      message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
      break;
    case ZodIssueCode.invalid_union:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_union_discriminator:
      message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
      break;
    case ZodIssueCode.invalid_enum_value:
      message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
      break;
    case ZodIssueCode.invalid_arguments:
      message = `Invalid function arguments`;
      break;
    case ZodIssueCode.invalid_return_type:
      message = `Invalid function return type`;
      break;
    case ZodIssueCode.invalid_date:
      message = `Invalid date`;
      break;
    case ZodIssueCode.invalid_string:
      if (typeof issue.validation === "object") {
        if ("includes" in issue.validation) {
          message = `Invalid input: must include "${issue.validation.includes}"`;
          if (typeof issue.validation.position === "number") {
            message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
          }
        } else if ("startsWith" in issue.validation) {
          message = `Invalid input: must start with "${issue.validation.startsWith}"`;
        } else if ("endsWith" in issue.validation) {
          message = `Invalid input: must end with "${issue.validation.endsWith}"`;
        } else {
          util.assertNever(issue.validation);
        }
      } else if (issue.validation !== "regex") {
        message = `Invalid ${issue.validation}`;
      } else {
        message = "Invalid";
      }
      break;
    case ZodIssueCode.too_small:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.too_big:
      if (issue.type === "array")
        message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
      else if (issue.type === "string")
        message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
      else if (issue.type === "number")
        message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "bigint")
        message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
      else if (issue.type === "date")
        message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
      else
        message = "Invalid input";
      break;
    case ZodIssueCode.custom:
      message = `Invalid input`;
      break;
    case ZodIssueCode.invalid_intersection_types:
      message = `Intersection results could not be merged`;
      break;
    case ZodIssueCode.not_multiple_of:
      message = `Number must be a multiple of ${issue.multipleOf}`;
      break;
    case ZodIssueCode.not_finite:
      message = "Number must be finite";
      break;
    default:
      message = _ctx.defaultError;
      util.assertNever(issue);
  }
  return { message };
};
var overrideErrorMap = errorMap;
var makeIssue = (params) => {
  const { data, path, errorMaps, issueData } = params;
  const fullPath = [...path, ...issueData.path || []];
  const fullIssue = {
    ...issueData,
    path: fullPath
  };
  let errorMessage = "";
  const maps = errorMaps.filter((m) => !!m).slice().reverse();
  for (const map of maps) {
    errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
  }
  return {
    ...issueData,
    path: fullPath,
    message: issueData.message || errorMessage
  };
};
var EMPTY_PATH = [];

class ParseStatus {
  constructor() {
    this.value = "valid";
  }
  dirty() {
    if (this.value === "valid")
      this.value = "dirty";
  }
  abort() {
    if (this.value !== "aborted")
      this.value = "aborted";
  }
  static mergeArray(status, results) {
    const arrayValue = [];
    for (const s of results) {
      if (s.status === "aborted")
        return INVALID;
      if (s.status === "dirty")
        status.dirty();
      arrayValue.push(s.value);
    }
    return { status: status.value, value: arrayValue };
  }
  static async mergeObjectAsync(status, pairs) {
    const syncPairs = [];
    for (const pair of pairs) {
      syncPairs.push({
        key: await pair.key,
        value: await pair.value
      });
    }
    return ParseStatus.mergeObjectSync(status, syncPairs);
  }
  static mergeObjectSync(status, pairs) {
    const finalObject = {};
    for (const pair of pairs) {
      const { key, value } = pair;
      if (key.status === "aborted")
        return INVALID;
      if (value.status === "aborted")
        return INVALID;
      if (key.status === "dirty")
        status.dirty();
      if (value.status === "dirty")
        status.dirty();
      if (key.value !== "__proto__" && (typeof value.value !== "undefined" || pair.alwaysSet)) {
        finalObject[key.value] = value.value;
      }
    }
    return { status: status.value, value: finalObject };
  }
}
var INVALID = Object.freeze({
  status: "aborted"
});
var DIRTY = (value) => ({ status: "dirty", value });
var OK = (value) => ({ status: "valid", value });
var isAborted = (x) => x.status === "aborted";
var isDirty = (x) => x.status === "dirty";
var isValid = (x) => x.status === "valid";
var isAsync = (x) => typeof Promise !== "undefined" && x instanceof Promise;
var errorUtil;
(function(errorUtil2) {
  errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
  errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === undefined ? undefined : message.message;
})(errorUtil || (errorUtil = {}));

class ParseInputLazyPath {
  constructor(parent, value, path, key) {
    this._cachedPath = [];
    this.parent = parent;
    this.data = value;
    this._path = path;
    this._key = key;
  }
  get path() {
    if (!this._cachedPath.length) {
      if (this._key instanceof Array) {
        this._cachedPath.push(...this._path, ...this._key);
      } else {
        this._cachedPath.push(...this._path, this._key);
      }
    }
    return this._cachedPath;
  }
}
var handleResult = (ctx, result) => {
  if (isValid(result)) {
    return { success: true, data: result.value };
  } else {
    if (!ctx.common.issues.length) {
      throw new Error("Validation failed but no issues detected.");
    }
    return {
      success: false,
      get error() {
        if (this._error)
          return this._error;
        const error = new ZodError(ctx.common.issues);
        this._error = error;
        return this._error;
      }
    };
  }
};

class ZodType {
  constructor(def) {
    this.spa = this.safeParseAsync;
    this._def = def;
    this.parse = this.parse.bind(this);
    this.safeParse = this.safeParse.bind(this);
    this.parseAsync = this.parseAsync.bind(this);
    this.safeParseAsync = this.safeParseAsync.bind(this);
    this.spa = this.spa.bind(this);
    this.refine = this.refine.bind(this);
    this.refinement = this.refinement.bind(this);
    this.superRefine = this.superRefine.bind(this);
    this.optional = this.optional.bind(this);
    this.nullable = this.nullable.bind(this);
    this.nullish = this.nullish.bind(this);
    this.array = this.array.bind(this);
    this.promise = this.promise.bind(this);
    this.or = this.or.bind(this);
    this.and = this.and.bind(this);
    this.transform = this.transform.bind(this);
    this.brand = this.brand.bind(this);
    this.default = this.default.bind(this);
    this.catch = this.catch.bind(this);
    this.describe = this.describe.bind(this);
    this.pipe = this.pipe.bind(this);
    this.readonly = this.readonly.bind(this);
    this.isNullable = this.isNullable.bind(this);
    this.isOptional = this.isOptional.bind(this);
  }
  get description() {
    return this._def.description;
  }
  _getType(input) {
    return getParsedType(input.data);
  }
  _getOrReturnCtx(input, ctx) {
    return ctx || {
      common: input.parent.common,
      data: input.data,
      parsedType: getParsedType(input.data),
      schemaErrorMap: this._def.errorMap,
      path: input.path,
      parent: input.parent
    };
  }
  _processInputParams(input) {
    return {
      status: new ParseStatus,
      ctx: {
        common: input.parent.common,
        data: input.data,
        parsedType: getParsedType(input.data),
        schemaErrorMap: this._def.errorMap,
        path: input.path,
        parent: input.parent
      }
    };
  }
  _parseSync(input) {
    const result = this._parse(input);
    if (isAsync(result)) {
      throw new Error("Synchronous parse encountered promise.");
    }
    return result;
  }
  _parseAsync(input) {
    const result = this._parse(input);
    return Promise.resolve(result);
  }
  parse(data, params) {
    const result = this.safeParse(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  safeParse(data, params) {
    var _a;
    const ctx = {
      common: {
        issues: [],
        async: (_a = params === null || params === undefined ? undefined : params.async) !== null && _a !== undefined ? _a : false,
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const result = this._parseSync({ data, path: ctx.path, parent: ctx });
    return handleResult(ctx, result);
  }
  async parseAsync(data, params) {
    const result = await this.safeParseAsync(data, params);
    if (result.success)
      return result.data;
    throw result.error;
  }
  async safeParseAsync(data, params) {
    const ctx = {
      common: {
        issues: [],
        contextualErrorMap: params === null || params === undefined ? undefined : params.errorMap,
        async: true
      },
      path: (params === null || params === undefined ? undefined : params.path) || [],
      schemaErrorMap: this._def.errorMap,
      parent: null,
      data,
      parsedType: getParsedType(data)
    };
    const maybeAsyncResult = this._parse({ data, path: ctx.path, parent: ctx });
    const result = await (isAsync(maybeAsyncResult) ? maybeAsyncResult : Promise.resolve(maybeAsyncResult));
    return handleResult(ctx, result);
  }
  refine(check, message) {
    const getIssueProperties = (val) => {
      if (typeof message === "string" || typeof message === "undefined") {
        return { message };
      } else if (typeof message === "function") {
        return message(val);
      } else {
        return message;
      }
    };
    return this._refinement((val, ctx) => {
      const result = check(val);
      const setError = () => ctx.addIssue({
        code: ZodIssueCode.custom,
        ...getIssueProperties(val)
      });
      if (typeof Promise !== "undefined" && result instanceof Promise) {
        return result.then((data) => {
          if (!data) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      if (!result) {
        setError();
        return false;
      } else {
        return true;
      }
    });
  }
  refinement(check, refinementData) {
    return this._refinement((val, ctx) => {
      if (!check(val)) {
        ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
        return false;
      } else {
        return true;
      }
    });
  }
  _refinement(refinement) {
    return new ZodEffects({
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "refinement", refinement }
    });
  }
  superRefine(refinement) {
    return this._refinement(refinement);
  }
  optional() {
    return ZodOptional.create(this, this._def);
  }
  nullable() {
    return ZodNullable.create(this, this._def);
  }
  nullish() {
    return this.nullable().optional();
  }
  array() {
    return ZodArray.create(this, this._def);
  }
  promise() {
    return ZodPromise.create(this, this._def);
  }
  or(option) {
    return ZodUnion.create([this, option], this._def);
  }
  and(incoming) {
    return ZodIntersection.create(this, incoming, this._def);
  }
  transform(transform) {
    return new ZodEffects({
      ...processCreateParams(this._def),
      schema: this,
      typeName: ZodFirstPartyTypeKind.ZodEffects,
      effect: { type: "transform", transform }
    });
  }
  default(def) {
    const defaultValueFunc = typeof def === "function" ? def : () => def;
    return new ZodDefault({
      ...processCreateParams(this._def),
      innerType: this,
      defaultValue: defaultValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodDefault
    });
  }
  brand() {
    return new ZodBranded({
      typeName: ZodFirstPartyTypeKind.ZodBranded,
      type: this,
      ...processCreateParams(this._def)
    });
  }
  catch(def) {
    const catchValueFunc = typeof def === "function" ? def : () => def;
    return new ZodCatch({
      ...processCreateParams(this._def),
      innerType: this,
      catchValue: catchValueFunc,
      typeName: ZodFirstPartyTypeKind.ZodCatch
    });
  }
  describe(description) {
    const This = this.constructor;
    return new This({
      ...this._def,
      description
    });
  }
  pipe(target) {
    return ZodPipeline.create(this, target);
  }
  readonly() {
    return ZodReadonly.create(this);
  }
  isOptional() {
    return this.safeParse(undefined).success;
  }
  isNullable() {
    return this.safeParse(null).success;
  }
}
var cuidRegex = /^c[^\s-]{8,}$/i;
var cuid2Regex = /^[a-z][a-z0-9]*$/;
var ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/;
var uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
var emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_+-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
var _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+\$`;
var emojiRegex;
var ipv4Regex = /^(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))$/;
var ipv6Regex = /^(([a-f0-9]{1,4}:){7}|::([a-f0-9]{1,4}:){0,6}|([a-f0-9]{1,4}:){1}:([a-f0-9]{1,4}:){0,5}|([a-f0-9]{1,4}:){2}:([a-f0-9]{1,4}:){0,4}|([a-f0-9]{1,4}:){3}:([a-f0-9]{1,4}:){0,3}|([a-f0-9]{1,4}:){4}:([a-f0-9]{1,4}:){0,2}|([a-f0-9]{1,4}:){5}:([a-f0-9]{1,4}:){0,1})([a-f0-9]{1,4}|(((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2}))\.){3}((25[0-5])|(2[0-4][0-9])|(1[0-9]{2})|([0-9]{1,2})))$/;
var datetimeRegex = (args) => {
  if (args.precision) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}\\.\\d{${args.precision}}Z\$`);
    }
  } else if (args.precision === 0) {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}Z\$`);
    }
  } else {
    if (args.offset) {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?(([+-]\\d{2}(:?\\d{2})?)|Z)\$`);
    } else {
      return new RegExp(`^\\d{4}-\\d{2}-\\d{2}T\\d{2}:\\d{2}:\\d{2}(\\.\\d+)?Z\$`);
    }
  }
};

class ZodString extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = String(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.string) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.string,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.length < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.length > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "string",
            inclusive: true,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "length") {
        const tooBig = input.data.length > check.value;
        const tooSmall = input.data.length < check.value;
        if (tooBig || tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          if (tooBig) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          } else if (tooSmall) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: check.value,
              type: "string",
              inclusive: true,
              exact: true,
              message: check.message
            });
          }
          status.dirty();
        }
      } else if (check.kind === "email") {
        if (!emailRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "email",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "emoji") {
        if (!emojiRegex) {
          emojiRegex = new RegExp(_emojiRegex, "u");
        }
        if (!emojiRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "emoji",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "uuid") {
        if (!uuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "uuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid") {
        if (!cuidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "cuid2") {
        if (!cuid2Regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "cuid2",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ulid") {
        if (!ulidRegex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ulid",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "url") {
        try {
          new URL(input.data);
        } catch (_a) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "url",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "regex") {
        check.regex.lastIndex = 0;
        const testResult = check.regex.test(input.data);
        if (!testResult) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "regex",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "trim") {
        input.data = input.data.trim();
      } else if (check.kind === "includes") {
        if (!input.data.includes(check.value, check.position)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { includes: check.value, position: check.position },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "toLowerCase") {
        input.data = input.data.toLowerCase();
      } else if (check.kind === "toUpperCase") {
        input.data = input.data.toUpperCase();
      } else if (check.kind === "startsWith") {
        if (!input.data.startsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { startsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "endsWith") {
        if (!input.data.endsWith(check.value)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: { endsWith: check.value },
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "datetime") {
        const regex = datetimeRegex(check);
        if (!regex.test(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_string,
            validation: "datetime",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "ip") {
        if (!isValidIP(input.data, check.version)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            validation: "ip",
            code: ZodIssueCode.invalid_string,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  _regex(regex, validation, message) {
    return this.refinement((data) => regex.test(data), {
      validation,
      code: ZodIssueCode.invalid_string,
      ...errorUtil.errToObj(message)
    });
  }
  _addCheck(check) {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  email(message) {
    return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
  }
  url(message) {
    return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
  }
  emoji(message) {
    return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
  }
  uuid(message) {
    return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
  }
  cuid(message) {
    return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
  }
  cuid2(message) {
    return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
  }
  ulid(message) {
    return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
  }
  ip(options) {
    return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
  }
  datetime(options) {
    var _a;
    if (typeof options === "string") {
      return this._addCheck({
        kind: "datetime",
        precision: null,
        offset: false,
        message: options
      });
    }
    return this._addCheck({
      kind: "datetime",
      precision: typeof (options === null || options === undefined ? undefined : options.precision) === "undefined" ? null : options === null || options === undefined ? undefined : options.precision,
      offset: (_a = options === null || options === undefined ? undefined : options.offset) !== null && _a !== undefined ? _a : false,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  regex(regex, message) {
    return this._addCheck({
      kind: "regex",
      regex,
      ...errorUtil.errToObj(message)
    });
  }
  includes(value, options) {
    return this._addCheck({
      kind: "includes",
      value,
      position: options === null || options === undefined ? undefined : options.position,
      ...errorUtil.errToObj(options === null || options === undefined ? undefined : options.message)
    });
  }
  startsWith(value, message) {
    return this._addCheck({
      kind: "startsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  endsWith(value, message) {
    return this._addCheck({
      kind: "endsWith",
      value,
      ...errorUtil.errToObj(message)
    });
  }
  min(minLength, message) {
    return this._addCheck({
      kind: "min",
      value: minLength,
      ...errorUtil.errToObj(message)
    });
  }
  max(maxLength, message) {
    return this._addCheck({
      kind: "max",
      value: maxLength,
      ...errorUtil.errToObj(message)
    });
  }
  length(len, message) {
    return this._addCheck({
      kind: "length",
      value: len,
      ...errorUtil.errToObj(message)
    });
  }
  nonempty(message) {
    return this.min(1, errorUtil.errToObj(message));
  }
  trim() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "trim" }]
    });
  }
  toLowerCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toLowerCase" }]
    });
  }
  toUpperCase() {
    return new ZodString({
      ...this._def,
      checks: [...this._def.checks, { kind: "toUpperCase" }]
    });
  }
  get isDatetime() {
    return !!this._def.checks.find((ch) => ch.kind === "datetime");
  }
  get isEmail() {
    return !!this._def.checks.find((ch) => ch.kind === "email");
  }
  get isURL() {
    return !!this._def.checks.find((ch) => ch.kind === "url");
  }
  get isEmoji() {
    return !!this._def.checks.find((ch) => ch.kind === "emoji");
  }
  get isUUID() {
    return !!this._def.checks.find((ch) => ch.kind === "uuid");
  }
  get isCUID() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid");
  }
  get isCUID2() {
    return !!this._def.checks.find((ch) => ch.kind === "cuid2");
  }
  get isULID() {
    return !!this._def.checks.find((ch) => ch.kind === "ulid");
  }
  get isIP() {
    return !!this._def.checks.find((ch) => ch.kind === "ip");
  }
  get minLength() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxLength() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodString.create = (params) => {
  var _a;
  return new ZodString({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodString,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodNumber extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
    this.step = this.multipleOf;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = Number(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.number) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.number,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "int") {
        if (!util.isInteger(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: "integer",
            received: "float",
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: check.value,
            type: "number",
            inclusive: check.inclusive,
            exact: false,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (floatSafeRemainder(input.data, check.value) !== 0) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "finite") {
        if (!Number.isFinite(input.data)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_finite,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodNumber({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodNumber({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  int(message) {
    return this._addCheck({
      kind: "int",
      message: errorUtil.toString(message)
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: 0,
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  finite(message) {
    return this._addCheck({
      kind: "finite",
      message: errorUtil.toString(message)
    });
  }
  safe(message) {
    return this._addCheck({
      kind: "min",
      inclusive: true,
      value: Number.MIN_SAFE_INTEGER,
      message: errorUtil.toString(message)
    })._addCheck({
      kind: "max",
      inclusive: true,
      value: Number.MAX_SAFE_INTEGER,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
  get isInt() {
    return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
  }
  get isFinite() {
    let max = null, min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
        return true;
      } else if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      } else if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return Number.isFinite(min) && Number.isFinite(max);
  }
}
ZodNumber.create = (params) => {
  return new ZodNumber({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodNumber,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodBigInt extends ZodType {
  constructor() {
    super(...arguments);
    this.min = this.gte;
    this.max = this.lte;
  }
  _parse(input) {
    if (this._def.coerce) {
      input.data = BigInt(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.bigint) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.bigint,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    let ctx = undefined;
    const status = new ParseStatus;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
        if (tooSmall) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            type: "bigint",
            minimum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
        if (tooBig) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            type: "bigint",
            maximum: check.value,
            inclusive: check.inclusive,
            message: check.message
          });
          status.dirty();
        }
      } else if (check.kind === "multipleOf") {
        if (input.data % check.value !== BigInt(0)) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.not_multiple_of,
            multipleOf: check.value,
            message: check.message
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return { status: status.value, value: input.data };
  }
  gte(value, message) {
    return this.setLimit("min", value, true, errorUtil.toString(message));
  }
  gt(value, message) {
    return this.setLimit("min", value, false, errorUtil.toString(message));
  }
  lte(value, message) {
    return this.setLimit("max", value, true, errorUtil.toString(message));
  }
  lt(value, message) {
    return this.setLimit("max", value, false, errorUtil.toString(message));
  }
  setLimit(kind, value, inclusive, message) {
    return new ZodBigInt({
      ...this._def,
      checks: [
        ...this._def.checks,
        {
          kind,
          value,
          inclusive,
          message: errorUtil.toString(message)
        }
      ]
    });
  }
  _addCheck(check) {
    return new ZodBigInt({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  positive(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  negative(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: false,
      message: errorUtil.toString(message)
    });
  }
  nonpositive(message) {
    return this._addCheck({
      kind: "max",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  nonnegative(message) {
    return this._addCheck({
      kind: "min",
      value: BigInt(0),
      inclusive: true,
      message: errorUtil.toString(message)
    });
  }
  multipleOf(value, message) {
    return this._addCheck({
      kind: "multipleOf",
      value,
      message: errorUtil.toString(message)
    });
  }
  get minValue() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min;
  }
  get maxValue() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max;
  }
}
ZodBigInt.create = (params) => {
  var _a;
  return new ZodBigInt({
    checks: [],
    typeName: ZodFirstPartyTypeKind.ZodBigInt,
    coerce: (_a = params === null || params === undefined ? undefined : params.coerce) !== null && _a !== undefined ? _a : false,
    ...processCreateParams(params)
  });
};

class ZodBoolean extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = Boolean(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.boolean) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.boolean,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodBoolean.create = (params) => {
  return new ZodBoolean({
    typeName: ZodFirstPartyTypeKind.ZodBoolean,
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    ...processCreateParams(params)
  });
};

class ZodDate extends ZodType {
  _parse(input) {
    if (this._def.coerce) {
      input.data = new Date(input.data);
    }
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.date) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.date,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    if (isNaN(input.data.getTime())) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_date
      });
      return INVALID;
    }
    const status = new ParseStatus;
    let ctx = undefined;
    for (const check of this._def.checks) {
      if (check.kind === "min") {
        if (input.data.getTime() < check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            message: check.message,
            inclusive: true,
            exact: false,
            minimum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else if (check.kind === "max") {
        if (input.data.getTime() > check.value) {
          ctx = this._getOrReturnCtx(input, ctx);
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            message: check.message,
            inclusive: true,
            exact: false,
            maximum: check.value,
            type: "date"
          });
          status.dirty();
        }
      } else {
        util.assertNever(check);
      }
    }
    return {
      status: status.value,
      value: new Date(input.data.getTime())
    };
  }
  _addCheck(check) {
    return new ZodDate({
      ...this._def,
      checks: [...this._def.checks, check]
    });
  }
  min(minDate, message) {
    return this._addCheck({
      kind: "min",
      value: minDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  max(maxDate, message) {
    return this._addCheck({
      kind: "max",
      value: maxDate.getTime(),
      message: errorUtil.toString(message)
    });
  }
  get minDate() {
    let min = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "min") {
        if (min === null || ch.value > min)
          min = ch.value;
      }
    }
    return min != null ? new Date(min) : null;
  }
  get maxDate() {
    let max = null;
    for (const ch of this._def.checks) {
      if (ch.kind === "max") {
        if (max === null || ch.value < max)
          max = ch.value;
      }
    }
    return max != null ? new Date(max) : null;
  }
}
ZodDate.create = (params) => {
  return new ZodDate({
    checks: [],
    coerce: (params === null || params === undefined ? undefined : params.coerce) || false,
    typeName: ZodFirstPartyTypeKind.ZodDate,
    ...processCreateParams(params)
  });
};

class ZodSymbol extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.symbol) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.symbol,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodSymbol.create = (params) => {
  return new ZodSymbol({
    typeName: ZodFirstPartyTypeKind.ZodSymbol,
    ...processCreateParams(params)
  });
};

class ZodUndefined extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.undefined,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodUndefined.create = (params) => {
  return new ZodUndefined({
    typeName: ZodFirstPartyTypeKind.ZodUndefined,
    ...processCreateParams(params)
  });
};

class ZodNull extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.null) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.null,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodNull.create = (params) => {
  return new ZodNull({
    typeName: ZodFirstPartyTypeKind.ZodNull,
    ...processCreateParams(params)
  });
};

class ZodAny extends ZodType {
  constructor() {
    super(...arguments);
    this._any = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodAny.create = (params) => {
  return new ZodAny({
    typeName: ZodFirstPartyTypeKind.ZodAny,
    ...processCreateParams(params)
  });
};

class ZodUnknown extends ZodType {
  constructor() {
    super(...arguments);
    this._unknown = true;
  }
  _parse(input) {
    return OK(input.data);
  }
}
ZodUnknown.create = (params) => {
  return new ZodUnknown({
    typeName: ZodFirstPartyTypeKind.ZodUnknown,
    ...processCreateParams(params)
  });
};

class ZodNever extends ZodType {
  _parse(input) {
    const ctx = this._getOrReturnCtx(input);
    addIssueToContext(ctx, {
      code: ZodIssueCode.invalid_type,
      expected: ZodParsedType.never,
      received: ctx.parsedType
    });
    return INVALID;
  }
}
ZodNever.create = (params) => {
  return new ZodNever({
    typeName: ZodFirstPartyTypeKind.ZodNever,
    ...processCreateParams(params)
  });
};

class ZodVoid extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.undefined) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.void,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return OK(input.data);
  }
}
ZodVoid.create = (params) => {
  return new ZodVoid({
    typeName: ZodFirstPartyTypeKind.ZodVoid,
    ...processCreateParams(params)
  });
};

class ZodArray extends ZodType {
  _parse(input) {
    const { ctx, status } = this._processInputParams(input);
    const def = this._def;
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (def.exactLength !== null) {
      const tooBig = ctx.data.length > def.exactLength.value;
      const tooSmall = ctx.data.length < def.exactLength.value;
      if (tooBig || tooSmall) {
        addIssueToContext(ctx, {
          code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
          minimum: tooSmall ? def.exactLength.value : undefined,
          maximum: tooBig ? def.exactLength.value : undefined,
          type: "array",
          inclusive: true,
          exact: true,
          message: def.exactLength.message
        });
        status.dirty();
      }
    }
    if (def.minLength !== null) {
      if (ctx.data.length < def.minLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.minLength.message
        });
        status.dirty();
      }
    }
    if (def.maxLength !== null) {
      if (ctx.data.length > def.maxLength.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxLength.value,
          type: "array",
          inclusive: true,
          exact: false,
          message: def.maxLength.message
        });
        status.dirty();
      }
    }
    if (ctx.common.async) {
      return Promise.all([...ctx.data].map((item, i) => {
        return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
      })).then((result2) => {
        return ParseStatus.mergeArray(status, result2);
      });
    }
    const result = [...ctx.data].map((item, i) => {
      return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
    });
    return ParseStatus.mergeArray(status, result);
  }
  get element() {
    return this._def.type;
  }
  min(minLength, message) {
    return new ZodArray({
      ...this._def,
      minLength: { value: minLength, message: errorUtil.toString(message) }
    });
  }
  max(maxLength, message) {
    return new ZodArray({
      ...this._def,
      maxLength: { value: maxLength, message: errorUtil.toString(message) }
    });
  }
  length(len, message) {
    return new ZodArray({
      ...this._def,
      exactLength: { value: len, message: errorUtil.toString(message) }
    });
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodArray.create = (schema, params) => {
  return new ZodArray({
    type: schema,
    minLength: null,
    maxLength: null,
    exactLength: null,
    typeName: ZodFirstPartyTypeKind.ZodArray,
    ...processCreateParams(params)
  });
};

class ZodObject extends ZodType {
  constructor() {
    super(...arguments);
    this._cached = null;
    this.nonstrict = this.passthrough;
    this.augment = this.extend;
  }
  _getCached() {
    if (this._cached !== null)
      return this._cached;
    const shape = this._def.shape();
    const keys = util.objectKeys(shape);
    return this._cached = { shape, keys };
  }
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.object) {
      const ctx2 = this._getOrReturnCtx(input);
      addIssueToContext(ctx2, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx2.parsedType
      });
      return INVALID;
    }
    const { status, ctx } = this._processInputParams(input);
    const { shape, keys: shapeKeys } = this._getCached();
    const extraKeys = [];
    if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
      for (const key in ctx.data) {
        if (!shapeKeys.includes(key)) {
          extraKeys.push(key);
        }
      }
    }
    const pairs = [];
    for (const key of shapeKeys) {
      const keyValidator = shape[key];
      const value = ctx.data[key];
      pairs.push({
        key: { status: "valid", value: key },
        value: keyValidator._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
        alwaysSet: key in ctx.data
      });
    }
    if (this._def.catchall instanceof ZodNever) {
      const unknownKeys = this._def.unknownKeys;
      if (unknownKeys === "passthrough") {
        for (const key of extraKeys) {
          pairs.push({
            key: { status: "valid", value: key },
            value: { status: "valid", value: ctx.data[key] }
          });
        }
      } else if (unknownKeys === "strict") {
        if (extraKeys.length > 0) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.unrecognized_keys,
            keys: extraKeys
          });
          status.dirty();
        }
      } else if (unknownKeys === "strip")
        ;
      else {
        throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
      }
    } else {
      const catchall = this._def.catchall;
      for (const key of extraKeys) {
        const value = ctx.data[key];
        pairs.push({
          key: { status: "valid", value: key },
          value: catchall._parse(new ParseInputLazyPath(ctx, value, ctx.path, key)),
          alwaysSet: key in ctx.data
        });
      }
    }
    if (ctx.common.async) {
      return Promise.resolve().then(async () => {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          syncPairs.push({
            key,
            value: await pair.value,
            alwaysSet: pair.alwaysSet
          });
        }
        return syncPairs;
      }).then((syncPairs) => {
        return ParseStatus.mergeObjectSync(status, syncPairs);
      });
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get shape() {
    return this._def.shape();
  }
  strict(message) {
    errorUtil.errToObj;
    return new ZodObject({
      ...this._def,
      unknownKeys: "strict",
      ...message !== undefined ? {
        errorMap: (issue, ctx) => {
          var _a, _b, _c, _d;
          const defaultError = (_c = (_b = (_a = this._def).errorMap) === null || _b === undefined ? undefined : _b.call(_a, issue, ctx).message) !== null && _c !== undefined ? _c : ctx.defaultError;
          if (issue.code === "unrecognized_keys")
            return {
              message: (_d = errorUtil.errToObj(message).message) !== null && _d !== undefined ? _d : defaultError
            };
          return {
            message: defaultError
          };
        }
      } : {}
    });
  }
  strip() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "strip"
    });
  }
  passthrough() {
    return new ZodObject({
      ...this._def,
      unknownKeys: "passthrough"
    });
  }
  extend(augmentation) {
    return new ZodObject({
      ...this._def,
      shape: () => ({
        ...this._def.shape(),
        ...augmentation
      })
    });
  }
  merge(merging) {
    const merged = new ZodObject({
      unknownKeys: merging._def.unknownKeys,
      catchall: merging._def.catchall,
      shape: () => ({
        ...this._def.shape(),
        ...merging._def.shape()
      }),
      typeName: ZodFirstPartyTypeKind.ZodObject
    });
    return merged;
  }
  setKey(key, schema) {
    return this.augment({ [key]: schema });
  }
  catchall(index) {
    return new ZodObject({
      ...this._def,
      catchall: index
    });
  }
  pick(mask) {
    const shape = {};
    util.objectKeys(mask).forEach((key) => {
      if (mask[key] && this.shape[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  omit(mask) {
    const shape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (!mask[key]) {
        shape[key] = this.shape[key];
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => shape
    });
  }
  deepPartial() {
    return deepPartialify(this);
  }
  partial(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      const fieldSchema = this.shape[key];
      if (mask && !mask[key]) {
        newShape[key] = fieldSchema;
      } else {
        newShape[key] = fieldSchema.optional();
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  required(mask) {
    const newShape = {};
    util.objectKeys(this.shape).forEach((key) => {
      if (mask && !mask[key]) {
        newShape[key] = this.shape[key];
      } else {
        const fieldSchema = this.shape[key];
        let newField = fieldSchema;
        while (newField instanceof ZodOptional) {
          newField = newField._def.innerType;
        }
        newShape[key] = newField;
      }
    });
    return new ZodObject({
      ...this._def,
      shape: () => newShape
    });
  }
  keyof() {
    return createZodEnum(util.objectKeys(this.shape));
  }
}
ZodObject.create = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.strictCreate = (shape, params) => {
  return new ZodObject({
    shape: () => shape,
    unknownKeys: "strict",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};
ZodObject.lazycreate = (shape, params) => {
  return new ZodObject({
    shape,
    unknownKeys: "strip",
    catchall: ZodNever.create(),
    typeName: ZodFirstPartyTypeKind.ZodObject,
    ...processCreateParams(params)
  });
};

class ZodUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const options = this._def.options;
    function handleResults(results) {
      for (const result of results) {
        if (result.result.status === "valid") {
          return result.result;
        }
      }
      for (const result of results) {
        if (result.result.status === "dirty") {
          ctx.common.issues.push(...result.ctx.common.issues);
          return result.result;
        }
      }
      const unionErrors = results.map((result) => new ZodError(result.ctx.common.issues));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return Promise.all(options.map(async (option) => {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        return {
          result: await option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: childCtx
          }),
          ctx: childCtx
        };
      })).then(handleResults);
    } else {
      let dirty = undefined;
      const issues = [];
      for (const option of options) {
        const childCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          },
          parent: null
        };
        const result = option._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: childCtx
        });
        if (result.status === "valid") {
          return result;
        } else if (result.status === "dirty" && !dirty) {
          dirty = { result, ctx: childCtx };
        }
        if (childCtx.common.issues.length) {
          issues.push(childCtx.common.issues);
        }
      }
      if (dirty) {
        ctx.common.issues.push(...dirty.ctx.common.issues);
        return dirty.result;
      }
      const unionErrors = issues.map((issues2) => new ZodError(issues2));
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union,
        unionErrors
      });
      return INVALID;
    }
  }
  get options() {
    return this._def.options;
  }
}
ZodUnion.create = (types, params) => {
  return new ZodUnion({
    options: types,
    typeName: ZodFirstPartyTypeKind.ZodUnion,
    ...processCreateParams(params)
  });
};
var getDiscriminator = (type) => {
  if (type instanceof ZodLazy) {
    return getDiscriminator(type.schema);
  } else if (type instanceof ZodEffects) {
    return getDiscriminator(type.innerType());
  } else if (type instanceof ZodLiteral) {
    return [type.value];
  } else if (type instanceof ZodEnum) {
    return type.options;
  } else if (type instanceof ZodNativeEnum) {
    return Object.keys(type.enum);
  } else if (type instanceof ZodDefault) {
    return getDiscriminator(type._def.innerType);
  } else if (type instanceof ZodUndefined) {
    return [undefined];
  } else if (type instanceof ZodNull) {
    return [null];
  } else {
    return null;
  }
};

class ZodDiscriminatedUnion extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const discriminator = this.discriminator;
    const discriminatorValue = ctx.data[discriminator];
    const option = this.optionsMap.get(discriminatorValue);
    if (!option) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_union_discriminator,
        options: Array.from(this.optionsMap.keys()),
        path: [discriminator]
      });
      return INVALID;
    }
    if (ctx.common.async) {
      return option._parseAsync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    } else {
      return option._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
    }
  }
  get discriminator() {
    return this._def.discriminator;
  }
  get options() {
    return this._def.options;
  }
  get optionsMap() {
    return this._def.optionsMap;
  }
  static create(discriminator, options, params) {
    const optionsMap = new Map;
    for (const type of options) {
      const discriminatorValues = getDiscriminator(type.shape[discriminator]);
      if (!discriminatorValues) {
        throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
      }
      for (const value of discriminatorValues) {
        if (optionsMap.has(value)) {
          throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value)}`);
        }
        optionsMap.set(value, type);
      }
    }
    return new ZodDiscriminatedUnion({
      typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
      discriminator,
      options,
      optionsMap,
      ...processCreateParams(params)
    });
  }
}

class ZodIntersection extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const handleParsed = (parsedLeft, parsedRight) => {
      if (isAborted(parsedLeft) || isAborted(parsedRight)) {
        return INVALID;
      }
      const merged = mergeValues(parsedLeft.value, parsedRight.value);
      if (!merged.valid) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_intersection_types
        });
        return INVALID;
      }
      if (isDirty(parsedLeft) || isDirty(parsedRight)) {
        status.dirty();
      }
      return { status: status.value, value: merged.data };
    };
    if (ctx.common.async) {
      return Promise.all([
        this._def.left._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        }),
        this._def.right._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        })
      ]).then(([left, right]) => handleParsed(left, right));
    } else {
      return handleParsed(this._def.left._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }), this._def.right._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      }));
    }
  }
}
ZodIntersection.create = (left, right, params) => {
  return new ZodIntersection({
    left,
    right,
    typeName: ZodFirstPartyTypeKind.ZodIntersection,
    ...processCreateParams(params)
  });
};

class ZodTuple extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.array) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.array,
        received: ctx.parsedType
      });
      return INVALID;
    }
    if (ctx.data.length < this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_small,
        minimum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      return INVALID;
    }
    const rest = this._def.rest;
    if (!rest && ctx.data.length > this._def.items.length) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.too_big,
        maximum: this._def.items.length,
        inclusive: true,
        exact: false,
        type: "array"
      });
      status.dirty();
    }
    const items = [...ctx.data].map((item, itemIndex) => {
      const schema = this._def.items[itemIndex] || this._def.rest;
      if (!schema)
        return null;
      return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
    }).filter((x) => !!x);
    if (ctx.common.async) {
      return Promise.all(items).then((results) => {
        return ParseStatus.mergeArray(status, results);
      });
    } else {
      return ParseStatus.mergeArray(status, items);
    }
  }
  get items() {
    return this._def.items;
  }
  rest(rest) {
    return new ZodTuple({
      ...this._def,
      rest
    });
  }
}
ZodTuple.create = (schemas, params) => {
  if (!Array.isArray(schemas)) {
    throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
  }
  return new ZodTuple({
    items: schemas,
    typeName: ZodFirstPartyTypeKind.ZodTuple,
    rest: null,
    ...processCreateParams(params)
  });
};

class ZodRecord extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.object) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.object,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const pairs = [];
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    for (const key in ctx.data) {
      pairs.push({
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
        value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key))
      });
    }
    if (ctx.common.async) {
      return ParseStatus.mergeObjectAsync(status, pairs);
    } else {
      return ParseStatus.mergeObjectSync(status, pairs);
    }
  }
  get element() {
    return this._def.valueType;
  }
  static create(first, second, third) {
    if (second instanceof ZodType) {
      return new ZodRecord({
        keyType: first,
        valueType: second,
        typeName: ZodFirstPartyTypeKind.ZodRecord,
        ...processCreateParams(third)
      });
    }
    return new ZodRecord({
      keyType: ZodString.create(),
      valueType: first,
      typeName: ZodFirstPartyTypeKind.ZodRecord,
      ...processCreateParams(second)
    });
  }
}

class ZodMap extends ZodType {
  get keySchema() {
    return this._def.keyType;
  }
  get valueSchema() {
    return this._def.valueType;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.map) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.map,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const keyType = this._def.keyType;
    const valueType = this._def.valueType;
    const pairs = [...ctx.data.entries()].map(([key, value], index) => {
      return {
        key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
        value: valueType._parse(new ParseInputLazyPath(ctx, value, ctx.path, [index, "value"]))
      };
    });
    if (ctx.common.async) {
      const finalMap = new Map;
      return Promise.resolve().then(async () => {
        for (const pair of pairs) {
          const key = await pair.key;
          const value = await pair.value;
          if (key.status === "aborted" || value.status === "aborted") {
            return INVALID;
          }
          if (key.status === "dirty" || value.status === "dirty") {
            status.dirty();
          }
          finalMap.set(key.value, value.value);
        }
        return { status: status.value, value: finalMap };
      });
    } else {
      const finalMap = new Map;
      for (const pair of pairs) {
        const key = pair.key;
        const value = pair.value;
        if (key.status === "aborted" || value.status === "aborted") {
          return INVALID;
        }
        if (key.status === "dirty" || value.status === "dirty") {
          status.dirty();
        }
        finalMap.set(key.value, value.value);
      }
      return { status: status.value, value: finalMap };
    }
  }
}
ZodMap.create = (keyType, valueType, params) => {
  return new ZodMap({
    valueType,
    keyType,
    typeName: ZodFirstPartyTypeKind.ZodMap,
    ...processCreateParams(params)
  });
};

class ZodSet extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.set) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.set,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const def = this._def;
    if (def.minSize !== null) {
      if (ctx.data.size < def.minSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_small,
          minimum: def.minSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.minSize.message
        });
        status.dirty();
      }
    }
    if (def.maxSize !== null) {
      if (ctx.data.size > def.maxSize.value) {
        addIssueToContext(ctx, {
          code: ZodIssueCode.too_big,
          maximum: def.maxSize.value,
          type: "set",
          inclusive: true,
          exact: false,
          message: def.maxSize.message
        });
        status.dirty();
      }
    }
    const valueType = this._def.valueType;
    function finalizeSet(elements2) {
      const parsedSet = new Set;
      for (const element of elements2) {
        if (element.status === "aborted")
          return INVALID;
        if (element.status === "dirty")
          status.dirty();
        parsedSet.add(element.value);
      }
      return { status: status.value, value: parsedSet };
    }
    const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
    if (ctx.common.async) {
      return Promise.all(elements).then((elements2) => finalizeSet(elements2));
    } else {
      return finalizeSet(elements);
    }
  }
  min(minSize, message) {
    return new ZodSet({
      ...this._def,
      minSize: { value: minSize, message: errorUtil.toString(message) }
    });
  }
  max(maxSize, message) {
    return new ZodSet({
      ...this._def,
      maxSize: { value: maxSize, message: errorUtil.toString(message) }
    });
  }
  size(size, message) {
    return this.min(size, message).max(size, message);
  }
  nonempty(message) {
    return this.min(1, message);
  }
}
ZodSet.create = (valueType, params) => {
  return new ZodSet({
    valueType,
    minSize: null,
    maxSize: null,
    typeName: ZodFirstPartyTypeKind.ZodSet,
    ...processCreateParams(params)
  });
};

class ZodFunction extends ZodType {
  constructor() {
    super(...arguments);
    this.validate = this.implement;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.function) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.function,
        received: ctx.parsedType
      });
      return INVALID;
    }
    function makeArgsIssue(args, error) {
      return makeIssue({
        data: args,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_arguments,
          argumentsError: error
        }
      });
    }
    function makeReturnsIssue(returns, error) {
      return makeIssue({
        data: returns,
        path: ctx.path,
        errorMaps: [
          ctx.common.contextualErrorMap,
          ctx.schemaErrorMap,
          getErrorMap(),
          errorMap
        ].filter((x) => !!x),
        issueData: {
          code: ZodIssueCode.invalid_return_type,
          returnTypeError: error
        }
      });
    }
    const params = { errorMap: ctx.common.contextualErrorMap };
    const fn = ctx.data;
    if (this._def.returns instanceof ZodPromise) {
      const me = this;
      return OK(async function(...args) {
        const error = new ZodError([]);
        const parsedArgs = await me._def.args.parseAsync(args, params).catch((e) => {
          error.addIssue(makeArgsIssue(args, e));
          throw error;
        });
        const result = await Reflect.apply(fn, this, parsedArgs);
        const parsedReturns = await me._def.returns._def.type.parseAsync(result, params).catch((e) => {
          error.addIssue(makeReturnsIssue(result, e));
          throw error;
        });
        return parsedReturns;
      });
    } else {
      const me = this;
      return OK(function(...args) {
        const parsedArgs = me._def.args.safeParse(args, params);
        if (!parsedArgs.success) {
          throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
        }
        const result = Reflect.apply(fn, this, parsedArgs.data);
        const parsedReturns = me._def.returns.safeParse(result, params);
        if (!parsedReturns.success) {
          throw new ZodError([makeReturnsIssue(result, parsedReturns.error)]);
        }
        return parsedReturns.data;
      });
    }
  }
  parameters() {
    return this._def.args;
  }
  returnType() {
    return this._def.returns;
  }
  args(...items) {
    return new ZodFunction({
      ...this._def,
      args: ZodTuple.create(items).rest(ZodUnknown.create())
    });
  }
  returns(returnType) {
    return new ZodFunction({
      ...this._def,
      returns: returnType
    });
  }
  implement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  strictImplement(func) {
    const validatedFunc = this.parse(func);
    return validatedFunc;
  }
  static create(args, returns, params) {
    return new ZodFunction({
      args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
      returns: returns || ZodUnknown.create(),
      typeName: ZodFirstPartyTypeKind.ZodFunction,
      ...processCreateParams(params)
    });
  }
}

class ZodLazy extends ZodType {
  get schema() {
    return this._def.getter();
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const lazySchema = this._def.getter();
    return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
  }
}
ZodLazy.create = (getter, params) => {
  return new ZodLazy({
    getter,
    typeName: ZodFirstPartyTypeKind.ZodLazy,
    ...processCreateParams(params)
  });
};

class ZodLiteral extends ZodType {
  _parse(input) {
    if (input.data !== this._def.value) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_literal,
        expected: this._def.value
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
  get value() {
    return this._def.value;
  }
}
ZodLiteral.create = (value, params) => {
  return new ZodLiteral({
    value,
    typeName: ZodFirstPartyTypeKind.ZodLiteral,
    ...processCreateParams(params)
  });
};

class ZodEnum extends ZodType {
  _parse(input) {
    if (typeof input.data !== "string") {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (this._def.values.indexOf(input.data) === -1) {
      const ctx = this._getOrReturnCtx(input);
      const expectedValues = this._def.values;
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get options() {
    return this._def.values;
  }
  get enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Values() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  get Enum() {
    const enumValues = {};
    for (const val of this._def.values) {
      enumValues[val] = val;
    }
    return enumValues;
  }
  extract(values) {
    return ZodEnum.create(values);
  }
  exclude(values) {
    return ZodEnum.create(this.options.filter((opt) => !values.includes(opt)));
  }
}
ZodEnum.create = createZodEnum;

class ZodNativeEnum extends ZodType {
  _parse(input) {
    const nativeEnumValues = util.getValidEnumValues(this._def.values);
    const ctx = this._getOrReturnCtx(input);
    if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        expected: util.joinValues(expectedValues),
        received: ctx.parsedType,
        code: ZodIssueCode.invalid_type
      });
      return INVALID;
    }
    if (nativeEnumValues.indexOf(input.data) === -1) {
      const expectedValues = util.objectValues(nativeEnumValues);
      addIssueToContext(ctx, {
        received: ctx.data,
        code: ZodIssueCode.invalid_enum_value,
        options: expectedValues
      });
      return INVALID;
    }
    return OK(input.data);
  }
  get enum() {
    return this._def.values;
  }
}
ZodNativeEnum.create = (values, params) => {
  return new ZodNativeEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
    ...processCreateParams(params)
  });
};

class ZodPromise extends ZodType {
  unwrap() {
    return this._def.type;
  }
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.promise,
        received: ctx.parsedType
      });
      return INVALID;
    }
    const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
    return OK(promisified.then((data) => {
      return this._def.type.parseAsync(data, {
        path: ctx.path,
        errorMap: ctx.common.contextualErrorMap
      });
    }));
  }
}
ZodPromise.create = (schema, params) => {
  return new ZodPromise({
    type: schema,
    typeName: ZodFirstPartyTypeKind.ZodPromise,
    ...processCreateParams(params)
  });
};

class ZodEffects extends ZodType {
  innerType() {
    return this._def.schema;
  }
  sourceType() {
    return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
  }
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    const effect = this._def.effect || null;
    const checkCtx = {
      addIssue: (arg) => {
        addIssueToContext(ctx, arg);
        if (arg.fatal) {
          status.abort();
        } else {
          status.dirty();
        }
      },
      get path() {
        return ctx.path;
      }
    };
    checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
    if (effect.type === "preprocess") {
      const processed = effect.transform(ctx.data, checkCtx);
      if (ctx.common.issues.length) {
        return {
          status: "dirty",
          value: ctx.data
        };
      }
      if (ctx.common.async) {
        return Promise.resolve(processed).then((processed2) => {
          return this._def.schema._parseAsync({
            data: processed2,
            path: ctx.path,
            parent: ctx
          });
        });
      } else {
        return this._def.schema._parseSync({
          data: processed,
          path: ctx.path,
          parent: ctx
        });
      }
    }
    if (effect.type === "refinement") {
      const executeRefinement = (acc) => {
        const result = effect.refinement(acc, checkCtx);
        if (ctx.common.async) {
          return Promise.resolve(result);
        }
        if (result instanceof Promise) {
          throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
        }
        return acc;
      };
      if (ctx.common.async === false) {
        const inner = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inner.status === "aborted")
          return INVALID;
        if (inner.status === "dirty")
          status.dirty();
        executeRefinement(inner.value);
        return { status: status.value, value: inner.value };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
          if (inner.status === "aborted")
            return INVALID;
          if (inner.status === "dirty")
            status.dirty();
          return executeRefinement(inner.value).then(() => {
            return { status: status.value, value: inner.value };
          });
        });
      }
    }
    if (effect.type === "transform") {
      if (ctx.common.async === false) {
        const base = this._def.schema._parseSync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (!isValid(base))
          return base;
        const result = effect.transform(base.value, checkCtx);
        if (result instanceof Promise) {
          throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
        }
        return { status: status.value, value: result };
      } else {
        return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
          if (!isValid(base))
            return base;
          return Promise.resolve(effect.transform(base.value, checkCtx)).then((result) => ({ status: status.value, value: result }));
        });
      }
    }
    util.assertNever(effect);
  }
}
ZodEffects.create = (schema, effect, params) => {
  return new ZodEffects({
    schema,
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    effect,
    ...processCreateParams(params)
  });
};
ZodEffects.createWithPreprocess = (preprocess, schema, params) => {
  return new ZodEffects({
    schema,
    effect: { type: "preprocess", transform: preprocess },
    typeName: ZodFirstPartyTypeKind.ZodEffects,
    ...processCreateParams(params)
  });
};

class ZodOptional extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.undefined) {
      return OK(undefined);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodOptional.create = (type, params) => {
  return new ZodOptional({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodOptional,
    ...processCreateParams(params)
  });
};

class ZodNullable extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType === ZodParsedType.null) {
      return OK(null);
    }
    return this._def.innerType._parse(input);
  }
  unwrap() {
    return this._def.innerType;
  }
}
ZodNullable.create = (type, params) => {
  return new ZodNullable({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodNullable,
    ...processCreateParams(params)
  });
};

class ZodDefault extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    let data = ctx.data;
    if (ctx.parsedType === ZodParsedType.undefined) {
      data = this._def.defaultValue();
    }
    return this._def.innerType._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  removeDefault() {
    return this._def.innerType;
  }
}
ZodDefault.create = (type, params) => {
  return new ZodDefault({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodDefault,
    defaultValue: typeof params.default === "function" ? params.default : () => params.default,
    ...processCreateParams(params)
  });
};

class ZodCatch extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const newCtx = {
      ...ctx,
      common: {
        ...ctx.common,
        issues: []
      }
    };
    const result = this._def.innerType._parse({
      data: newCtx.data,
      path: newCtx.path,
      parent: {
        ...newCtx
      }
    });
    if (isAsync(result)) {
      return result.then((result2) => {
        return {
          status: "valid",
          value: result2.status === "valid" ? result2.value : this._def.catchValue({
            get error() {
              return new ZodError(newCtx.common.issues);
            },
            input: newCtx.data
          })
        };
      });
    } else {
      return {
        status: "valid",
        value: result.status === "valid" ? result.value : this._def.catchValue({
          get error() {
            return new ZodError(newCtx.common.issues);
          },
          input: newCtx.data
        })
      };
    }
  }
  removeCatch() {
    return this._def.innerType;
  }
}
ZodCatch.create = (type, params) => {
  return new ZodCatch({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodCatch,
    catchValue: typeof params.catch === "function" ? params.catch : () => params.catch,
    ...processCreateParams(params)
  });
};

class ZodNaN extends ZodType {
  _parse(input) {
    const parsedType = this._getType(input);
    if (parsedType !== ZodParsedType.nan) {
      const ctx = this._getOrReturnCtx(input);
      addIssueToContext(ctx, {
        code: ZodIssueCode.invalid_type,
        expected: ZodParsedType.nan,
        received: ctx.parsedType
      });
      return INVALID;
    }
    return { status: "valid", value: input.data };
  }
}
ZodNaN.create = (params) => {
  return new ZodNaN({
    typeName: ZodFirstPartyTypeKind.ZodNaN,
    ...processCreateParams(params)
  });
};
var BRAND = Symbol("zod_brand");

class ZodBranded extends ZodType {
  _parse(input) {
    const { ctx } = this._processInputParams(input);
    const data = ctx.data;
    return this._def.type._parse({
      data,
      path: ctx.path,
      parent: ctx
    });
  }
  unwrap() {
    return this._def.type;
  }
}

class ZodPipeline extends ZodType {
  _parse(input) {
    const { status, ctx } = this._processInputParams(input);
    if (ctx.common.async) {
      const handleAsync = async () => {
        const inResult = await this._def.in._parseAsync({
          data: ctx.data,
          path: ctx.path,
          parent: ctx
        });
        if (inResult.status === "aborted")
          return INVALID;
        if (inResult.status === "dirty") {
          status.dirty();
          return DIRTY(inResult.value);
        } else {
          return this._def.out._parseAsync({
            data: inResult.value,
            path: ctx.path,
            parent: ctx
          });
        }
      };
      return handleAsync();
    } else {
      const inResult = this._def.in._parseSync({
        data: ctx.data,
        path: ctx.path,
        parent: ctx
      });
      if (inResult.status === "aborted")
        return INVALID;
      if (inResult.status === "dirty") {
        status.dirty();
        return {
          status: "dirty",
          value: inResult.value
        };
      } else {
        return this._def.out._parseSync({
          data: inResult.value,
          path: ctx.path,
          parent: ctx
        });
      }
    }
  }
  static create(a, b) {
    return new ZodPipeline({
      in: a,
      out: b,
      typeName: ZodFirstPartyTypeKind.ZodPipeline
    });
  }
}

class ZodReadonly extends ZodType {
  _parse(input) {
    const result = this._def.innerType._parse(input);
    if (isValid(result)) {
      result.value = Object.freeze(result.value);
    }
    return result;
  }
}
ZodReadonly.create = (type, params) => {
  return new ZodReadonly({
    innerType: type,
    typeName: ZodFirstPartyTypeKind.ZodReadonly,
    ...processCreateParams(params)
  });
};
var custom = (check, params = {}, fatal) => {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a, _b;
      if (!check(data)) {
        const p = typeof params === "function" ? params(data) : typeof params === "string" ? { message: params } : params;
        const _fatal = (_b = (_a = p.fatal) !== null && _a !== undefined ? _a : fatal) !== null && _b !== undefined ? _b : true;
        const p2 = typeof p === "string" ? { message: p } : p;
        ctx.addIssue({ code: "custom", ...p2, fatal: _fatal });
      }
    });
  return ZodAny.create();
};
var late = {
  object: ZodObject.lazycreate
};
var ZodFirstPartyTypeKind;
(function(ZodFirstPartyTypeKind2) {
  ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
  ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
  ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
  ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
  ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
  ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
  ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
  ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
  ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
  ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
  ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
  ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
  ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
  ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
  ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
  ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
  ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
  ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
  ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
  ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
  ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
  ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
  ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
  ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
  ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
  ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
  ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
  ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
  ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
  ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
  ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
  ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
  ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
  ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
  ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
  ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
})(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
var instanceOfType = (cls, params = {
  message: `Input not instance of ${cls.name}`
}) => custom((data) => data instanceof cls, params);
var stringType = ZodString.create;
var numberType = ZodNumber.create;
var nanType = ZodNaN.create;
var bigIntType = ZodBigInt.create;
var booleanType = ZodBoolean.create;
var dateType = ZodDate.create;
var symbolType = ZodSymbol.create;
var undefinedType = ZodUndefined.create;
var nullType = ZodNull.create;
var anyType = ZodAny.create;
var unknownType = ZodUnknown.create;
var neverType = ZodNever.create;
var voidType = ZodVoid.create;
var arrayType = ZodArray.create;
var objectType = ZodObject.create;
var strictObjectType = ZodObject.strictCreate;
var unionType = ZodUnion.create;
var discriminatedUnionType = ZodDiscriminatedUnion.create;
var intersectionType = ZodIntersection.create;
var tupleType = ZodTuple.create;
var recordType = ZodRecord.create;
var mapType = ZodMap.create;
var setType = ZodSet.create;
var functionType = ZodFunction.create;
var lazyType = ZodLazy.create;
var literalType = ZodLiteral.create;
var enumType = ZodEnum.create;
var nativeEnumType = ZodNativeEnum.create;
var promiseType = ZodPromise.create;
var effectsType = ZodEffects.create;
var optionalType = ZodOptional.create;
var nullableType = ZodNullable.create;
var preprocessType = ZodEffects.createWithPreprocess;
var pipelineType = ZodPipeline.create;
var ostring = () => stringType().optional();
var onumber = () => numberType().optional();
var oboolean = () => booleanType().optional();
var coerce = {
  string: (arg) => ZodString.create({ ...arg, coerce: true }),
  number: (arg) => ZodNumber.create({ ...arg, coerce: true }),
  boolean: (arg) => ZodBoolean.create({
    ...arg,
    coerce: true
  }),
  bigint: (arg) => ZodBigInt.create({ ...arg, coerce: true }),
  date: (arg) => ZodDate.create({ ...arg, coerce: true })
};
var NEVER = INVALID;
var z = Object.freeze({
  __proto__: null,
  defaultErrorMap: errorMap,
  setErrorMap,
  getErrorMap,
  makeIssue,
  EMPTY_PATH,
  addIssueToContext,
  ParseStatus,
  INVALID,
  DIRTY,
  OK,
  isAborted,
  isDirty,
  isValid,
  isAsync,
  get util() {
    return util;
  },
  get objectUtil() {
    return objectUtil;
  },
  ZodParsedType,
  getParsedType,
  ZodType,
  ZodString,
  ZodNumber,
  ZodBigInt,
  ZodBoolean,
  ZodDate,
  ZodSymbol,
  ZodUndefined,
  ZodNull,
  ZodAny,
  ZodUnknown,
  ZodNever,
  ZodVoid,
  ZodArray,
  ZodObject,
  ZodUnion,
  ZodDiscriminatedUnion,
  ZodIntersection,
  ZodTuple,
  ZodRecord,
  ZodMap,
  ZodSet,
  ZodFunction,
  ZodLazy,
  ZodLiteral,
  ZodEnum,
  ZodNativeEnum,
  ZodPromise,
  ZodEffects,
  ZodTransformer: ZodEffects,
  ZodOptional,
  ZodNullable,
  ZodDefault,
  ZodCatch,
  ZodNaN,
  BRAND,
  ZodBranded,
  ZodPipeline,
  ZodReadonly,
  custom,
  Schema: ZodType,
  ZodSchema: ZodType,
  late,
  get ZodFirstPartyTypeKind() {
    return ZodFirstPartyTypeKind;
  },
  coerce,
  any: anyType,
  array: arrayType,
  bigint: bigIntType,
  boolean: booleanType,
  date: dateType,
  discriminatedUnion: discriminatedUnionType,
  effect: effectsType,
  enum: enumType,
  function: functionType,
  instanceof: instanceOfType,
  intersection: intersectionType,
  lazy: lazyType,
  literal: literalType,
  map: mapType,
  nan: nanType,
  nativeEnum: nativeEnumType,
  never: neverType,
  null: nullType,
  nullable: nullableType,
  number: numberType,
  object: objectType,
  oboolean,
  onumber,
  optional: optionalType,
  ostring,
  pipeline: pipelineType,
  preprocess: preprocessType,
  promise: promiseType,
  record: recordType,
  set: setType,
  strictObject: strictObjectType,
  string: stringType,
  symbol: symbolType,
  transformer: effectsType,
  tuple: tupleType,
  undefined: undefinedType,
  union: unionType,
  unknown: unknownType,
  void: voidType,
  NEVER,
  ZodIssueCode,
  quotelessJson,
  ZodError
});

// node_modules/web3-validator/lib/esm/errors.js
var errorFormatter = (error) => {
  if (error.message) {
    return error.message;
  }
  return "unspecified error";
};

class Web3ValidatorError extends BaseWeb3Error {
  constructor(errors) {
    super();
    this.code = ERR_VALIDATION;
    this.errors = errors;
    super.message = `Web3 validator found ${errors.length} error[s]:\n${this._compileErrors().join("\n")}`;
  }
  _compileErrors() {
    return this.errors.map(errorFormatter);
  }
}

// node_modules/web3-validator/lib/esm/utils.js
var exports_utils = {};
__export(exports_utils, {
  uint8ArrayToHexString: () => {
    {
      return uint8ArrayToHexString;
    }
  },
  transformJsonDataToAbiFormat: () => {
    {
      return transformJsonDataToAbiFormat;
    }
  },
  parseBaseType: () => {
    {
      return parseBaseType;
    }
  },
  padLeft: () => {
    {
      return padLeft;
    }
  },
  numberToHex: () => {
    {
      return numberToHex;
    }
  },
  hexToUint8Array: () => {
    {
      return hexToUint8Array;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber;
    }
  },
  fetchArrayElement: () => {
    {
      return fetchArrayElement;
    }
  },
  ethAbiToJsonSchema: () => {
    {
      return ethAbiToJsonSchema;
    }
  },
  ensureIfUint8Array: () => {
    {
      return ensureIfUint8Array;
    }
  },
  codePointToInt: () => {
    {
      return codePointToInt;
    }
  },
  abiSchemaToJsonSchema: () => {
    {
      return abiSchemaToJsonSchema;
    }
  }
});

// node_modules/web3-validator/lib/esm/constants.js
var VALID_ETH_BASE_TYPES = ["bool", "int", "uint", "bytes", "string", "address", "tuple"];

// node_modules/web3-validator/lib/esm/validation/abi.js
var isAbiParameterSchema = (schema) => typeof schema === "object" && ("type" in schema) && ("name" in schema);

// node_modules/web3-validator/lib/esm/validation/string.js
function isHexString(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/))
    return false;
  if (typeof length !== "undefined" && length > 0 && value.length !== 2 + 2 * length)
    return false;
  return true;
}
function isHexPrefixed(str) {
  if (typeof str !== "string") {
    throw new Error(`[isHexPrefixed] input must be type 'string', received type ${typeof str}`);
  }
  return str.startsWith("0x");
}
var isString = (value) => typeof value === "string";
var isHexStrict = (hex) => typeof hex === "string" && /^((-)?0x[0-9a-f]+|(0x))$/i.test(hex);
var isHex = (hex) => typeof hex === "number" || typeof hex === "bigint" || typeof hex === "string" && /^((-0x|0x|-)?[0-9a-f]+|(0x))$/i.test(hex);
var validateNoLeadingZeroes = function(values) {
  for (const [k, v] of Object.entries(values)) {
    if (v !== undefined && v.length > 0 && v[0] === 0) {
      throw new Error(`${k} cannot have leading zeroes, received: ${v.toString()}`);
    }
  }
};

// node_modules/web3-validator/lib/esm/utils.js
function uint8ArrayToHexString(uint8Array) {
  let hexString = "0x";
  for (const e of uint8Array) {
    const hex = e.toString(16);
    hexString += hex.length === 1 ? `0${hex}` : hex;
  }
  return hexString;
}
var charCodeToBase16 = function(char) {
  if (char >= charCodeMap.zero && char <= charCodeMap.nine)
    return char - charCodeMap.zero;
  if (char >= charCodeMap.A && char <= charCodeMap.F)
    return char - (charCodeMap.A - 10);
  if (char >= charCodeMap.a && char <= charCodeMap.f)
    return char - (charCodeMap.a - 10);
  return;
};
function hexToUint8Array(hex) {
  let offset = 0;
  if (hex.startsWith("0") && (hex[1] === "x" || hex[1] === "X")) {
    offset = 2;
  }
  if (hex.length % 2 !== 0) {
    throw new InvalidBytesError(`hex string has odd length: ${hex}`);
  }
  const length = (hex.length - offset) / 2;
  const bytes2 = new Uint8Array(length);
  for (let index = 0, j = offset;index < length; index += 1) {
    const nibbleLeft = charCodeToBase16(hex.charCodeAt(j++));
    const nibbleRight = charCodeToBase16(hex.charCodeAt(j++));
    if (nibbleLeft === undefined || nibbleRight === undefined) {
      throw new InvalidBytesError(`Invalid byte sequence ("${hex[j - 2]}${hex[j - 1]}" in "${hex}").`);
    }
    bytes2[index] = nibbleLeft * 16 + nibbleRight;
  }
  return bytes2;
}
function ensureIfUint8Array(data) {
  var _a;
  if (!(data instanceof Uint8Array) && ((_a = data === null || data === undefined ? undefined : data.constructor) === null || _a === undefined ? undefined : _a.name) === "Uint8Array") {
    return Uint8Array.from(data);
  }
  return data;
}
var extraTypes = ["hex", "number", "blockNumber", "blockNumberOrTag", "filter", "bloom"];
var parseBaseType = (type) => {
  let strippedType = type.replace(/ /, "");
  let baseTypeSize;
  let isArray = false;
  let arraySizes = [];
  if (type.includes("[")) {
    strippedType = strippedType.slice(0, strippedType.indexOf("["));
    arraySizes = [...type.matchAll(/(?:\[(\d*)\])/g)].map((match) => parseInt(match[1], 10)).map((size) => Number.isNaN(size) ? -1 : size);
    isArray = arraySizes.length > 0;
  }
  if (VALID_ETH_BASE_TYPES.includes(strippedType)) {
    return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
  }
  if (strippedType.startsWith("int")) {
    baseTypeSize = parseInt(strippedType.substring(3), 10);
    strippedType = "int";
  } else if (strippedType.startsWith("uint")) {
    baseTypeSize = parseInt(type.substring(4), 10);
    strippedType = "uint";
  } else if (strippedType.startsWith("bytes")) {
    baseTypeSize = parseInt(strippedType.substring(5), 10);
    strippedType = "bytes";
  } else {
    return { baseType: undefined, isArray: false, baseTypeSize: undefined, arraySizes };
  }
  return { baseType: strippedType, isArray, baseTypeSize, arraySizes };
};
var convertEthType = (type, parentSchema = {}) => {
  const typePropertyPresent = Object.keys(parentSchema).includes("type");
  if (typePropertyPresent) {
    throw new Web3ValidatorError([
      {
        keyword: "eth",
        message: 'Either "eth" or "type" can be presented in schema',
        params: { eth: type },
        instancePath: "",
        schemaPath: ""
      }
    ]);
  }
  const { baseType, baseTypeSize } = parseBaseType(type);
  if (!baseType && !extraTypes.includes(type)) {
    throw new Web3ValidatorError([
      {
        keyword: "eth",
        message: `Eth data type "${type}" is not valid`,
        params: { eth: type },
        instancePath: "",
        schemaPath: ""
      }
    ]);
  }
  if (baseType) {
    if (baseType === "tuple") {
      throw new Error('"tuple" type is not implemented directly.');
    }
    return { format: `${baseType}${baseTypeSize !== null && baseTypeSize !== undefined ? baseTypeSize : ""}`, required: true };
  }
  if (type) {
    return { format: type, required: true };
  }
  return {};
};
var abiSchemaToJsonSchema = (abis, level = "/0") => {
  const schema = {
    type: "array",
    items: [],
    maxItems: abis.length,
    minItems: abis.length
  };
  for (const [index, abi2] of abis.entries()) {
    let abiType;
    let abiName;
    let abiComponents = [];
    if (isAbiParameterSchema(abi2)) {
      abiType = abi2.type;
      abiName = abi2.name;
      abiComponents = abi2.components;
    } else if (typeof abi2 === "string") {
      abiType = abi2;
      abiName = `${level}/${index}`;
    } else if (Array.isArray(abi2)) {
      if (abi2[0] && typeof abi2[0] === "string" && abi2[0].startsWith("tuple") && !Array.isArray(abi2[0]) && abi2[1] && Array.isArray(abi2[1])) {
        abiType = abi2[0];
        abiName = `${level}/${index}`;
        abiComponents = abi2[1];
      } else {
        abiType = "tuple";
        abiName = `${level}/${index}`;
        abiComponents = abi2;
      }
    }
    const { baseType, isArray, arraySizes } = parseBaseType(abiType);
    let childSchema;
    let lastSchema = schema;
    for (let i = arraySizes.length - 1;i > 0; i -= 1) {
      childSchema = {
        type: "array",
        $id: abiName,
        items: [],
        maxItems: arraySizes[i],
        minItems: arraySizes[i]
      };
      if (arraySizes[i] < 0) {
        delete childSchema.maxItems;
        delete childSchema.minItems;
      }
      if (!Array.isArray(lastSchema.items)) {
        lastSchema.items = [lastSchema.items, childSchema];
      } else if (lastSchema.items.length === 0) {
        lastSchema.items = [childSchema];
      } else {
        lastSchema.items.push(childSchema);
      }
      lastSchema = childSchema;
    }
    if (baseType === "tuple" && !isArray) {
      const nestedTuple = abiSchemaToJsonSchema(abiComponents, abiName);
      nestedTuple.$id = abiName;
      lastSchema.items.push(nestedTuple);
    } else if (baseType === "tuple" && isArray) {
      const arraySize = arraySizes[0];
      const item = Object.assign({ type: "array", $id: abiName, items: abiSchemaToJsonSchema(abiComponents, abiName) }, arraySize >= 0 && { minItems: arraySize, maxItems: arraySize });
      lastSchema.items.push(item);
    } else if (isArray) {
      const arraySize = arraySizes[0];
      const item = Object.assign({ type: "array", $id: abiName, items: convertEthType(abiType) }, arraySize >= 0 && { minItems: arraySize, maxItems: arraySize });
      lastSchema.items.push(item);
    } else if (Array.isArray(lastSchema.items)) {
      lastSchema.items.push(Object.assign({ $id: abiName }, convertEthType(abiType)));
    } else {
      lastSchema.items.push(Object.assign({ $id: abiName }, convertEthType(abiType)));
    }
    lastSchema = schema;
  }
  return schema;
};
var ethAbiToJsonSchema = (abis) => abiSchemaToJsonSchema(abis);
var fetchArrayElement = (data, level) => {
  if (level === 1) {
    return data;
  }
  return fetchArrayElement(data[0], level - 1);
};
var transformJsonDataToAbiFormat = (abis, data, transformedData) => {
  const newData = [];
  for (const [index, abi2] of abis.entries()) {
    let abiType;
    let abiName;
    let abiComponents = [];
    if (isAbiParameterSchema(abi2)) {
      abiType = abi2.type;
      abiName = abi2.name;
      abiComponents = abi2.components;
    } else if (typeof abi2 === "string") {
      abiType = abi2;
    } else if (Array.isArray(abi2)) {
      if (abi2[1] && Array.isArray(abi2[1])) {
        abiType = abi2[0];
        abiComponents = abi2[1];
      } else {
        abiType = "tuple";
        abiComponents = abi2;
      }
    }
    const { baseType, isArray, arraySizes } = parseBaseType(abiType);
    const dataItem = Array.isArray(data) ? data[index] : data[abiName];
    if (baseType === "tuple" && !isArray) {
      newData.push(transformJsonDataToAbiFormat(abiComponents, dataItem, transformedData));
    } else if (baseType === "tuple" && isArray) {
      const tupleData = [];
      for (const tupleItem of dataItem) {
        if (arraySizes.length > 1) {
          const nestedItems = fetchArrayElement(tupleItem, arraySizes.length - 1);
          const nestedData = [];
          for (const nestedItem of nestedItems) {
            nestedData.push(transformJsonDataToAbiFormat(abiComponents, nestedItem, transformedData));
          }
          tupleData.push(nestedData);
        } else {
          tupleData.push(transformJsonDataToAbiFormat(abiComponents, tupleItem, transformedData));
        }
      }
      newData.push(tupleData);
    } else {
      newData.push(dataItem);
    }
  }
  transformedData = transformedData !== null && transformedData !== undefined ? transformedData : [];
  transformedData.push(...newData);
  return transformedData;
};
var codePointToInt = (codePoint) => {
  if (codePoint >= 48 && codePoint <= 57) {
    return codePoint - 48;
  }
  if (codePoint >= 65 && codePoint <= 70) {
    return codePoint - 55;
  }
  if (codePoint >= 97 && codePoint <= 102) {
    return codePoint - 87;
  }
  throw new Error(`Invalid code point: ${codePoint}`);
};
var hexToNumber = (value) => {
  if (!isHexStrict(value)) {
    throw new Error("Invalid hex string");
  }
  const [negative, hexValue] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
  const num = BigInt(hexValue);
  if (num > Number.MAX_SAFE_INTEGER) {
    return negative ? -num : num;
  }
  if (num < Number.MIN_SAFE_INTEGER) {
    return num;
  }
  return negative ? -1 * Number(num) : Number(num);
};
var numberToHex = (value) => {
  if ((typeof value === "number" || typeof value === "bigint") && value < 0) {
    return `-0x${value.toString(16).slice(1)}`;
  }
  if ((typeof value === "number" || typeof value === "bigint") && value >= 0) {
    return `0x${value.toString(16)}`;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    const [negative, hex] = value.startsWith("-") ? [true, value.slice(1)] : [false, value];
    const hexValue = hex.split(/^(-)?0(x|X)/).slice(-1)[0];
    return `${negative ? "-" : ""}0x${hexValue.replace(/^0+/, "").toLowerCase()}`;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return numberToHex(BigInt(value));
  }
  throw new InvalidNumberError(value);
};
var padLeft = (value, characterAmount, sign = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padStart(characterAmount, sign);
  }
  const hex = typeof value === "string" && isHexStrict(value) ? value : numberToHex(value);
  const [prefix, hexValue] = hex.startsWith("-") ? ["-0x", hex.slice(3)] : ["0x", hex.slice(2)];
  return `${prefix}${hexValue.padStart(characterAmount, sign)}`;
};
var charCodeMap = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};

// node_modules/web3-validator/lib/esm/validation/bytes.js
var isUint8Array = (data) => {
  var _a;
  return data instanceof Uint8Array || ((_a = data === null || data === undefined ? undefined : data.constructor) === null || _a === undefined ? undefined : _a.name) === "Uint8Array";
};
var isBytes3 = (value, options = {
  abiType: "bytes"
}) => {
  if (typeof value !== "string" && !Array.isArray(value) && !isUint8Array(value)) {
    return false;
  }
  if (typeof value === "string" && isHexStrict(value) && value.startsWith("-")) {
    return false;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return false;
  }
  let valueToCheck;
  if (typeof value === "string") {
    if (value.length % 2 !== 0) {
      return false;
    }
    valueToCheck = hexToUint8Array(value);
  } else if (Array.isArray(value)) {
    if (value.some((d) => d < 0 || d > 255 || !Number.isInteger(d))) {
      return false;
    }
    valueToCheck = new Uint8Array(value);
  } else {
    valueToCheck = value;
  }
  if (options === null || options === undefined ? undefined : options.abiType) {
    const { baseTypeSize } = parseBaseType(options.abiType);
    return baseTypeSize ? valueToCheck.length === baseTypeSize : true;
  }
  if (options === null || options === undefined ? undefined : options.size) {
    return valueToCheck.length === (options === null || options === undefined ? undefined : options.size);
  }
  return true;
};

// node_modules/web3-validator/lib/esm/validation/address.js
var checkAddressCheckSum = (data) => {
  if (!/^(0x)?[0-9a-f]{40}$/i.test(data))
    return false;
  const address = data.slice(2);
  const updatedData = utf8ToBytes(address.toLowerCase());
  const addressHash = uint8ArrayToHexString(keccak256(ensureIfUint8Array(updatedData))).slice(2);
  for (let i = 0;i < 40; i += 1) {
    if (parseInt(addressHash[i], 16) > 7 && address[i].toUpperCase() !== address[i] || parseInt(addressHash[i], 16) <= 7 && address[i].toLowerCase() !== address[i]) {
      return false;
    }
  }
  return true;
};
var isAddress = (value, checkChecksum = true) => {
  if (typeof value !== "string" && !isUint8Array(value)) {
    return false;
  }
  let valueToCheck;
  if (isUint8Array(value)) {
    valueToCheck = uint8ArrayToHexString(value);
  } else if (typeof value === "string" && !isHexStrict(value)) {
    valueToCheck = value.toLowerCase().startsWith("0x") ? value : `0x${value}`;
  } else {
    valueToCheck = value;
  }
  if (!/^(0x)?[0-9a-f]{40}$/i.test(valueToCheck)) {
    return false;
  }
  if (/^(0x|0X)?[0-9a-f]{40}$/.test(valueToCheck) || /^(0x|0X)?[0-9A-F]{40}$/.test(valueToCheck)) {
    return true;
  }
  return checkChecksum ? checkAddressCheckSum(valueToCheck) : true;
};
// node_modules/web3-types/lib/esm/data_format_types.js
var FMT_NUMBER;
(function(FMT_NUMBER2) {
  FMT_NUMBER2["NUMBER"] = "NUMBER_NUMBER";
  FMT_NUMBER2["HEX"] = "NUMBER_HEX";
  FMT_NUMBER2["STR"] = "NUMBER_STR";
  FMT_NUMBER2["BIGINT"] = "NUMBER_BIGINT";
})(FMT_NUMBER || (FMT_NUMBER = {}));
var FMT_BYTES;
(function(FMT_BYTES2) {
  FMT_BYTES2["HEX"] = "BYTES_HEX";
  FMT_BYTES2["UINT8ARRAY"] = "BYTES_UINT8ARRAY";
})(FMT_BYTES || (FMT_BYTES = {}));
var DEFAULT_RETURN_FORMAT = { number: FMT_NUMBER.BIGINT, bytes: FMT_BYTES.HEX };
var ETH_DATA_FORMAT = { number: FMT_NUMBER.HEX, bytes: FMT_BYTES.HEX };
// node_modules/web3-types/lib/esm/eth_types.js
var BlockTags;
(function(BlockTags2) {
  BlockTags2["EARLIEST"] = "earliest";
  BlockTags2["LATEST"] = "latest";
  BlockTags2["PENDING"] = "pending";
  BlockTags2["SAFE"] = "safe";
  BlockTags2["FINALIZED"] = "finalized";
})(BlockTags || (BlockTags = {}));
var HardforksOrdered;
(function(HardforksOrdered2) {
  HardforksOrdered2["chainstart"] = "chainstart";
  HardforksOrdered2["frontier"] = "frontier";
  HardforksOrdered2["homestead"] = "homestead";
  HardforksOrdered2["dao"] = "dao";
  HardforksOrdered2["tangerineWhistle"] = "tangerineWhistle";
  HardforksOrdered2["spuriousDragon"] = "spuriousDragon";
  HardforksOrdered2["byzantium"] = "byzantium";
  HardforksOrdered2["constantinople"] = "constantinople";
  HardforksOrdered2["petersburg"] = "petersburg";
  HardforksOrdered2["istanbul"] = "istanbul";
  HardforksOrdered2["muirGlacier"] = "muirGlacier";
  HardforksOrdered2["berlin"] = "berlin";
  HardforksOrdered2["london"] = "london";
  HardforksOrdered2["altair"] = "altair";
  HardforksOrdered2["arrowGlacier"] = "arrowGlacier";
  HardforksOrdered2["grayGlacier"] = "grayGlacier";
  HardforksOrdered2["bellatrix"] = "bellatrix";
  HardforksOrdered2["merge"] = "merge";
  HardforksOrdered2["capella"] = "capella";
  HardforksOrdered2["shanghai"] = "shanghai";
})(HardforksOrdered || (HardforksOrdered = {}));
// node_modules/web3-types/lib/esm/primitives_types.js
var TypedArray = Object.getPrototypeOf(Uint8Array);
// node_modules/web3-types/lib/esm/web3_base_provider.js
var __awaiter = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var symbol = Symbol.for("web3/base-provider");

class Web3BaseProvider {
  static isWeb3Provider(provider) {
    return provider instanceof Web3BaseProvider || Boolean(provider && provider[symbol]);
  }
  get [symbol]() {
    return true;
  }
  send(payload, callback) {
    this.request(payload).then((response) => {
      callback(null, response);
    }).catch((err) => {
      callback(err);
    });
  }
  sendAsync(payload) {
    return __awaiter(this, undefined, undefined, function* () {
      return this.request(payload);
    });
  }
  asEIP1193Provider() {
    const newObj = Object.create(this);
    const originalRequest = newObj.request;
    newObj.request = function request(args) {
      return __awaiter(this, undefined, undefined, function* () {
        const response = yield originalRequest(args);
        return response.result;
      });
    };
    newObj.asEIP1193Provider = undefined;
    return newObj;
  }
}
// node_modules/web3-types/lib/esm/web3_base_wallet.js
class Web3BaseWallet extends Array {
  constructor(accountProvider) {
    super();
    this._accountProvider = accountProvider;
  }
}
// node_modules/web3-validator/lib/esm/validation/numbers.js
var bigintPower = (base, expo) => {
  let res = base;
  for (let index = 1;index < expo; index += 1) {
    res *= base;
  }
  return res;
};
var isUInt = (value, options = {
  abiType: "uint"
}) => {
  if (!["number", "string", "bigint"].includes(typeof value) || typeof value === "string" && value.length === 0) {
    return false;
  }
  let size;
  if (options === null || options === undefined ? undefined : options.abiType) {
    const { baseTypeSize } = parseBaseType(options.abiType);
    if (baseTypeSize) {
      size = baseTypeSize;
    }
  } else if (options.bitSize) {
    size = options.bitSize;
  }
  const maxSize = bigintPower(BigInt(2), BigInt(size !== null && size !== undefined ? size : 256)) - BigInt(1);
  try {
    const valueToCheck = typeof value === "string" && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);
    return valueToCheck >= 0 && valueToCheck <= maxSize;
  } catch (error) {
    return false;
  }
};
var isInt = (value, options = {
  abiType: "int"
}) => {
  if (!["number", "string", "bigint"].includes(typeof value)) {
    return false;
  }
  if (typeof value === "number" && value > Number.MAX_SAFE_INTEGER) {
    return false;
  }
  let size;
  if (options === null || options === undefined ? undefined : options.abiType) {
    const { baseTypeSize, baseType } = parseBaseType(options.abiType);
    if (baseType !== "int") {
      return false;
    }
    if (baseTypeSize) {
      size = baseTypeSize;
    }
  } else if (options.bitSize) {
    size = options.bitSize;
  }
  const maxSize = bigintPower(BigInt(2), BigInt((size !== null && size !== undefined ? size : 256) - 1));
  const minSize = BigInt(-1) * bigintPower(BigInt(2), BigInt((size !== null && size !== undefined ? size : 256) - 1));
  try {
    const valueToCheck = typeof value === "string" && isHexStrict(value) ? BigInt(hexToNumber(value)) : BigInt(value);
    return valueToCheck >= minSize && valueToCheck <= maxSize;
  } catch (error) {
    return false;
  }
};
var isNumber = (value) => {
  if (isInt(value)) {
    return true;
  }
  if (typeof value === "string" && /[0-9.]/.test(value) && value.indexOf(".") === value.lastIndexOf(".")) {
    return true;
  }
  if (typeof value === "number") {
    return true;
  }
  return false;
};

// node_modules/web3-validator/lib/esm/validation/block.js
var isBlockNumber = (value) => isUInt(value);
var isBlockTag = (value) => Object.values(BlockTags).includes(value);
var isBlockNumberOrTag = (value) => isBlockTag(value) || isBlockNumber(value);

// node_modules/web3-validator/lib/esm/validation/bloom.js
var isBloom = (bloom) => {
  if (typeof bloom !== "string") {
    return false;
  }
  if (!/^(0x)?[0-9a-f]{512}$/i.test(bloom)) {
    return false;
  }
  if (/^(0x)?[0-9a-f]{512}$/.test(bloom) || /^(0x)?[0-9A-F]{512}$/.test(bloom)) {
    return true;
  }
  return false;
};
var isInBloom = (bloom, value) => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return false;
  }
  if (!isBloom(bloom)) {
    return false;
  }
  const uint8Array = typeof value === "string" ? hexToUint8Array(value) : value;
  const hash2 = uint8ArrayToHexString(keccak256(uint8Array)).slice(2);
  for (let i = 0;i < 12; i += 4) {
    const bitpos = (parseInt(hash2.slice(i, i + 2), 16) << 8) + parseInt(hash2.slice(i + 2, i + 4), 16) & 2047;
    const code = codePointToInt(bloom.charCodeAt(bloom.length - 1 - Math.floor(bitpos / 4)));
    const offset = 1 << bitpos % 4;
    if ((code & offset) !== offset) {
      return false;
    }
  }
  return true;
};
var isUserEthereumAddressInBloom = (bloom, ethereumAddress) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isAddress(ethereumAddress)) {
    return false;
  }
  const address2 = padLeft(ethereumAddress, 64);
  return isInBloom(bloom, address2);
};
var isContractAddressInBloom = (bloom, contractAddress) => {
  if (!isBloom(bloom)) {
    return false;
  }
  if (!isAddress(contractAddress)) {
    return false;
  }
  return isInBloom(bloom, contractAddress);
};

// node_modules/web3-validator/lib/esm/validation/boolean.js
var isBoolean = (value) => {
  if (!["number", "string", "boolean"].includes(typeof value)) {
    return false;
  }
  if (typeof value === "boolean") {
    return true;
  }
  if (typeof value === "string" && !isHexStrict(value)) {
    return value === "1" || value === "0";
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return value === "0x1" || value === "0x0";
  }
  return value === 1 || value === 0;
};

// node_modules/web3-validator/lib/esm/validation/object.js
var isNullish = (item) => item === undefined || item === null;
var isObject = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);

// node_modules/web3-validator/lib/esm/validation/topic.js
var isTopic = (topic) => {
  if (typeof topic !== "string") {
    return false;
  }
  if (!/^(0x)?[0-9a-f]{64}$/i.test(topic)) {
    return false;
  }
  if (/^(0x)?[0-9a-f]{64}$/.test(topic) || /^(0x)?[0-9A-F]{64}$/.test(topic)) {
    return true;
  }
  return false;
};
var isTopicInBloom = (bloom2, topic) => {
  if (!isBloom(bloom2)) {
    return false;
  }
  if (!isTopic(topic)) {
    return false;
  }
  return isInBloom(bloom2, topic);
};

// node_modules/web3-validator/lib/esm/validation/filter.js
var isFilterObject = (value) => {
  const expectedFilterProperties = [
    "fromBlock",
    "toBlock",
    "address",
    "topics",
    "blockHash"
  ];
  if (isNullish(value) || typeof value !== "object")
    return false;
  if (!Object.keys(value).every((property) => expectedFilterProperties.includes(property)))
    return false;
  if (!isNullish(value.fromBlock) && !isBlockNumberOrTag(value.fromBlock) || !isNullish(value.toBlock) && !isBlockNumberOrTag(value.toBlock))
    return false;
  if (!isNullish(value.address)) {
    if (Array.isArray(value.address)) {
      if (!value.address.every((address3) => isAddress(address3)))
        return false;
    } else if (!isAddress(value.address))
      return false;
  }
  if (!isNullish(value.topics)) {
    if (!value.topics.every((topic2) => {
      if (isNullish(topic2))
        return true;
      if (Array.isArray(topic2)) {
        return topic2.every((nestedTopic) => isTopic(nestedTopic));
      }
      if (isTopic(topic2))
        return true;
      return false;
    }))
      return false;
  }
  return true;
};

// node_modules/web3-validator/lib/esm/formats.js
var formats = {
  address: (data) => isAddress(data),
  bloom: (data) => isBloom(data),
  blockNumber: (data) => isBlockNumber(data),
  blockTag: (data) => isBlockTag(data),
  blockNumberOrTag: (data) => isBlockNumberOrTag(data),
  bool: (data) => isBoolean(data),
  bytes: (data) => isBytes3(data),
  filter: (data) => isFilterObject(data),
  hex: (data) => isHexStrict(data),
  uint: (data) => isUInt(data),
  int: (data) => isInt(data),
  number: (data) => isNumber(data),
  string: (data) => isString(data)
};
for (let bitSize = 8;bitSize <= 256; bitSize += 8) {
  formats[`int${bitSize}`] = (data) => isInt(data, { bitSize });
  formats[`uint${bitSize}`] = (data) => isUInt(data, { bitSize });
}
for (let size = 1;size <= 32; size += 1) {
  formats[`bytes${size}`] = (data) => isBytes3(data, { size });
}
formats.bytes256 = formats.bytes;
var formats_default = formats;

// node_modules/web3-validator/lib/esm/validator.js
var convertToZod = (schema) => {
  if ((!(schema === null || schema === undefined ? undefined : schema.type) || (schema === null || schema === undefined ? undefined : schema.type) === "object") && (schema === null || schema === undefined ? undefined : schema.properties)) {
    const obj = {};
    for (const name of Object.keys(schema.properties)) {
      const zItem = convertToZod(schema.properties[name]);
      if (zItem) {
        obj[name] = zItem;
      }
    }
    if (Array.isArray(schema.required)) {
      return z.object(obj).partial().required(schema.required.reduce((acc, v) => Object.assign(Object.assign({}, acc), { [v]: true }), {}));
    }
    return z.object(obj).partial();
  }
  if ((schema === null || schema === undefined ? undefined : schema.type) === "array" && (schema === null || schema === undefined ? undefined : schema.items)) {
    if (Array.isArray(schema.items) && schema.items.length > 1 && schema.maxItems !== undefined && new Set(schema.items.map((item) => item.$id)).size === schema.items.length) {
      const arr = [];
      for (const item of schema.items) {
        const zItem = convertToZod(item);
        if (zItem) {
          arr.push(zItem);
        }
      }
      return z.tuple(arr);
    }
    const nextSchema = Array.isArray(schema.items) ? schema.items[0] : schema.items;
    let zodArraySchema = z.array(convertToZod(nextSchema));
    zodArraySchema = schema.minItems !== undefined ? zodArraySchema.min(schema.minItems) : zodArraySchema;
    zodArraySchema = schema.maxItems !== undefined ? zodArraySchema.max(schema.maxItems) : zodArraySchema;
    return zodArraySchema;
  }
  if (schema.oneOf && Array.isArray(schema.oneOf)) {
    return z.union(schema.oneOf.map((oneOfSchema) => convertToZod(oneOfSchema)));
  }
  if (schema === null || schema === undefined ? undefined : schema.format) {
    if (!formats_default[schema.format]) {
      throw new SchemaFormatError(schema.format);
    }
    return z.any().refine(formats_default[schema.format], (value) => ({
      params: { value, format: schema.format }
    }));
  }
  if ((schema === null || schema === undefined ? undefined : schema.type) && (schema === null || schema === undefined ? undefined : schema.type) !== "object" && typeof z[String(schema.type)] === "function") {
    return z[String(schema.type)]();
  }
  return z.object({ data: z.any() }).partial();
};

class Validator {
  static factory() {
    if (!Validator.validatorInstance) {
      Validator.validatorInstance = new Validator;
    }
    return Validator.validatorInstance;
  }
  validate(schema, data, options) {
    var _a, _b;
    const zod = convertToZod(schema);
    const result = zod.safeParse(data);
    if (!result.success) {
      const errors3 = this.convertErrors((_b = (_a = result.error) === null || _a === undefined ? undefined : _a.issues) !== null && _b !== undefined ? _b : []);
      if (errors3) {
        if (options === null || options === undefined ? undefined : options.silent) {
          return errors3;
        }
        throw new Web3ValidatorError(errors3);
      }
    }
    return;
  }
  convertErrors(errors3) {
    if (errors3 && Array.isArray(errors3) && errors3.length > 0) {
      return errors3.map((error) => {
        var _a;
        let message;
        let keyword;
        let params;
        let schemaPath;
        schemaPath = error.path.join("/");
        const field = String(error.path[error.path.length - 1]);
        const instancePath = error.path.join("/");
        if (error.code === ZodIssueCode.too_big) {
          keyword = "maxItems";
          schemaPath = `${instancePath}/maxItems`;
          params = { limit: error.maximum };
          message = `must NOT have more than ${error.maximum} items`;
        } else if (error.code === ZodIssueCode.too_small) {
          keyword = "minItems";
          schemaPath = `${instancePath}/minItems`;
          params = { limit: error.minimum };
          message = `must NOT have fewer than ${error.minimum} items`;
        } else if (error.code === ZodIssueCode.custom) {
          const { value, format } = (_a = error.params) !== null && _a !== undefined ? _a : {};
          if (typeof value === "undefined") {
            message = `value at "/${schemaPath}" is required`;
          } else {
            message = `value "${typeof value === "object" ? JSON.stringify(value) : value}" at "/${schemaPath}" must pass "${format}" validation`;
          }
          params = { value };
        }
        return {
          keyword: keyword !== null && keyword !== undefined ? keyword : field,
          instancePath: instancePath ? `/${instancePath}` : "",
          schemaPath: schemaPath ? `#${schemaPath}` : "#",
          params: params !== null && params !== undefined ? params : { value: error.message },
          message: message !== null && message !== undefined ? message : error.message
        };
      });
    }
    return;
  }
}

// node_modules/web3-validator/lib/esm/web3_validator.js
class Web3Validator {
  constructor() {
    this._validator = Validator.factory();
  }
  validateJSONSchema(schema, data, options) {
    return this._validator.validate(schema, data, options);
  }
  validate(schema, data, options = { silent: false }) {
    var _a, _b;
    const jsonSchema = ethAbiToJsonSchema(schema);
    if (Array.isArray(jsonSchema.items) && ((_a = jsonSchema.items) === null || _a === undefined ? undefined : _a.length) === 0 && data.length === 0) {
      return;
    }
    if (Array.isArray(jsonSchema.items) && ((_b = jsonSchema.items) === null || _b === undefined ? undefined : _b.length) === 0 && data.length !== 0) {
      throw new Web3ValidatorError([
        {
          instancePath: "/0",
          schemaPath: "/",
          keyword: "required",
          message: "empty schema against data can not be validated",
          params: data
        }
      ]);
    }
    return this._validator.validate(jsonSchema, data, options);
  }
}
// node_modules/web3-validator/lib/esm/default_validator.js
var validator2 = new Web3Validator;
// node_modules/web3-utils/lib/esm/uint8array.js
function isUint8Array2(data) {
  var _a;
  return data instanceof Uint8Array || ((_a = data === null || data === undefined ? undefined : data.constructor) === null || _a === undefined ? undefined : _a.name) === "Uint8Array";
}
function uint8ArrayConcat(...parts) {
  const length = parts.reduce((prev, part) => {
    const agg = prev + part.length;
    return agg;
  }, 0);
  const result = new Uint8Array(length);
  let offset = 0;
  for (const part of parts) {
    result.set(part, offset);
    offset += part.length;
  }
  return result;
}
function uint8ArrayEquals(a, b) {
  if (a === b) {
    return true;
  }
  if (a.byteLength !== b.byteLength) {
    return false;
  }
  for (let i = 0;i < a.byteLength; i += 1) {
    if (a[i] !== b[i]) {
      return false;
    }
  }
  return true;
}

// node_modules/web3-utils/lib/esm/converters.js
var ethUnitMap = {
  noether: BigInt(0),
  wei: BigInt(1),
  kwei: BigInt(1000),
  Kwei: BigInt(1000),
  babbage: BigInt(1000),
  femtoether: BigInt(1000),
  mwei: BigInt(1e6),
  Mwei: BigInt(1e6),
  lovelace: BigInt(1e6),
  picoether: BigInt(1e6),
  gwei: BigInt(1e9),
  Gwei: BigInt(1e9),
  shannon: BigInt(1e9),
  nanoether: BigInt(1e9),
  nano: BigInt(1e9),
  szabo: BigInt(1000000000000),
  microether: BigInt(1000000000000),
  micro: BigInt(1000000000000),
  finney: BigInt(1000000000000000),
  milliether: BigInt(1000000000000000),
  milli: BigInt(1000000000000000),
  ether: BigInt("1000000000000000000"),
  kether: BigInt("1000000000000000000000"),
  grand: BigInt("1000000000000000000000"),
  mether: BigInt("1000000000000000000000000"),
  gether: BigInt("1000000000000000000000000000"),
  tether: BigInt("1000000000000000000000000000000")
};
var bytesToUint8Array = (data) => {
  validator2.validate(["bytes"], [data]);
  if (isUint8Array2(data)) {
    return data;
  }
  if (Array.isArray(data)) {
    return new Uint8Array(data);
  }
  if (typeof data === "string") {
    return exports_utils.hexToUint8Array(data);
  }
  throw new InvalidBytesError(data);
};
var { uint8ArrayToHexString: uint8ArrayToHexString2 } = exports_utils;
var bytesToHex2 = (bytes5) => uint8ArrayToHexString2(bytesToUint8Array(bytes5));
var hexToBytes = (bytes5) => {
  if (typeof bytes5 === "string" && bytes5.slice(0, 2).toLowerCase() !== "0x") {
    return bytesToUint8Array(`0x${bytes5}`);
  }
  return bytesToUint8Array(bytes5);
};
var hexToNumber2 = (value) => {
  validator2.validate(["hex"], [value]);
  return exports_utils.hexToNumber(value);
};
var toDecimal = hexToNumber2;
var numberToHex2 = (value, hexstrict) => {
  if (typeof value !== "bigint")
    validator2.validate(["int"], [value]);
  let updatedValue = exports_utils.numberToHex(value);
  if (hexstrict) {
    if (!updatedValue.startsWith("-") && updatedValue.length % 2 === 1) {
      updatedValue = "0x0".concat(updatedValue.slice(2));
    } else if (updatedValue.length % 2 === 0 && updatedValue.startsWith("-"))
      updatedValue = "-0x0".concat(updatedValue.slice(3));
  }
  return updatedValue;
};
var fromDecimal = numberToHex2;
var hexToNumberString = (data) => hexToNumber2(data).toString();
var utf8ToHex = (str) => {
  validator2.validate(["string"], [str]);
  let strWithoutNullCharacter = str.replace(/^(?:\u0000)/, "");
  strWithoutNullCharacter = strWithoutNullCharacter.replace(/(?:\u0000)$/, "");
  return bytesToHex2(new TextEncoder().encode(strWithoutNullCharacter));
};
var fromUtf8 = utf8ToHex;
var stringToHex = utf8ToHex;
var hexToUtf8 = (str) => bytesToUtf8(hexToBytes(str));
var toUtf8 = (input) => {
  if (typeof input === "string") {
    return hexToUtf8(input);
  }
  validator2.validate(["bytes"], [input]);
  return bytesToUtf8(input);
};
var utf8ToBytes2 = utf8ToBytes;
var hexToString = hexToUtf8;
var asciiToHex = (str) => {
  validator2.validate(["string"], [str]);
  let hexString = "";
  for (let i = 0;i < str.length; i += 1) {
    const hexCharCode = str.charCodeAt(i).toString(16);
    hexString += hexCharCode.length % 2 !== 0 ? `0${hexCharCode}` : hexCharCode;
  }
  return `0x${hexString}`;
};
var fromAscii = asciiToHex;
var hexToAscii = (str) => {
  const decoder = new TextDecoder("ascii");
  return decoder.decode(hexToBytes(str));
};
var toAscii = hexToAscii;
var toHex = (value, returnType) => {
  if (typeof value === "string" && isAddress(value)) {
    return returnType ? "address" : `0x${value.toLowerCase().replace(/^0x/i, "")}`;
  }
  if (typeof value === "boolean") {
    return returnType ? "bool" : value ? "0x01" : "0x00";
  }
  if (typeof value === "number") {
    return returnType ? value < 0 ? "int256" : "uint256" : numberToHex2(value);
  }
  if (typeof value === "bigint") {
    return returnType ? "bigint" : numberToHex2(value);
  }
  if (typeof value === "object" && !!value) {
    return returnType ? "string" : utf8ToHex(JSON.stringify(value));
  }
  if (typeof value === "string") {
    if (value.startsWith("-0x") || value.startsWith("-0X")) {
      return returnType ? "int256" : numberToHex2(value);
    }
    if (isHexStrict(value)) {
      return returnType ? "bytes" : value;
    }
    if (isHex(value) && !isInt(value) && !isUInt(value)) {
      return returnType ? "bytes" : `0x${value}`;
    }
    if (isHex(value) && !isInt(value) && isUInt(value)) {
      return returnType ? "uint" : numberToHex2(value);
    }
    if (!Number.isFinite(value)) {
      return returnType ? "string" : utf8ToHex(value);
    }
  }
  throw new HexProcessingError(value);
};
var toNumber = (value) => {
  if (typeof value === "number") {
    if (value > 100000000000000000000) {
      return BigInt(value);
    }
    return value;
  }
  if (typeof value === "bigint") {
    return value >= Number.MIN_SAFE_INTEGER && value <= Number.MAX_SAFE_INTEGER ? Number(value) : value;
  }
  if (typeof value === "string" && isHexStrict(value)) {
    return hexToNumber2(value);
  }
  try {
    return toNumber(BigInt(value));
  } catch (_a) {
    throw new InvalidNumberError(value);
  }
};
var toBigInt = (value) => {
  if (typeof value === "number") {
    return BigInt(value);
  }
  if (typeof value === "bigint") {
    return value;
  }
  if (typeof value === "string" && isHex(value)) {
    if (value.startsWith("-")) {
      return -BigInt(value.substring(1));
    }
    return BigInt(value);
  }
  throw new InvalidNumberError(value);
};
var fromWei = (number2, unit) => {
  const denomination = ethUnitMap[unit];
  if (!denomination) {
    throw new InvalidUnitError(unit);
  }
  const value = String(toNumber(number2));
  const numberOfZerosInDenomination = denomination.toString().length - 1;
  if (numberOfZerosInDenomination <= 0) {
    return value.toString();
  }
  const zeroPaddedValue = value.padStart(numberOfZerosInDenomination, "0");
  const integer = zeroPaddedValue.slice(0, -numberOfZerosInDenomination);
  const fraction = zeroPaddedValue.slice(-numberOfZerosInDenomination).replace(/\.?0+$/, "");
  if (integer === "") {
    return `0.${fraction}`;
  }
  if (fraction === "") {
    return integer;
  }
  return `${integer}.${fraction}`;
};
var toWei = (number2, unit) => {
  validator2.validate(["number"], [number2]);
  const denomination = ethUnitMap[unit];
  if (!denomination) {
    throw new InvalidUnitError(unit);
  }
  const [integer, fraction] = String(typeof number2 === "string" && !isHexStrict(number2) ? number2 : toNumber(number2)).split(".").concat("");
  const value = BigInt(`${integer}${fraction}`);
  const updatedValue = value * denomination;
  const numberOfZerosInDenomination = denomination.toString().length - 1;
  const decimals = Math.min(fraction.length, numberOfZerosInDenomination);
  if (decimals === 0) {
    return updatedValue.toString();
  }
  return updatedValue.toString().padStart(decimals, "0").slice(0, -decimals);
};
var toChecksumAddress = (address5) => {
  if (!isAddress(address5, false)) {
    throw new InvalidAddressError(address5);
  }
  const lowerCaseAddress = address5.toLowerCase().replace(/^0x/i, "");
  const hash2 = exports_utils.uint8ArrayToHexString(keccak256(exports_utils.ensureIfUint8Array(utf8ToBytes2(lowerCaseAddress))));
  if (isNullish(hash2) || hash2 === "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470")
    return "";
  let checksumAddress = "0x";
  const addressHash = hash2.replace(/^0x/i, "");
  for (let i = 0;i < lowerCaseAddress.length; i += 1) {
    if (parseInt(addressHash[i], 16) > 7) {
      checksumAddress += lowerCaseAddress[i].toUpperCase();
    } else {
      checksumAddress += lowerCaseAddress[i];
    }
  }
  return checksumAddress;
};
var toBool = (value) => {
  if (typeof value === "boolean") {
    return value;
  }
  if (typeof value === "number" && (value === 0 || value === 1)) {
    return Boolean(value);
  }
  if (typeof value === "bigint" && (value === BigInt(0) || value === BigInt(1))) {
    return Boolean(value);
  }
  if (typeof value === "string" && !isHexStrict(value) && (value === "1" || value === "0" || value === "false" || value === "true")) {
    if (value === "true") {
      return true;
    }
    if (value === "false") {
      return false;
    }
    return Boolean(Number(value));
  }
  if (typeof value === "string" && isHexStrict(value) && (value === "0x1" || value === "0x0")) {
    return Boolean(toNumber(value));
  }
  throw new InvalidBooleanError(value);
};
// node_modules/eventemitter3/index.mjs
var import_ = __toESM(require_eventemitter3(), 1);
var eventemitter3_default = import_.default;

// node_modules/web3-utils/lib/esm/event_emitter.js
class EventEmitter2 extends eventemitter3_default {
  constructor() {
    super(...arguments);
    this.maxListeners = Number.MAX_SAFE_INTEGER;
  }
  setMaxListeners(maxListeners) {
    this.maxListeners = maxListeners;
    return this;
  }
  getMaxListeners() {
    return this.maxListeners;
  }
}
// node_modules/web3-utils/lib/esm/validation.js
var isHexStrict2 = isHexStrict;
var isHex2 = isHex;
var checkAddressCheckSum2 = checkAddressCheckSum;
var isAddress2 = isAddress;
var isBloom2 = isBloom;
var isInBloom2 = isInBloom;
var isUserEthereumAddressInBloom2 = isUserEthereumAddressInBloom;
var isContractAddressInBloom2 = isContractAddressInBloom;
var isTopic2 = isTopic;
var isTopicInBloom2 = isTopicInBloom;
var compareBlockNumbers = (blockA, blockB) => {
  const isABlockTag = typeof blockA === "string" && isBlockTag(blockA);
  const isBBlockTag = typeof blockB === "string" && isBlockTag(blockB);
  if (blockA === blockB || (blockA === "earliest" || blockA === 0) && (blockB === "earliest" || blockB === 0)) {
    return 0;
  }
  if (blockA === "earliest" && blockB > 0) {
    return -1;
  }
  if (blockB === "earliest" && blockA > 0) {
    return 1;
  }
  if (isABlockTag && isBBlockTag) {
    const tagsOrder = {
      [BlockTags.EARLIEST]: 1,
      [BlockTags.FINALIZED]: 2,
      [BlockTags.SAFE]: 3,
      [BlockTags.LATEST]: 4,
      [BlockTags.PENDING]: 5
    };
    if (tagsOrder[blockA] < tagsOrder[blockB]) {
      return -1;
    }
    return 1;
  }
  if (isABlockTag && !isBBlockTag || !isABlockTag && isBBlockTag) {
    throw new InvalidBlockError("Cannot compare blocktag with provided non-blocktag input.");
  }
  const bigIntA = BigInt(blockA);
  const bigIntB = BigInt(blockB);
  if (bigIntA < bigIntB) {
    return -1;
  }
  if (bigIntA === bigIntB) {
    return 0;
  }
  return 1;
};
var isContractInitOptions = (options) => typeof options === "object" && !isNullish(options) && Object.keys(options).length !== 0 && [
  "input",
  "data",
  "from",
  "gas",
  "gasPrice",
  "gasLimit",
  "address",
  "jsonInterface",
  "syncWithContext",
  "dataInputFill"
].some((key) => (key in options));
var isNullish2 = isNullish;
// node_modules/web3-utils/lib/esm/objects.js
var isIterable = (item) => typeof item === "object" && !isNullish(item) && !Array.isArray(item) && !(item instanceof TypedArray);
var mergeDeep = (destination, ...sources) => {
  if (!isIterable(destination)) {
    return destination;
  }
  const result = Object.assign({}, destination);
  for (const src of sources) {
    for (const key in src) {
      if (isIterable(src[key])) {
        if (!result[key]) {
          result[key] = {};
        }
        result[key] = mergeDeep(result[key], src[key]);
      } else if (!isNullish(src[key]) && Object.hasOwnProperty.call(src, key)) {
        if (Array.isArray(src[key]) || src[key] instanceof TypedArray) {
          result[key] = src[key].slice(0);
        } else {
          result[key] = src[key];
        }
      }
    }
  }
  return result;
};

// node_modules/web3-utils/lib/esm/string_manipulation.js
var padLeft2 = (value, characterAmount, sign = "0") => {
  if (typeof value === "string") {
    if (!isHexStrict(value)) {
      return value.padStart(characterAmount, sign);
    }
    return exports_utils.padLeft(value, characterAmount, sign);
  }
  validator2.validate(["int"], [value]);
  return exports_utils.padLeft(value, characterAmount, sign);
};
var padRight = (value, characterAmount, sign = "0") => {
  if (typeof value === "string" && !isHexStrict(value)) {
    return value.padEnd(characterAmount, sign);
  }
  validator2.validate(["int"], [value]);
  const hexString = typeof value === "string" && isHexStrict(value) ? value : numberToHex2(value);
  const prefixLength = hexString.startsWith("-") ? 3 : 2;
  return hexString.padEnd(characterAmount + prefixLength, sign);
};
var rightPad = padRight;
var leftPad = padLeft2;
var toTwosComplement = (value, nibbleWidth = 64) => {
  validator2.validate(["int"], [value]);
  const val = toNumber(value);
  if (val >= 0)
    return padLeft2(toHex(val), nibbleWidth);
  const largestBit = bigintPower(BigInt(2), BigInt(nibbleWidth * 4));
  if (-val >= largestBit) {
    throw new NibbleWidthError(`value: ${value}, nibbleWidth: ${nibbleWidth}`);
  }
  const updatedVal = BigInt(val);
  const complement = updatedVal + largestBit;
  return padLeft2(numberToHex2(complement), nibbleWidth);
};
var fromTwosComplement = (value, nibbleWidth = 64) => {
  validator2.validate(["int"], [value]);
  const val = toNumber(value);
  if (val < 0)
    return val;
  const largestBit = Math.ceil(Math.log(Number(val)) / Math.log(2));
  if (largestBit > nibbleWidth * 4)
    throw new NibbleWidthError(`value: "${value}", nibbleWidth: "${nibbleWidth}"`);
  if (nibbleWidth * 4 !== largestBit)
    return val;
  const complement = bigintPower(BigInt(2), BigInt(nibbleWidth) * BigInt(4));
  return toNumber(BigInt(val) - complement);
};

// node_modules/web3-utils/lib/esm/formatter.js
var { parseBaseType: parseBaseType2 } = exports_utils;
var isDataFormat = (dataFormat) => typeof dataFormat === "object" && !isNullish(dataFormat) && ("number" in dataFormat) && ("bytes" in dataFormat);
var findSchemaByDataPath = (schema, dataPath, oneOfPath = []) => {
  let result = Object.assign({}, schema);
  let previousDataPath;
  for (const dataPart of dataPath) {
    if (result.oneOf && previousDataPath) {
      const path = oneOfPath.find(function(element) {
        return this === element[0];
      }, previousDataPath !== null && previousDataPath !== undefined ? previousDataPath : "");
      if (path && path[0] === previousDataPath) {
        result = result.oneOf[path[1]];
      }
    }
    if (!result.properties && !result.items) {
      return;
    }
    if (result.properties) {
      result = result.properties[dataPart];
    } else if (result.items && result.items.properties) {
      const node = result.items.properties;
      if (!node) {
        return;
      }
      result = node[dataPart];
    } else if (result.items && isObject(result.items)) {
      result = result.items;
    } else if (result.items && Array.isArray(result.items)) {
      result = result.items[parseInt(dataPart, 10)];
    }
    if (result && dataPart)
      previousDataPath = dataPart;
  }
  return result;
};
var convertScalarValue = (value, ethType, format) => {
  try {
    const { baseType, baseTypeSize } = parseBaseType2(ethType);
    if (baseType === "int" || baseType === "uint") {
      switch (format.number) {
        case FMT_NUMBER.NUMBER:
          return Number(toBigInt(value));
        case FMT_NUMBER.HEX:
          return numberToHex2(toBigInt(value));
        case FMT_NUMBER.STR:
          return toBigInt(value).toString();
        case FMT_NUMBER.BIGINT:
          return toBigInt(value);
        default:
          throw new FormatterError(`Invalid format: ${String(format.number)}`);
      }
    }
    if (baseType === "bytes") {
      let paddedValue;
      if (baseTypeSize) {
        if (typeof value === "string")
          paddedValue = padLeft2(value, baseTypeSize * 2);
        else if (isUint8Array2(value)) {
          paddedValue = uint8ArrayConcat(new Uint8Array(baseTypeSize - value.length), value);
        }
      } else {
        paddedValue = value;
      }
      switch (format.bytes) {
        case FMT_BYTES.HEX:
          return bytesToHex2(bytesToUint8Array(paddedValue));
        case FMT_BYTES.UINT8ARRAY:
          return bytesToUint8Array(paddedValue);
        default:
          throw new FormatterError(`Invalid format: ${String(format.bytes)}`);
      }
    }
  } catch (error) {
    return value;
  }
  return value;
};
var convert = (data, schema, dataPath, format, oneOfPath = []) => {
  var _a, _b;
  if (!isObject(data) && !Array.isArray(data)) {
    return convertScalarValue(data, schema === null || schema === undefined ? undefined : schema.format, format);
  }
  const object3 = data;
  for (const [key, value] of Object.entries(object3)) {
    dataPath.push(key);
    const schemaProp = findSchemaByDataPath(schema, dataPath, oneOfPath);
    if (isNullish(schemaProp)) {
      delete object3[key];
      dataPath.pop();
      continue;
    }
    if (isObject(value)) {
      convert(value, schema, dataPath, format);
      dataPath.pop();
      continue;
    }
    if (Array.isArray(value)) {
      let _schemaProp = schemaProp;
      if ((schemaProp === null || schemaProp === undefined ? undefined : schemaProp.oneOf) !== undefined) {
        schemaProp.oneOf.forEach((oneOfSchemaProp, index) => {
          var _a2, _b2;
          if (!Array.isArray(schemaProp === null || schemaProp === undefined ? undefined : schemaProp.items) && (typeof value[0] === "object" && ((_a2 = oneOfSchemaProp === null || oneOfSchemaProp === undefined ? undefined : oneOfSchemaProp.items) === null || _a2 === undefined ? undefined : _a2.type) === "object" || typeof value[0] === "string" && ((_b2 = oneOfSchemaProp === null || oneOfSchemaProp === undefined ? undefined : oneOfSchemaProp.items) === null || _b2 === undefined ? undefined : _b2.type) !== "object")) {
            _schemaProp = oneOfSchemaProp;
            oneOfPath.push([key, index]);
          }
        });
      }
      if (isNullish(_schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items)) {
        delete object3[key];
        dataPath.pop();
        continue;
      }
      if (isObject(_schemaProp.items) && !isNullish(_schemaProp.items.format)) {
        for (let i = 0;i < value.length; i += 1) {
          object3[key][i] = convertScalarValue(value[i], (_a = _schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items) === null || _a === undefined ? undefined : _a.format, format);
        }
        dataPath.pop();
        continue;
      }
      if (!Array.isArray(_schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items) && ((_b = _schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items) === null || _b === undefined ? undefined : _b.type) === "object") {
        for (const arrObject of value) {
          convert(arrObject, schema, dataPath, format, oneOfPath);
        }
        dataPath.pop();
        continue;
      }
      if (Array.isArray(_schemaProp === null || _schemaProp === undefined ? undefined : _schemaProp.items)) {
        for (let i = 0;i < value.length; i += 1) {
          object3[key][i] = convertScalarValue(value[i], _schemaProp.items[i].format, format);
        }
        dataPath.pop();
        continue;
      }
    }
    object3[key] = convertScalarValue(value, schemaProp.format, format);
    dataPath.pop();
  }
  return object3;
};
var format = (schema, data, returnFormat) => {
  let dataToParse;
  if (isObject(data)) {
    dataToParse = mergeDeep({}, data);
  } else if (Array.isArray(data)) {
    dataToParse = [...data];
  } else {
    dataToParse = data;
  }
  const jsonSchema = isObject(schema) ? schema : exports_utils.ethAbiToJsonSchema(schema);
  if (!jsonSchema.properties && !jsonSchema.items && !jsonSchema.format) {
    throw new FormatterError("Invalid json schema for formatting");
  }
  return convert(dataToParse, jsonSchema, [], returnFormat);
};
// node_modules/web3-utils/lib/esm/hash.js
var SHA3_EMPTY_BYTES = "0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470";
var sha32 = (data) => {
  let updatedData;
  if (typeof data === "string") {
    if (data.startsWith("0x") && isHexStrict(data)) {
      updatedData = hexToBytes(data);
    } else {
      updatedData = utf8ToBytes(data);
    }
  } else {
    updatedData = data;
  }
  const hash2 = bytesToHex2(keccak256(exports_utils.ensureIfUint8Array(updatedData)));
  return hash2 === SHA3_EMPTY_BYTES ? undefined : hash2;
};
var sha3Raw = (data) => {
  const hash2 = sha32(data);
  if (isNullish(hash2)) {
    return SHA3_EMPTY_BYTES;
  }
  return hash2;
};
var keccak256Wrapper = (data) => {
  let processedData;
  if (typeof data === "bigint" || typeof data === "number") {
    processedData = utf8ToBytes(data.toString());
  } else if (Array.isArray(data)) {
    processedData = new Uint8Array(data);
  } else if (typeof data === "string" && !isHexStrict(data)) {
    processedData = utf8ToBytes(data);
  } else {
    processedData = bytesToUint8Array(data);
  }
  return bytesToHex2(keccak256(exports_utils.ensureIfUint8Array(processedData)));
};
var getType = (arg) => {
  if (Array.isArray(arg)) {
    throw new Error("Autodetection of array types is not supported.");
  }
  let type;
  let value;
  if (typeof arg === "object" && (("t" in arg) || ("type" in arg)) && (("v" in arg) || ("value" in arg))) {
    type = "t" in arg ? arg.t : arg.type;
    value = "v" in arg ? arg.v : arg.value;
    type = type.toLowerCase() === "bigint" ? "int" : type;
  } else if (typeof arg === "bigint") {
    return ["int", arg];
  } else {
    type = toHex(arg, true);
    value = toHex(arg);
    if (!type.startsWith("int") && !type.startsWith("uint")) {
      type = "bytes";
    }
  }
  if ((type.startsWith("int") || type.startsWith("uint")) && typeof value === "string" && !/^(-)?0x/i.test(value)) {
    value = toBigInt(value);
  }
  return [type, value];
};
var elementaryName = (name) => {
  if (name.startsWith("int[")) {
    return `int256${name.slice(3)}`;
  }
  if (name === "int") {
    return "int256";
  }
  if (name.startsWith("uint[")) {
    return `uint256'${name.slice(4)}`;
  }
  if (name === "uint") {
    return "uint256";
  }
  return name;
};
var parseTypeN = (value, typeLength) => {
  const typesize = /^(\d+).*$/.exec(value.slice(typeLength));
  return typesize ? parseInt(typesize[1], 10) : 0;
};
var bitLength = (value) => {
  const updatedVal = value.toString(2);
  return updatedVal.length;
};
var solidityPack = (type, val) => {
  const value = val.toString();
  if (type === "string") {
    if (typeof val === "string")
      return utf8ToHex(val);
    throw new InvalidStringError(val);
  }
  if (type === "bool" || type === "boolean") {
    if (typeof val === "boolean")
      return val ? "01" : "00";
    throw new InvalidBooleanError(val);
  }
  if (type === "address") {
    if (!isAddress(value)) {
      throw new InvalidAddressError(value);
    }
    return value;
  }
  const name = elementaryName(type);
  if (type.startsWith("uint")) {
    const size = parseTypeN(name, "uint".length);
    if (size % 8 || size < 8 || size > 256) {
      throw new InvalidSizeError(value);
    }
    const num = toNumber(value);
    if (bitLength(num) > size) {
      throw new InvalidLargeValueError(value);
    }
    if (num < BigInt(0)) {
      throw new InvalidUnsignedIntegerError(value);
    }
    return size ? leftPad(num.toString(16), size / 8 * 2) : num.toString(16);
  }
  if (type.startsWith("int")) {
    const size = parseTypeN(name, "int".length);
    if (size % 8 || size < 8 || size > 256) {
      throw new InvalidSizeError(type);
    }
    const num = toNumber(value);
    if (bitLength(num) > size) {
      throw new InvalidLargeValueError(value);
    }
    if (num < BigInt(0)) {
      return toTwosComplement(num.toString(), size / 8 * 2);
    }
    return size ? leftPad(num.toString(16), size / 4) : num.toString(16);
  }
  if (name === "bytes") {
    if (value.replace(/^0x/i, "").length % 2 !== 0) {
      throw new InvalidBytesError(value);
    }
    return value;
  }
  if (type.startsWith("bytes")) {
    if (value.replace(/^0x/i, "").length % 2 !== 0) {
      throw new InvalidBytesError(value);
    }
    const size = parseTypeN(type, "bytes".length);
    if (!size || size < 1 || size > 64 || size < value.replace(/^0x/i, "").length / 2) {
      throw new InvalidBytesError(value);
    }
    return rightPad(value, size * 2);
  }
  return "";
};
var processSolidityEncodePackedArgs = (arg) => {
  const [type, val] = getType(arg);
  if (Array.isArray(val)) {
    const hexArg2 = val.map((v) => solidityPack(type, v).replace("0x", ""));
    return hexArg2.join("");
  }
  const hexArg = solidityPack(type, val);
  return hexArg.replace("0x", "");
};
var encodePacked = (...values) => {
  const hexArgs = values.map(processSolidityEncodePackedArgs);
  return `0x${hexArgs.join("").toLowerCase()}`;
};
var soliditySha3 = (...values) => sha32(encodePacked(...values));
var soliditySha3Raw = (...values) => sha3Raw(encodePacked(...values));
var getStorageSlotNumForLongString = (mainSlotNumber) => sha32(`0x${(typeof mainSlotNumber === "number" ? mainSlotNumber.toString() : mainSlotNumber).padStart(64, "0")}`);
// node_modules/ethereum-cryptography/esm/random.js
function getRandomBytesSync(bytes5) {
  return randomBytes(bytes5);
}

// node_modules/web3-utils/lib/esm/random.js
var randomBytes2 = (size) => getRandomBytesSync(size);
var randomHex = (byteSize) => bytesToHex2(randomBytes2(byteSize));
// node_modules/web3-utils/lib/esm/promise_helpers.js
function isPromise(object3) {
  return (typeof object3 === "object" || typeof object3 === "function") && typeof object3.then === "function";
}
function waitWithTimeout(awaitable, timeout, error) {
  return __awaiter2(this, undefined, undefined, function* () {
    let timeoutId;
    const result = yield Promise.race([
      awaitable instanceof Promise ? awaitable : awaitable(),
      new Promise((resolve, reject) => {
        timeoutId = setTimeout(() => error ? reject(error) : resolve(undefined), timeout);
      })
    ]);
    if (timeoutId) {
      clearTimeout(timeoutId);
    }
    if (result instanceof Error) {
      throw result;
    }
    return result;
  });
}
function pollTillDefinedAndReturnIntervalId(func, interval) {
  let intervalId;
  const polledRes = new Promise((resolve, reject) => {
    intervalId = setInterval(function intervalCallbackFunc() {
      (() => __awaiter2(this, undefined, undefined, function* () {
        try {
          const res = yield waitWithTimeout(func, interval);
          if (!isNullish(res)) {
            clearInterval(intervalId);
            resolve(res);
          }
        } catch (error) {
          clearInterval(intervalId);
          reject(error);
        }
      }))();
      return intervalCallbackFunc;
    }(), interval);
  });
  return [polledRes, intervalId];
}
function pollTillDefined(func, interval) {
  return __awaiter2(this, undefined, undefined, function* () {
    return pollTillDefinedAndReturnIntervalId(func, interval)[0];
  });
}
function rejectIfTimeout(timeout, error) {
  let timeoutId;
  const rejectOnTimeout = new Promise((_, reject) => {
    timeoutId = setTimeout(() => {
      reject(error);
    }, timeout);
  });
  return [timeoutId, rejectOnTimeout];
}
function rejectIfConditionAtInterval(cond, interval) {
  let intervalId;
  const rejectIfCondition = new Promise((_, reject) => {
    intervalId = setInterval(() => {
      (() => __awaiter2(this, undefined, undefined, function* () {
        const error = yield cond();
        if (error) {
          clearInterval(intervalId);
          reject(error);
        }
      }))();
    }, interval);
  });
  return [intervalId, rejectIfCondition];
}
var __awaiter2 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
// node_modules/web3-utils/lib/esm/json_rpc.js
var exports_json_rpc = {};
__export(exports_json_rpc, {
  validateResponse: () => {
    {
      return validateResponse;
    }
  },
  toPayload: () => {
    {
      return toPayload;
    }
  },
  toBatchPayload: () => {
    {
      return toBatchPayload;
    }
  },
  setRequestIdStart: () => {
    {
      return setRequestIdStart;
    }
  },
  isValidResponse: () => {
    {
      return isValidResponse;
    }
  },
  isSubscriptionResult: () => {
    {
      return isSubscriptionResult;
    }
  },
  isResponseWithResult: () => {
    {
      return isResponseWithResult;
    }
  },
  isResponseWithNotification: () => {
    {
      return isResponseWithNotification;
    }
  },
  isResponseWithError: () => {
    {
      return isResponseWithError2;
    }
  },
  isResponseRpcError: () => {
    {
      return isResponseRpcError;
    }
  },
  isBatchResponse: () => {
    {
      return isBatchResponse;
    }
  },
  isBatchRequest: () => {
    {
      return isBatchRequest;
    }
  }
});

// node_modules/web3-utils/lib/esm/uuid.js
var uuidV4 = () => {
  const bytes5 = randomBytes2(16);
  bytes5[6] = bytes5[6] & 15 | 64;
  bytes5[8] = bytes5[8] & 63 | 128;
  const hexString = bytesToHex2(bytes5);
  return [
    hexString.substring(2, 10),
    hexString.substring(10, 14),
    hexString.substring(14, 18),
    hexString.substring(18, 22),
    hexString.substring(22, 34)
  ].join("-");
};

// node_modules/web3-utils/lib/esm/json_rpc.js
var isResponseRpcError = (rpcError) => {
  const errorCode = rpcError.error.code;
  return rpcErrorsMap.has(errorCode) || errorCode >= -32099 && errorCode <= -32000;
};
var isResponseWithResult = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && ("result" in response) && isNullish(response.error) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithError2 = (response) => !Array.isArray(response) && response.jsonrpc === "2.0" && !!response && isNullish(response.result) && ("error" in response) && (typeof response.id === "number" || typeof response.id === "string");
var isResponseWithNotification = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && !isNullish(response.params) && !isNullish(response.method);
var isSubscriptionResult = (response) => !Array.isArray(response) && !!response && response.jsonrpc === "2.0" && ("id" in response) && ("result" in response);
var validateResponse = (response) => isResponseWithResult(response) || isResponseWithError2(response);
var isValidResponse = (response) => Array.isArray(response) ? response.every(validateResponse) : validateResponse(response);
var isBatchResponse = (response) => Array.isArray(response) && response.length > 0 && isValidResponse(response);
var requestIdSeed;
var setRequestIdStart = (start) => {
  requestIdSeed = start;
};
var toPayload = (request) => {
  var _a, _b, _c, _d;
  if (typeof requestIdSeed !== "undefined") {
    requestIdSeed += 1;
  }
  return {
    jsonrpc: (_a = request.jsonrpc) !== null && _a !== undefined ? _a : "2.0",
    id: (_c = (_b = request.id) !== null && _b !== undefined ? _b : requestIdSeed) !== null && _c !== undefined ? _c : uuidV4(),
    method: request.method,
    params: (_d = request.params) !== null && _d !== undefined ? _d : undefined
  };
};
var toBatchPayload = (requests) => requests.map((request) => toPayload(request));
var isBatchRequest = (request) => Array.isArray(request) && request.length > 0;
// node_modules/web3-utils/lib/esm/web3_deferred_promise.js
var __awaiter3 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a;

class Web3DeferredPromise {
  constructor({ timeout, eagerStart, timeoutMessage } = {
    timeout: 0,
    eagerStart: false,
    timeoutMessage: "DeferredPromise timed out"
  }) {
    this[_a] = "Promise";
    this._state = "pending";
    this._promise = new Promise((resolve, reject) => {
      this._resolve = resolve;
      this._reject = reject;
    });
    this._timeoutMessage = timeoutMessage;
    this._timeoutInterval = timeout;
    if (eagerStart) {
      this.startTimer();
    }
  }
  get state() {
    return this._state;
  }
  then(onfulfilled, onrejected) {
    return __awaiter3(this, undefined, undefined, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter3(this, undefined, undefined, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter3(this, undefined, undefined, function* () {
      return this._promise.finally(onfinally);
    });
  }
  resolve(value) {
    this._resolve(value);
    this._state = "fulfilled";
    this._clearTimeout();
  }
  reject(reason) {
    this._reject(reason);
    this._state = "rejected";
    this._clearTimeout();
  }
  startTimer() {
    if (this._timeoutInterval && this._timeoutInterval > 0) {
      this._timeoutId = setTimeout(this._checkTimeout.bind(this), this._timeoutInterval);
    }
  }
  _checkTimeout() {
    if (this._state === "pending" && this._timeoutId) {
      this.reject(new OperationTimeoutError(this._timeoutMessage));
    }
  }
  _clearTimeout() {
    if (this._timeoutId) {
      clearTimeout(this._timeoutId);
    }
  }
}
_a = Symbol.toStringTag;
// node_modules/web3-utils/lib/esm/chunk_response_parser.js
class ChunkResponseParser {
  constructor(eventEmitter, autoReconnect) {
    this.eventEmitter = eventEmitter;
    this.autoReconnect = autoReconnect;
    this.chunkTimeout = 1000 * 15;
  }
  clearQueues() {
    if (typeof this._clearQueues === "function") {
      this._clearQueues();
    }
  }
  onError(clearQueues) {
    this._clearQueues = clearQueues;
  }
  parseResponse(data) {
    const returnValues = [];
    const dechunkedData = data.replace(/\}[\n\r]?\{/g, "}|--|{").replace(/\}\][\n\r]?\[\{/g, "}]|--|[{").replace(/\}[\n\r]?\[\{/g, "}|--|[{").replace(/\}\][\n\r]?\{/g, "}]|--|{").split("|--|");
    dechunkedData.forEach((_chunkData) => {
      let chunkData = _chunkData;
      if (this.lastChunk) {
        chunkData = this.lastChunk + chunkData;
      }
      let result;
      try {
        result = JSON.parse(chunkData);
      } catch (e) {
        this.lastChunk = chunkData;
        if (this.lastChunkTimeout) {
          clearTimeout(this.lastChunkTimeout);
        }
        this.lastChunkTimeout = setTimeout(() => {
          if (this.autoReconnect)
            return;
          this.clearQueues();
          this.eventEmitter.emit("error", new InvalidResponseError({
            id: 1,
            jsonrpc: "2.0",
            error: { code: 2, message: "Chunk timeout" }
          }));
        }, this.chunkTimeout);
        return;
      }
      clearTimeout(this.lastChunkTimeout);
      this.lastChunk = undefined;
      if (result)
        returnValues.push(result);
    });
    return returnValues;
  }
}
// node_modules/web3-utils/lib/esm/web3_eip1193_provider.js
var __awaiter4 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Eip1193Provider extends Web3BaseProvider {
  constructor() {
    super(...arguments);
    this._eventEmitter = new import_.default;
    this._chainId = "";
    this._accounts = [];
  }
  _getChainId() {
    var _a2;
    return __awaiter4(this, undefined, undefined, function* () {
      const data = yield this.request(toPayload({
        method: "eth_chainId",
        params: []
      }));
      return (_a2 = data === null || data === undefined ? undefined : data.result) !== null && _a2 !== undefined ? _a2 : "";
    });
  }
  _getAccounts() {
    var _a2;
    return __awaiter4(this, undefined, undefined, function* () {
      const data = yield this.request(toPayload({
        method: "eth_accounts",
        params: []
      }));
      return (_a2 = data === null || data === undefined ? undefined : data.result) !== null && _a2 !== undefined ? _a2 : [];
    });
  }
  _onConnect() {
    Promise.all([
      this._getChainId().then((chainId) => {
        if (chainId !== this._chainId) {
          this._chainId = chainId;
          this._eventEmitter.emit("chainChanged", this._chainId);
        }
      }).catch((err) => {
        console.error(err);
      }),
      this._getAccounts().then((accounts) => {
        if (!(this._accounts.length === accounts.length && accounts.every((v) => accounts.includes(v)))) {
          this._accounts = accounts;
          this._onAccountsChanged();
        }
      }).catch((err) => {
        console.error(err);
      })
    ]).then(() => this._eventEmitter.emit("connect", {
      chainId: this._chainId
    })).catch((err) => {
      console.error(err);
    });
  }
  _onDisconnect(code, data) {
    this._eventEmitter.emit("disconnect", new EIP1193ProviderRpcError(code, data));
  }
  _onAccountsChanged() {
    this._eventEmitter.emit("accountsChanged", this._accounts);
  }
}
// node_modules/web3-utils/lib/esm/socket_provider.js
var __awaiter5 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_RECONNECTION_OPTIONS = {
  autoReconnect: true,
  delay: 5000,
  maxAttempts: 5
};
var NORMAL_CLOSE_CODE = 1000;

class SocketProvider extends Eip1193Provider {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super();
    this._connectionStatus = "connecting";
    this._onMessageHandler = this._onMessage.bind(this);
    this._onOpenHandler = this._onConnect.bind(this);
    this._onCloseHandler = this._onCloseEvent.bind(this);
    this._onErrorHandler = this._onError.bind(this);
    if (!this._validateProviderPath(socketPath))
      throw new InvalidClientError(socketPath);
    this._socketPath = socketPath;
    this._socketOptions = socketOptions;
    this._reconnectOptions = Object.assign(Object.assign({}, DEFAULT_RECONNECTION_OPTIONS), reconnectOptions !== null && reconnectOptions !== undefined ? reconnectOptions : {});
    this._pendingRequestsQueue = new Map;
    this._sentRequestsQueue = new Map;
    this._init();
    this.connect();
    this.chunkResponseParser = new ChunkResponseParser(this._eventEmitter, this._reconnectOptions.autoReconnect);
    this.chunkResponseParser.onError(() => {
      this._clearQueues();
    });
    this.isReconnecting = false;
  }
  get SocketConnection() {
    return this._socketConnection;
  }
  _init() {
    this._reconnectAttempts = 0;
  }
  connect() {
    try {
      this._openSocketConnection();
      this._connectionStatus = "connecting";
      this._addSocketListeners();
    } catch (e) {
      if (!this.isReconnecting) {
        this._connectionStatus = "disconnected";
        if (e && e.message) {
          throw new ConnectionError(`Error while connecting to ${this._socketPath}. Reason: ${e.message}`);
        } else {
          throw new InvalidClientError(this._socketPath);
        }
      } else {
        setImmediate(() => {
          this._reconnect();
        });
      }
    }
  }
  _validateProviderPath(path) {
    return !!path;
  }
  getPendingRequestQueueSize() {
    return this._pendingRequestsQueue.size;
  }
  getSentRequestsQueueSize() {
    return this._sentRequestsQueue.size;
  }
  supportsSubscriptions() {
    return true;
  }
  on(type, listener) {
    this._eventEmitter.on(type, listener);
  }
  once(type, listener) {
    this._eventEmitter.once(type, listener);
  }
  removeListener(type, listener) {
    this._eventEmitter.removeListener(type, listener);
  }
  _onDisconnect(code, data) {
    this._connectionStatus = "disconnected";
    super._onDisconnect(code, data);
  }
  disconnect(code, data) {
    const disconnectCode = code !== null && code !== undefined ? code : NORMAL_CLOSE_CODE;
    this._removeSocketListeners();
    if (this.getStatus() !== "disconnected") {
      this._closeSocketConnection(disconnectCode, data);
    }
    this._onDisconnect(disconnectCode, data);
  }
  safeDisconnect(code, data, forceDisconnect = false, ms = 1000) {
    return __awaiter5(this, undefined, undefined, function* () {
      let retryAttempt = 0;
      const checkQueue = () => __awaiter5(this, undefined, undefined, function* () {
        return new Promise((resolve) => {
          const interval = setInterval(() => {
            if (forceDisconnect && retryAttempt === 5) {
              this.clearQueues();
            }
            if (this.getPendingRequestQueueSize() === 0 && this.getSentRequestsQueueSize() === 0) {
              clearInterval(interval);
              resolve(true);
            }
            retryAttempt += 1;
          }, ms);
        });
      });
      yield checkQueue();
      this.disconnect(code, data);
    });
  }
  removeAllListeners(type) {
    this._eventEmitter.removeAllListeners(type);
  }
  _onError(event) {
    if (this.isReconnecting) {
      this._reconnect();
    } else {
      this._eventEmitter.emit("error", event);
    }
  }
  reset() {
    this._sentRequestsQueue.clear();
    this._pendingRequestsQueue.clear();
    this._init();
    this._removeSocketListeners();
    this._addSocketListeners();
  }
  _reconnect() {
    if (this.isReconnecting) {
      return;
    }
    this.isReconnecting = true;
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new PendingRequestsOnReconnectingError);
        this._sentRequestsQueue.delete(key);
      });
    }
    if (this._reconnectAttempts < this._reconnectOptions.maxAttempts) {
      this._reconnectAttempts += 1;
      setTimeout(() => {
        this._removeSocketListeners();
        this.connect();
        this.isReconnecting = false;
      }, this._reconnectOptions.delay);
    } else {
      this.isReconnecting = false;
      this._clearQueues();
      this._removeSocketListeners();
      this._eventEmitter.emit("error", new MaxAttemptsReachedOnReconnectingError(this._reconnectOptions.maxAttempts));
    }
  }
  request(request) {
    return __awaiter5(this, undefined, undefined, function* () {
      if (isNullish2(this._socketConnection)) {
        throw new Error("Connection is undefined");
      }
      if (this.getStatus() === "disconnected") {
        this.connect();
      }
      const requestId = isBatchRequest(request) ? request[0].id : request.id;
      if (!requestId) {
        throw new Web3WSProviderError("Request Id not defined");
      }
      if (this._sentRequestsQueue.has(requestId)) {
        throw new RequestAlreadySentError(requestId);
      }
      const deferredPromise = new Web3DeferredPromise;
      deferredPromise.catch((error) => {
        this._eventEmitter.emit("error", error);
      });
      const reqItem = {
        payload: request,
        deferredPromise
      };
      if (this.getStatus() === "connecting") {
        this._pendingRequestsQueue.set(requestId, reqItem);
        return reqItem.deferredPromise;
      }
      this._sentRequestsQueue.set(requestId, reqItem);
      try {
        this._sendToSocket(reqItem.payload);
      } catch (error) {
        this._sentRequestsQueue.delete(requestId);
        this._eventEmitter.emit("error", error);
      }
      return deferredPromise;
    });
  }
  _onConnect() {
    this._connectionStatus = "connected";
    this._reconnectAttempts = 0;
    super._onConnect();
    this._sendPendingRequests();
  }
  _sendPendingRequests() {
    for (const [id, value] of this._pendingRequestsQueue.entries()) {
      this._sendToSocket(value.payload);
      this._pendingRequestsQueue.delete(id);
      this._sentRequestsQueue.set(id, value);
    }
  }
  _onMessage(event) {
    const responses = this._parseResponses(event);
    if (isNullish2(responses) || responses.length === 0) {
      return;
    }
    for (const response of responses) {
      if (isResponseWithNotification(response) && response.method.endsWith("_subscription")) {
        this._eventEmitter.emit("message", response);
        return;
      }
      const requestId = isBatchResponse(response) ? response[0].id : response.id;
      const requestItem = this._sentRequestsQueue.get(requestId);
      if (!requestItem) {
        return;
      }
      if (isBatchResponse(response) || isResponseWithResult(response) || isResponseWithError2(response)) {
        this._eventEmitter.emit("message", response);
        requestItem.deferredPromise.resolve(response);
      }
      this._sentRequestsQueue.delete(requestId);
    }
  }
  clearQueues(event) {
    this._clearQueues(event);
  }
  _clearQueues(event) {
    if (this._pendingRequestsQueue.size > 0) {
      this._pendingRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._pendingRequestsQueue.delete(key);
      });
    }
    if (this._sentRequestsQueue.size > 0) {
      this._sentRequestsQueue.forEach((request, key) => {
        request.deferredPromise.reject(new ConnectionNotOpenError(event));
        this._sentRequestsQueue.delete(key);
      });
    }
    this._removeSocketListeners();
  }
}
// node_modules/web3-core/lib/esm/web3_event_emitter.js
class Web3EventEmitter {
  constructor() {
    this._emitter = new EventEmitter2;
  }
  on(eventName, fn) {
    this._emitter.on(eventName, fn);
  }
  once(eventName, fn) {
    this._emitter.once(eventName, fn);
  }
  off(eventName, fn) {
    this._emitter.off(eventName, fn);
  }
  emit(eventName, params) {
    this._emitter.emit(eventName, params);
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
  listeners(eventName) {
    return this._emitter.listeners(eventName);
  }
  eventNames() {
    return this._emitter.eventNames();
  }
  removeAllListeners() {
    return this._emitter.removeAllListeners();
  }
  setMaxListenerWarningThreshold(maxListenersWarningThreshold) {
    this._emitter.setMaxListeners(maxListenersWarningThreshold);
  }
  getMaxListeners() {
    return this._emitter.getMaxListeners();
  }
}

// node_modules/web3-core/lib/esm/web3_config.js
var Web3ConfigEvent;
(function(Web3ConfigEvent2) {
  Web3ConfigEvent2["CONFIG_CHANGE"] = "CONFIG_CHANGE";
})(Web3ConfigEvent || (Web3ConfigEvent = {}));

class Web3Config extends Web3EventEmitter {
  constructor(options) {
    super();
    this.config = {
      handleRevert: false,
      defaultAccount: undefined,
      defaultBlock: "latest",
      transactionBlockTimeout: 50,
      transactionConfirmationBlocks: 24,
      transactionPollingInterval: 1000,
      transactionPollingTimeout: 750 * 1000,
      transactionReceiptPollingInterval: undefined,
      transactionSendTimeout: 750 * 1000,
      transactionConfirmationPollingInterval: undefined,
      blockHeaderTimeout: 10,
      maxListenersWarningThreshold: 100,
      contractDataInputFill: "data",
      defaultNetworkId: undefined,
      defaultChain: "mainnet",
      defaultHardfork: "london",
      defaultCommon: undefined,
      defaultTransactionType: "0x2",
      defaultMaxPriorityFeePerGas: toHex(2500000000),
      enableExperimentalFeatures: {
        useSubscriptionWhenCheckingBlockTimeout: false,
        useRpcCallSpecification: false
      },
      transactionBuilder: undefined,
      transactionTypeParser: undefined
    };
    this.setConfig(options !== null && options !== undefined ? options : {});
  }
  setConfig(options) {
    const keys = Object.keys(options);
    for (const key of keys) {
      this._triggerConfigChange(key, options[key]);
    }
    Object.assign(this.config, options);
  }
  get handleRevert() {
    return this.config.handleRevert;
  }
  set handleRevert(val) {
    this._triggerConfigChange("handleRevert", val);
    this.config.handleRevert = val;
  }
  get contractDataInputFill() {
    return this.config.contractDataInputFill;
  }
  set contractDataInputFill(val) {
    this._triggerConfigChange("contractDataInputFill", val);
    this.config.contractDataInputFill = val;
  }
  get defaultAccount() {
    return this.config.defaultAccount;
  }
  set defaultAccount(val) {
    this._triggerConfigChange("defaultAccount", val);
    this.config.defaultAccount = val;
  }
  get defaultBlock() {
    return this.config.defaultBlock;
  }
  set defaultBlock(val) {
    this._triggerConfigChange("defaultBlock", val);
    this.config.defaultBlock = val;
  }
  get transactionSendTimeout() {
    return this.config.transactionSendTimeout;
  }
  set transactionSendTimeout(val) {
    this._triggerConfigChange("transactionSendTimeout", val);
    this.config.transactionSendTimeout = val;
  }
  get transactionBlockTimeout() {
    return this.config.transactionBlockTimeout;
  }
  set transactionBlockTimeout(val) {
    this._triggerConfigChange("transactionBlockTimeout", val);
    this.config.transactionBlockTimeout = val;
  }
  get transactionConfirmationBlocks() {
    return this.config.transactionConfirmationBlocks;
  }
  set transactionConfirmationBlocks(val) {
    this._triggerConfigChange("transactionConfirmationBlocks", val);
    this.config.transactionConfirmationBlocks = val;
  }
  get transactionPollingInterval() {
    return this.config.transactionPollingInterval;
  }
  set transactionPollingInterval(val) {
    this._triggerConfigChange("transactionPollingInterval", val);
    this.config.transactionPollingInterval = val;
    this.transactionReceiptPollingInterval = val;
    this.transactionConfirmationPollingInterval = val;
  }
  get transactionPollingTimeout() {
    return this.config.transactionPollingTimeout;
  }
  set transactionPollingTimeout(val) {
    this._triggerConfigChange("transactionPollingTimeout", val);
    this.config.transactionPollingTimeout = val;
  }
  get transactionReceiptPollingInterval() {
    return this.config.transactionReceiptPollingInterval;
  }
  set transactionReceiptPollingInterval(val) {
    this._triggerConfigChange("transactionReceiptPollingInterval", val);
    this.config.transactionReceiptPollingInterval = val;
  }
  get transactionConfirmationPollingInterval() {
    return this.config.transactionConfirmationPollingInterval;
  }
  set transactionConfirmationPollingInterval(val) {
    this._triggerConfigChange("transactionConfirmationPollingInterval", val);
    this.config.transactionConfirmationPollingInterval = val;
  }
  get blockHeaderTimeout() {
    return this.config.blockHeaderTimeout;
  }
  set blockHeaderTimeout(val) {
    this._triggerConfigChange("blockHeaderTimeout", val);
    this.config.blockHeaderTimeout = val;
  }
  get enableExperimentalFeatures() {
    return this.config.enableExperimentalFeatures;
  }
  set enableExperimentalFeatures(val) {
    this._triggerConfigChange("enableExperimentalFeatures", val);
    this.config.enableExperimentalFeatures = val;
  }
  get maxListenersWarningThreshold() {
    return this.config.maxListenersWarningThreshold;
  }
  set maxListenersWarningThreshold(val) {
    this._triggerConfigChange("maxListenersWarningThreshold", val);
    this.setMaxListenerWarningThreshold(val);
    this.config.maxListenersWarningThreshold = val;
  }
  get defaultNetworkId() {
    return this.config.defaultNetworkId;
  }
  set defaultNetworkId(val) {
    this._triggerConfigChange("defaultNetworkId", val);
    this.config.defaultNetworkId = val;
  }
  get defaultChain() {
    return this.config.defaultChain;
  }
  set defaultChain(val) {
    if (!isNullish2(this.config.defaultCommon) && !isNullish2(this.config.defaultCommon.baseChain) && val !== this.config.defaultCommon.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val);
    this._triggerConfigChange("defaultChain", val);
    this.config.defaultChain = val;
  }
  get defaultHardfork() {
    return this.config.defaultHardfork;
  }
  set defaultHardfork(val) {
    if (!isNullish2(this.config.defaultCommon) && !isNullish2(this.config.defaultCommon.hardfork) && val !== this.config.defaultCommon.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultCommon.hardfork, val);
    this._triggerConfigChange("defaultHardfork", val);
    this.config.defaultHardfork = val;
  }
  get defaultCommon() {
    return this.config.defaultCommon;
  }
  set defaultCommon(val) {
    if (!isNullish2(this.config.defaultHardfork) && !isNullish2(val) && !isNullish2(val.hardfork) && this.config.defaultHardfork !== val.hardfork)
      throw new ConfigHardforkMismatchError(this.config.defaultHardfork, val.hardfork);
    if (!isNullish2(this.config.defaultChain) && !isNullish2(val) && !isNullish2(val.baseChain) && this.config.defaultChain !== val.baseChain)
      throw new ConfigChainMismatchError(this.config.defaultChain, val.baseChain);
    this._triggerConfigChange("defaultCommon", val);
    this.config.defaultCommon = val;
  }
  get defaultTransactionType() {
    return this.config.defaultTransactionType;
  }
  set defaultTransactionType(val) {
    this._triggerConfigChange("defaultTransactionType", val);
    this.config.defaultTransactionType = val;
  }
  get defaultMaxPriorityFeePerGas() {
    return this.config.defaultMaxPriorityFeePerGas;
  }
  set defaultMaxPriorityFeePerGas(val) {
    this._triggerConfigChange("defaultMaxPriorityFeePerGas", val);
    this.config.defaultMaxPriorityFeePerGas = val;
  }
  get transactionBuilder() {
    return this.config.transactionBuilder;
  }
  set transactionBuilder(val) {
    this._triggerConfigChange("transactionBuilder", val);
    this.config.transactionBuilder = val;
  }
  get transactionTypeParser() {
    return this.config.transactionTypeParser;
  }
  set transactionTypeParser(val) {
    this._triggerConfigChange("transactionTypeParser", val);
    this.config.transactionTypeParser = val;
  }
  _triggerConfigChange(config, newValue) {
    this.emit(Web3ConfigEvent.CONFIG_CHANGE, {
      name: config,
      oldValue: this.config[config],
      newValue
    });
  }
}
// node_modules/web3-providers-http/lib/esm/index.js
var import_cross_fetch = __toESM(require_node_ponyfill(), 1);
var __awaiter6 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class HttpProvider extends Web3BaseProvider {
  constructor(clientUrl, httpProviderOptions) {
    super();
    if (!HttpProvider.validateClientUrl(clientUrl))
      throw new InvalidClientError(clientUrl);
    this.clientUrl = clientUrl;
    this.httpProviderOptions = httpProviderOptions;
  }
  static validateClientUrl(clientUrl) {
    return typeof clientUrl === "string" ? /^http(s)?:\/\//i.test(clientUrl) : false;
  }
  getStatus() {
    throw new MethodNotImplementedError;
  }
  supportsSubscriptions() {
    return false;
  }
  request(payload, requestOptions) {
    var _a2;
    return __awaiter6(this, undefined, undefined, function* () {
      const providerOptionsCombined = Object.assign(Object.assign({}, (_a2 = this.httpProviderOptions) === null || _a2 === undefined ? undefined : _a2.providerOptions), requestOptions);
      const response = yield import_cross_fetch.default(this.clientUrl, Object.assign(Object.assign({}, providerOptionsCombined), { method: "POST", headers: Object.assign(Object.assign({}, providerOptionsCombined.headers), { "Content-Type": "application/json" }), body: JSON.stringify(payload) }));
      if (!response.ok)
        throw new ResponseError(yield response.json());
      return yield response.json();
    });
  }
  on() {
    throw new MethodNotImplementedError;
  }
  removeListener() {
    throw new MethodNotImplementedError;
  }
  once() {
    throw new MethodNotImplementedError;
  }
  removeAllListeners() {
    throw new MethodNotImplementedError;
  }
  connect() {
    throw new MethodNotImplementedError;
  }
  disconnect() {
    throw new MethodNotImplementedError;
  }
  reset() {
    throw new MethodNotImplementedError;
  }
  reconnect() {
    throw new MethodNotImplementedError;
  }
}

// node_modules/web3-providers-ws/lib/esm/index.js
import WebSocket2 from "ws";
class WebSocketProvider extends SocketProvider {
  constructor(socketPath, socketOptions, reconnectOptions) {
    super(socketPath, socketOptions, reconnectOptions);
  }
  _validateProviderPath(providerUrl) {
    return typeof providerUrl === "string" ? /^ws(s)?:\/\//i.test(providerUrl) : false;
  }
  getStatus() {
    if (this._socketConnection && !isNullish2(this._socketConnection)) {
      switch (this._socketConnection.readyState) {
        case this._socketConnection.CONNECTING: {
          return "connecting";
        }
        case this._socketConnection.OPEN: {
          return "connected";
        }
        default: {
          return "disconnected";
        }
      }
    }
    return "disconnected";
  }
  _openSocketConnection() {
    this._socketConnection = new WebSocket2(this._socketPath, undefined, this._socketOptions && Object.keys(this._socketOptions).length === 0 ? undefined : this._socketOptions);
  }
  _closeSocketConnection(code, data) {
    var _a2;
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.close(code, data);
  }
  _sendToSocket(payload) {
    var _a2;
    if (this.getStatus() === "disconnected") {
      throw new ConnectionNotOpenError;
    }
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.send(JSON.stringify(payload));
  }
  _parseResponses(event) {
    return this.chunkResponseParser.parseResponse(event.data);
  }
  _addSocketListeners() {
    var _a2, _b, _c, _d;
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.addEventListener("open", this._onOpenHandler);
    (_b = this._socketConnection) === null || _b === undefined || _b.addEventListener("message", this._onMessageHandler);
    (_c = this._socketConnection) === null || _c === undefined || _c.addEventListener("close", (e) => this._onCloseHandler(e));
    (_d = this._socketConnection) === null || _d === undefined || _d.addEventListener("error", this._onErrorHandler);
  }
  _removeSocketListeners() {
    var _a2, _b, _c;
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.removeEventListener("message", this._onMessageHandler);
    (_b = this._socketConnection) === null || _b === undefined || _b.removeEventListener("open", this._onOpenHandler);
    (_c = this._socketConnection) === null || _c === undefined || _c.removeEventListener("close", this._onCloseHandler);
  }
  _onCloseEvent(event) {
    var _a2;
    if (this._reconnectOptions.autoReconnect && (![1000, 1001].includes(event.code) || !event.wasClean)) {
      this._reconnect();
      return;
    }
    this._clearQueues(event);
    this._removeSocketListeners();
    this._onDisconnect(event.code, event.reason);
    (_a2 = this._socketConnection) === null || _a2 === undefined || _a2.removeEventListener("error", this._onErrorHandler);
  }
}

// node_modules/web3-core/lib/esm/utils.js
var isWeb3Provider = (provider) => Web3BaseProvider.isWeb3Provider(provider);
var isLegacyRequestProvider = (provider) => typeof provider !== "string" && ("request" in provider) && provider.request.constructor.name === "Function";
var isEIP1193Provider = (provider) => typeof provider !== "string" && ("request" in provider) && provider.request.constructor.name === "AsyncFunction";
var isLegacySendProvider = (provider) => typeof provider !== "string" && ("send" in provider);
var isLegacySendAsyncProvider = (provider) => typeof provider !== "string" && ("sendAsync" in provider);
var isSupportedProvider = (provider) => provider && (isWeb3Provider(provider) || isEIP1193Provider(provider) || isLegacyRequestProvider(provider) || isLegacySendAsyncProvider(provider) || isLegacySendProvider(provider));
var isSupportSubscriptions = (provider) => {
  if (provider && "supportsSubscriptions" in provider) {
    return provider.supportsSubscriptions();
  }
  if (provider && typeof provider !== "string" && "on" in provider) {
    return true;
  }
  return false;
};

// node_modules/web3-core/lib/esm/web3_request_manager.js
var __awaiter7 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Web3RequestManagerEvent;
(function(Web3RequestManagerEvent2) {
  Web3RequestManagerEvent2["PROVIDER_CHANGED"] = "PROVIDER_CHANGED";
  Web3RequestManagerEvent2["BEFORE_PROVIDER_CHANGE"] = "BEFORE_PROVIDER_CHANGE";
})(Web3RequestManagerEvent || (Web3RequestManagerEvent = {}));
var availableProviders = {
  HttpProvider,
  WebsocketProvider: WebSocketProvider
};

class Web3RequestManager extends Web3EventEmitter {
  constructor(provider, useRpcCallSpecification) {
    super();
    if (!isNullish2(provider)) {
      this.setProvider(provider);
    }
    this.useRpcCallSpecification = useRpcCallSpecification;
  }
  static get providers() {
    return availableProviders;
  }
  get provider() {
    return this._provider;
  }
  get providers() {
    return availableProviders;
  }
  setProvider(provider) {
    let newProvider;
    if (provider && typeof provider === "string" && this.providers) {
      if (/^http(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.HttpProvider(provider);
      } else if (/^ws(s)?:\/\//i.test(provider)) {
        newProvider = new this.providers.WebsocketProvider(provider);
      } else {
        throw new ProviderError(`Can't autodetect provider for "${provider}"`);
      }
    } else if (isNullish2(provider)) {
      newProvider = undefined;
    } else {
      newProvider = provider;
    }
    this.emit(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, this._provider);
    this._provider = newProvider;
    this.emit(Web3RequestManagerEvent.PROVIDER_CHANGED, this._provider);
    return true;
  }
  send(request) {
    return __awaiter7(this, undefined, undefined, function* () {
      const response = yield this._sendRequest(request);
      if (exports_json_rpc.isResponseWithResult(response)) {
        return response.result;
      }
      throw new ResponseError(response);
    });
  }
  sendBatch(request) {
    return __awaiter7(this, undefined, undefined, function* () {
      const response = yield this._sendRequest(request);
      return response;
    });
  }
  _sendRequest(request) {
    return __awaiter7(this, undefined, undefined, function* () {
      const { provider } = this;
      if (isNullish2(provider)) {
        throw new ProviderError("Provider not available. Use `.setProvider` or `.provider=` to initialize the provider.");
      }
      const payload = exports_json_rpc.isBatchRequest(request) ? exports_json_rpc.toBatchPayload(request) : exports_json_rpc.toPayload(request);
      if (isWeb3Provider(provider)) {
        let response;
        try {
          response = yield provider.request(payload);
        } catch (error) {
          response = error;
        }
        return this._processJsonRpcResponse(payload, response, { legacy: false, error: false });
      }
      if (isEIP1193Provider(provider)) {
        return provider.request(payload).then((res) => this._processJsonRpcResponse(payload, res, {
          legacy: true,
          error: false
        })).catch((error) => this._processJsonRpcResponse(payload, error, { legacy: true, error: true }));
      }
      if (isLegacyRequestProvider(provider)) {
        return new Promise((resolve, reject) => {
          const rejectWithError = (err) => reject(this._processJsonRpcResponse(payload, err, {
            legacy: true,
            error: true
          }));
          const resolveWithResponse = (response) => resolve(this._processJsonRpcResponse(payload, response, {
            legacy: true,
            error: false
          }));
          const result = provider.request(payload, (err, response) => {
            if (err) {
              return rejectWithError(err);
            }
            return resolveWithResponse(response);
          });
          if (isPromise(result)) {
            const responsePromise = result;
            responsePromise.then(resolveWithResponse).catch(rejectWithError);
          }
        });
      }
      if (isLegacySendProvider(provider)) {
        return new Promise((resolve, reject) => {
          provider.send(payload, (err, response) => {
            if (err) {
              return reject(this._processJsonRpcResponse(payload, err, {
                legacy: true,
                error: true
              }));
            }
            if (isNullish2(response)) {
              throw new ResponseError("", 'Got a "nullish" response from provider.');
            }
            return resolve(this._processJsonRpcResponse(payload, response, {
              legacy: true,
              error: false
            }));
          });
        });
      }
      if (isLegacySendAsyncProvider(provider)) {
        return provider.sendAsync(payload).then((response) => this._processJsonRpcResponse(payload, response, { legacy: true, error: false })).catch((error) => this._processJsonRpcResponse(payload, error, {
          legacy: true,
          error: true
        }));
      }
      throw new ProviderError("Provider does not have a request or send method to use.");
    });
  }
  _processJsonRpcResponse(payload, response, { legacy, error }) {
    if (isNullish2(response)) {
      return this._buildResponse(payload, null, error);
    }
    if (exports_json_rpc.isResponseWithError(response)) {
      if (this.useRpcCallSpecification && isResponseRpcError(response)) {
        const rpcErrorResponse = response;
        if (rpcErrorsMap.get(rpcErrorResponse.error.code)) {
          const Err = rpcErrorsMap.get(rpcErrorResponse.error.code).error;
          throw new Err(rpcErrorResponse);
        } else {
          throw new RpcError(rpcErrorResponse);
        }
      } else if (!Web3RequestManager._isReverted(response)) {
        throw new InvalidResponseError(response, payload);
      }
    }
    if (exports_json_rpc.isResponseWithResult(response)) {
      return response;
    }
    if (response instanceof Error) {
      Web3RequestManager._isReverted(response);
      throw response;
    }
    if (!legacy && exports_json_rpc.isBatchRequest(payload) && exports_json_rpc.isBatchResponse(response)) {
      return response;
    }
    if (legacy && !error && exports_json_rpc.isBatchRequest(payload)) {
      return response;
    }
    if (legacy && error && exports_json_rpc.isBatchRequest(payload)) {
      throw response;
    }
    if (legacy && !exports_json_rpc.isResponseWithError(response) && !exports_json_rpc.isResponseWithResult(response)) {
      return this._buildResponse(payload, response, error);
    }
    if (exports_json_rpc.isBatchRequest(payload) && !Array.isArray(response)) {
      throw new ResponseError(response, "Got normal response for a batch request.");
    }
    if (!exports_json_rpc.isBatchRequest(payload) && Array.isArray(response)) {
      throw new ResponseError(response, "Got batch response for a normal request.");
    }
    if ((exports_json_rpc.isResponseWithError(response) || exports_json_rpc.isResponseWithResult(response)) && !exports_json_rpc.isBatchRequest(payload)) {
      if (response.id && payload.id !== response.id) {
        throw new InvalidResponseError(response);
      }
    }
    throw new ResponseError(response, "Invalid response");
  }
  static _isReverted(response) {
    let error;
    if (exports_json_rpc.isResponseWithError(response)) {
      error = response.error;
    } else if (response instanceof Error) {
      error = response;
    }
    if (error === null || error === undefined ? undefined : error.message.includes("revert"))
      throw new ContractExecutionError(error);
    return false;
  }
  _buildResponse(payload, response, error) {
    const res = {
      jsonrpc: "2.0",
      id: exports_json_rpc.isBatchRequest(payload) ? payload[0].id : ("id" in payload) ? payload.id : null
    };
    if (error) {
      return Object.assign(Object.assign({}, res), { error: response });
    }
    return Object.assign(Object.assign({}, res), { result: response });
  }
}
// node_modules/web3-core/lib/esm/web3_subscription_manager.js
var __awaiter8 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Web3SubscriptionManager {
  constructor(requestManager, registeredSubscriptions, tolerateUnlinkedSubscription = false) {
    this.requestManager = requestManager;
    this.registeredSubscriptions = registeredSubscriptions;
    this.tolerateUnlinkedSubscription = tolerateUnlinkedSubscription;
    this._subscriptions = new Map;
    this.requestManager.on(Web3RequestManagerEvent.BEFORE_PROVIDER_CHANGE, () => __awaiter8(this, undefined, undefined, function* () {
      yield this.unsubscribe();
    }));
    this.requestManager.on(Web3RequestManagerEvent.PROVIDER_CHANGED, () => {
      this.clear();
      this.listenToProviderEvents();
    });
    this.listenToProviderEvents();
  }
  listenToProviderEvents() {
    const providerAsWebProvider = this.requestManager.provider;
    if (!this.requestManager.provider || typeof (providerAsWebProvider === null || providerAsWebProvider === undefined ? undefined : providerAsWebProvider.supportsSubscriptions) === "function" && !(providerAsWebProvider === null || providerAsWebProvider === undefined ? undefined : providerAsWebProvider.supportsSubscriptions())) {
      return;
    }
    if (typeof this.requestManager.provider.on === "function") {
      if (typeof this.requestManager.provider.request === "function") {
        this.requestManager.provider.on("message", (message) => this.messageListener(message));
      } else {
        providerAsWebProvider.on("data", (data) => this.messageListener(data));
      }
    }
  }
  messageListener(data) {
    var _a2, _b, _c;
    if (!data) {
      throw new SubscriptionError("Should not call messageListener with no data. Type was");
    }
    const subscriptionId = ((_a2 = data.params) === null || _a2 === undefined ? undefined : _a2.subscription) || ((_b = data.data) === null || _b === undefined ? undefined : _b.subscription) || ((_c = data.id) === null || _c === undefined ? undefined : _c.toString(16));
    if (subscriptionId) {
      const sub = this._subscriptions.get(subscriptionId);
      sub === null || sub === undefined || sub.processSubscriptionData(data);
    }
  }
  subscribe(name, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter8(this, undefined, undefined, function* () {
      const Klass = this.registeredSubscriptions[name];
      if (!Klass) {
        throw new SubscriptionError("Invalid subscription type");
      }
      const subscription = new Klass(args !== null && args !== undefined ? args : undefined, {
        subscriptionManager: this,
        returnFormat
      });
      yield this.addSubscription(subscription);
      return subscription;
    });
  }
  get subscriptions() {
    return this._subscriptions;
  }
  addSubscription(sub) {
    return __awaiter8(this, undefined, undefined, function* () {
      if (!this.requestManager.provider) {
        throw new ProviderError("Provider not available");
      }
      if (!this.supportsSubscriptions()) {
        throw new SubscriptionError("The current provider does not support subscriptions");
      }
      if (sub.id && this._subscriptions.has(sub.id)) {
        throw new SubscriptionError(`Subscription with id "${sub.id}" already exists`);
      }
      yield sub.sendSubscriptionRequest();
      if (isNullish2(sub.id)) {
        throw new SubscriptionError("Subscription is not subscribed yet.");
      }
      this._subscriptions.set(sub.id, sub);
      return sub.id;
    });
  }
  removeSubscription(sub) {
    return __awaiter8(this, undefined, undefined, function* () {
      const { id } = sub;
      if (isNullish2(id)) {
        throw new SubscriptionError("Subscription is not subscribed yet. Or, had already been unsubscribed but not through the Subscription Manager.");
      }
      if (!this._subscriptions.has(id) && !this.tolerateUnlinkedSubscription) {
        throw new SubscriptionError(`Subscription with id "${id.toString()}" does not exists`);
      }
      yield sub.sendUnsubscribeRequest();
      this._subscriptions.delete(id);
      return id;
    });
  }
  unsubscribe(condition) {
    return __awaiter8(this, undefined, undefined, function* () {
      const result = [];
      for (const [id, sub] of this.subscriptions.entries()) {
        if (!condition || typeof condition === "function" && condition({ id, sub })) {
          result.push(this.removeSubscription(sub));
        }
      }
      return Promise.all(result);
    });
  }
  clear() {
    this._subscriptions.clear();
  }
  supportsSubscriptions() {
    return isNullish2(this.requestManager.provider) ? false : isSupportSubscriptions(this.requestManager.provider);
  }
}
// node_modules/web3-core/lib/esm/web3_subscriptions.js
var __awaiter9 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Web3Subscription extends Web3EventEmitter {
  constructor(args, options) {
    var _a2;
    super();
    this.args = args;
    const { requestManager } = options;
    const { subscriptionManager } = options;
    if (requestManager && subscriptionManager) {
      throw new SubscriptionError("Only requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (!requestManager && !subscriptionManager) {
      throw new SubscriptionError("Either requestManager or subscriptionManager should be provided at Subscription constructor");
    }
    if (requestManager) {
      this._subscriptionManager = new Web3SubscriptionManager(requestManager, {}, true);
    } else {
      this._subscriptionManager = subscriptionManager;
    }
    this._returnFormat = (_a2 = options === null || options === undefined ? undefined : options.returnFormat) !== null && _a2 !== undefined ? _a2 : DEFAULT_RETURN_FORMAT;
  }
  get id() {
    return this._id;
  }
  get lastBlock() {
    return this._lastBlock;
  }
  subscribe() {
    return __awaiter9(this, undefined, undefined, function* () {
      return this._subscriptionManager.addSubscription(this);
    });
  }
  processSubscriptionData(data) {
    var _a2, _b;
    if (data === null || data === undefined ? undefined : data.data) {
      this._processSubscriptionResult((_b = (_a2 = data === null || data === undefined ? undefined : data.data) === null || _a2 === undefined ? undefined : _a2.result) !== null && _b !== undefined ? _b : data === null || data === undefined ? undefined : data.data);
    } else if (data && exports_json_rpc.isResponseWithNotification(data)) {
      this._processSubscriptionResult(data === null || data === undefined ? undefined : data.params.result);
    }
  }
  sendSubscriptionRequest() {
    return __awaiter9(this, undefined, undefined, function* () {
      this._id = yield this._subscriptionManager.requestManager.send({
        method: "eth_subscribe",
        params: this._buildSubscriptionParams()
      });
      this.emit("connected", this._id);
      return this._id;
    });
  }
  get returnFormat() {
    return this._returnFormat;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  resubscribe() {
    return __awaiter9(this, undefined, undefined, function* () {
      yield this.unsubscribe();
      yield this.subscribe();
    });
  }
  unsubscribe() {
    return __awaiter9(this, undefined, undefined, function* () {
      if (!this.id) {
        return;
      }
      yield this._subscriptionManager.removeSubscription(this);
    });
  }
  sendUnsubscribeRequest() {
    return __awaiter9(this, undefined, undefined, function* () {
      yield this._subscriptionManager.requestManager.send({
        method: "eth_unsubscribe",
        params: [this.id]
      });
      this._id = undefined;
    });
  }
  formatSubscriptionResult(data) {
    return data;
  }
  _processSubscriptionResult(data) {
    this.emit("data", this.formatSubscriptionResult(data));
  }
  _processSubscriptionError(error) {
    this.emit("error", error);
  }
  _buildSubscriptionParams() {
    throw new Error("Implement in the child class");
  }
}
// node_modules/web3-eth-accounts/lib/esm/wallet.js
var __awaiter10 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Wallet extends Web3BaseWallet {
  constructor() {
    super(...arguments);
    this._addressMap = new Map;
    this._defaultKeyName = "web3js_wallet";
  }
  static getStorage() {
    let storage;
    try {
      storage = window.localStorage;
      const x = "__storage_test__";
      storage.setItem(x, x);
      storage.removeItem(x);
      return storage;
    } catch (e) {
      return e && (e.code === 22 || e.code === 1014 || e.name === "QuotaExceededError" || e.name === "NS_ERROR_DOM_QUOTA_REACHED") && !isNullish(storage) && storage.length !== 0 ? storage : undefined;
    }
  }
  create(numberOfAccounts) {
    for (let i = 0;i < numberOfAccounts; i += 1) {
      this.add(this._accountProvider.create());
    }
    return this;
  }
  add(account) {
    var _a2;
    if (typeof account === "string") {
      return this.add(this._accountProvider.privateKeyToAccount(account));
    }
    let index = this.length;
    const existAccount = this.get(account.address);
    if (existAccount) {
      console.warn(`Account ${account.address.toLowerCase()} already exists.`);
      index = (_a2 = this._addressMap.get(account.address.toLowerCase())) !== null && _a2 !== undefined ? _a2 : index;
    }
    this._addressMap.set(account.address.toLowerCase(), index);
    this[index] = account;
    return this;
  }
  get(addressOrIndex) {
    if (typeof addressOrIndex === "string") {
      const index = this._addressMap.get(addressOrIndex.toLowerCase());
      if (!isNullish(index)) {
        return this[index];
      }
      return;
    }
    return this[addressOrIndex];
  }
  remove(addressOrIndex) {
    if (typeof addressOrIndex === "string") {
      const index = this._addressMap.get(addressOrIndex.toLowerCase());
      if (isNullish(index)) {
        return false;
      }
      this._addressMap.delete(addressOrIndex.toLowerCase());
      this.splice(index, 1);
      return true;
    }
    if (this[addressOrIndex]) {
      this.splice(addressOrIndex, 1);
      return true;
    }
    return false;
  }
  clear() {
    this._addressMap.clear();
    this.length = 0;
    return this;
  }
  encrypt(password, options) {
    return __awaiter10(this, undefined, undefined, function* () {
      return Promise.all(this.map((account) => __awaiter10(this, undefined, undefined, function* () {
        return account.encrypt(password, options);
      })));
    });
  }
  decrypt(encryptedWallets, password, options) {
    return __awaiter10(this, undefined, undefined, function* () {
      const results = yield Promise.all(encryptedWallets.map((wallet) => __awaiter10(this, undefined, undefined, function* () {
        return this._accountProvider.decrypt(wallet, password, options);
      })));
      for (const res of results) {
        this.add(res);
      }
      return this;
    });
  }
  save(password, keyName) {
    return __awaiter10(this, undefined, undefined, function* () {
      const storage = Wallet.getStorage();
      if (!storage) {
        throw new Error("Local storage not available.");
      }
      storage.setItem(keyName !== null && keyName !== undefined ? keyName : this._defaultKeyName, JSON.stringify(yield this.encrypt(password)));
      return true;
    });
  }
  load(password, keyName) {
    return __awaiter10(this, undefined, undefined, function* () {
      const storage = Wallet.getStorage();
      if (!storage) {
        throw new Error("Local storage not available.");
      }
      const keystore = storage.getItem(keyName !== null && keyName !== undefined ? keyName : this._defaultKeyName);
      if (keystore) {
        yield this.decrypt(JSON.parse(keystore) || [], password);
      }
      return this;
    });
  }
}
// node_modules/ethereum-cryptography/esm/aes.js
var validateOpt = function(key, iv, mode) {
  if (!mode.startsWith("aes-")) {
    throw new Error(`AES submodule doesn't support mode ${mode}`);
  }
  if (iv.length !== 16) {
    throw new Error("AES: wrong IV length");
  }
  if (mode.startsWith("aes-128") && key.length !== 16 || mode.startsWith("aes-256") && key.length !== 32) {
    throw new Error("AES: wrong key length");
  }
};
async function getBrowserKey(mode, key, iv) {
  if (!crypto5.web) {
    throw new Error("Browser crypto not available.");
  }
  let keyMode;
  if (["aes-128-cbc", "aes-256-cbc"].includes(mode)) {
    keyMode = "cbc";
  }
  if (["aes-128-ctr", "aes-256-ctr"].includes(mode)) {
    keyMode = "ctr";
  }
  if (!keyMode) {
    throw new Error("AES: unsupported mode");
  }
  const wKey = await crypto5.web.subtle.importKey("raw", key, { name: `AES-${keyMode.toUpperCase()}`, length: key.length * 8 }, true, ["encrypt", "decrypt"]);
  return [wKey, { name: `aes-${keyMode}`, iv, counter: iv, length: 128 }];
}
async function encrypt(msg, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  validateOpt(key, iv, mode);
  if (crypto5.web) {
    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);
    const cipher = await crypto5.web.subtle.encrypt(wOpt, wKey, msg);
    let res = new Uint8Array(cipher);
    if (!pkcs7PaddingEnabled && wOpt.name === "aes-cbc" && !(msg.length % 16)) {
      res = res.slice(0, -16);
    }
    return res;
  } else if (crypto5.node) {
    const cipher = crypto5.node.createCipheriv(mode, key, iv);
    cipher.setAutoPadding(pkcs7PaddingEnabled);
    return concatBytes(cipher.update(msg), cipher.final());
  } else {
    throw new Error("The environment doesn't have AES module");
  }
}
async function getPadding(cypherText, key, iv, mode) {
  const lastBlock = cypherText.slice(-16);
  for (let i = 0;i < 16; i++) {
    lastBlock[i] ^= iv[i] ^ 16;
  }
  const res = await encrypt(lastBlock, key, iv, mode);
  return res.slice(0, 16);
}
async function decrypt(cypherText, key, iv, mode = "aes-128-ctr", pkcs7PaddingEnabled = true) {
  validateOpt(key, iv, mode);
  if (crypto5.web) {
    const [wKey, wOpt] = await getBrowserKey(mode, key, iv);
    if (!pkcs7PaddingEnabled && wOpt.name === "aes-cbc") {
      const padding = await getPadding(cypherText, key, iv, mode);
      cypherText = concatBytes(cypherText, padding);
    }
    const msg = await crypto5.web.subtle.decrypt(wOpt, wKey, cypherText);
    const msgBytes = new Uint8Array(msg);
    if (wOpt.name === "aes-cbc") {
      const encrypted = await encrypt(msgBytes, key, iv, mode);
      if (!equalsBytes(encrypted, cypherText)) {
        throw new Error("AES: wrong padding");
      }
    }
    return msgBytes;
  } else if (crypto5.node) {
    const decipher = crypto5.node.createDecipheriv(mode, key, iv);
    decipher.setAutoPadding(pkcs7PaddingEnabled);
    return concatBytes(decipher.update(cypherText), decipher.final());
  } else {
    throw new Error("The environment doesn't have AES module");
  }
}
var crypto5 = { web: crypto };

// node_modules/@noble/hashes/esm/hmac.js
class HMAC extends Hash {
  constructor(hash3, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    hash(hash3);
    const key = toBytes(_key);
    this.iHash = hash3.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > blockLen ? hash3.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash3.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    exists(this);
    bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac = (hash3, key, message) => new HMAC(hash3, key).update(message).digest();
hmac.create = (hash3, key) => new HMAC(hash3, key);

// node_modules/@noble/hashes/esm/pbkdf2.js
var pbkdf2Init = function(hash3, _password, _salt, _opts) {
  hash(hash3);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  number(c);
  number(dkLen);
  number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes(_password);
  const salt = toBytes(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac.create(hash3, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
};
var pbkdf2Output = function(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
};
function pbkdf2(hash3, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash3, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u);
}

// node_modules/@noble/hashes/esm/_sha2.js
var setBigUint64 = function(view, byteOffset, value, isLE2) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE2);
  const _32n2 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n2 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE2 ? 4 : 0;
  const l = isLE2 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE2);
  view.setUint32(byteOffset + l, wl, isLE2);
};

class SHA2 extends Hash {
  constructor(blockLen, outputLen, padOffset, isLE2) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE2;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    exists(this);
    const { view, buffer, blockLen } = this;
    data = toBytes(data);
    const len = data.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    exists(this);
    output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE2 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE2);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i = 0;i < outLen; i++)
      oview.setUint32(4 * i, state[i], isLE2);
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// node_modules/@noble/hashes/esm/sha256.js
var Chi = (a, b, c) => a & b ^ ~a & c;
var Maj = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);

class SHA256 extends SHA2 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV[0] | 0;
    this.B = IV[1] | 0;
    this.C = IV[2] | 0;
    this.D = IV[3] | 0;
    this.E = IV[4] | 0;
    this.F = IV[5] | 0;
    this.G = IV[6] | 0;
    this.H = IV[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W[i - 15];
      const W2 = SHA256_W[i - 2];
      const s0 = rotr(W15, 7) ^ rotr(W15, 18) ^ W15 >>> 3;
      const s1 = rotr(W2, 17) ^ rotr(W2, 19) ^ W2 >>> 10;
      SHA256_W[i] = s1 + SHA256_W[i - 7] + s0 + SHA256_W[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr(E, 6) ^ rotr(E, 11) ^ rotr(E, 25);
      const T1 = H + sigma1 + Chi(E, F, G) + SHA256_K[i] + SHA256_W[i] | 0;
      const sigma0 = rotr(A, 2) ^ rotr(A, 13) ^ rotr(A, 22);
      const T2 = sigma0 + Maj(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T1 | 0;
      D = C;
      C = B;
      B = A;
      A = T1 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var sha256 = wrapConstructor(() => new SHA256);

// node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => _u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n) => BigInt(n))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);

class SHA512 extends SHA2 {
  constructor() {
    super(128, 64, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  get() {
    const { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    return [Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl];
  }
  set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl) {
    this.Ah = Ah | 0;
    this.Al = Al | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl | 0;
    this.Eh = Eh | 0;
    this.El = El | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4) {
      SHA512_W_H[i] = view.getUint32(offset);
      SHA512_W_L[i] = view.getUint32(offset += 4);
    }
    for (let i = 16;i < 80; i++) {
      const W15h = SHA512_W_H[i - 15] | 0;
      const W15l = SHA512_W_L[i - 15] | 0;
      const s0h = _u64_default.rotrSH(W15h, W15l, 1) ^ _u64_default.rotrSH(W15h, W15l, 8) ^ _u64_default.shrSH(W15h, W15l, 7);
      const s0l = _u64_default.rotrSL(W15h, W15l, 1) ^ _u64_default.rotrSL(W15h, W15l, 8) ^ _u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i - 2] | 0;
      const W2l = SHA512_W_L[i - 2] | 0;
      const s1h = _u64_default.rotrSH(W2h, W2l, 19) ^ _u64_default.rotrBH(W2h, W2l, 61) ^ _u64_default.shrSH(W2h, W2l, 6);
      const s1l = _u64_default.rotrSL(W2h, W2l, 19) ^ _u64_default.rotrBL(W2h, W2l, 61) ^ _u64_default.shrSL(W2h, W2l, 6);
      const SUMl = _u64_default.add4L(s0l, s1l, SHA512_W_L[i - 7], SHA512_W_L[i - 16]);
      const SUMh = _u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i - 7], SHA512_W_H[i - 16]);
      SHA512_W_H[i] = SUMh | 0;
      SHA512_W_L[i] = SUMl | 0;
    }
    let { Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl } = this;
    for (let i = 0;i < 80; i++) {
      const sigma1h = _u64_default.rotrSH(Eh, El, 14) ^ _u64_default.rotrSH(Eh, El, 18) ^ _u64_default.rotrBH(Eh, El, 41);
      const sigma1l = _u64_default.rotrSL(Eh, El, 14) ^ _u64_default.rotrSL(Eh, El, 18) ^ _u64_default.rotrBL(Eh, El, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El & Fl ^ ~El & Gl;
      const T1ll = _u64_default.add5L(Hl, sigma1l, CHIl, SHA512_Kl[i], SHA512_W_L[i]);
      const T1h = _u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i], SHA512_W_H[i]);
      const T1l = T1ll | 0;
      const sigma0h = _u64_default.rotrSH(Ah, Al, 28) ^ _u64_default.rotrBH(Ah, Al, 34) ^ _u64_default.rotrBH(Ah, Al, 39);
      const sigma0l = _u64_default.rotrSL(Ah, Al, 28) ^ _u64_default.rotrBL(Ah, Al, 34) ^ _u64_default.rotrBL(Ah, Al, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al & Bl ^ Al & Cl ^ Bl & Cl;
      Hh = Gh | 0;
      Hl = Gl | 0;
      Gh = Fh | 0;
      Gl = Fl | 0;
      Fh = Eh | 0;
      Fl = El | 0;
      ({ h: Eh, l: El } = _u64_default.add(Dh | 0, Dl | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl = Cl | 0;
      Ch = Bh | 0;
      Cl = Bl | 0;
      Bh = Ah | 0;
      Bl = Al | 0;
      const All = _u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = _u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al = All | 0;
    }
    ({ h: Ah, l: Al } = _u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al | 0));
    ({ h: Bh, l: Bl } = _u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl | 0));
    ({ h: Ch, l: Cl } = _u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl | 0));
    ({ h: Dh, l: Dl } = _u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl | 0));
    ({ h: Eh, l: El } = _u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El | 0));
    ({ h: Fh, l: Fl } = _u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl | 0));
    ({ h: Gh, l: Gl } = _u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl | 0));
    ({ h: Hh, l: Hl } = _u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl | 0));
    this.set(Ah, Al, Bh, Bl, Ch, Cl, Dh, Dl, Eh, El, Fh, Fl, Gh, Gl, Hh, Hl);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
}
var sha512 = wrapConstructor(() => new SHA512);

// node_modules/ethereum-cryptography/esm/pbkdf2.js
function pbkdf2Sync(password, salt, iterations, keylen, digest) {
  if (!["sha256", "sha512"].includes(digest)) {
    throw new Error("Only sha256 and sha512 are supported");
  }
  assertBytes(password);
  assertBytes(salt);
  return pbkdf2(digest === "sha256" ? sha256 : sha512, password, salt, {
    c: iterations,
    dkLen: keylen
  });
}

// node_modules/@noble/hashes/esm/scrypt.js
var XorAndSalsa = function(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl(x00 + x12 | 0, 7);
    x08 ^= rotl(x04 + x00 | 0, 9);
    x12 ^= rotl(x08 + x04 | 0, 13);
    x00 ^= rotl(x12 + x08 | 0, 18);
    x09 ^= rotl(x05 + x01 | 0, 7);
    x13 ^= rotl(x09 + x05 | 0, 9);
    x01 ^= rotl(x13 + x09 | 0, 13);
    x05 ^= rotl(x01 + x13 | 0, 18);
    x14 ^= rotl(x10 + x06 | 0, 7);
    x02 ^= rotl(x14 + x10 | 0, 9);
    x06 ^= rotl(x02 + x14 | 0, 13);
    x10 ^= rotl(x06 + x02 | 0, 18);
    x03 ^= rotl(x15 + x11 | 0, 7);
    x07 ^= rotl(x03 + x15 | 0, 9);
    x11 ^= rotl(x07 + x03 | 0, 13);
    x15 ^= rotl(x11 + x07 | 0, 18);
    x01 ^= rotl(x00 + x03 | 0, 7);
    x02 ^= rotl(x01 + x00 | 0, 9);
    x03 ^= rotl(x02 + x01 | 0, 13);
    x00 ^= rotl(x03 + x02 | 0, 18);
    x06 ^= rotl(x05 + x04 | 0, 7);
    x07 ^= rotl(x06 + x05 | 0, 9);
    x04 ^= rotl(x07 + x06 | 0, 13);
    x05 ^= rotl(x04 + x07 | 0, 18);
    x11 ^= rotl(x10 + x09 | 0, 7);
    x08 ^= rotl(x11 + x10 | 0, 9);
    x09 ^= rotl(x08 + x11 | 0, 13);
    x10 ^= rotl(x09 + x08 | 0, 18);
    x12 ^= rotl(x15 + x14 | 0, 7);
    x13 ^= rotl(x12 + x15 | 0, 9);
    x14 ^= rotl(x13 + x12 | 0, 13);
    x15 ^= rotl(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
};
var BlockMix = function(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa(out, head, input, ii += 16, out, tail);
  }
};
var scryptInit = function(password, salt, _opts) {
  const opts = checkOpts({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  number(N);
  number(r);
  number(p);
  number(dkLen);
  number(asyncTick);
  number(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf2(sha256, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u32(B);
  const V = u32(new Uint8Array(blockSize * N));
  const tmp = u32(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
};
var scryptOutput = function(password, dkLen, B, V, tmp) {
  const res = pbkdf2(sha256, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
};
function scrypt(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi + i];
    for (let i = 0, pos = 0;i < N - 1; i++) {
      BlockMix(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix(V, (N - 1) * blockSize32, B32, Pi, r);
    blockMixCb();
    for (let i = 0;i < N; i++) {
      const j = B32[Pi + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi + k] ^ V[j * blockSize32 + k];
      BlockMix(tmp, 0, B32, Pi, r);
      blockMixCb();
    }
  }
  return scryptOutput(password, dkLen, B, V, tmp);
}
var rotl = (a, b) => a << b | a >>> 32 - b;

// node_modules/ethereum-cryptography/esm/scrypt.js
function scryptSync(password, salt, n, p, r, dkLen, onProgress) {
  assertBytes(password);
  assertBytes(salt);
  return scrypt(password, salt, { N: n, r, p, dkLen, onProgress });
}

// node_modules/ethereum-cryptography/esm/secp256k1.js
var exports_secp256k1 = {};
__export(exports_secp256k1, {
  secp256k1: () => {
    {
      return secp256k1;
    }
  }
});

// node_modules/@noble/curves/esm/abstract/utils.js
var exports_utils2 = {};
__export(exports_utils2, {
  validateObject: () => {
    {
      return validateObject;
    }
  },
  utf8ToBytes: () => {
    {
      return utf8ToBytes3;
    }
  },
  numberToVarBytesBE: () => {
    {
      return numberToVarBytesBE;
    }
  },
  numberToHexUnpadded: () => {
    {
      return numberToHexUnpadded;
    }
  },
  numberToBytesLE: () => {
    {
      return numberToBytesLE;
    }
  },
  numberToBytesBE: () => {
    {
      return numberToBytesBE;
    }
  },
  isBytes: () => {
    {
      return isBytes4;
    }
  },
  hexToNumber: () => {
    {
      return hexToNumber3;
    }
  },
  hexToBytes: () => {
    {
      return hexToBytes2;
    }
  },
  equalBytes: () => {
    {
      return equalBytes;
    }
  },
  ensureBytes: () => {
    {
      return ensureBytes;
    }
  },
  createHmacDrbg: () => {
    {
      return createHmacDrbg;
    }
  },
  concatBytes: () => {
    {
      return concatBytes2;
    }
  },
  bytesToNumberLE: () => {
    {
      return bytesToNumberLE;
    }
  },
  bytesToNumberBE: () => {
    {
      return bytesToNumberBE;
    }
  },
  bytesToHex: () => {
    {
      return bytesToHex3;
    }
  },
  bitSet: () => {
    {
      return bitSet;
    }
  },
  bitMask: () => {
    {
      return bitMask;
    }
  },
  bitLen: () => {
    {
      return bitLen;
    }
  },
  bitGet: () => {
    {
      return bitGet;
    }
  }
});
function isBytes4(a) {
  return a instanceof Uint8Array || a != null && typeof a === "object" && a.constructor.name === "Uint8Array";
}
function bytesToHex3(bytes5) {
  if (!isBytes4(bytes5))
    throw new Error("Uint8Array expected");
  let hex = "";
  for (let i = 0;i < bytes5.length; i++) {
    hex += hexes[bytes5[i]];
  }
  return hex;
}
function numberToHexUnpadded(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
}
function hexToNumber3(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  return BigInt(hex === "" ? "0" : `0x${hex}`);
}
var asciiToBase16 = function(char) {
  if (char >= asciis._0 && char <= asciis._9)
    return char - asciis._0;
  if (char >= asciis._A && char <= asciis._F)
    return char - (asciis._A - 10);
  if (char >= asciis._a && char <= asciis._f)
    return char - (asciis._a - 10);
  return;
};
function hexToBytes2(hex) {
  if (typeof hex !== "string")
    throw new Error("hex string expected, got " + typeof hex);
  const hl = hex.length;
  const al = hl / 2;
  if (hl % 2)
    throw new Error("padded hex string expected, got unpadded hex of length " + hl);
  const array = new Uint8Array(al);
  for (let ai = 0, hi = 0;ai < al; ai++, hi += 2) {
    const n1 = asciiToBase16(hex.charCodeAt(hi));
    const n2 = asciiToBase16(hex.charCodeAt(hi + 1));
    if (n1 === undefined || n2 === undefined) {
      const char = hex[hi] + hex[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function bytesToNumberBE(bytes5) {
  return hexToNumber3(bytesToHex3(bytes5));
}
function bytesToNumberLE(bytes5) {
  if (!isBytes4(bytes5))
    throw new Error("Uint8Array expected");
  return hexToNumber3(bytesToHex3(Uint8Array.from(bytes5).reverse()));
}
function numberToBytesBE(n, len) {
  return hexToBytes2(n.toString(16).padStart(len * 2, "0"));
}
function numberToBytesLE(n, len) {
  return numberToBytesBE(n, len).reverse();
}
function numberToVarBytesBE(n) {
  return hexToBytes2(numberToHexUnpadded(n));
}
function ensureBytes(title, hex, expectedLength) {
  let res;
  if (typeof hex === "string") {
    try {
      res = hexToBytes2(hex);
    } catch (e) {
      throw new Error(`${title} must be valid hex string, got "${hex}". Cause: ${e}`);
    }
  } else if (isBytes4(hex)) {
    res = Uint8Array.from(hex);
  } else {
    throw new Error(`${title} must be hex string or Uint8Array`);
  }
  const len = res.length;
  if (typeof expectedLength === "number" && len !== expectedLength)
    throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
  return res;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    if (!isBytes4(a))
      throw new Error("Uint8Array expected");
    sum += a.length;
  }
  let res = new Uint8Array(sum);
  let pad = 0;
  for (let i = 0;i < arrays.length; i++) {
    const a = arrays[i];
    res.set(a, pad);
    pad += a.length;
  }
  return res;
}
function equalBytes(a, b) {
  if (a.length !== b.length)
    return false;
  let diff = 0;
  for (let i = 0;i < a.length; i++)
    diff |= a[i] ^ b[i];
  return diff === 0;
}
function utf8ToBytes3(str) {
  if (typeof str !== "string")
    throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
  return new Uint8Array(new TextEncoder().encode(str));
}
function bitLen(n) {
  let len;
  for (len = 0;n > _0n2; n >>= _1n2, len += 1)
    ;
  return len;
}
function bitGet(n, pos) {
  return n >> BigInt(pos) & _1n2;
}
function createHmacDrbg(hashLen, qByteLen, hmacFn) {
  if (typeof hashLen !== "number" || hashLen < 2)
    throw new Error("hashLen must be a number");
  if (typeof qByteLen !== "number" || qByteLen < 2)
    throw new Error("qByteLen must be a number");
  if (typeof hmacFn !== "function")
    throw new Error("hmacFn must be a function");
  let v = u8n(hashLen);
  let k = u8n(hashLen);
  let i = 0;
  const reset = () => {
    v.fill(1);
    k.fill(0);
    i = 0;
  };
  const h = (...b) => hmacFn(k, v, ...b);
  const reseed = (seed = u8n()) => {
    k = h(u8fr([0]), seed);
    v = h();
    if (seed.length === 0)
      return;
    k = h(u8fr([1]), seed);
    v = h();
  };
  const gen2 = () => {
    if (i++ >= 1000)
      throw new Error("drbg: tried 1000 values");
    let len = 0;
    const out = [];
    while (len < qByteLen) {
      v = h();
      const sl = v.slice();
      out.push(sl);
      len += v.length;
    }
    return concatBytes2(...out);
  };
  const genUntil = (seed, pred) => {
    reset();
    reseed(seed);
    let res = undefined;
    while (!(res = pred(gen2())))
      reseed();
    reset();
    return res;
  };
  return genUntil;
}
function validateObject(object3, validators, optValidators = {}) {
  const checkField = (fieldName, type, isOptional) => {
    const checkVal = validatorFns[type];
    if (typeof checkVal !== "function")
      throw new Error(`Invalid validator "${type}", expected function`);
    const val = object3[fieldName];
    if (isOptional && val === undefined)
      return;
    if (!checkVal(val, object3)) {
      throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type}`);
    }
  };
  for (const [fieldName, type] of Object.entries(validators))
    checkField(fieldName, type, false);
  for (const [fieldName, type] of Object.entries(optValidators))
    checkField(fieldName, type, true);
  return object3;
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var hexes = Array.from({ length: 256 }, (_, i) => i.toString(16).padStart(2, "0"));
var asciis = { _0: 48, _9: 57, _A: 65, _F: 70, _a: 97, _f: 102 };
var bitSet = (n, pos, value) => {
  return n | (value ? _1n2 : _0n2) << BigInt(pos);
};
var bitMask = (n) => (_2n2 << BigInt(n - 1)) - _1n2;
var u8n = (data) => new Uint8Array(data);
var u8fr = (arr) => Uint8Array.from(arr);
var validatorFns = {
  bigint: (val) => typeof val === "bigint",
  function: (val) => typeof val === "function",
  boolean: (val) => typeof val === "boolean",
  string: (val) => typeof val === "string",
  stringOrUint8Array: (val) => typeof val === "string" || isBytes4(val),
  isSafeInteger: (val) => Number.isSafeInteger(val),
  array: (val) => Array.isArray(val),
  field: (val, object3) => object3.Fp.isValid(val),
  hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
};

// node_modules/@noble/curves/esm/abstract/modular.js
function mod(a, b) {
  const result = a % b;
  return result >= _0n3 ? result : b + result;
}
function pow(num, power, modulo) {
  if (modulo <= _0n3 || power < _0n3)
    throw new Error("Expected power/modulo > 0");
  if (modulo === _1n3)
    return _0n3;
  let res = _1n3;
  while (power > _0n3) {
    if (power & _1n3)
      res = res * num % modulo;
    num = num * num % modulo;
    power >>= _1n3;
  }
  return res;
}
function pow2(x, power, modulo) {
  let res = x;
  while (power-- > _0n3) {
    res *= res;
    res %= modulo;
  }
  return res;
}
function invert(number2, modulo) {
  if (number2 === _0n3 || modulo <= _0n3) {
    throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
  }
  let a = mod(number2, modulo);
  let b = modulo;
  let x = _0n3, y = _1n3, u = _1n3, v = _0n3;
  while (a !== _0n3) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n3)
    throw new Error("invert: does not exist");
  return mod(x, modulo);
}
function tonelliShanks(P) {
  const legendreC = (P - _1n3) / _2n3;
  let Q, S, Z;
  for (Q = P - _1n3, S = 0;Q % _2n3 === _0n3; Q /= _2n3, S++)
    ;
  for (Z = _2n3;Z < P && pow(Z, legendreC, P) !== P - _1n3; Z++)
    ;
  if (S === 1) {
    const p1div4 = (P + _1n3) / _4n;
    return function tonelliFast(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  const Q1div2 = (Q + _1n3) / _2n3;
  return function tonelliSlow(Fp, n) {
    if (Fp.pow(n, legendreC) === Fp.neg(Fp.ONE))
      throw new Error("Cannot find square root");
    let r = S;
    let g = Fp.pow(Fp.mul(Fp.ONE, Z), Q);
    let x = Fp.pow(n, Q1div2);
    let b = Fp.pow(n, Q);
    while (!Fp.eql(b, Fp.ONE)) {
      if (Fp.eql(b, Fp.ZERO))
        return Fp.ZERO;
      let m = 1;
      for (let t2 = Fp.sqr(b);m < r; m++) {
        if (Fp.eql(t2, Fp.ONE))
          break;
        t2 = Fp.sqr(t2);
      }
      const ge = Fp.pow(g, _1n3 << BigInt(r - m - 1));
      g = Fp.sqr(ge);
      x = Fp.mul(x, ge);
      b = Fp.mul(b, g);
      r = m;
    }
    return x;
  };
}
function FpSqrt(P) {
  if (P % _4n === _3n) {
    const p1div4 = (P + _1n3) / _4n;
    return function sqrt3mod4(Fp, n) {
      const root = Fp.pow(n, p1div4);
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _8n === _5n) {
    const c1 = (P - _5n) / _8n;
    return function sqrt5mod8(Fp, n) {
      const n2 = Fp.mul(n, _2n3);
      const v = Fp.pow(n2, c1);
      const nv = Fp.mul(n, v);
      const i = Fp.mul(Fp.mul(nv, _2n3), v);
      const root = Fp.mul(nv, Fp.sub(i, Fp.ONE));
      if (!Fp.eql(Fp.sqr(root), n))
        throw new Error("Cannot find square root");
      return root;
    };
  }
  if (P % _16n === _9n) {
  }
  return tonelliShanks(P);
}
function validateField(field) {
  const initial = {
    ORDER: "bigint",
    MASK: "bigint",
    BYTES: "isSafeInteger",
    BITS: "isSafeInteger"
  };
  const opts = FIELD_FIELDS.reduce((map, val) => {
    map[val] = "function";
    return map;
  }, initial);
  return validateObject(field, opts);
}
function FpPow(f, num, power) {
  if (power < _0n3)
    throw new Error("Expected power > 0");
  if (power === _0n3)
    return f.ONE;
  if (power === _1n3)
    return num;
  let p = f.ONE;
  let d = num;
  while (power > _0n3) {
    if (power & _1n3)
      p = f.mul(p, d);
    d = f.sqr(d);
    power >>= _1n3;
  }
  return p;
}
function FpInvertBatch(f, nums) {
  const tmp = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = acc;
    return f.mul(acc, num);
  }, f.ONE);
  const inverted = f.inv(lastMultiplied);
  nums.reduceRight((acc, num, i) => {
    if (f.is0(num))
      return acc;
    tmp[i] = f.mul(acc, tmp[i]);
    return f.mul(acc, num);
  }, inverted);
  return tmp;
}
function nLength(n, nBitLength) {
  const _nBitLength = nBitLength !== undefined ? nBitLength : n.toString(2).length;
  const nByteLength = Math.ceil(_nBitLength / 8);
  return { nBitLength: _nBitLength, nByteLength };
}
function Field(ORDER, bitLen2, isLE2 = false, redef = {}) {
  if (ORDER <= _0n3)
    throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
  const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
  if (BYTES > 2048)
    throw new Error("Field lengths over 2048 bytes are not supported");
  const sqrtP = FpSqrt(ORDER);
  const f = Object.freeze({
    ORDER,
    BITS,
    BYTES,
    MASK: bitMask(BITS),
    ZERO: _0n3,
    ONE: _1n3,
    create: (num) => mod(num, ORDER),
    isValid: (num) => {
      if (typeof num !== "bigint")
        throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
      return _0n3 <= num && num < ORDER;
    },
    is0: (num) => num === _0n3,
    isOdd: (num) => (num & _1n3) === _1n3,
    neg: (num) => mod(-num, ORDER),
    eql: (lhs, rhs) => lhs === rhs,
    sqr: (num) => mod(num * num, ORDER),
    add: (lhs, rhs) => mod(lhs + rhs, ORDER),
    sub: (lhs, rhs) => mod(lhs - rhs, ORDER),
    mul: (lhs, rhs) => mod(lhs * rhs, ORDER),
    pow: (num, power) => FpPow(f, num, power),
    div: (lhs, rhs) => mod(lhs * invert(rhs, ORDER), ORDER),
    sqrN: (num) => num * num,
    addN: (lhs, rhs) => lhs + rhs,
    subN: (lhs, rhs) => lhs - rhs,
    mulN: (lhs, rhs) => lhs * rhs,
    inv: (num) => invert(num, ORDER),
    sqrt: redef.sqrt || ((n) => sqrtP(f, n)),
    invertBatch: (lst) => FpInvertBatch(f, lst),
    cmov: (a, b, c) => c ? b : a,
    toBytes: (num) => isLE2 ? numberToBytesLE(num, BYTES) : numberToBytesBE(num, BYTES),
    fromBytes: (bytes5) => {
      if (bytes5.length !== BYTES)
        throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes5.length}`);
      return isLE2 ? bytesToNumberLE(bytes5) : bytesToNumberBE(bytes5);
    }
  });
  return Object.freeze(f);
}
function getFieldBytesLength(fieldOrder) {
  if (typeof fieldOrder !== "bigint")
    throw new Error("field order must be bigint");
  const bitLength2 = fieldOrder.toString(2).length;
  return Math.ceil(bitLength2 / 8);
}
function getMinHashLength(fieldOrder) {
  const length = getFieldBytesLength(fieldOrder);
  return length + Math.ceil(length / 2);
}
function mapHashToField(key, fieldOrder, isLE2 = false) {
  const len = key.length;
  const fieldLen = getFieldBytesLength(fieldOrder);
  const minLen = getMinHashLength(fieldOrder);
  if (len < 16 || len < minLen || len > 1024)
    throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
  const num = isLE2 ? bytesToNumberBE(key) : bytesToNumberLE(key);
  const reduced = mod(num, fieldOrder - _1n3) + _1n3;
  return isLE2 ? numberToBytesLE(reduced, fieldLen) : numberToBytesBE(reduced, fieldLen);
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n = BigInt(3);
var _4n = BigInt(4);
var _5n = BigInt(5);
var _8n = BigInt(8);
var _9n = BigInt(9);
var _16n = BigInt(16);
var FIELD_FIELDS = [
  "create",
  "isValid",
  "is0",
  "neg",
  "inv",
  "sqrt",
  "sqr",
  "eql",
  "add",
  "sub",
  "mul",
  "pow",
  "div",
  "addN",
  "subN",
  "mulN",
  "sqrN"
];

// node_modules/@noble/curves/esm/abstract/curve.js
function wNAF(c, bits) {
  const constTimeNegate = (condition, item) => {
    const neg = item.negate();
    return condition ? neg : item;
  };
  const opts = (W) => {
    const windows = Math.ceil(bits / W) + 1;
    const windowSize = 2 ** (W - 1);
    return { windows, windowSize };
  };
  return {
    constTimeNegate,
    unsafeLadder(elm, n) {
      let p = c.ZERO;
      let d = elm;
      while (n > _0n4) {
        if (n & _1n4)
          p = p.add(d);
        d = d.double();
        n >>= _1n4;
      }
      return p;
    },
    precomputeWindow(elm, W) {
      const { windows, windowSize } = opts(W);
      const points = [];
      let p = elm;
      let base = p;
      for (let window2 = 0;window2 < windows; window2++) {
        base = p;
        points.push(base);
        for (let i = 1;i < windowSize; i++) {
          base = base.add(p);
          points.push(base);
        }
        p = base.double();
      }
      return points;
    },
    wNAF(W, precomputes, n) {
      const { windows, windowSize } = opts(W);
      let p = c.ZERO;
      let f = c.BASE;
      const mask = BigInt(2 ** W - 1);
      const maxNumber = 2 ** W;
      const shiftBy = BigInt(W);
      for (let window2 = 0;window2 < windows; window2++) {
        const offset = window2 * windowSize;
        let wbits = Number(n & mask);
        n >>= shiftBy;
        if (wbits > windowSize) {
          wbits -= maxNumber;
          n += _1n4;
        }
        const offset1 = offset;
        const offset2 = offset + Math.abs(wbits) - 1;
        const cond1 = window2 % 2 !== 0;
        const cond2 = wbits < 0;
        if (wbits === 0) {
          f = f.add(constTimeNegate(cond1, precomputes[offset1]));
        } else {
          p = p.add(constTimeNegate(cond2, precomputes[offset2]));
        }
      }
      return { p, f };
    },
    wNAFCached(P, precomputesMap, n, transform) {
      const W = P._WINDOW_SIZE || 1;
      let comp = precomputesMap.get(P);
      if (!comp) {
        comp = this.precomputeWindow(P, W);
        if (W !== 1) {
          precomputesMap.set(P, transform(comp));
        }
      }
      return this.wNAF(W, comp, n);
    }
  };
}
function validateBasic(curve) {
  validateField(curve.Fp);
  validateObject(curve, {
    n: "bigint",
    h: "bigint",
    Gx: "field",
    Gy: "field"
  }, {
    nBitLength: "isSafeInteger",
    nByteLength: "isSafeInteger"
  });
  return Object.freeze({
    ...nLength(curve.n, curve.nBitLength),
    ...curve,
    ...{ p: curve.Fp.ORDER }
  });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var _0n4 = BigInt(0);
var _1n4 = BigInt(1);

// node_modules/@noble/curves/esm/abstract/weierstrass.js
var validatePointOpts = function(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    a: "field",
    b: "field"
  }, {
    allowedPrivateKeyLengths: "array",
    wrapPrivateKey: "boolean",
    isTorsionFree: "function",
    clearCofactor: "function",
    allowInfinityPoint: "boolean",
    fromBytes: "function",
    toBytes: "function"
  });
  const { endo, Fp, a } = opts;
  if (endo) {
    if (!Fp.eql(a, Fp.ZERO)) {
      throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
    }
    if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
      throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
    }
  }
  return Object.freeze({ ...opts });
};
function weierstrassPoints(opts) {
  const CURVE = validatePointOpts(opts);
  const { Fp } = CURVE;
  const toBytes2 = CURVE.toBytes || ((_c, point, _isCompressed) => {
    const a = point.toAffine();
    return concatBytes2(Uint8Array.from([4]), Fp.toBytes(a.x), Fp.toBytes(a.y));
  });
  const fromBytes = CURVE.fromBytes || ((bytes5) => {
    const tail = bytes5.subarray(1);
    const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
    const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
    return { x, y };
  });
  function weierstrassEquation(x) {
    const { a, b } = CURVE;
    const x2 = Fp.sqr(x);
    const x3 = Fp.mul(x2, x);
    return Fp.add(Fp.add(x3, Fp.mul(x, a)), b);
  }
  if (!Fp.eql(Fp.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
    throw new Error("bad generator point: equation left != right");
  function isWithinCurveOrder(num) {
    return typeof num === "bigint" && _0n5 < num && num < CURVE.n;
  }
  function assertGE(num) {
    if (!isWithinCurveOrder(num))
      throw new Error("Expected valid bigint: 0 < bigint < curve.n");
  }
  function normPrivateKeyToScalar(key) {
    const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n } = CURVE;
    if (lengths && typeof key !== "bigint") {
      if (isBytes4(key))
        key = bytesToHex3(key);
      if (typeof key !== "string" || !lengths.includes(key.length))
        throw new Error("Invalid key");
      key = key.padStart(nByteLength * 2, "0");
    }
    let num;
    try {
      num = typeof key === "bigint" ? key : bytesToNumberBE(ensureBytes("private key", key, nByteLength));
    } catch (error) {
      throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
    }
    if (wrapPrivateKey)
      num = mod(num, n);
    assertGE(num);
    return num;
  }
  const pointPrecomputes = new Map;
  function assertPrjPoint(other) {
    if (!(other instanceof Point))
      throw new Error("ProjectivePoint expected");
  }

  class Point {
    constructor(px, py, pz) {
      this.px = px;
      this.py = py;
      this.pz = pz;
      if (px == null || !Fp.isValid(px))
        throw new Error("x required");
      if (py == null || !Fp.isValid(py))
        throw new Error("y required");
      if (pz == null || !Fp.isValid(pz))
        throw new Error("z required");
    }
    static fromAffine(p) {
      const { x, y } = p || {};
      if (!p || !Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("invalid affine point");
      if (p instanceof Point)
        throw new Error("projective point not allowed");
      const is0 = (i) => Fp.eql(i, Fp.ZERO);
      if (is0(x) && is0(y))
        return Point.ZERO;
      return new Point(x, y, Fp.ONE);
    }
    get x() {
      return this.toAffine().x;
    }
    get y() {
      return this.toAffine().y;
    }
    static normalizeZ(points) {
      const toInv = Fp.invertBatch(points.map((p) => p.pz));
      return points.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
    }
    static fromHex(hex) {
      const P = Point.fromAffine(fromBytes(ensureBytes("pointHex", hex)));
      P.assertValidity();
      return P;
    }
    static fromPrivateKey(privateKey) {
      return Point.BASE.multiply(normPrivateKeyToScalar(privateKey));
    }
    _setWindowSize(windowSize) {
      this._WINDOW_SIZE = windowSize;
      pointPrecomputes.delete(this);
    }
    assertValidity() {
      if (this.is0()) {
        if (CURVE.allowInfinityPoint && !Fp.is0(this.py))
          return;
        throw new Error("bad point: ZERO");
      }
      const { x, y } = this.toAffine();
      if (!Fp.isValid(x) || !Fp.isValid(y))
        throw new Error("bad point: x or y not FE");
      const left = Fp.sqr(y);
      const right = weierstrassEquation(x);
      if (!Fp.eql(left, right))
        throw new Error("bad point: equation left != right");
      if (!this.isTorsionFree())
        throw new Error("bad point: not in prime-order subgroup");
    }
    hasEvenY() {
      const { y } = this.toAffine();
      if (Fp.isOdd)
        return !Fp.isOdd(y);
      throw new Error("Field doesn't support isOdd");
    }
    equals(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      const U1 = Fp.eql(Fp.mul(X1, Z2), Fp.mul(X2, Z1));
      const U2 = Fp.eql(Fp.mul(Y1, Z2), Fp.mul(Y2, Z1));
      return U1 && U2;
    }
    negate() {
      return new Point(this.px, Fp.neg(this.py), this.pz);
    }
    double() {
      const { a, b } = CURVE;
      const b3 = Fp.mul(b, _3n2);
      const { px: X1, py: Y1, pz: Z1 } = this;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      let t0 = Fp.mul(X1, X1);
      let t1 = Fp.mul(Y1, Y1);
      let t2 = Fp.mul(Z1, Z1);
      let t3 = Fp.mul(X1, Y1);
      t3 = Fp.add(t3, t3);
      Z3 = Fp.mul(X1, Z1);
      Z3 = Fp.add(Z3, Z3);
      X3 = Fp.mul(a, Z3);
      Y3 = Fp.mul(b3, t2);
      Y3 = Fp.add(X3, Y3);
      X3 = Fp.sub(t1, Y3);
      Y3 = Fp.add(t1, Y3);
      Y3 = Fp.mul(X3, Y3);
      X3 = Fp.mul(t3, X3);
      Z3 = Fp.mul(b3, Z3);
      t2 = Fp.mul(a, t2);
      t3 = Fp.sub(t0, t2);
      t3 = Fp.mul(a, t3);
      t3 = Fp.add(t3, Z3);
      Z3 = Fp.add(t0, t0);
      t0 = Fp.add(Z3, t0);
      t0 = Fp.add(t0, t2);
      t0 = Fp.mul(t0, t3);
      Y3 = Fp.add(Y3, t0);
      t2 = Fp.mul(Y1, Z1);
      t2 = Fp.add(t2, t2);
      t0 = Fp.mul(t2, t3);
      X3 = Fp.sub(X3, t0);
      Z3 = Fp.mul(t2, t1);
      Z3 = Fp.add(Z3, Z3);
      Z3 = Fp.add(Z3, Z3);
      return new Point(X3, Y3, Z3);
    }
    add(other) {
      assertPrjPoint(other);
      const { px: X1, py: Y1, pz: Z1 } = this;
      const { px: X2, py: Y2, pz: Z2 } = other;
      let { ZERO: X3, ZERO: Y3, ZERO: Z3 } = Fp;
      const a = CURVE.a;
      const b3 = Fp.mul(CURVE.b, _3n2);
      let t0 = Fp.mul(X1, X2);
      let t1 = Fp.mul(Y1, Y2);
      let t2 = Fp.mul(Z1, Z2);
      let t3 = Fp.add(X1, Y1);
      let t4 = Fp.add(X2, Y2);
      t3 = Fp.mul(t3, t4);
      t4 = Fp.add(t0, t1);
      t3 = Fp.sub(t3, t4);
      t4 = Fp.add(X1, Z1);
      let t5 = Fp.add(X2, Z2);
      t4 = Fp.mul(t4, t5);
      t5 = Fp.add(t0, t2);
      t4 = Fp.sub(t4, t5);
      t5 = Fp.add(Y1, Z1);
      X3 = Fp.add(Y2, Z2);
      t5 = Fp.mul(t5, X3);
      X3 = Fp.add(t1, t2);
      t5 = Fp.sub(t5, X3);
      Z3 = Fp.mul(a, t4);
      X3 = Fp.mul(b3, t2);
      Z3 = Fp.add(X3, Z3);
      X3 = Fp.sub(t1, Z3);
      Z3 = Fp.add(t1, Z3);
      Y3 = Fp.mul(X3, Z3);
      t1 = Fp.add(t0, t0);
      t1 = Fp.add(t1, t0);
      t2 = Fp.mul(a, t2);
      t4 = Fp.mul(b3, t4);
      t1 = Fp.add(t1, t2);
      t2 = Fp.sub(t0, t2);
      t2 = Fp.mul(a, t2);
      t4 = Fp.add(t4, t2);
      t0 = Fp.mul(t1, t4);
      Y3 = Fp.add(Y3, t0);
      t0 = Fp.mul(t5, t4);
      X3 = Fp.mul(t3, X3);
      X3 = Fp.sub(X3, t0);
      t0 = Fp.mul(t3, t1);
      Z3 = Fp.mul(t5, Z3);
      Z3 = Fp.add(Z3, t0);
      return new Point(X3, Y3, Z3);
    }
    subtract(other) {
      return this.add(other.negate());
    }
    is0() {
      return this.equals(Point.ZERO);
    }
    wNAF(n) {
      return wnaf.wNAFCached(this, pointPrecomputes, n, (comp) => {
        const toInv = Fp.invertBatch(comp.map((p) => p.pz));
        return comp.map((p, i) => p.toAffine(toInv[i])).map(Point.fromAffine);
      });
    }
    multiplyUnsafe(n) {
      const I = Point.ZERO;
      if (n === _0n5)
        return I;
      assertGE(n);
      if (n === _1n5)
        return this;
      const { endo } = CURVE;
      if (!endo)
        return wnaf.unsafeLadder(this, n);
      let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let k1p = I;
      let k2p = I;
      let d = this;
      while (k1 > _0n5 || k2 > _0n5) {
        if (k1 & _1n5)
          k1p = k1p.add(d);
        if (k2 & _1n5)
          k2p = k2p.add(d);
        d = d.double();
        k1 >>= _1n5;
        k2 >>= _1n5;
      }
      if (k1neg)
        k1p = k1p.negate();
      if (k2neg)
        k2p = k2p.negate();
      k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
      return k1p.add(k2p);
    }
    multiply(scalar) {
      assertGE(scalar);
      let n = scalar;
      let point, fake;
      const { endo } = CURVE;
      if (endo) {
        const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
        let { p: k1p, f: f1p } = this.wNAF(k1);
        let { p: k2p, f: f2p } = this.wNAF(k2);
        k1p = wnaf.constTimeNegate(k1neg, k1p);
        k2p = wnaf.constTimeNegate(k2neg, k2p);
        k2p = new Point(Fp.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
        point = k1p.add(k2p);
        fake = f1p.add(f2p);
      } else {
        const { p, f } = this.wNAF(n);
        point = p;
        fake = f;
      }
      return Point.normalizeZ([point, fake])[0];
    }
    multiplyAndAddUnsafe(Q, a, b) {
      const G = Point.BASE;
      const mul = (P, a2) => a2 === _0n5 || a2 === _1n5 || !P.equals(G) ? P.multiplyUnsafe(a2) : P.multiply(a2);
      const sum = mul(this, a).add(mul(Q, b));
      return sum.is0() ? undefined : sum;
    }
    toAffine(iz) {
      const { px: x, py: y, pz: z2 } = this;
      const is0 = this.is0();
      if (iz == null)
        iz = is0 ? Fp.ONE : Fp.inv(z2);
      const ax = Fp.mul(x, iz);
      const ay = Fp.mul(y, iz);
      const zz = Fp.mul(z2, iz);
      if (is0)
        return { x: Fp.ZERO, y: Fp.ZERO };
      if (!Fp.eql(zz, Fp.ONE))
        throw new Error("invZ was invalid");
      return { x: ax, y: ay };
    }
    isTorsionFree() {
      const { h: cofactor, isTorsionFree } = CURVE;
      if (cofactor === _1n5)
        return true;
      if (isTorsionFree)
        return isTorsionFree(Point, this);
      throw new Error("isTorsionFree() has not been declared for the elliptic curve");
    }
    clearCofactor() {
      const { h: cofactor, clearCofactor } = CURVE;
      if (cofactor === _1n5)
        return this;
      if (clearCofactor)
        return clearCofactor(Point, this);
      return this.multiplyUnsafe(CURVE.h);
    }
    toRawBytes(isCompressed = true) {
      this.assertValidity();
      return toBytes2(Point, this, isCompressed);
    }
    toHex(isCompressed = true) {
      return bytesToHex3(this.toRawBytes(isCompressed));
    }
  }
  Point.BASE = new Point(CURVE.Gx, CURVE.Gy, Fp.ONE);
  Point.ZERO = new Point(Fp.ZERO, Fp.ONE, Fp.ZERO);
  const _bits = CURVE.nBitLength;
  const wnaf = wNAF(Point, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
  return {
    CURVE,
    ProjectivePoint: Point,
    normPrivateKeyToScalar,
    weierstrassEquation,
    isWithinCurveOrder
  };
}
var validateOpts = function(curve2) {
  const opts = validateBasic(curve2);
  validateObject(opts, {
    hash: "hash",
    hmac: "function",
    randomBytes: "function"
  }, {
    bits2int: "function",
    bits2int_modN: "function",
    lowS: "boolean"
  });
  return Object.freeze({ lowS: true, ...opts });
};
function weierstrass(curveDef) {
  const CURVE = validateOpts(curveDef);
  const { Fp, n: CURVE_ORDER } = CURVE;
  const compressedLen = Fp.BYTES + 1;
  const uncompressedLen = 2 * Fp.BYTES + 1;
  function isValidFieldElement(num) {
    return _0n5 < num && num < Fp.ORDER;
  }
  function modN(a) {
    return mod(a, CURVE_ORDER);
  }
  function invN(a) {
    return invert(a, CURVE_ORDER);
  }
  const { ProjectivePoint: Point, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints({
    ...CURVE,
    toBytes(_c, point, isCompressed) {
      const a = point.toAffine();
      const x = Fp.toBytes(a.x);
      const cat = concatBytes2;
      if (isCompressed) {
        return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x);
      } else {
        return cat(Uint8Array.from([4]), x, Fp.toBytes(a.y));
      }
    },
    fromBytes(bytes5) {
      const len = bytes5.length;
      const head = bytes5[0];
      const tail = bytes5.subarray(1);
      if (len === compressedLen && (head === 2 || head === 3)) {
        const x = bytesToNumberBE(tail);
        if (!isValidFieldElement(x))
          throw new Error("Point is not on curve");
        const y2 = weierstrassEquation(x);
        let y = Fp.sqrt(y2);
        const isYOdd = (y & _1n5) === _1n5;
        const isHeadOdd = (head & 1) === 1;
        if (isHeadOdd !== isYOdd)
          y = Fp.neg(y);
        return { x, y };
      } else if (len === uncompressedLen && head === 4) {
        const x = Fp.fromBytes(tail.subarray(0, Fp.BYTES));
        const y = Fp.fromBytes(tail.subarray(Fp.BYTES, 2 * Fp.BYTES));
        return { x, y };
      } else {
        throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
      }
    }
  });
  const numToNByteStr = (num) => bytesToHex3(numberToBytesBE(num, CURVE.nByteLength));
  function isBiggerThanHalfOrder(number2) {
    const HALF = CURVE_ORDER >> _1n5;
    return number2 > HALF;
  }
  function normalizeS(s) {
    return isBiggerThanHalfOrder(s) ? modN(-s) : s;
  }
  const slcNum = (b, from, to) => bytesToNumberBE(b.slice(from, to));

  class Signature {
    constructor(r, s, recovery) {
      this.r = r;
      this.s = s;
      this.recovery = recovery;
      this.assertValidity();
    }
    static fromCompact(hex) {
      const l = CURVE.nByteLength;
      hex = ensureBytes("compactSignature", hex, l * 2);
      return new Signature(slcNum(hex, 0, l), slcNum(hex, l, 2 * l));
    }
    static fromDER(hex) {
      const { r, s } = DER.toSig(ensureBytes("DER", hex));
      return new Signature(r, s);
    }
    assertValidity() {
      if (!isWithinCurveOrder(this.r))
        throw new Error("r must be 0 < r < CURVE.n");
      if (!isWithinCurveOrder(this.s))
        throw new Error("s must be 0 < s < CURVE.n");
    }
    addRecoveryBit(recovery) {
      return new Signature(this.r, this.s, recovery);
    }
    recoverPublicKey(msgHash) {
      const { r, s, recovery: rec } = this;
      const h = bits2int_modN(ensureBytes("msgHash", msgHash));
      if (rec == null || ![0, 1, 2, 3].includes(rec))
        throw new Error("recovery id invalid");
      const radj = rec === 2 || rec === 3 ? r + CURVE.n : r;
      if (radj >= Fp.ORDER)
        throw new Error("recovery id 2 or 3 invalid");
      const prefix = (rec & 1) === 0 ? "02" : "03";
      const R = Point.fromHex(prefix + numToNByteStr(radj));
      const ir = invN(radj);
      const u1 = modN(-h * ir);
      const u2 = modN(s * ir);
      const Q = Point.BASE.multiplyAndAddUnsafe(R, u1, u2);
      if (!Q)
        throw new Error("point at infinify");
      Q.assertValidity();
      return Q;
    }
    hasHighS() {
      return isBiggerThanHalfOrder(this.s);
    }
    normalizeS() {
      return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
    }
    toDERRawBytes() {
      return hexToBytes2(this.toDERHex());
    }
    toDERHex() {
      return DER.hexFromSig({ r: this.r, s: this.s });
    }
    toCompactRawBytes() {
      return hexToBytes2(this.toCompactHex());
    }
    toCompactHex() {
      return numToNByteStr(this.r) + numToNByteStr(this.s);
    }
  }
  const utils27 = {
    isValidPrivateKey(privateKey) {
      try {
        normPrivateKeyToScalar(privateKey);
        return true;
      } catch (error) {
        return false;
      }
    },
    normPrivateKeyToScalar,
    randomPrivateKey: () => {
      const length = getMinHashLength(CURVE.n);
      return mapHashToField(CURVE.randomBytes(length), CURVE.n);
    },
    precompute(windowSize = 8, point = Point.BASE) {
      point._setWindowSize(windowSize);
      point.multiply(BigInt(3));
      return point;
    }
  };
  function getPublicKey(privateKey, isCompressed = true) {
    return Point.fromPrivateKey(privateKey).toRawBytes(isCompressed);
  }
  function isProbPub(item) {
    const arr = isBytes4(item);
    const str = typeof item === "string";
    const len = (arr || str) && item.length;
    if (arr)
      return len === compressedLen || len === uncompressedLen;
    if (str)
      return len === 2 * compressedLen || len === 2 * uncompressedLen;
    if (item instanceof Point)
      return true;
    return false;
  }
  function getSharedSecret(privateA, publicB, isCompressed = true) {
    if (isProbPub(privateA))
      throw new Error("first arg must be private key");
    if (!isProbPub(publicB))
      throw new Error("second arg must be public key");
    const b = Point.fromHex(publicB);
    return b.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
  }
  const bits2int = CURVE.bits2int || function(bytes5) {
    const num = bytesToNumberBE(bytes5);
    const delta = bytes5.length * 8 - CURVE.nBitLength;
    return delta > 0 ? num >> BigInt(delta) : num;
  };
  const bits2int_modN = CURVE.bits2int_modN || function(bytes5) {
    return modN(bits2int(bytes5));
  };
  const ORDER_MASK = bitMask(CURVE.nBitLength);
  function int2octets(num) {
    if (typeof num !== "bigint")
      throw new Error("bigint expected");
    if (!(_0n5 <= num && num < ORDER_MASK))
      throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
    return numberToBytesBE(num, CURVE.nByteLength);
  }
  function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
    if (["recovered", "canonical"].some((k) => (k in opts)))
      throw new Error("sign() legacy options not supported");
    const { hash: hash3, randomBytes: randomBytes3 } = CURVE;
    let { lowS, prehash, extraEntropy: ent } = opts;
    if (lowS == null)
      lowS = true;
    msgHash = ensureBytes("msgHash", msgHash);
    if (prehash)
      msgHash = ensureBytes("prehashed msgHash", hash3(msgHash));
    const h1int = bits2int_modN(msgHash);
    const d = normPrivateKeyToScalar(privateKey);
    const seedArgs = [int2octets(d), int2octets(h1int)];
    if (ent != null) {
      const e = ent === true ? randomBytes3(Fp.BYTES) : ent;
      seedArgs.push(ensureBytes("extraEntropy", e));
    }
    const seed = concatBytes2(...seedArgs);
    const m = h1int;
    function k2sig(kBytes) {
      const k = bits2int(kBytes);
      if (!isWithinCurveOrder(k))
        return;
      const ik = invN(k);
      const q = Point.BASE.multiply(k).toAffine();
      const r = modN(q.x);
      if (r === _0n5)
        return;
      const s = modN(ik * modN(m + r * d));
      if (s === _0n5)
        return;
      let recovery = (q.x === r ? 0 : 2) | Number(q.y & _1n5);
      let normS = s;
      if (lowS && isBiggerThanHalfOrder(s)) {
        normS = normalizeS(s);
        recovery ^= 1;
      }
      return new Signature(r, normS, recovery);
    }
    return { seed, k2sig };
  }
  const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
  const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
  function sign(msgHash, privKey, opts = defaultSigOpts) {
    const { seed, k2sig } = prepSig(msgHash, privKey, opts);
    const C = CURVE;
    const drbg = createHmacDrbg(C.hash.outputLen, C.nByteLength, C.hmac);
    return drbg(seed, k2sig);
  }
  Point.BASE._setWindowSize(8);
  function verify(signature, msgHash, publicKey, opts = defaultVerOpts) {
    const sg = signature;
    msgHash = ensureBytes("msgHash", msgHash);
    publicKey = ensureBytes("publicKey", publicKey);
    if ("strict" in opts)
      throw new Error("options.strict was renamed to lowS");
    const { lowS, prehash } = opts;
    let _sig = undefined;
    let P;
    try {
      if (typeof sg === "string" || isBytes4(sg)) {
        try {
          _sig = Signature.fromDER(sg);
        } catch (derError) {
          if (!(derError instanceof DER.Err))
            throw derError;
          _sig = Signature.fromCompact(sg);
        }
      } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
        const { r: r2, s: s2 } = sg;
        _sig = new Signature(r2, s2);
      } else {
        throw new Error("PARSE");
      }
      P = Point.fromHex(publicKey);
    } catch (error) {
      if (error.message === "PARSE")
        throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
      return false;
    }
    if (lowS && _sig.hasHighS())
      return false;
    if (prehash)
      msgHash = CURVE.hash(msgHash);
    const { r, s } = _sig;
    const h = bits2int_modN(msgHash);
    const is = invN(s);
    const u1 = modN(h * is);
    const u2 = modN(r * is);
    const R = Point.BASE.multiplyAndAddUnsafe(P, u1, u2)?.toAffine();
    if (!R)
      return false;
    const v = modN(R.x);
    return v === r;
  }
  return {
    CURVE,
    getPublicKey,
    getSharedSecret,
    sign,
    verify,
    ProjectivePoint: Point,
    Signature,
    utils: utils27
  };
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var { bytesToNumberBE: b2n, hexToBytes: h2b } = exports_utils2;
var DER = {
  Err: class DERErr extends Error {
    constructor(m = "") {
      super(m);
    }
  },
  _parseInt(data) {
    const { Err: E } = DER;
    if (data.length < 2 || data[0] !== 2)
      throw new E("Invalid signature integer tag");
    const len = data[1];
    const res = data.subarray(2, len + 2);
    if (!len || res.length !== len)
      throw new E("Invalid signature integer: wrong length");
    if (res[0] & 128)
      throw new E("Invalid signature integer: negative");
    if (res[0] === 0 && !(res[1] & 128))
      throw new E("Invalid signature integer: unnecessary leading zero");
    return { d: b2n(res), l: data.subarray(len + 2) };
  },
  toSig(hex) {
    const { Err: E } = DER;
    const data = typeof hex === "string" ? h2b(hex) : hex;
    if (!isBytes4(data))
      throw new Error("ui8a expected");
    let l = data.length;
    if (l < 2 || data[0] != 48)
      throw new E("Invalid signature tag");
    if (data[1] !== l - 2)
      throw new E("Invalid signature: incorrect length");
    const { d: r, l: sBytes } = DER._parseInt(data.subarray(2));
    const { d: s, l: rBytesLeft } = DER._parseInt(sBytes);
    if (rBytesLeft.length)
      throw new E("Invalid signature: left bytes after parsing");
    return { r, s };
  },
  hexFromSig(sig) {
    const slice = (s2) => Number.parseInt(s2[0], 16) & 8 ? "00" + s2 : s2;
    const h = (num) => {
      const hex = num.toString(16);
      return hex.length & 1 ? `0${hex}` : hex;
    };
    const s = slice(h(sig.s));
    const r = slice(h(sig.r));
    const shl = s.length / 2;
    const rhl = r.length / 2;
    const sl = h(shl);
    const rl = h(rhl);
    return `30${h(rhl + shl + 4)}02${rl}${r}02${sl}${s}`;
  }
};
var _0n5 = BigInt(0);
var _1n5 = BigInt(1);
var _2n4 = BigInt(2);
var _3n2 = BigInt(3);
var _4n2 = BigInt(4);

// node_modules/@noble/curves/esm/_shortw_utils.js
function getHash(hash3) {
  return {
    hash: hash3,
    hmac: (key, ...msgs) => hmac(hash3, key, concatBytes(...msgs)),
    randomBytes
  };
}
function createCurve(curveDef, defHash) {
  const create = (hash3) => weierstrass({ ...curveDef, ...getHash(hash3) });
  return Object.freeze({ ...create(defHash), create });
}
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */

// node_modules/@noble/curves/esm/secp256k1.js
var sqrtMod = function(y) {
  const P = secp256k1P;
  const _3n3 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
  const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
  const b2 = y * y * y % P;
  const b3 = b2 * b2 * y % P;
  const b6 = pow2(b3, _3n3, P) * b3 % P;
  const b9 = pow2(b6, _3n3, P) * b3 % P;
  const b11 = pow2(b9, _2n5, P) * b2 % P;
  const b22 = pow2(b11, _11n, P) * b11 % P;
  const b44 = pow2(b22, _22n, P) * b22 % P;
  const b88 = pow2(b44, _44n, P) * b44 % P;
  const b176 = pow2(b88, _88n, P) * b88 % P;
  const b220 = pow2(b176, _44n, P) * b44 % P;
  const b223 = pow2(b220, _3n3, P) * b3 % P;
  const t1 = pow2(b223, _23n, P) * b22 % P;
  const t2 = pow2(t1, _6n, P) * b2 % P;
  const root = pow2(t2, _2n5, P);
  if (!Fp.eql(Fp.sqr(root), y))
    throw new Error("Cannot find square root");
  return root;
};
/*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var _1n6 = BigInt(1);
var _2n5 = BigInt(2);
var divNearest = (a, b) => (a + b / _2n5) / b;
var Fp = Field(secp256k1P, undefined, undefined, { sqrt: sqrtMod });
var secp256k1 = createCurve({
  a: BigInt(0),
  b: BigInt(7),
  Fp,
  n: secp256k1N,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  h: BigInt(1),
  lowS: true,
  endo: {
    beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
    splitScalar: (k) => {
      const n = secp256k1N;
      const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
      const b1 = -_1n6 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
      const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
      const b2 = a1;
      const POW_2_128 = BigInt("0x100000000000000000000000000000000");
      const c1 = divNearest(b2 * k, n);
      const c2 = divNearest(-b1 * k, n);
      let k1 = mod(k - c1 * a1 - c2 * a2, n);
      let k2 = mod(-c1 * b1 - c2 * b2, n);
      const k1neg = k1 > POW_2_128;
      const k2neg = k2 > POW_2_128;
      if (k1neg)
        k1 = n - k1;
      if (k2neg)
        k2 = n - k2;
      if (k1 > POW_2_128 || k2 > POW_2_128) {
        throw new Error("splitScalar: Endomorphism failed, k=" + k);
      }
      return { k1neg, k1, k2neg, k2 };
    }
  }
}, sha256);
var _0n6 = BigInt(0);
var Point = secp256k1.ProjectivePoint;
// node_modules/web3-eth-accounts/lib/esm/tx/constants.js
var _a2;
var secp256k12 = (_a2 = secp256k1) !== null && _a2 !== undefined ? _a2 : exports_secp256k1;
var MAX_UINT64 = BigInt("0xffffffffffffffff");
var MAX_INTEGER = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var SECP256K1_ORDER = secp256k12.CURVE.n;
var SECP256K1_ORDER_DIV_2 = SECP256K1_ORDER / BigInt(2);

// node_modules/web3-eth-accounts/lib/esm/schemas.js
var keyStoreSchema = {
  type: "object",
  required: ["crypto", "id", "version", "address"],
  properties: {
    crypto: {
      type: "object",
      required: ["cipher", "ciphertext", "cipherparams", "kdf", "kdfparams", "mac"],
      properties: {
        cipher: { type: "string" },
        ciphertext: { type: "string" },
        cipherparams: { type: "object" },
        kdf: { type: "string" },
        kdfparams: { type: "object" },
        salt: { type: "string" },
        mac: { type: "string" }
      }
    },
    id: { type: "string" },
    version: { type: "number" },
    address: { type: "string" }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/enums.js
var Chain;
(function(Chain2) {
  Chain2[Chain2["Mainnet"] = 1] = "Mainnet";
  Chain2[Chain2["Goerli"] = 5] = "Goerli";
  Chain2[Chain2["Sepolia"] = 11155111] = "Sepolia";
})(Chain || (Chain = {}));
var Hardfork;
(function(Hardfork2) {
  Hardfork2["Chainstart"] = "chainstart";
  Hardfork2["Homestead"] = "homestead";
  Hardfork2["Dao"] = "dao";
  Hardfork2["TangerineWhistle"] = "tangerineWhistle";
  Hardfork2["SpuriousDragon"] = "spuriousDragon";
  Hardfork2["Byzantium"] = "byzantium";
  Hardfork2["Constantinople"] = "constantinople";
  Hardfork2["Petersburg"] = "petersburg";
  Hardfork2["Istanbul"] = "istanbul";
  Hardfork2["MuirGlacier"] = "muirGlacier";
  Hardfork2["Berlin"] = "berlin";
  Hardfork2["London"] = "london";
  Hardfork2["ArrowGlacier"] = "arrowGlacier";
  Hardfork2["GrayGlacier"] = "grayGlacier";
  Hardfork2["MergeForkIdTransition"] = "mergeForkIdTransition";
  Hardfork2["Merge"] = "merge";
  Hardfork2["Shanghai"] = "shanghai";
  Hardfork2["ShardingForkDev"] = "shardingFork";
})(Hardfork || (Hardfork = {}));
var ConsensusType;
(function(ConsensusType2) {
  ConsensusType2["ProofOfStake"] = "pos";
  ConsensusType2["ProofOfWork"] = "pow";
  ConsensusType2["ProofOfAuthority"] = "poa";
})(ConsensusType || (ConsensusType = {}));
var ConsensusAlgorithm;
(function(ConsensusAlgorithm2) {
  ConsensusAlgorithm2["Ethash"] = "ethash";
  ConsensusAlgorithm2["Clique"] = "clique";
  ConsensusAlgorithm2["Casper"] = "casper";
})(ConsensusAlgorithm || (ConsensusAlgorithm = {}));
var CustomChain;
(function(CustomChain2) {
  CustomChain2["PolygonMainnet"] = "polygon-mainnet";
  CustomChain2["PolygonMumbai"] = "polygon-mumbai";
  CustomChain2["ArbitrumRinkebyTestnet"] = "arbitrum-rinkeby-testnet";
  CustomChain2["ArbitrumOne"] = "arbitrum-one";
  CustomChain2["xDaiChain"] = "x-dai-chain";
  CustomChain2["OptimisticKovan"] = "optimistic-kovan";
  CustomChain2["OptimisticEthereum"] = "optimistic-ethereum";
})(CustomChain || (CustomChain = {}));

// node_modules/web3-eth-accounts/lib/esm/common/types.js
var TypeOutput;
(function(TypeOutput2) {
  TypeOutput2[TypeOutput2["Number"] = 0] = "Number";
  TypeOutput2[TypeOutput2["BigInt"] = 1] = "BigInt";
  TypeOutput2[TypeOutput2["Uint8Array"] = 2] = "Uint8Array";
  TypeOutput2[TypeOutput2["PrefixedHexString"] = 3] = "PrefixedHexString";
})(TypeOutput || (TypeOutput = {}));

// node_modules/web3-eth-accounts/lib/esm/common/utils.js
var formatNonce = function(nonce) {
  if (!nonce || nonce === "0x0") {
    return "0x0000000000000000";
  }
  if (isHexPrefixed(nonce)) {
    return `0x${stripHexPrefix(nonce).padStart(16, "0")}`;
  }
  return `0x${nonce.padStart(16, "0")}`;
};
var parseGethParams = function(json, mergeForkIdPostMerge = true) {
  var _a3, _b;
  const { name, config, difficulty, mixHash, gasLimit, coinbase, baseFeePerGas } = json;
  let { extraData, timestamp, nonce } = json;
  const genesisTimestamp = Number(timestamp);
  const { chainId } = config;
  if (extraData === "") {
    extraData = "0x";
  }
  if (!isHexPrefixed(timestamp)) {
    timestamp = intToHex(parseInt(timestamp));
  }
  if (nonce.length !== 18) {
    nonce = formatNonce(nonce);
  }
  if (config.eip155Block !== config.eip158Block) {
    throw new Error("EIP155 block number must equal EIP 158 block number since both are part of SpuriousDragon hardfork and the client only supports activating the full hardfork");
  }
  const params = {
    name,
    chainId,
    networkId: chainId,
    genesis: {
      timestamp,
      gasLimit: parseInt(gasLimit),
      difficulty: parseInt(difficulty),
      nonce,
      extraData,
      mixHash,
      coinbase,
      baseFeePerGas
    },
    hardfork: undefined,
    hardforks: [],
    bootstrapNodes: [],
    consensus: config.clique !== undefined ? {
      type: "poa",
      algorithm: "clique",
      clique: {
        period: (_a3 = config.clique.period) !== null && _a3 !== undefined ? _a3 : config.clique.blockperiodseconds,
        epoch: (_b = config.clique.epoch) !== null && _b !== undefined ? _b : config.clique.epochlength
      }
    } : {
      type: "pow",
      algorithm: "ethash",
      ethash: {}
    }
  };
  const forkMap = {
    [Hardfork.Homestead]: { name: "homesteadBlock" },
    [Hardfork.Dao]: { name: "daoForkBlock" },
    [Hardfork.TangerineWhistle]: { name: "eip150Block" },
    [Hardfork.SpuriousDragon]: { name: "eip155Block" },
    [Hardfork.Byzantium]: { name: "byzantiumBlock" },
    [Hardfork.Constantinople]: { name: "constantinopleBlock" },
    [Hardfork.Petersburg]: { name: "petersburgBlock" },
    [Hardfork.Istanbul]: { name: "istanbulBlock" },
    [Hardfork.MuirGlacier]: { name: "muirGlacierBlock" },
    [Hardfork.Berlin]: { name: "berlinBlock" },
    [Hardfork.London]: { name: "londonBlock" },
    [Hardfork.MergeForkIdTransition]: {
      name: "mergeForkBlock",
      postMerge: mergeForkIdPostMerge
    },
    [Hardfork.Shanghai]: { name: "shanghaiTime", postMerge: true, isTimestamp: true },
    [Hardfork.ShardingForkDev]: {
      name: "shardingForkTime",
      postMerge: true,
      isTimestamp: true
    }
  };
  const forkMapRev = Object.keys(forkMap).reduce((acc, elem) => {
    acc[forkMap[elem].name] = elem;
    return acc;
  }, {});
  const configHardforkNames = Object.keys(config).filter((key) => forkMapRev[key] !== undefined && config[key] !== undefined && config[key] !== null);
  params.hardforks = configHardforkNames.map((nameBlock) => ({
    name: forkMapRev[nameBlock],
    block: forkMap[forkMapRev[nameBlock]].isTimestamp === true || typeof config[nameBlock] !== "number" ? null : config[nameBlock],
    timestamp: forkMap[forkMapRev[nameBlock]].isTimestamp === true && typeof config[nameBlock] === "number" ? config[nameBlock] : undefined
  })).filter((fork) => fork.block !== null || fork.timestamp !== undefined);
  params.hardforks.sort((a, b) => {
    var _a4, _b2;
    return ((_a4 = a.block) !== null && _a4 !== undefined ? _a4 : Infinity) - ((_b2 = b.block) !== null && _b2 !== undefined ? _b2 : Infinity);
  });
  params.hardforks.sort((a, b) => {
    var _a4, _b2;
    return ((_a4 = a.timestamp) !== null && _a4 !== undefined ? _a4 : genesisTimestamp) - ((_b2 = b.timestamp) !== null && _b2 !== undefined ? _b2 : genesisTimestamp);
  });
  if (config.terminalTotalDifficulty !== undefined) {
    const mergeConfig = {
      name: Hardfork.Merge,
      ttd: config.terminalTotalDifficulty,
      block: null
    };
    const postMergeIndex = params.hardforks.findIndex((hf) => {
      var _a4;
      return ((_a4 = forkMap[hf.name]) === null || _a4 === undefined ? undefined : _a4.postMerge) === true;
    });
    if (postMergeIndex !== -1) {
      params.hardforks.splice(postMergeIndex, 0, mergeConfig);
    } else {
      params.hardforks.push(mergeConfig);
    }
  }
  const latestHardfork = params.hardforks.length > 0 ? params.hardforks.slice(-1)[0] : undefined;
  params.hardfork = latestHardfork === null || latestHardfork === undefined ? undefined : latestHardfork.name;
  params.hardforks.unshift({ name: Hardfork.Chainstart, block: 0 });
  return params;
};
function parseGethGenesis(json, name, mergeForkIdPostMerge) {
  try {
    if (["config", "difficulty", "gasLimit", "alloc"].some((field) => !(field in json))) {
      throw new Error("Invalid format, expected geth genesis fields missing");
    }
    if (name !== undefined) {
      json.name = name;
    }
    return parseGethParams(json, mergeForkIdPostMerge);
  } catch (e) {
    throw new Error(`Error parsing parameters file: ${e.message}`);
  }
}
function padToEven(value) {
  let a = value;
  if (typeof a !== "string") {
    throw new Error(`[padToEven] value must be type 'string', received ${typeof a}`);
  }
  if (a.length % 2)
    a = `0${a}`;
  return a;
}
function uint8ArrayToBigInt(buf) {
  const hex = bytesToHex2(buf);
  if (hex === "0x") {
    return BigInt(0);
  }
  return BigInt(hex);
}
function bigIntToUint8Array(num) {
  return toUint8Array(`0x${num.toString(16)}`);
}
function assertIsUint8Array(input) {
  if (!isUint8Array2(input)) {
    const msg = `This method only supports Uint8Array but input was: ${input}`;
    throw new Error(msg);
  }
}
function stripZeros(a) {
  let first = a[0];
  while (a.length > 0 && first.toString() === "0") {
    a = a.slice(1);
    first = a[0];
  }
  return a;
}
function bigIntToUnpaddedUint8Array(value) {
  return unpadUint8Array(bigIntToUint8Array(value));
}
var calculateSigRecovery = function(v, chainId) {
  if (v === BigInt(0) || v === BigInt(1))
    return v;
  if (chainId === undefined) {
    return v - BigInt(27);
  }
  return v - (chainId * BigInt(2) + BigInt(35));
};
var isValidSigRecovery = function(recovery) {
  return recovery === BigInt(0) || recovery === BigInt(1);
};
function toType(input, outputType) {
  if (input === null) {
    return null;
  }
  if (input === undefined) {
    return;
  }
  if (typeof input === "string" && !isHexString(input)) {
    throw new Error(`A string must be provided with a 0x-prefix, given: ${input}`);
  } else if (typeof input === "number" && !Number.isSafeInteger(input)) {
    throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative input type)");
  }
  const output2 = toUint8Array(input);
  switch (outputType) {
    case TypeOutput.Uint8Array:
      return output2;
    case TypeOutput.BigInt:
      return uint8ArrayToBigInt(output2);
    case TypeOutput.Number: {
      const bigInt = uint8ArrayToBigInt(output2);
      if (bigInt > BigInt(Number.MAX_SAFE_INTEGER)) {
        throw new Error("The provided number is greater than MAX_SAFE_INTEGER (please use an alternative output type)");
      }
      return Number(bigInt);
    }
    case TypeOutput.PrefixedHexString:
      return bytesToHex2(output2);
    default:
      throw new Error("unknown outputType");
  }
}
var stripHexPrefix = (str) => {
  if (typeof str !== "string")
    throw new Error(`[stripHexPrefix] input must be type 'string', received ${typeof str}`);
  return isHexPrefixed(str) ? str.slice(2) : str;
};
var intToHex = function(i) {
  if (!Number.isSafeInteger(i) || i < 0) {
    throw new Error(`Received an invalid integer type: ${i}`);
  }
  return `0x${i.toString(16)}`;
};
var intToUint8Array = function(i) {
  const hex = intToHex(i);
  return hexToBytes(`0x${padToEven(hex.slice(2))}`);
};
var toUint8Array = function(v) {
  var _a3;
  if (v === null || v === undefined) {
    return new Uint8Array;
  }
  if (v instanceof Uint8Array) {
    return v;
  }
  if (((_a3 = v === null || v === undefined ? undefined : v.constructor) === null || _a3 === undefined ? undefined : _a3.name) === "Uint8Array") {
    return Uint8Array.from(v);
  }
  if (Array.isArray(v)) {
    return Uint8Array.from(v);
  }
  if (typeof v === "string") {
    if (!isHexString(v)) {
      throw new Error(`Cannot convert string to Uint8Array. only supports 0x-prefixed hex strings and this string was given: ${v}`);
    }
    return hexToBytes(padToEven(stripHexPrefix(v)));
  }
  if (typeof v === "number") {
    return toUint8Array(numberToHex2(v));
  }
  if (typeof v === "bigint") {
    if (v < BigInt(0)) {
      throw new Error(`Cannot convert negative bigint to Uint8Array. Given: ${v}`);
    }
    let n = v.toString(16);
    if (n.length % 2)
      n = `0${n}`;
    return toUint8Array(`0x${n}`);
  }
  if (v.toArray) {
    return Uint8Array.from(v.toArray());
  }
  throw new Error("invalid type");
};
var zeros = function(bytes5) {
  return new Uint8Array(bytes5).fill(0);
};
var setLength = function(msg, length, right) {
  const buf = zeros(length);
  if (right) {
    if (msg.length < length) {
      buf.set(msg);
      return buf;
    }
    return msg.subarray(0, length);
  }
  if (msg.length < length) {
    buf.set(msg, length - msg.length);
    return buf;
  }
  return msg.subarray(-length);
};
var setLengthLeft = function(msg, length) {
  assertIsUint8Array(msg);
  return setLength(msg, length, false);
};
var unpadUint8Array = function(a) {
  assertIsUint8Array(a);
  return stripZeros(a);
};
var bigIntToHex = (num) => `0x${num.toString(16)}`;
var ecrecover = function(msgHash, v, r, s, chainId) {
  const recovery = calculateSigRecovery(v, chainId);
  if (!isValidSigRecovery(recovery)) {
    throw new Error("Invalid signature v value");
  }
  const senderPubKey = new secp256k12.Signature(uint8ArrayToBigInt(r), uint8ArrayToBigInt(s)).addRecoveryBit(Number(recovery)).recoverPublicKey(msgHash).toRawBytes(false);
  return senderPubKey.slice(1);
};

// node_modules/web3-eth-accounts/lib/esm/tx/eip1559Transaction.js
var rlp = __toESM(require_dist(), 1);

// node_modules/web3-eth-accounts/lib/esm/common/common.js
var import_crc_32 = __toESM(require_crc32(), 1);

// node_modules/web3-eth-accounts/lib/esm/common/chains/goerli.js
var goerli_default = {
  name: "goerli",
  chainId: 5,
  networkId: 5,
  defaultHardfork: "merge",
  consensus: {
    type: "poa",
    algorithm: "clique",
    clique: {
      period: 15,
      epoch: 30000
    }
  },
  comment: "Cross-client PoA test network",
  url: "https://github.com/goerli/testnet",
  genesis: {
    timestamp: "0x5c51a607",
    gasLimit: 10485760,
    difficulty: 1,
    nonce: "0x0000000000000000",
    extraData: "0x22466c6578692069732061207468696e6722202d204166726900000000000000e0a2bd4258d2768837baa26a28fe71dc079f84c70000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000"
  },
  hardforks: [
    {
      name: "chainstart",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "homestead",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "tangerineWhistle",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "spuriousDragon",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "byzantium",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "constantinople",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "petersburg",
      block: 0,
      forkHash: "0xa3f5ab08"
    },
    {
      name: "istanbul",
      block: 1561651,
      forkHash: "0xc25efa5c"
    },
    {
      name: "berlin",
      block: 4460644,
      forkHash: "0x757a1c47"
    },
    {
      name: "london",
      block: 5062605,
      forkHash: "0xb8c6299d"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://goerli.etherscan.io/block/7382818",
      name: "merge",
      ttd: "10790000",
      block: 7382819,
      forkHash: "0xb8c6299d"
    },
    {
      name: "mergeForkIdTransition",
      block: null,
      forkHash: null
    },
    {
      name: "shanghai",
      block: null,
      forkHash: null
    }
  ],
  bootstrapNodes: [],
  dnsNetworks: [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.goerli.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/chains/mainnet.js
var mainnet_default = {
  name: "mainnet",
  chainId: 1,
  networkId: 1,
  defaultHardfork: "merge",
  consensus: {
    type: "pow",
    algorithm: "ethash",
    ethash: {}
  },
  comment: "The Ethereum main chain",
  url: "https://ethstats.net/",
  genesis: {
    gasLimit: 5000,
    difficulty: 17179869184,
    nonce: "0x0000000000000042",
    extraData: "0x11bbe8db4e347b4e8c937c1c8370e4b5ed33adb3db69cbdb7a38e1e50b1b82fa"
  },
  hardforks: [
    {
      name: "chainstart",
      block: 0,
      forkHash: "0xfc64ec04"
    },
    {
      name: "homestead",
      block: 1150000,
      forkHash: "0x97c2c34c"
    },
    {
      name: "dao",
      block: 1920000,
      forkHash: "0x91d1f948"
    },
    {
      name: "tangerineWhistle",
      block: 2463000,
      forkHash: "0x7a64da13"
    },
    {
      name: "spuriousDragon",
      block: 2675000,
      forkHash: "0x3edd5b10"
    },
    {
      name: "byzantium",
      block: 4370000,
      forkHash: "0xa00bc324"
    },
    {
      name: "constantinople",
      block: 7280000,
      forkHash: "0x668db0af"
    },
    {
      name: "petersburg",
      block: 7280000,
      forkHash: "0x668db0af"
    },
    {
      name: "istanbul",
      block: 9069000,
      forkHash: "0x879d6e30"
    },
    {
      name: "muirGlacier",
      block: 9200000,
      forkHash: "0xe029e991"
    },
    {
      name: "berlin",
      block: 12244000,
      forkHash: "0x0eb440f6"
    },
    {
      name: "london",
      block: 12965000,
      forkHash: "0xb715077d"
    },
    {
      name: "arrowGlacier",
      block: 13773000,
      forkHash: "0x20c327fc"
    },
    {
      name: "grayGlacier",
      block: 15050000,
      forkHash: "0xf0afd0e3"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://etherscan.io/block/15537393",
      name: "merge",
      ttd: "58750000000000000000000",
      block: 15537394,
      forkHash: "0xf0afd0e3"
    },
    {
      name: "mergeForkIdTransition",
      block: null,
      forkHash: null
    },
    {
      name: "shanghai",
      block: null,
      forkHash: null
    }
  ],
  bootstrapNodes: [],
  dnsNetworks: [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.mainnet.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/chains/sepolia.js
var sepolia_default = {
  name: "sepolia",
  chainId: 11155111,
  networkId: 11155111,
  defaultHardfork: "merge",
  consensus: {
    type: "pow",
    algorithm: "ethash",
    ethash: {}
  },
  comment: "PoW test network to replace Ropsten",
  url: "https://github.com/ethereum/go-ethereum/pull/23730",
  genesis: {
    timestamp: "0x6159af19",
    gasLimit: 30000000,
    difficulty: 131072,
    nonce: "0x0000000000000000",
    extraData: "0x5365706f6c69612c20417468656e732c204174746963612c2047726565636521"
  },
  hardforks: [
    {
      name: "chainstart",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "homestead",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "tangerineWhistle",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "spuriousDragon",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "byzantium",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "constantinople",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "petersburg",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "istanbul",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "muirGlacier",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "berlin",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      name: "london",
      block: 0,
      forkHash: "0xfe3366e7"
    },
    {
      "//_comment": "The forkHash will remain same as mergeForkIdTransition is post merge, terminal block: https://sepolia.etherscan.io/block/1450408",
      name: "merge",
      ttd: "17000000000000000",
      block: 1450409,
      forkHash: "0xfe3366e7"
    },
    {
      name: "mergeForkIdTransition",
      block: 1735371,
      forkHash: "0xb96cbd13"
    },
    {
      name: "shanghai",
      block: null,
      timestamp: "1677557088",
      forkHash: "0xf7f9bc08"
    }
  ],
  bootstrapNodes: [],
  dnsNetworks: [
    "enrtree://AKA3AM6LPBYEUDMVNU3BSVQJ5AD45Y7YPOHJLEF6W26QOE4VTUDPE@all.sepolia.ethdisco.net"
  ]
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/1153.js
var _1153_default = {
  name: "EIP-1153",
  number: 1153,
  comment: "Transient Storage",
  url: "https://eips.ethereum.org/EIPS/eip-1153",
  status: "Review",
  minimumHardfork: "chainstart",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {
    tstore: {
      v: 100,
      d: "Base fee of the TSTORE opcode"
    },
    tload: {
      v: 100,
      d: "Base fee of the TLOAD opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/1559.js
var _1559_default = {
  name: "EIP-1559",
  number: 1559,
  comment: "Fee market change for ETH 1.0 chain",
  url: "https://eips.ethereum.org/EIPS/eip-1559",
  status: "Final",
  minimumHardfork: "berlin",
  requiredEIPs: [2930],
  gasConfig: {
    baseFeeMaxChangeDenominator: {
      v: 8,
      d: "Maximum base fee change denominator"
    },
    elasticityMultiplier: {
      v: 2,
      d: "Maximum block gas target elasticity"
    },
    initialBaseFee: {
      v: 1e9,
      d: "Initial base fee on first EIP1559 block"
    }
  },
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2315.js
var _2315_default = {
  name: "EIP-2315",
  number: 2315,
  comment: "Simple subroutines for the EVM",
  url: "https://eips.ethereum.org/EIPS/eip-2315",
  status: "Draft",
  minimumHardfork: "istanbul",
  gasConfig: {},
  gasPrices: {
    beginsub: {
      v: 2,
      d: "Base fee of the BEGINSUB opcode"
    },
    returnsub: {
      v: 5,
      d: "Base fee of the RETURNSUB opcode"
    },
    jumpsub: {
      v: 10,
      d: "Base fee of the JUMPSUB opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2537.js
var _2537_default = {
  name: "EIP-2537",
  number: 2537,
  comment: "BLS12-381 precompiles",
  url: "https://eips.ethereum.org/EIPS/eip-2537",
  status: "Draft",
  minimumHardfork: "chainstart",
  gasConfig: {},
  gasPrices: {
    Bls12381G1AddGas: {
      v: 600,
      d: "Gas cost of a single BLS12-381 G1 addition precompile-call"
    },
    Bls12381G1MulGas: {
      v: 12000,
      d: "Gas cost of a single BLS12-381 G1 multiplication precompile-call"
    },
    Bls12381G2AddGas: {
      v: 4500,
      d: "Gas cost of a single BLS12-381 G2 addition precompile-call"
    },
    Bls12381G2MulGas: {
      v: 55000,
      d: "Gas cost of a single BLS12-381 G2 multiplication precompile-call"
    },
    Bls12381PairingBaseGas: {
      v: 115000,
      d: "Base gas cost of BLS12-381 pairing check"
    },
    Bls12381PairingPerPairGas: {
      v: 23000,
      d: "Per-pair gas cost of BLS12-381 pairing check"
    },
    Bls12381MapG1Gas: {
      v: 5500,
      d: "Gas cost of BLS12-381 map field element to G1"
    },
    Bls12381MapG2Gas: {
      v: 110000,
      d: "Gas cost of BLS12-381 map field element to G2"
    },
    Bls12381MultiExpGasDiscount: {
      v: [
        [1, 1200],
        [2, 888],
        [3, 764],
        [4, 641],
        [5, 594],
        [6, 547],
        [7, 500],
        [8, 453],
        [9, 438],
        [10, 423],
        [11, 408],
        [12, 394],
        [13, 379],
        [14, 364],
        [15, 349],
        [16, 334],
        [17, 330],
        [18, 326],
        [19, 322],
        [20, 318],
        [21, 314],
        [22, 310],
        [23, 306],
        [24, 302],
        [25, 298],
        [26, 294],
        [27, 289],
        [28, 285],
        [29, 281],
        [30, 277],
        [31, 273],
        [32, 269],
        [33, 268],
        [34, 266],
        [35, 265],
        [36, 263],
        [37, 262],
        [38, 260],
        [39, 259],
        [40, 257],
        [41, 256],
        [42, 254],
        [43, 253],
        [44, 251],
        [45, 250],
        [46, 248],
        [47, 247],
        [48, 245],
        [49, 244],
        [50, 242],
        [51, 241],
        [52, 239],
        [53, 238],
        [54, 236],
        [55, 235],
        [56, 233],
        [57, 232],
        [58, 231],
        [59, 229],
        [60, 228],
        [61, 226],
        [62, 225],
        [63, 223],
        [64, 222],
        [65, 221],
        [66, 220],
        [67, 219],
        [68, 219],
        [69, 218],
        [70, 217],
        [71, 216],
        [72, 216],
        [73, 215],
        [74, 214],
        [75, 213],
        [76, 213],
        [77, 212],
        [78, 211],
        [79, 211],
        [80, 210],
        [81, 209],
        [82, 208],
        [83, 208],
        [84, 207],
        [85, 206],
        [86, 205],
        [87, 205],
        [88, 204],
        [89, 203],
        [90, 202],
        [91, 202],
        [92, 201],
        [93, 200],
        [94, 199],
        [95, 199],
        [96, 198],
        [97, 197],
        [98, 196],
        [99, 196],
        [100, 195],
        [101, 194],
        [102, 193],
        [103, 193],
        [104, 192],
        [105, 191],
        [106, 191],
        [107, 190],
        [108, 189],
        [109, 188],
        [110, 188],
        [111, 187],
        [112, 186],
        [113, 185],
        [114, 185],
        [115, 184],
        [116, 183],
        [117, 182],
        [118, 182],
        [119, 181],
        [120, 180],
        [121, 179],
        [122, 179],
        [123, 178],
        [124, 177],
        [125, 176],
        [126, 176],
        [127, 175],
        [128, 174]
      ],
      d: "Discount gas costs of calls to the MultiExp precompiles with `k` (point, scalar) pair"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2565.js
var _2565_default = {
  name: "EIP-2565",
  number: 2565,
  comment: "ModExp gas cost",
  url: "https://eips.ethereum.org/EIPS/eip-2565",
  status: "Final",
  minimumHardfork: "byzantium",
  gasConfig: {},
  gasPrices: {
    modexpGquaddivisor: {
      v: 3,
      d: "Gquaddivisor from modexp precompile for gas calculation"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2718.js
var _2718_default = {
  name: "EIP-2718",
  comment: "Typed Transaction Envelope",
  url: "https://eips.ethereum.org/EIPS/eip-2718",
  status: "Final",
  minimumHardfork: "chainstart",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2929.js
var _2929_default = {
  name: "EIP-2929",
  comment: "Gas cost increases for state access opcodes",
  url: "https://eips.ethereum.org/EIPS/eip-2929",
  status: "Final",
  minimumHardfork: "chainstart",
  gasConfig: {},
  gasPrices: {
    coldsload: {
      v: 2100,
      d: "Gas cost of the first read of storage from a given location (per transaction)"
    },
    coldaccountaccess: {
      v: 2600,
      d: "Gas cost of the first read of a given address (per transaction)"
    },
    warmstorageread: {
      v: 100,
      d: "Gas cost of reading storage locations which have already loaded 'cold'"
    },
    sstoreCleanGasEIP2200: {
      v: 2900,
      d: "Once per SSTORE operation from clean non-zero to something else"
    },
    sstoreNoopGasEIP2200: {
      v: 100,
      d: "Once per SSTORE operation if the value doesn't change"
    },
    sstoreDirtyGasEIP2200: {
      v: 100,
      d: "Once per SSTORE operation if a dirty value is changed"
    },
    sstoreInitRefundEIP2200: {
      v: 19900,
      d: "Once per SSTORE operation for resetting to the original zero value"
    },
    sstoreCleanRefundEIP2200: {
      v: 4900,
      d: "Once per SSTORE operation for resetting to the original non-zero value"
    },
    call: {
      v: 0,
      d: "Base fee of the CALL opcode"
    },
    callcode: {
      v: 0,
      d: "Base fee of the CALLCODE opcode"
    },
    delegatecall: {
      v: 0,
      d: "Base fee of the DELEGATECALL opcode"
    },
    staticcall: {
      v: 0,
      d: "Base fee of the STATICCALL opcode"
    },
    balance: {
      v: 0,
      d: "Base fee of the BALANCE opcode"
    },
    extcodesize: {
      v: 0,
      d: "Base fee of the EXTCODESIZE opcode"
    },
    extcodecopy: {
      v: 0,
      d: "Base fee of the EXTCODECOPY opcode"
    },
    extcodehash: {
      v: 0,
      d: "Base fee of the EXTCODEHASH opcode"
    },
    sload: {
      v: 0,
      d: "Base fee of the SLOAD opcode"
    },
    sstore: {
      v: 0,
      d: "Base fee of the SSTORE opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/2930.js
var _2930_default = {
  name: "EIP-2930",
  comment: "Optional access lists",
  url: "https://eips.ethereum.org/EIPS/eip-2930",
  status: "Final",
  minimumHardfork: "istanbul",
  requiredEIPs: [2718, 2929],
  gasConfig: {},
  gasPrices: {
    accessListStorageKeyCost: {
      v: 1900,
      d: "Gas cost per storage key in an Access List transaction"
    },
    accessListAddressCost: {
      v: 2400,
      d: "Gas cost per storage key in an Access List transaction"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3198.js
var _3198_default = {
  name: "EIP-3198",
  number: 3198,
  comment: "BASEFEE opcode",
  url: "https://eips.ethereum.org/EIPS/eip-3198",
  status: "Final",
  minimumHardfork: "london",
  gasConfig: {},
  gasPrices: {
    basefee: {
      v: 2,
      d: "Gas cost of the BASEFEE opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3529.js
var _3529_default = {
  name: "EIP-3529",
  comment: "Reduction in refunds",
  url: "https://eips.ethereum.org/EIPS/eip-3529",
  status: "Final",
  minimumHardfork: "berlin",
  requiredEIPs: [2929],
  gasConfig: {
    maxRefundQuotient: {
      v: 5,
      d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
    }
  },
  gasPrices: {
    selfdestructRefund: {
      v: 0,
      d: "Refunded following a selfdestruct operation"
    },
    sstoreClearRefundEIP2200: {
      v: 4800,
      d: "Once per SSTORE operation for clearing an originally existing storage slot"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3540.js
var _3540_default = {
  name: "EIP-3540",
  number: 3540,
  comment: "EVM Object Format (EOF) v1",
  url: "https://eips.ethereum.org/EIPS/eip-3540",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [3541],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3541.js
var _3541_default = {
  name: "EIP-3541",
  comment: "Reject new contracts starting with the 0xEF byte",
  url: "https://eips.ethereum.org/EIPS/eip-3541",
  status: "Final",
  minimumHardfork: "berlin",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3554.js
var _3554_default = {
  name: "EIP-3554",
  comment: "Reduction in refunds",
  url: "Difficulty Bomb Delay to December 1st 2021",
  status: "Final",
  minimumHardfork: "muirGlacier",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 9500000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3607.js
var _3607_default = {
  name: "EIP-3607",
  number: 3607,
  comment: "Reject transactions from senders with deployed code",
  url: "https://eips.ethereum.org/EIPS/eip-3607",
  status: "Final",
  minimumHardfork: "chainstart",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3651.js
var _3651_default = {
  name: "EIP-3651",
  number: 3198,
  comment: "Warm COINBASE",
  url: "https://eips.ethereum.org/EIPS/eip-3651",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [2929],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3670.js
var _3670_default = {
  name: "EIP-3670",
  number: 3670,
  comment: "EOF - Code Validation",
  url: "https://eips.ethereum.org/EIPS/eip-3670",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [3540],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3675.js
var _3675_default = {
  name: "EIP-3675",
  number: 3675,
  comment: "Upgrade consensus to Proof-of-Stake",
  url: "https://eips.ethereum.org/EIPS/eip-3675",
  status: "Final",
  minimumHardfork: "london",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3855.js
var _3855_default = {
  name: "EIP-3855",
  number: 3855,
  comment: "PUSH0 instruction",
  url: "https://eips.ethereum.org/EIPS/eip-3855",
  status: "Review",
  minimumHardfork: "chainstart",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {
    push0: {
      v: 2,
      d: "Base fee of the PUSH0 opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/3860.js
var _3860_default = {
  name: "EIP-3860",
  number: 3860,
  comment: "Limit and meter initcode",
  url: "https://eips.ethereum.org/EIPS/eip-3860",
  status: "Review",
  minimumHardfork: "spuriousDragon",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {
    initCodeWordCost: {
      v: 2,
      d: "Gas to pay for each word (32 bytes) of initcode when creating a contract"
    }
  },
  vm: {
    maxInitCodeSize: {
      v: 49152,
      d: "Maximum length of initialization code when creating a contract"
    }
  },
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/4345.js
var _4345_default = {
  name: "EIP-4345",
  number: 4345,
  comment: "Difficulty Bomb Delay to June 2022",
  url: "https://eips.ethereum.org/EIPS/eip-4345",
  status: "Final",
  minimumHardfork: "london",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 10700000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/4399.js
var _4399_default = {
  name: "EIP-4399",
  number: 4399,
  comment: "Supplant DIFFICULTY opcode with PREVRANDAO",
  url: "https://eips.ethereum.org/EIPS/eip-4399",
  status: "Review",
  minimumHardfork: "london",
  requiredEIPs: [],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/5133.js
var _5133_default = {
  name: "EIP-5133",
  number: 5133,
  comment: "Delaying Difficulty Bomb to mid-September 2022",
  url: "https://eips.ethereum.org/EIPS/eip-5133",
  status: "Draft",
  minimumHardfork: "grayGlacier",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 11400000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/eips/index.js
var EIPs = {
  1153: _1153_default,
  1559: _1559_default,
  2315: _2315_default,
  2537: _2537_default,
  2565: _2565_default,
  2718: _2718_default,
  2929: _2929_default,
  2930: _2930_default,
  3198: _3198_default,
  3529: _3529_default,
  3540: _3540_default,
  3541: _3541_default,
  3554: _3554_default,
  3607: _3607_default,
  3651: _3651_default,
  3670: _3670_default,
  3675: _3675_default,
  3855: _3855_default,
  3860: _3860_default,
  4345: _4345_default,
  4399: _4399_default,
  5133: _5133_default
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/chainstart.js
var chainstart_default = {
  name: "chainstart",
  comment: "Start of the Ethereum main chain",
  url: "",
  status: "",
  gasConfig: {
    minGasLimit: {
      v: 5000,
      d: "Minimum the gas limit may ever be"
    },
    gasLimitBoundDivisor: {
      v: 1024,
      d: "The bound divisor of the gas limit, used in update calculations"
    },
    maxRefundQuotient: {
      v: 2,
      d: "Maximum refund quotient; max tx refund is min(tx.gasUsed/maxRefundQuotient, tx.gasRefund)"
    }
  },
  gasPrices: {
    base: {
      v: 2,
      d: "Gas base cost, used e.g. for ChainID opcode (Istanbul)"
    },
    tierStep: {
      v: [0, 2, 3, 5, 8, 10, 20],
      d: "Once per operation, for a selection of them"
    },
    exp: {
      v: 10,
      d: "Base fee of the EXP opcode"
    },
    expByte: {
      v: 10,
      d: "Times ceil(log256(exponent)) for the EXP instruction"
    },
    sha3: {
      v: 30,
      d: "Base fee of the SHA3 opcode"
    },
    sha3Word: {
      v: 6,
      d: "Once per word of the SHA3 operation's data"
    },
    sload: {
      v: 50,
      d: "Base fee of the SLOAD opcode"
    },
    sstoreSet: {
      v: 20000,
      d: "Once per SSTORE operation if the zeroness changes from zero"
    },
    sstoreReset: {
      v: 5000,
      d: "Once per SSTORE operation if the zeroness does not change from zero"
    },
    sstoreRefund: {
      v: 15000,
      d: "Once per SSTORE operation if the zeroness changes to zero"
    },
    jumpdest: {
      v: 1,
      d: "Base fee of the JUMPDEST opcode"
    },
    log: {
      v: 375,
      d: "Base fee of the LOG opcode"
    },
    logData: {
      v: 8,
      d: "Per byte in a LOG* operation's data"
    },
    logTopic: {
      v: 375,
      d: "Multiplied by the * of the LOG*, per LOG transaction. e.g. LOG0 incurs 0 * c_txLogTopicGas, LOG4 incurs 4 * c_txLogTopicGas"
    },
    create: {
      v: 32000,
      d: "Base fee of the CREATE opcode"
    },
    call: {
      v: 40,
      d: "Base fee of the CALL opcode"
    },
    callStipend: {
      v: 2300,
      d: "Free gas given at beginning of call"
    },
    callValueTransfer: {
      v: 9000,
      d: "Paid for CALL when the value transfor is non-zero"
    },
    callNewAccount: {
      v: 25000,
      d: "Paid for CALL when the destination address didn't exist prior"
    },
    selfdestructRefund: {
      v: 24000,
      d: "Refunded following a selfdestruct operation"
    },
    memory: {
      v: 3,
      d: "Times the address of the (highest referenced byte in memory + 1). NOTE: referencing happens on read, write and in instructions such as RETURN and CALL"
    },
    quadCoeffDiv: {
      v: 512,
      d: "Divisor for the quadratic particle of the memory cost equation"
    },
    createData: {
      v: 200,
      d: ""
    },
    tx: {
      v: 21000,
      d: "Per transaction. NOTE: Not payable on data of calls between transactions"
    },
    txCreation: {
      v: 32000,
      d: "The cost of creating a contract via tx"
    },
    txDataZero: {
      v: 4,
      d: "Per byte of data attached to a transaction that equals zero. NOTE: Not payable on data of calls between transactions"
    },
    txDataNonZero: {
      v: 68,
      d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
    },
    copy: {
      v: 3,
      d: "Multiplied by the number of 32-byte words that are copied (round up) for any *COPY operation and added"
    },
    ecRecover: {
      v: 3000,
      d: ""
    },
    sha256: {
      v: 60,
      d: ""
    },
    sha256Word: {
      v: 12,
      d: ""
    },
    ripemd160: {
      v: 600,
      d: ""
    },
    ripemd160Word: {
      v: 120,
      d: ""
    },
    identity: {
      v: 15,
      d: ""
    },
    identityWord: {
      v: 3,
      d: ""
    },
    stop: {
      v: 0,
      d: "Base fee of the STOP opcode"
    },
    add: {
      v: 3,
      d: "Base fee of the ADD opcode"
    },
    mul: {
      v: 5,
      d: "Base fee of the MUL opcode"
    },
    sub: {
      v: 3,
      d: "Base fee of the SUB opcode"
    },
    div: {
      v: 5,
      d: "Base fee of the DIV opcode"
    },
    sdiv: {
      v: 5,
      d: "Base fee of the SDIV opcode"
    },
    mod: {
      v: 5,
      d: "Base fee of the MOD opcode"
    },
    smod: {
      v: 5,
      d: "Base fee of the SMOD opcode"
    },
    addmod: {
      v: 8,
      d: "Base fee of the ADDMOD opcode"
    },
    mulmod: {
      v: 8,
      d: "Base fee of the MULMOD opcode"
    },
    signextend: {
      v: 5,
      d: "Base fee of the SIGNEXTEND opcode"
    },
    lt: {
      v: 3,
      d: "Base fee of the LT opcode"
    },
    gt: {
      v: 3,
      d: "Base fee of the GT opcode"
    },
    slt: {
      v: 3,
      d: "Base fee of the SLT opcode"
    },
    sgt: {
      v: 3,
      d: "Base fee of the SGT opcode"
    },
    eq: {
      v: 3,
      d: "Base fee of the EQ opcode"
    },
    iszero: {
      v: 3,
      d: "Base fee of the ISZERO opcode"
    },
    and: {
      v: 3,
      d: "Base fee of the AND opcode"
    },
    or: {
      v: 3,
      d: "Base fee of the OR opcode"
    },
    xor: {
      v: 3,
      d: "Base fee of the XOR opcode"
    },
    not: {
      v: 3,
      d: "Base fee of the NOT opcode"
    },
    byte: {
      v: 3,
      d: "Base fee of the BYTE opcode"
    },
    address: {
      v: 2,
      d: "Base fee of the ADDRESS opcode"
    },
    balance: {
      v: 20,
      d: "Base fee of the BALANCE opcode"
    },
    origin: {
      v: 2,
      d: "Base fee of the ORIGIN opcode"
    },
    caller: {
      v: 2,
      d: "Base fee of the CALLER opcode"
    },
    callvalue: {
      v: 2,
      d: "Base fee of the CALLVALUE opcode"
    },
    calldataload: {
      v: 3,
      d: "Base fee of the CALLDATALOAD opcode"
    },
    calldatasize: {
      v: 2,
      d: "Base fee of the CALLDATASIZE opcode"
    },
    calldatacopy: {
      v: 3,
      d: "Base fee of the CALLDATACOPY opcode"
    },
    codesize: {
      v: 2,
      d: "Base fee of the CODESIZE opcode"
    },
    codecopy: {
      v: 3,
      d: "Base fee of the CODECOPY opcode"
    },
    gasprice: {
      v: 2,
      d: "Base fee of the GASPRICE opcode"
    },
    extcodesize: {
      v: 20,
      d: "Base fee of the EXTCODESIZE opcode"
    },
    extcodecopy: {
      v: 20,
      d: "Base fee of the EXTCODECOPY opcode"
    },
    blockhash: {
      v: 20,
      d: "Base fee of the BLOCKHASH opcode"
    },
    coinbase: {
      v: 2,
      d: "Base fee of the COINBASE opcode"
    },
    timestamp: {
      v: 2,
      d: "Base fee of the TIMESTAMP opcode"
    },
    number: {
      v: 2,
      d: "Base fee of the NUMBER opcode"
    },
    difficulty: {
      v: 2,
      d: "Base fee of the DIFFICULTY opcode"
    },
    gaslimit: {
      v: 2,
      d: "Base fee of the GASLIMIT opcode"
    },
    pop: {
      v: 2,
      d: "Base fee of the POP opcode"
    },
    mload: {
      v: 3,
      d: "Base fee of the MLOAD opcode"
    },
    mstore: {
      v: 3,
      d: "Base fee of the MSTORE opcode"
    },
    mstore8: {
      v: 3,
      d: "Base fee of the MSTORE8 opcode"
    },
    sstore: {
      v: 0,
      d: "Base fee of the SSTORE opcode"
    },
    jump: {
      v: 8,
      d: "Base fee of the JUMP opcode"
    },
    jumpi: {
      v: 10,
      d: "Base fee of the JUMPI opcode"
    },
    pc: {
      v: 2,
      d: "Base fee of the PC opcode"
    },
    msize: {
      v: 2,
      d: "Base fee of the MSIZE opcode"
    },
    gas: {
      v: 2,
      d: "Base fee of the GAS opcode"
    },
    push: {
      v: 3,
      d: "Base fee of the PUSH opcode"
    },
    dup: {
      v: 3,
      d: "Base fee of the DUP opcode"
    },
    swap: {
      v: 3,
      d: "Base fee of the SWAP opcode"
    },
    callcode: {
      v: 40,
      d: "Base fee of the CALLCODE opcode"
    },
    return: {
      v: 0,
      d: "Base fee of the RETURN opcode"
    },
    invalid: {
      v: 0,
      d: "Base fee of the INVALID opcode"
    },
    selfdestruct: {
      v: 0,
      d: "Base fee of the SELFDESTRUCT opcode"
    }
  },
  vm: {
    stackLimit: {
      v: 1024,
      d: "Maximum size of VM stack allowed"
    },
    callCreateDepth: {
      v: 1024,
      d: "Maximum depth of call/create stack"
    },
    maxExtraDataSize: {
      v: 32,
      d: "Maximum size extra data may be after Genesis"
    }
  },
  pow: {
    minimumDifficulty: {
      v: 131072,
      d: "The minimum that the difficulty may ever be"
    },
    difficultyBoundDivisor: {
      v: 2048,
      d: "The bound divisor of the difficulty, used in the update calculations"
    },
    durationLimit: {
      v: 13,
      d: "The decision boundary on the blocktime duration used to determine whether difficulty should go up or not"
    },
    epochDuration: {
      v: 30000,
      d: "Duration between proof-of-work epochs"
    },
    timebombPeriod: {
      v: 1e5,
      d: "Exponential difficulty timebomb period"
    },
    minerReward: {
      v: "5000000000000000000",
      d: "the amount a miner get rewarded for mining a block"
    },
    difficultyBombDelay: {
      v: 0,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/dao.js
var dao_default = {
  name: "dao",
  comment: "DAO rescue hardfork",
  url: "https://eips.ethereum.org/EIPS/eip-779",
  status: "Final",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/homestead.js
var homestead_default = {
  name: "homestead",
  comment: "Homestead hardfork with protocol and network changes",
  url: "https://eips.ethereum.org/EIPS/eip-606",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    delegatecall: {
      v: 40,
      d: "Base fee of the DELEGATECALL opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/tangerineWhistle.js
var tangerineWhistle_default = {
  name: "tangerineWhistle",
  comment: "Hardfork with gas cost changes for IO-heavy operations",
  url: "https://eips.ethereum.org/EIPS/eip-608",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    sload: {
      v: 200,
      d: "Once per SLOAD operation"
    },
    call: {
      v: 700,
      d: "Once per CALL operation & message call transaction"
    },
    extcodesize: {
      v: 700,
      d: "Base fee of the EXTCODESIZE opcode"
    },
    extcodecopy: {
      v: 700,
      d: "Base fee of the EXTCODECOPY opcode"
    },
    balance: {
      v: 400,
      d: "Base fee of the BALANCE opcode"
    },
    delegatecall: {
      v: 700,
      d: "Base fee of the DELEGATECALL opcode"
    },
    callcode: {
      v: 700,
      d: "Base fee of the CALLCODE opcode"
    },
    selfdestruct: {
      v: 5000,
      d: "Base fee of the SELFDESTRUCT opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/spuriousDragon.js
var spuriousDragon_default = {
  name: "spuriousDragon",
  comment: "HF with EIPs for simple replay attack protection, EXP cost increase, state trie clearing, contract code size limit",
  url: "https://eips.ethereum.org/EIPS/eip-607",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    expByte: {
      v: 50,
      d: "Times ceil(log256(exponent)) for the EXP instruction"
    }
  },
  vm: {
    maxCodeSize: {
      v: 24576,
      d: "Maximum length of contract code"
    }
  },
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/byzantium.js
var byzantium_default = {
  name: "byzantium",
  comment: "Hardfork with new precompiles, instructions and other protocol changes",
  url: "https://eips.ethereum.org/EIPS/eip-609",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    modexpGquaddivisor: {
      v: 20,
      d: "Gquaddivisor from modexp precompile for gas calculation"
    },
    ecAdd: {
      v: 500,
      d: "Gas costs for curve addition precompile"
    },
    ecMul: {
      v: 40000,
      d: "Gas costs for curve multiplication precompile"
    },
    ecPairing: {
      v: 1e5,
      d: "Base gas costs for curve pairing precompile"
    },
    ecPairingWord: {
      v: 80000,
      d: "Gas costs regarding curve pairing precompile input length"
    },
    revert: {
      v: 0,
      d: "Base fee of the REVERT opcode"
    },
    staticcall: {
      v: 700,
      d: "Base fee of the STATICCALL opcode"
    },
    returndatasize: {
      v: 2,
      d: "Base fee of the RETURNDATASIZE opcode"
    },
    returndatacopy: {
      v: 3,
      d: "Base fee of the RETURNDATACOPY opcode"
    }
  },
  vm: {},
  pow: {
    minerReward: {
      v: "3000000000000000000",
      d: "the amount a miner get rewarded for mining a block"
    },
    difficultyBombDelay: {
      v: 3000000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/constantinople.js
var constantinople_default = {
  name: "constantinople",
  comment: "Postponed hardfork including EIP-1283 (SSTORE gas metering changes)",
  url: "https://eips.ethereum.org/EIPS/eip-1013",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    netSstoreNoopGas: {
      v: 200,
      d: "Once per SSTORE operation if the value doesn't change"
    },
    netSstoreInitGas: {
      v: 20000,
      d: "Once per SSTORE operation from clean zero"
    },
    netSstoreCleanGas: {
      v: 5000,
      d: "Once per SSTORE operation from clean non-zero"
    },
    netSstoreDirtyGas: {
      v: 200,
      d: "Once per SSTORE operation from dirty"
    },
    netSstoreClearRefund: {
      v: 15000,
      d: "Once per SSTORE operation for clearing an originally existing storage slot"
    },
    netSstoreResetRefund: {
      v: 4800,
      d: "Once per SSTORE operation for resetting to the original non-zero value"
    },
    netSstoreResetClearRefund: {
      v: 19800,
      d: "Once per SSTORE operation for resetting to the original zero value"
    },
    shl: {
      v: 3,
      d: "Base fee of the SHL opcode"
    },
    shr: {
      v: 3,
      d: "Base fee of the SHR opcode"
    },
    sar: {
      v: 3,
      d: "Base fee of the SAR opcode"
    },
    extcodehash: {
      v: 400,
      d: "Base fee of the EXTCODEHASH opcode"
    },
    create2: {
      v: 32000,
      d: "Base fee of the CREATE2 opcode"
    }
  },
  vm: {},
  pow: {
    minerReward: {
      v: "2000000000000000000",
      d: "The amount a miner gets rewarded for mining a block"
    },
    difficultyBombDelay: {
      v: 5000000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/petersburg.js
var petersburg_default = {
  name: "petersburg",
  comment: "Aka constantinopleFix, removes EIP-1283, activate together with or after constantinople",
  url: "https://eips.ethereum.org/EIPS/eip-1716",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    netSstoreNoopGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreInitGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreCleanGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreDirtyGas: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreClearRefund: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreResetRefund: {
      v: null,
      d: "Removed along EIP-1283"
    },
    netSstoreResetClearRefund: {
      v: null,
      d: "Removed along EIP-1283"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/istanbul.js
var istanbul_default = {
  name: "istanbul",
  comment: "HF targeted for December 2019 following the Constantinople/Petersburg HF",
  url: "https://eips.ethereum.org/EIPS/eip-1679",
  status: "Final",
  gasConfig: {},
  gasPrices: {
    blake2Round: {
      v: 1,
      d: "Gas cost per round for the Blake2 F precompile"
    },
    ecAdd: {
      v: 150,
      d: "Gas costs for curve addition precompile"
    },
    ecMul: {
      v: 6000,
      d: "Gas costs for curve multiplication precompile"
    },
    ecPairing: {
      v: 45000,
      d: "Base gas costs for curve pairing precompile"
    },
    ecPairingWord: {
      v: 34000,
      d: "Gas costs regarding curve pairing precompile input length"
    },
    txDataNonZero: {
      v: 16,
      d: "Per byte of data attached to a transaction that is not equal to zero. NOTE: Not payable on data of calls between transactions"
    },
    sstoreSentryGasEIP2200: {
      v: 2300,
      d: "Minimum gas required to be present for an SSTORE call, not consumed"
    },
    sstoreNoopGasEIP2200: {
      v: 800,
      d: "Once per SSTORE operation if the value doesn't change"
    },
    sstoreDirtyGasEIP2200: {
      v: 800,
      d: "Once per SSTORE operation if a dirty value is changed"
    },
    sstoreInitGasEIP2200: {
      v: 20000,
      d: "Once per SSTORE operation from clean zero to non-zero"
    },
    sstoreInitRefundEIP2200: {
      v: 19200,
      d: "Once per SSTORE operation for resetting to the original zero value"
    },
    sstoreCleanGasEIP2200: {
      v: 5000,
      d: "Once per SSTORE operation from clean non-zero to something else"
    },
    sstoreCleanRefundEIP2200: {
      v: 4200,
      d: "Once per SSTORE operation for resetting to the original non-zero value"
    },
    sstoreClearRefundEIP2200: {
      v: 15000,
      d: "Once per SSTORE operation for clearing an originally existing storage slot"
    },
    balance: {
      v: 700,
      d: "Base fee of the BALANCE opcode"
    },
    extcodehash: {
      v: 700,
      d: "Base fee of the EXTCODEHASH opcode"
    },
    chainid: {
      v: 2,
      d: "Base fee of the CHAINID opcode"
    },
    selfbalance: {
      v: 5,
      d: "Base fee of the SELFBALANCE opcode"
    },
    sload: {
      v: 800,
      d: "Base fee of the SLOAD opcode"
    }
  },
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/muirGlacier.js
var muirGlacier_default = {
  name: "muirGlacier",
  comment: "HF to delay the difficulty bomb",
  url: "https://eips.ethereum.org/EIPS/eip-2384",
  status: "Final",
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {
    difficultyBombDelay: {
      v: 9000000,
      d: "the amount of blocks to delay the difficulty bomb with"
    }
  }
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/berlin.js
var berlin_default = {
  name: "berlin",
  comment: "HF targeted for July 2020 following the Muir Glacier HF",
  url: "https://eips.ethereum.org/EIPS/eip-2070",
  status: "Final",
  eips: [2565, 2929, 2718, 2930]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/london.js
var london_default = {
  name: "london",
  comment: "HF targeted for July 2021 following the Berlin fork",
  url: "https://github.com/ethereum/eth1.0-specs/blob/master/network-upgrades/mainnet-upgrades/london.md",
  status: "Final",
  eips: [1559, 3198, 3529, 3541]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/shanghai.js
var shanghai_default = {
  name: "shanghai",
  comment: "Next feature hardfork after the merge hardfork having withdrawals, warm coinbase, push0, limit/meter initcode",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/shanghai.md",
  status: "Final",
  eips: [3651, 3855, 3860, 4895]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/arrowGlacier.js
var arrowGlacier_default = {
  name: "arrowGlacier",
  comment: "HF to delay the difficulty bomb",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/arrow-glacier.md",
  status: "Final",
  eips: [4345],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/grayGlacier.js
var grayGlacier_default = {
  name: "grayGlacier",
  comment: "Delaying the difficulty bomb to Mid September 2022",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/gray-glacier.md",
  status: "Draft",
  eips: [5133],
  gasConfig: {},
  gasPrices: {},
  vm: {},
  pow: {}
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/mergeForkIdTransition.js
var mergeForkIdTransition_default = {
  name: "mergeForkIdTransition",
  comment: "Pre-merge hardfork to fork off non-upgraded clients",
  url: "https://eips.ethereum.org/EIPS/eip-3675",
  status: "Draft",
  eips: []
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/merge.js
var merge_default = {
  name: "merge",
  comment: "Hardfork to upgrade the consensus mechanism to Proof-of-Stake",
  url: "https://github.com/ethereum/execution-specs/blob/master/network-upgrades/mainnet-upgrades/merge.md",
  status: "Final",
  consensus: {
    type: "pos",
    algorithm: "casper",
    casper: {}
  },
  eips: [3675, 4399]
};

// node_modules/web3-eth-accounts/lib/esm/common/hardforks/index.js
var hardforks = {
  chainstart: chainstart_default,
  homestead: homestead_default,
  dao: dao_default,
  tangerineWhistle: tangerineWhistle_default,
  spuriousDragon: spuriousDragon_default,
  byzantium: byzantium_default,
  constantinople: constantinople_default,
  petersburg: petersburg_default,
  istanbul: istanbul_default,
  muirGlacier: muirGlacier_default,
  berlin: berlin_default,
  london: london_default,
  shanghai: shanghai_default,
  arrowGlacier: arrowGlacier_default,
  grayGlacier: grayGlacier_default,
  mergeForkIdTransition: mergeForkIdTransition_default,
  merge: merge_default
};

// node_modules/web3-eth-accounts/lib/esm/common/common.js
var { buf: crc32Uint8Array } = import_crc_32.default;

class Common extends EventEmitter2 {
  constructor(opts) {
    var _a3, _b;
    super();
    this._eips = [];
    this._customChains = (_a3 = opts.customChains) !== null && _a3 !== undefined ? _a3 : [];
    this._chainParams = this.setChain(opts.chain);
    this.DEFAULT_HARDFORK = (_b = this._chainParams.defaultHardfork) !== null && _b !== undefined ? _b : Hardfork.Merge;
    this.HARDFORK_CHANGES = this.hardforks().map((hf) => [
      hf.name,
      hardforks[hf.name]
    ]);
    this._hardfork = this.DEFAULT_HARDFORK;
    if (opts.hardfork !== undefined) {
      this.setHardfork(opts.hardfork);
    }
    if (opts.eips) {
      this.setEIPs(opts.eips);
    }
  }
  static custom(chainParamsOrName, opts = {}) {
    var _a3;
    const baseChain = (_a3 = opts.baseChain) !== null && _a3 !== undefined ? _a3 : "mainnet";
    const standardChainParams = Object.assign({}, Common._getChainParams(baseChain));
    standardChainParams.name = "custom-chain";
    if (typeof chainParamsOrName !== "string") {
      return new Common(Object.assign({ chain: Object.assign(Object.assign({}, standardChainParams), chainParamsOrName) }, opts));
    }
    if (chainParamsOrName === CustomChain.PolygonMainnet) {
      return Common.custom({
        name: CustomChain.PolygonMainnet,
        chainId: 137,
        networkId: 137
      }, opts);
    }
    if (chainParamsOrName === CustomChain.PolygonMumbai) {
      return Common.custom({
        name: CustomChain.PolygonMumbai,
        chainId: 80001,
        networkId: 80001
      }, opts);
    }
    if (chainParamsOrName === CustomChain.ArbitrumRinkebyTestnet) {
      return Common.custom({
        name: CustomChain.ArbitrumRinkebyTestnet,
        chainId: 421611,
        networkId: 421611
      }, opts);
    }
    if (chainParamsOrName === CustomChain.ArbitrumOne) {
      return Common.custom({
        name: CustomChain.ArbitrumOne,
        chainId: 42161,
        networkId: 42161
      }, opts);
    }
    if (chainParamsOrName === CustomChain.xDaiChain) {
      return Common.custom({
        name: CustomChain.xDaiChain,
        chainId: 100,
        networkId: 100
      }, opts);
    }
    if (chainParamsOrName === CustomChain.OptimisticKovan) {
      return Common.custom({
        name: CustomChain.OptimisticKovan,
        chainId: 69,
        networkId: 69
      }, Object.assign({ hardfork: Hardfork.Berlin }, opts));
    }
    if (chainParamsOrName === CustomChain.OptimisticEthereum) {
      return Common.custom({
        name: CustomChain.OptimisticEthereum,
        chainId: 10,
        networkId: 10
      }, Object.assign({ hardfork: Hardfork.Berlin }, opts));
    }
    throw new Error(`Custom chain ${chainParamsOrName} not supported`);
  }
  static fromGethGenesis(genesisJson, { chain, eips: eips2, genesisHash, hardfork, mergeForkIdPostMerge }) {
    var _a3;
    const genesisParams = parseGethGenesis(genesisJson, chain, mergeForkIdPostMerge);
    const common = new Common({
      chain: (_a3 = genesisParams.name) !== null && _a3 !== undefined ? _a3 : "custom",
      customChains: [genesisParams],
      eips: eips2,
      hardfork: hardfork !== null && hardfork !== undefined ? hardfork : genesisParams.hardfork
    });
    if (genesisHash !== undefined) {
      common.setForkHashes(genesisHash);
    }
    return common;
  }
  static isSupportedChainId(chainId) {
    const initializedChains = this._getInitializedChains();
    return Boolean(initializedChains.names[chainId.toString()]);
  }
  static _getChainParams(_chain, customChains) {
    let chain = _chain;
    const initializedChains = this._getInitializedChains(customChains);
    if (typeof chain === "number" || typeof chain === "bigint") {
      chain = chain.toString();
      if (initializedChains.names[chain]) {
        const name = initializedChains.names[chain];
        return initializedChains[name];
      }
      throw new Error(`Chain with ID ${chain} not supported`);
    }
    if (initializedChains[chain] !== undefined) {
      return initializedChains[chain];
    }
    throw new Error(`Chain with name ${chain} not supported`);
  }
  setChain(chain) {
    if (typeof chain === "number" || typeof chain === "bigint" || typeof chain === "string") {
      this._chainParams = Common._getChainParams(chain, this._customChains);
    } else if (typeof chain === "object") {
      if (this._customChains.length > 0) {
        throw new Error("Chain must be a string, number, or bigint when initialized with customChains passed in");
      }
      const required = ["networkId", "genesis", "hardforks", "bootstrapNodes"];
      for (const param of required) {
        if (!(param in chain)) {
          throw new Error(`Missing required chain parameter: ${param}`);
        }
      }
      this._chainParams = chain;
    } else {
      throw new Error("Wrong input format");
    }
    for (const hf of this.hardforks()) {
      if (hf.block === undefined) {
        throw new Error(`Hardfork cannot have undefined block number`);
      }
    }
    return this._chainParams;
  }
  setHardfork(hardfork) {
    let existing = false;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if (hfChanges[0] === hardfork) {
        if (this._hardfork !== hardfork) {
          this._hardfork = hardfork;
          this.emit("hardforkChanged", hardfork);
        }
        existing = true;
      }
    }
    if (!existing) {
      throw new Error(`Hardfork with name ${hardfork} not supported`);
    }
  }
  getHardforkByBlockNumber(_blockNumber, _td, _timestamp) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const td = toType(_td, TypeOutput.BigInt);
    const timestamp = toType(_timestamp, TypeOutput.Number);
    const hfs = this.hardforks().filter((hf) => hf.block !== null || hf.ttd !== null && hf.ttd !== undefined || hf.timestamp !== undefined);
    const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
    const doubleTTDHF = hfs.slice(mergeIndex + 1).findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
    if (doubleTTDHF >= 0) {
      throw Error(`More than one merge hardforks found with ttd specified`);
    }
    let hfIndex = hfs.findIndex((hf) => hf.block !== null && hf.block > blockNumber || timestamp !== undefined && Number(hf.timestamp) > timestamp);
    if (hfIndex === -1) {
      hfIndex = hfs.length;
    } else if (hfIndex === 0) {
      throw Error("Must have at least one hardfork at block 0");
    }
    if (timestamp === undefined) {
      const stepBack = hfs.slice(0, hfIndex).reverse().findIndex((hf) => hf.block !== null || hf.ttd !== undefined);
      hfIndex -= stepBack;
    }
    hfIndex -= 1;
    if (hfs[hfIndex].block === null && hfs[hfIndex].timestamp === undefined) {
      if (td === undefined || td === null || BigInt(hfs[hfIndex].ttd) > td) {
        hfIndex -= 1;
      }
    } else if (mergeIndex >= 0 && td !== undefined && td !== null) {
      if (hfIndex >= mergeIndex && BigInt(hfs[mergeIndex].ttd) > td) {
        throw Error("Maximum HF determined by total difficulty is lower than the block number HF");
      } else if (hfIndex < mergeIndex && BigInt(hfs[mergeIndex].ttd) <= td) {
        throw Error("HF determined by block number is lower than the minimum total difficulty HF");
      }
    }
    const hfStartIndex = hfIndex;
    for (;hfIndex < hfs.length - 1; hfIndex += 1) {
      if (hfs[hfIndex].block !== hfs[hfIndex + 1].block || hfs[hfIndex].timestamp !== hfs[hfIndex + 1].timestamp) {
        break;
      }
    }
    if (timestamp) {
      const minTimeStamp = hfs.slice(0, hfStartIndex).reduce((acc, hf) => {
        var _a3;
        return Math.max(Number((_a3 = hf.timestamp) !== null && _a3 !== undefined ? _a3 : "0"), acc);
      }, 0);
      if (minTimeStamp > timestamp) {
        throw Error(`Maximum HF determined by timestamp is lower than the block number/ttd HF`);
      }
      const maxTimeStamp = hfs.slice(hfIndex + 1).reduce((acc, hf) => {
        var _a3;
        return Math.min(Number((_a3 = hf.timestamp) !== null && _a3 !== undefined ? _a3 : timestamp), acc);
      }, timestamp);
      if (maxTimeStamp < timestamp) {
        throw Error(`Maximum HF determined by block number/ttd is lower than timestamp HF`);
      }
    }
    const hardfork = hfs[hfIndex];
    return hardfork.name;
  }
  setHardforkByBlockNumber(blockNumber, td, timestamp) {
    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
    this.setHardfork(hardfork);
    return hardfork;
  }
  _getHardfork(hardfork) {
    const hfs = this.hardforks();
    for (const hf of hfs) {
      if (hf.name === hardfork)
        return hf;
    }
    return null;
  }
  setEIPs(eips2 = []) {
    for (const eip of eips2) {
      if (!(eip in EIPs)) {
        throw new Error(`${eip} not supported`);
      }
      const minHF = this.gteHardfork(EIPs[eip].minimumHardfork);
      if (!minHF) {
        throw new Error(`${eip} cannot be activated on hardfork ${this.hardfork()}, minimumHardfork: ${minHF}`);
      }
      if (EIPs[eip].requiredEIPs !== undefined) {
        for (const elem of EIPs[eip].requiredEIPs) {
          if (!(eips2.includes(elem) || this.isActivatedEIP(elem))) {
            throw new Error(`${eip} requires EIP ${elem}, but is not included in the EIP list`);
          }
        }
      }
    }
    this._eips = eips2;
  }
  param(topic3, name) {
    let value;
    for (const eip of this._eips) {
      value = this.paramByEIP(topic3, name, eip);
      if (value !== undefined)
        return value;
    }
    return this.paramByHardfork(topic3, name, this._hardfork);
  }
  paramByHardfork(topic3, name, hardfork) {
    let value = null;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("eips" in hfChanges[1]) {
        const hfEIPs = hfChanges[1].eips;
        for (const eip of hfEIPs) {
          const valueEIP = this.paramByEIP(topic3, name, eip);
          value = typeof valueEIP === "bigint" ? valueEIP : value;
        }
      } else {
        if (hfChanges[1][topic3] === undefined) {
          throw new Error(`Topic ${topic3} not defined`);
        }
        if (hfChanges[1][topic3][name] !== undefined) {
          value = hfChanges[1][topic3][name].v;
        }
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return BigInt(value !== null && value !== undefined ? value : 0);
  }
  paramByEIP(topic3, name, eip) {
    if (!(eip in EIPs)) {
      throw new Error(`${eip} not supported`);
    }
    const eipParams = EIPs[eip];
    if (!(topic3 in eipParams)) {
      throw new Error(`Topic ${topic3} not defined`);
    }
    if (eipParams[topic3][name] === undefined) {
      return;
    }
    const value = eipParams[topic3][name].v;
    return BigInt(value);
  }
  paramByBlock(topic3, name, blockNumber, td, timestamp) {
    const hardfork = this.getHardforkByBlockNumber(blockNumber, td, timestamp);
    return this.paramByHardfork(topic3, name, hardfork);
  }
  isActivatedEIP(eip) {
    if (this.eips().includes(eip)) {
      return true;
    }
    for (const hfChanges of this.HARDFORK_CHANGES) {
      const hf = hfChanges[1];
      if (this.gteHardfork(hf.name) && "eips" in hf) {
        if (hf.eips.includes(eip)) {
          return true;
        }
      }
    }
    return false;
  }
  hardforkIsActiveOnBlock(_hardfork, _blockNumber) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const hfBlock = this.hardforkBlock(hardfork);
    if (typeof hfBlock === "bigint" && hfBlock !== BigInt(0) && blockNumber >= hfBlock) {
      return true;
    }
    return false;
  }
  activeOnBlock(blockNumber) {
    return this.hardforkIsActiveOnBlock(null, blockNumber);
  }
  hardforkGteHardfork(_hardfork1, hardfork2) {
    const hardfork1 = _hardfork1 !== null && _hardfork1 !== undefined ? _hardfork1 : this._hardfork;
    const hardforks3 = this.hardforks();
    let posHf1 = -1;
    let posHf2 = -1;
    let index = 0;
    for (const hf of hardforks3) {
      if (hf.name === hardfork1)
        posHf1 = index;
      if (hf.name === hardfork2)
        posHf2 = index;
      index += 1;
    }
    return posHf1 >= posHf2 && posHf2 !== -1;
  }
  gteHardfork(hardfork) {
    return this.hardforkGteHardfork(null, hardfork);
  }
  hardforkBlock(_hardfork) {
    var _a3;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const block4 = (_a3 = this._getHardfork(hardfork)) === null || _a3 === undefined ? undefined : _a3.block;
    if (block4 === undefined || block4 === null) {
      return null;
    }
    return BigInt(block4);
  }
  hardforkTimestamp(_hardfork) {
    var _a3;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const timestamp = (_a3 = this._getHardfork(hardfork)) === null || _a3 === undefined ? undefined : _a3.timestamp;
    if (timestamp === undefined || timestamp === null) {
      return null;
    }
    return BigInt(timestamp);
  }
  eipBlock(eip) {
    for (const hfChanges of this.HARDFORK_CHANGES) {
      const hf = hfChanges[1];
      if ("eips" in hf) {
        if (hf.eips.includes(eip)) {
          return this.hardforkBlock(typeof hfChanges[0] === "number" ? String(hfChanges[0]) : hfChanges[0]);
        }
      }
    }
    return null;
  }
  hardforkTTD(_hardfork) {
    var _a3;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const ttd = (_a3 = this._getHardfork(hardfork)) === null || _a3 === undefined ? undefined : _a3.ttd;
    if (ttd === undefined || ttd === null) {
      return null;
    }
    return BigInt(ttd);
  }
  isHardforkBlock(_blockNumber, _hardfork) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const block4 = this.hardforkBlock(hardfork);
    return typeof block4 === "bigint" && block4 !== BigInt(0) ? block4 === blockNumber : false;
  }
  nextHardforkBlockOrTimestamp(_hardfork) {
    var _a3, _b;
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const hfs = this.hardforks();
    let hfIndex = hfs.findIndex((hf) => hf.name === hardfork);
    if (hardfork === Hardfork.Merge) {
      hfIndex -= 1;
    }
    if (hfIndex < 0) {
      return null;
    }
    let currHfTimeOrBlock = (_a3 = hfs[hfIndex].timestamp) !== null && _a3 !== undefined ? _a3 : hfs[hfIndex].block;
    currHfTimeOrBlock = currHfTimeOrBlock !== null && currHfTimeOrBlock !== undefined ? Number(currHfTimeOrBlock) : null;
    const nextHf = hfs.slice(hfIndex + 1).find((hf) => {
      var _a4;
      let hfTimeOrBlock = (_a4 = hf.timestamp) !== null && _a4 !== undefined ? _a4 : hf.block;
      hfTimeOrBlock = hfTimeOrBlock !== null && hfTimeOrBlock !== undefined ? Number(hfTimeOrBlock) : null;
      return hf.name !== Hardfork.Merge && hfTimeOrBlock !== null && hfTimeOrBlock !== undefined && hfTimeOrBlock !== currHfTimeOrBlock;
    });
    if (nextHf === undefined) {
      return null;
    }
    const nextHfBlock = (_b = nextHf.timestamp) !== null && _b !== undefined ? _b : nextHf.block;
    if (nextHfBlock === null || nextHfBlock === undefined) {
      return null;
    }
    return BigInt(nextHfBlock);
  }
  nextHardforkBlock(_hardfork) {
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    let hfBlock = this.hardforkBlock(hardfork);
    if (hfBlock === null && hardfork === Hardfork.Merge) {
      const hfs = this.hardforks();
      const mergeIndex = hfs.findIndex((hf) => hf.ttd !== null && hf.ttd !== undefined);
      if (mergeIndex < 0) {
        throw Error(`Merge hardfork should have been found`);
      }
      hfBlock = this.hardforkBlock(hfs[mergeIndex - 1].name);
    }
    if (hfBlock === null) {
      return null;
    }
    const nextHfBlock = this.hardforks().reduce((acc, hf) => {
      const block4 = BigInt(hf.block === null || hf.ttd !== undefined && hf.ttd !== null ? 0 : hf.block);
      return block4 > hfBlock && acc === null ? block4 : acc;
    }, null);
    return nextHfBlock;
  }
  isNextHardforkBlock(_blockNumber, _hardfork) {
    const blockNumber = toType(_blockNumber, TypeOutput.BigInt);
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const nextHardforkBlock = this.nextHardforkBlock(hardfork);
    return nextHardforkBlock === null ? false : nextHardforkBlock === blockNumber;
  }
  _calcForkHash(hardfork, genesisHash) {
    let hfUint8Array = new Uint8Array;
    let prevBlockOrTime = 0;
    for (const hf of this.hardforks()) {
      const { block: block4, timestamp, name } = hf;
      let blockOrTime = timestamp !== null && timestamp !== undefined ? timestamp : block4;
      blockOrTime = blockOrTime !== null ? Number(blockOrTime) : null;
      if (typeof blockOrTime === "number" && blockOrTime !== 0 && blockOrTime !== prevBlockOrTime && name !== Hardfork.Merge) {
        const hfBlockUint8Array = hexToBytes(blockOrTime.toString(16).padStart(16, "0"));
        hfUint8Array = uint8ArrayConcat(hfUint8Array, hfBlockUint8Array);
        prevBlockOrTime = blockOrTime;
      }
      if (hf.name === hardfork)
        break;
    }
    const inputUint8Array = uint8ArrayConcat(genesisHash, hfUint8Array);
    const forkhash = bytesToHex2(intToUint8Array(crc32Uint8Array(inputUint8Array) >>> 0));
    return forkhash;
  }
  forkHash(_hardfork, genesisHash) {
    const hardfork = _hardfork !== null && _hardfork !== undefined ? _hardfork : this._hardfork;
    const data = this._getHardfork(hardfork);
    if (data === null || (data === null || data === undefined ? undefined : data.block) === null && (data === null || data === undefined ? undefined : data.timestamp) === undefined && (data === null || data === undefined ? undefined : data.ttd) === undefined) {
      const msg = "No fork hash calculation possible for future hardfork";
      throw new Error(msg);
    }
    if ((data === null || data === undefined ? undefined : data.forkHash) !== null && (data === null || data === undefined ? undefined : data.forkHash) !== undefined) {
      return data.forkHash;
    }
    if (!genesisHash)
      throw new Error("genesisHash required for forkHash calculation");
    return this._calcForkHash(hardfork, genesisHash);
  }
  hardforkForForkHash(forkHash) {
    const resArray = this.hardforks().filter((hf) => hf.forkHash === forkHash);
    return resArray.length >= 1 ? resArray[resArray.length - 1] : null;
  }
  setForkHashes(genesisHash) {
    var _a3;
    for (const hf of this.hardforks()) {
      const blockOrTime = (_a3 = hf.timestamp) !== null && _a3 !== undefined ? _a3 : hf.block;
      if ((hf.forkHash === null || hf.forkHash === undefined) && (blockOrTime !== null && blockOrTime !== undefined || typeof hf.ttd !== "undefined")) {
        hf.forkHash = this.forkHash(hf.name, genesisHash);
      }
    }
  }
  genesis() {
    return this._chainParams.genesis;
  }
  hardforks() {
    return this._chainParams.hardforks;
  }
  bootstrapNodes() {
    return this._chainParams.bootstrapNodes;
  }
  dnsNetworks() {
    return this._chainParams.dnsNetworks;
  }
  hardfork() {
    return this._hardfork;
  }
  chainId() {
    return BigInt(this._chainParams.chainId);
  }
  chainName() {
    return this._chainParams.name;
  }
  networkId() {
    return BigInt(this._chainParams.networkId);
  }
  eips() {
    return this._eips;
  }
  consensusType() {
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus.type;
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return value !== null && value !== undefined ? value : this._chainParams.consensus.type;
  }
  consensusAlgorithm() {
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus.algorithm;
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return value !== null && value !== undefined ? value : this._chainParams.consensus.algorithm;
  }
  consensusConfig() {
    var _a3;
    const hardfork = this.hardfork();
    let value;
    for (const hfChanges of this.HARDFORK_CHANGES) {
      if ("consensus" in hfChanges[1]) {
        value = hfChanges[1].consensus[hfChanges[1].consensus.algorithm];
      }
      if (hfChanges[0] === hardfork)
        break;
    }
    return (_a3 = value !== null && value !== undefined ? value : this._chainParams.consensus[this.consensusAlgorithm()]) !== null && _a3 !== undefined ? _a3 : {};
  }
  copy() {
    const copy = Object.assign(Object.create(Object.getPrototypeOf(this)), this);
    copy.removeAllListeners();
    return copy;
  }
  static _getInitializedChains(customChains) {
    const names = {};
    for (const [name, id] of Object.entries(Chain)) {
      names[id] = name.toLowerCase();
    }
    const chains = { mainnet: mainnet_default, goerli: goerli_default, sepolia: sepolia_default };
    if (customChains) {
      for (const chain of customChains) {
        const { name } = chain;
        names[chain.chainId.toString()] = name;
        chains[name] = chain;
      }
    }
    chains.names = names;
    return chains;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/types.js
function isAccessListUint8Array(input) {
  if (input.length === 0) {
    return true;
  }
  const firstItem = input[0];
  if (Array.isArray(firstItem)) {
    return true;
  }
  return false;
}
function isAccessList(input) {
  return !isAccessListUint8Array(input);
}
var Capability;
(function(Capability2) {
  Capability2[Capability2["EIP155ReplayProtection"] = 155] = "EIP155ReplayProtection";
  Capability2[Capability2["EIP1559FeeMarket"] = 1559] = "EIP1559FeeMarket";
  Capability2[Capability2["EIP2718TypedTransaction"] = 2718] = "EIP2718TypedTransaction";
  Capability2[Capability2["EIP2930AccessLists"] = 2930] = "EIP2930AccessLists";
})(Capability || (Capability = {}));

// node_modules/web3-eth-accounts/lib/esm/tx/address.js
class Address {
  constructor(buf) {
    if (buf.length !== 20) {
      throw new Error("Invalid address length");
    }
    this.buf = buf;
  }
  static zero() {
    return new Address(zeros(20));
  }
  equals(address5) {
    return uint8ArrayEquals(this.buf, address5.buf);
  }
  isZero() {
    return this.equals(Address.zero());
  }
  toString() {
    return bytesToHex2(this.buf);
  }
  toArray() {
    return this.buf;
  }
  static publicToAddress(_pubKey, sanitize = false) {
    let pubKey = _pubKey;
    assertIsUint8Array(pubKey);
    if (sanitize && pubKey.length !== 64) {
      pubKey = secp256k12.ProjectivePoint.fromHex(pubKey).toRawBytes(false).slice(1);
    }
    if (pubKey.length !== 64) {
      throw new Error("Expected pubKey to be of length 64");
    }
    return keccak256(pubKey).slice(-20);
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/utils.js
var checkMaxInitCodeSize = (common, length) => {
  const maxInitCodeSize = common.param("vm", "maxInitCodeSize");
  if (maxInitCodeSize && BigInt(length) > maxInitCodeSize) {
    throw new Error(`the initcode size of this transaction is too large: it is ${length} while the max is ${common.param("vm", "maxInitCodeSize")}`);
  }
};
var getAccessListData = (accessList) => {
  let AccessListJSON;
  let uint8arrayAccessList;
  if (isAccessList(accessList)) {
    AccessListJSON = accessList;
    const newAccessList = [];
    for (let i = 0;i < accessList.length; i += 1) {
      const item = accessList[i];
      const addressBytes = toUint8Array(item.address);
      const storageItems = [];
      for (let index = 0;index < item.storageKeys.length; index += 1) {
        storageItems.push(toUint8Array(item.storageKeys[index]));
      }
      newAccessList.push([addressBytes, storageItems]);
    }
    uint8arrayAccessList = newAccessList;
  } else {
    uint8arrayAccessList = accessList !== null && accessList !== undefined ? accessList : [];
    const json = [];
    for (let i = 0;i < uint8arrayAccessList.length; i += 1) {
      const data = uint8arrayAccessList[i];
      const address5 = bytesToHex2(data[0]);
      const storageKeys = [];
      for (let item = 0;item < data[1].length; item += 1) {
        storageKeys.push(bytesToHex2(data[1][item]));
      }
      const jsonItem = {
        address: address5,
        storageKeys
      };
      json.push(jsonItem);
    }
    AccessListJSON = json;
  }
  return {
    AccessListJSON,
    accessList: uint8arrayAccessList
  };
};
var verifyAccessList = (accessList) => {
  for (let key = 0;key < accessList.length; key += 1) {
    const accessListItem = accessList[key];
    const address5 = accessListItem[0];
    const storageSlots = accessListItem[1];
    if (accessListItem[2] !== undefined) {
      throw new Error("Access list item cannot have 3 elements. It can only have an address, and an array of storage slots.");
    }
    if (address5.length !== 20) {
      throw new Error("Invalid EIP-2930 transaction: address length should be 20 bytes");
    }
    for (let storageSlot = 0;storageSlot < storageSlots.length; storageSlot += 1) {
      if (storageSlots[storageSlot].length !== 32) {
        throw new Error("Invalid EIP-2930 transaction: storage slot length should be 32 bytes");
      }
    }
  }
};
var getAccessListJSON = (accessList) => {
  const accessListJSON = [];
  for (let index = 0;index < accessList.length; index += 1) {
    const item = accessList[index];
    const JSONItem = {
      address: bytesToHex2(setLengthLeft(item[0], 20)),
      storageKeys: []
    };
    const storageSlots = item && item[1];
    for (let slot = 0;slot < storageSlots.length; slot += 1) {
      const storageSlot = storageSlots[slot];
      JSONItem.storageKeys.push(bytesToHex2(setLengthLeft(storageSlot, 32)));
    }
    accessListJSON.push(JSONItem);
  }
  return accessListJSON;
};
var getDataFeeEIP2930 = (accessList, common) => {
  const accessListStorageKeyCost = common.param("gasPrices", "accessListStorageKeyCost");
  const accessListAddressCost = common.param("gasPrices", "accessListAddressCost");
  let slots = 0;
  for (let index = 0;index < accessList.length; index += 1) {
    const item = accessList[index];
    const storageSlots = item[1];
    slots += storageSlots.length;
  }
  const addresses = accessList.length;
  return addresses * Number(accessListAddressCost) + slots * Number(accessListStorageKeyCost);
};

// node_modules/web3-eth-accounts/lib/esm/tx/baseTransaction.js
class BaseTransaction {
  constructor(txData, opts) {
    var _a3, _b;
    this.cache = {
      hash: undefined,
      dataFee: undefined
    };
    this.activeCapabilities = [];
    this.DEFAULT_CHAIN = Chain.Mainnet;
    this.DEFAULT_HARDFORK = Hardfork.Merge;
    const { nonce, gasLimit, to, value, data, v, r, s, type } = txData;
    this._type = Number(uint8ArrayToBigInt(toUint8Array(type)));
    this.txOptions = opts;
    const toB = toUint8Array(to === "" ? "0x" : to);
    const vB = toUint8Array(v === "" ? "0x" : v);
    const rB = toUint8Array(r === "" ? "0x" : r);
    const sB = toUint8Array(s === "" ? "0x" : s);
    this.nonce = uint8ArrayToBigInt(toUint8Array(nonce === "" ? "0x" : nonce));
    this.gasLimit = uint8ArrayToBigInt(toUint8Array(gasLimit === "" ? "0x" : gasLimit));
    this.to = toB.length > 0 ? new Address(toB) : undefined;
    this.value = uint8ArrayToBigInt(toUint8Array(value === "" ? "0x" : value));
    this.data = toUint8Array(data === "" ? "0x" : data);
    this.v = vB.length > 0 ? uint8ArrayToBigInt(vB) : undefined;
    this.r = rB.length > 0 ? uint8ArrayToBigInt(rB) : undefined;
    this.s = sB.length > 0 ? uint8ArrayToBigInt(sB) : undefined;
    this._validateCannotExceedMaxInteger({ value: this.value, r: this.r, s: this.s });
    this._validateCannotExceedMaxInteger({ gasLimit: this.gasLimit }, 64);
    this._validateCannotExceedMaxInteger({ nonce: this.nonce }, 64, true);
    const createContract = this.to === undefined || this.to === null;
    const allowUnlimitedInitCodeSize = (_a3 = opts.allowUnlimitedInitCodeSize) !== null && _a3 !== undefined ? _a3 : false;
    const common2 = (_b = opts.common) !== null && _b !== undefined ? _b : this._getCommon();
    if (createContract && common2.isActivatedEIP(3860) && !allowUnlimitedInitCodeSize) {
      checkMaxInitCodeSize(common2, this.data.length);
    }
  }
  get type() {
    return this._type;
  }
  supports(capability) {
    return this.activeCapabilities.includes(capability);
  }
  validate(stringError = false) {
    const errors5 = [];
    if (this.getBaseFee() > this.gasLimit) {
      errors5.push(`gasLimit is too low. given ${this.gasLimit}, need at least ${this.getBaseFee()}`);
    }
    if (this.isSigned() && !this.verifySignature()) {
      errors5.push("Invalid Signature");
    }
    return stringError ? errors5 : errors5.length === 0;
  }
  _validateYParity() {
    const { v } = this;
    if (v !== undefined && v !== BigInt(0) && v !== BigInt(1)) {
      const msg = this._errorMsg("The y-parity of the transaction should either be 0 or 1");
      throw new Error(msg);
    }
  }
  _validateHighS() {
    const { s } = this;
    if (this.common.gteHardfork("homestead") && s !== undefined && s > SECP256K1_ORDER_DIV_2) {
      const msg = this._errorMsg("Invalid Signature: s-values greater than secp256k1n/2 are considered invalid");
      throw new Error(msg);
    }
  }
  getBaseFee() {
    const txFee = this.common.param("gasPrices", "tx");
    let fee = this.getDataFee();
    if (txFee)
      fee += txFee;
    if (this.common.gteHardfork("homestead") && this.toCreationAddress()) {
      const txCreationFee = this.common.param("gasPrices", "txCreation");
      if (txCreationFee)
        fee += txCreationFee;
    }
    return fee;
  }
  getDataFee() {
    const txDataZero = this.common.param("gasPrices", "txDataZero");
    const txDataNonZero = this.common.param("gasPrices", "txDataNonZero");
    let cost = BigInt(0);
    for (let i = 0;i < this.data.length; i += 1) {
      this.data[i] === 0 ? cost += txDataZero : cost += txDataNonZero;
    }
    if ((this.to === undefined || this.to === null) && this.common.isActivatedEIP(3860)) {
      const dataLength = BigInt(Math.ceil(this.data.length / 32));
      const initCodeCost = this.common.param("gasPrices", "initCodeWordCost") * dataLength;
      cost += initCodeCost;
    }
    return cost;
  }
  toCreationAddress() {
    return this.to === undefined || this.to.buf.length === 0;
  }
  isSigned() {
    const { v, r, s } = this;
    if (v === undefined || r === undefined || s === undefined) {
      return false;
    }
    return true;
  }
  verifySignature() {
    try {
      const publicKey = this.getSenderPublicKey();
      return unpadUint8Array(publicKey).length !== 0;
    } catch (e) {
      return false;
    }
  }
  getSenderAddress() {
    return new Address(Address.publicToAddress(this.getSenderPublicKey()));
  }
  sign(privateKey) {
    if (privateKey.length !== 32) {
      const msg = this._errorMsg("Private key must be 32 bytes in length.");
      throw new Error(msg);
    }
    let hackApplied = false;
    if (this.type === 0 && this.common.gteHardfork("spuriousDragon") && !this.supports(Capability.EIP155ReplayProtection)) {
      this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      hackApplied = true;
    }
    const msgHash = this.getMessageToSign(true);
    const { v, r, s } = this._ecsign(msgHash, privateKey);
    const tx = this._processSignature(v, r, s);
    if (hackApplied) {
      const index = this.activeCapabilities.indexOf(Capability.EIP155ReplayProtection);
      if (index > -1) {
        this.activeCapabilities.splice(index, 1);
      }
    }
    return tx;
  }
  _getCommon(common2, chainId) {
    var _a3, _b, _c, _d;
    if (chainId !== undefined) {
      const chainIdBigInt = uint8ArrayToBigInt(toUint8Array(chainId));
      if (common2) {
        if (common2.chainId() !== chainIdBigInt) {
          const msg = this._errorMsg("The chain ID does not match the chain ID of Common");
          throw new Error(msg);
        }
        return common2.copy();
      }
      if (Common.isSupportedChainId(chainIdBigInt)) {
        return new Common({ chain: chainIdBigInt, hardfork: this.DEFAULT_HARDFORK });
      }
      return Common.custom({
        name: "custom-chain",
        networkId: chainIdBigInt,
        chainId: chainIdBigInt
      }, { baseChain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
    }
    if ((common2 === null || common2 === undefined ? undefined : common2.copy) && typeof (common2 === null || common2 === undefined ? undefined : common2.copy) === "function") {
      return common2.copy();
    }
    if (common2) {
      const hardfork = typeof common2.hardfork === "function" ? common2.hardfork() : common2.hardfork;
      return Common.custom({
        name: "custom-chain",
        networkId: common2.networkId ? common2.networkId() : (_b = BigInt((_a3 = common2.customChain) === null || _a3 === undefined ? undefined : _a3.networkId)) !== null && _b !== undefined ? _b : undefined,
        chainId: common2.chainId ? common2.chainId() : (_d = BigInt((_c = common2.customChain) === null || _c === undefined ? undefined : _c.chainId)) !== null && _d !== undefined ? _d : undefined
      }, {
        baseChain: this.DEFAULT_CHAIN,
        hardfork: hardfork || this.DEFAULT_HARDFORK
      });
    }
    return new Common({ chain: this.DEFAULT_CHAIN, hardfork: this.DEFAULT_HARDFORK });
  }
  _validateCannotExceedMaxInteger(values, bits = 256, cannotEqual = false) {
    for (const [key, value] of Object.entries(values)) {
      switch (bits) {
        case 64:
          if (cannotEqual) {
            if (value !== undefined && value >= MAX_UINT64) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_UINT64 (2^64-1), given ${value}`);
              throw new Error(msg);
            }
          } else if (value !== undefined && value > MAX_UINT64) {
            const msg = this._errorMsg(`${key} cannot exceed MAX_UINT64 (2^64-1), given ${value}`);
            throw new Error(msg);
          }
          break;
        case 256:
          if (cannotEqual) {
            if (value !== undefined && value >= MAX_INTEGER) {
              const msg = this._errorMsg(`${key} cannot equal or exceed MAX_INTEGER (2^256-1), given ${value}`);
              throw new Error(msg);
            }
          } else if (value !== undefined && value > MAX_INTEGER) {
            const msg = this._errorMsg(`${key} cannot exceed MAX_INTEGER (2^256-1), given ${value}`);
            throw new Error(msg);
          }
          break;
        default: {
          const msg = this._errorMsg("unimplemented bits value");
          throw new Error(msg);
        }
      }
    }
  }
  static _validateNotArray(values) {
    const txDataKeys = [
      "nonce",
      "gasPrice",
      "gasLimit",
      "to",
      "value",
      "data",
      "v",
      "r",
      "s",
      "type",
      "baseFee",
      "maxFeePerGas",
      "chainId"
    ];
    for (const [key, value] of Object.entries(values)) {
      if (txDataKeys.includes(key)) {
        if (Array.isArray(value)) {
          throw new Error(`${key} cannot be an array`);
        }
      }
    }
  }
  _getSharedErrorPostfix() {
    let hash3 = "";
    try {
      hash3 = this.isSigned() ? bytesToHex2(this.hash()) : "not available (unsigned)";
    } catch (e) {
      hash3 = "error";
    }
    let isSigned = "";
    try {
      isSigned = this.isSigned().toString();
    } catch (e) {
      hash3 = "error";
    }
    let hf = "";
    try {
      hf = this.common.hardfork();
    } catch (e) {
      hf = "error";
    }
    let postfix = `tx type=${this.type} hash=${hash3} nonce=${this.nonce} value=${this.value} `;
    postfix += `signed=${isSigned} hf=${hf}`;
    return postfix;
  }
  _ecsign(msgHash, privateKey, chainId) {
    const signature = secp256k12.sign(msgHash, privateKey);
    const signatureBytes = signature.toCompactRawBytes();
    const r = signatureBytes.subarray(0, 32);
    const s = signatureBytes.subarray(32, 64);
    const v = chainId === undefined ? BigInt(signature.recovery + 27) : BigInt(signature.recovery + 35) + BigInt(chainId) * BigInt(2);
    return { r, s, v };
  }
  static fromSerializedTx(serialized, opts = {}) {
  }
  static fromTxData(txData, opts = {}) {
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/eip1559Transaction.js
var TRANSACTION_TYPE = 2;
var TRANSACTION_TYPE_UINT8ARRAY = hexToBytes(TRANSACTION_TYPE.toString(16).padStart(2, "0"));

class FeeMarketEIP1559Transaction extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a3;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE }), opts);
    this.DEFAULT_HARDFORK = "london";
    const { chainId, accessList, maxFeePerGas, maxPriorityFeePerGas } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(1559)) {
      throw new Error("EIP-1559 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([1559, 2718, 2930]);
    const accessListData = getAccessListData(accessList !== null && accessList !== undefined ? accessList : []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    verifyAccessList(this.accessList);
    this.maxFeePerGas = uint8ArrayToBigInt(toUint8Array(maxFeePerGas === "" ? "0x" : maxFeePerGas));
    this.maxPriorityFeePerGas = uint8ArrayToBigInt(toUint8Array(maxPriorityFeePerGas === "" ? "0x" : maxPriorityFeePerGas));
    this._validateCannotExceedMaxInteger({
      maxFeePerGas: this.maxFeePerGas,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasLimit * this.maxFeePerGas > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * maxFeePerGas cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    if (this.maxFeePerGas < this.maxPriorityFeePerGas) {
      const msg = this._errorMsg("maxFeePerGas cannot be less than maxPriorityFeePerGas (The total must be the larger of the two)");
      throw new Error(msg);
    }
    this._validateYParity();
    this._validateHighS();
    const freeze = (_a3 = opts === null || opts === undefined ? undefined : opts.freeze) !== null && _a3 !== undefined ? _a3 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new FeeMarketEIP1559Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    if (!uint8ArrayEquals(serialized.subarray(0, 1), TRANSACTION_TYPE_UINT8ARRAY)) {
      throw new Error(`Invalid serialized tx input: not an EIP-1559 transaction (wrong tx type, expected: ${TRANSACTION_TYPE}, received: ${bytesToHex2(serialized.subarray(0, 1))}`);
    }
    const values = rlp.RLP.decode(serialized.subarray(1));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return FeeMarketEIP1559Transaction.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 9 && values.length !== 12) {
      throw new Error("Invalid EIP-1559 transaction. Only expecting 9 values (for unsigned tx) or 12 values (for signed tx).");
    }
    const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      value,
      v,
      r,
      s
    });
    return new FeeMarketEIP1559Transaction({
      chainId: uint8ArrayToBigInt(chainId),
      nonce,
      maxPriorityFeePerGas,
      maxFeePerGas,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList !== null && accessList !== undefined ? accessList : [],
      v: v !== undefined ? uint8ArrayToBigInt(v) : undefined,
      r,
      s
    }, opts);
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    let cost = super.getDataFee();
    cost += BigInt(getDataFeeEIP2930(this.accessList, this.common));
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: cost,
        hardfork: this.common.hardfork()
      };
    }
    return cost;
  }
  getUpfrontCost(baseFee = BigInt(0)) {
    const prio = this.maxPriorityFeePerGas;
    const maxBase = this.maxFeePerGas - baseFee;
    const inclusionFeePerGas = prio < maxBase ? prio : maxBase;
    const gasPrice = inclusionFeePerGas + baseFee;
    return this.gasLimit * gasPrice + this.value;
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.chainId),
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.maxPriorityFeePerGas),
      bigIntToUnpaddedUint8Array(this.maxFeePerGas),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.accessList,
      this.v !== undefined ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== undefined ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== undefined ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    const base = this.raw();
    return uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY, rlp.RLP.encode(base));
  }
  getMessageToSign(hashMessage = true) {
    const base = this.raw().slice(0, 9);
    const message = uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY, rlp.RLP.encode(base));
    if (hashMessage) {
      return keccak256(message);
    }
    return message;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak256(this.serialize());
      }
      return this.cache.hash;
    }
    return keccak256(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call this method if transaction is not signed");
      throw new Error(msg);
    }
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v + BigInt(27), bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s));
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(v, r, s) {
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return FeeMarketEIP1559Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      maxPriorityFeePerGas: this.maxPriorityFeePerGas,
      maxFeePerGas: this.maxFeePerGas,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: v - BigInt(27),
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    const accessListJSON = getAccessListJSON(this.accessList);
    return {
      chainId: bigIntToHex(this.chainId),
      nonce: bigIntToHex(this.nonce),
      maxPriorityFeePerGas: bigIntToHex(this.maxPriorityFeePerGas),
      maxFeePerGas: bigIntToHex(this.maxFeePerGas),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== undefined ? this.to.toString() : undefined,
      value: bigIntToHex(this.value),
      data: bytesToHex2(this.data),
      accessList: accessListJSON,
      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,
      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,
      s: this.s !== undefined ? bigIntToHex(this.s) : undefined
    };
  }
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` maxFeePerGas=${this.maxFeePerGas} maxPriorityFeePerGas=${this.maxPriorityFeePerGas}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/eip2930Transaction.js
var rlp2 = __toESM(require_dist(), 1);
var TRANSACTION_TYPE2 = 1;
var TRANSACTION_TYPE_UINT8ARRAY2 = hexToBytes(TRANSACTION_TYPE2.toString(16).padStart(2, "0"));

class AccessListEIP2930Transaction extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a3;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE2 }), opts);
    this.DEFAULT_HARDFORK = "berlin";
    const { chainId, accessList, gasPrice } = txData;
    this.common = this._getCommon(opts.common, chainId);
    this.chainId = this.common.chainId();
    if (!this.common.isActivatedEIP(2930)) {
      throw new Error("EIP-2930 not enabled on Common");
    }
    this.activeCapabilities = this.activeCapabilities.concat([2718, 2930]);
    const accessListData = getAccessListData(accessList !== null && accessList !== undefined ? accessList : []);
    this.accessList = accessListData.accessList;
    this.AccessListJSON = accessListData.AccessListJSON;
    verifyAccessList(this.accessList);
    this.gasPrice = uint8ArrayToBigInt(toUint8Array(gasPrice === "" ? "0x" : gasPrice));
    this._validateCannotExceedMaxInteger({
      gasPrice: this.gasPrice
    });
    BaseTransaction._validateNotArray(txData);
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gasLimit * gasPrice cannot exceed MAX_INTEGER");
      throw new Error(msg);
    }
    this._validateYParity();
    this._validateHighS();
    const freeze = (_a3 = opts === null || opts === undefined ? undefined : opts.freeze) !== null && _a3 !== undefined ? _a3 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new AccessListEIP2930Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    if (!uint8ArrayEquals(serialized.subarray(0, 1), TRANSACTION_TYPE_UINT8ARRAY2)) {
      throw new Error(`Invalid serialized tx input: not an EIP-2930 transaction (wrong tx type, expected: ${TRANSACTION_TYPE2}, received: ${bytesToHex2(serialized.subarray(0, 1))}`);
    }
    const values = rlp2.RLP.decode(Uint8Array.from(serialized.subarray(1)));
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input: must be array");
    }
    return AccessListEIP2930Transaction.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 8 && values.length !== 11) {
      throw new Error("Invalid EIP-2930 transaction. Only expecting 8 values (for unsigned tx) or 11 values (for signed tx).");
    }
    const [chainId, nonce, gasPrice, gasLimit, to, value, data, accessList, v, r, s] = values;
    this._validateNotArray({ chainId, v });
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    const emptyAccessList = [];
    return new AccessListEIP2930Transaction({
      chainId: uint8ArrayToBigInt(chainId),
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      accessList: accessList !== null && accessList !== undefined ? accessList : emptyAccessList,
      v: v !== undefined ? uint8ArrayToBigInt(v) : undefined,
      r,
      s
    }, opts);
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    let cost = super.getDataFee();
    cost += BigInt(getDataFeeEIP2930(this.accessList, this.common));
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: cost,
        hardfork: this.common.hardfork()
      };
    }
    return cost;
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.chainId),
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.accessList,
      this.v !== undefined ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== undefined ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== undefined ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    const base = this.raw();
    return uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY2, rlp2.RLP.encode(base));
  }
  getMessageToSign(hashMessage = true) {
    const base = this.raw().slice(0, 8);
    const message = uint8ArrayConcat(TRANSACTION_TYPE_UINT8ARRAY2, rlp2.RLP.encode(base));
    if (hashMessage) {
      return keccak256(message);
    }
    return message;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak256(this.serialize());
      }
      return this.cache.hash;
    }
    return keccak256(this.serialize());
  }
  getMessageToVerifySignature() {
    return this.getMessageToSign();
  }
  getSenderPublicKey() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call this method if transaction is not signed");
      throw new Error(msg);
    }
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v + BigInt(27), bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s));
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(v, r, s) {
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return AccessListEIP2930Transaction.fromTxData({
      chainId: this.chainId,
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      accessList: this.accessList,
      v: v - BigInt(27),
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    const accessListJSON = getAccessListJSON(this.accessList);
    return {
      chainId: bigIntToHex(this.chainId),
      nonce: bigIntToHex(this.nonce),
      gasPrice: bigIntToHex(this.gasPrice),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== undefined ? this.to.toString() : undefined,
      value: bigIntToHex(this.value),
      data: bytesToHex2(this.data),
      accessList: accessListJSON,
      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,
      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,
      s: this.s !== undefined ? bigIntToHex(this.s) : undefined
    };
  }
  errorStr() {
    var _a3, _b;
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice} accessListCount=${(_b = (_a3 = this.accessList) === null || _a3 === undefined ? undefined : _a3.length) !== null && _b !== undefined ? _b : 0}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/legacyTransaction.js
var rlp3 = __toESM(require_dist(), 1);
var meetsEIP155 = function(_v, chainId) {
  const v = Number(_v);
  const chainIdDoubled = Number(chainId) * 2;
  return v === chainIdDoubled + 35 || v === chainIdDoubled + 36;
};
var TRANSACTION_TYPE3 = 0;

class Transaction extends BaseTransaction {
  constructor(txData, opts = {}) {
    var _a3;
    super(Object.assign(Object.assign({}, txData), { type: TRANSACTION_TYPE3 }), opts);
    this.common = this._validateTxV(this.v, opts.common);
    this.gasPrice = uint8ArrayToBigInt(toUint8Array(txData.gasPrice === "" ? "0x" : txData.gasPrice));
    if (this.gasPrice * this.gasLimit > MAX_INTEGER) {
      const msg = this._errorMsg("gas limit * gasPrice cannot exceed MAX_INTEGER (2^256-1)");
      throw new Error(msg);
    }
    this._validateCannotExceedMaxInteger({ gasPrice: this.gasPrice });
    BaseTransaction._validateNotArray(txData);
    if (this.common.gteHardfork("spuriousDragon")) {
      if (!this.isSigned()) {
        this.activeCapabilities.push(Capability.EIP155ReplayProtection);
      } else {
        if (meetsEIP155(this.v, this.common.chainId())) {
          this.activeCapabilities.push(Capability.EIP155ReplayProtection);
        }
      }
    }
    const freeze = (_a3 = opts === null || opts === undefined ? undefined : opts.freeze) !== null && _a3 !== undefined ? _a3 : true;
    if (freeze) {
      Object.freeze(this);
    }
  }
  static fromTxData(txData, opts = {}) {
    return new Transaction(txData, opts);
  }
  static fromSerializedTx(serialized, opts = {}) {
    const values = rlp3.RLP.decode(serialized);
    if (!Array.isArray(values)) {
      throw new Error("Invalid serialized tx input. Must be array");
    }
    return this.fromValuesArray(values, opts);
  }
  static fromValuesArray(values, opts = {}) {
    if (values.length !== 6 && values.length !== 9) {
      throw new Error("Invalid transaction. Only expecting 6 values (for unsigned tx) or 9 values (for signed tx).");
    }
    const [nonce, gasPrice, gasLimit, to, value, data, v, r, s] = values;
    validateNoLeadingZeroes({ nonce, gasPrice, gasLimit, value, v, r, s });
    return new Transaction({
      nonce,
      gasPrice,
      gasLimit,
      to,
      value,
      data,
      v,
      r,
      s
    }, opts);
  }
  raw() {
    return [
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data,
      this.v !== undefined ? bigIntToUnpaddedUint8Array(this.v) : Uint8Array.from([]),
      this.r !== undefined ? bigIntToUnpaddedUint8Array(this.r) : Uint8Array.from([]),
      this.s !== undefined ? bigIntToUnpaddedUint8Array(this.s) : Uint8Array.from([])
    ];
  }
  serialize() {
    return rlp3.RLP.encode(this.raw());
  }
  _getMessageToSign() {
    const values = [
      bigIntToUnpaddedUint8Array(this.nonce),
      bigIntToUnpaddedUint8Array(this.gasPrice),
      bigIntToUnpaddedUint8Array(this.gasLimit),
      this.to !== undefined ? this.to.buf : Uint8Array.from([]),
      bigIntToUnpaddedUint8Array(this.value),
      this.data
    ];
    if (this.supports(Capability.EIP155ReplayProtection)) {
      values.push(toUint8Array(this.common.chainId()));
      values.push(unpadUint8Array(toUint8Array(0)));
      values.push(unpadUint8Array(toUint8Array(0)));
    }
    return values;
  }
  getMessageToSign(hashMessage = true) {
    const message = this._getMessageToSign();
    if (hashMessage) {
      return keccak256(rlp3.RLP.encode(message));
    }
    return message;
  }
  getDataFee() {
    if (this.cache.dataFee && this.cache.dataFee.hardfork === this.common.hardfork()) {
      return this.cache.dataFee.value;
    }
    if (Object.isFrozen(this)) {
      this.cache.dataFee = {
        value: super.getDataFee(),
        hardfork: this.common.hardfork()
      };
    }
    return super.getDataFee();
  }
  getUpfrontCost() {
    return this.gasLimit * this.gasPrice + this.value;
  }
  hash() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("Cannot call hash method if transaction is not signed");
      throw new Error(msg);
    }
    if (Object.isFrozen(this)) {
      if (!this.cache.hash) {
        this.cache.hash = keccak256(rlp3.RLP.encode(this.raw()));
      }
      return this.cache.hash;
    }
    return keccak256(rlp3.RLP.encode(this.raw()));
  }
  getMessageToVerifySignature() {
    if (!this.isSigned()) {
      const msg = this._errorMsg("This transaction is not signed");
      throw new Error(msg);
    }
    const message = this._getMessageToSign();
    return keccak256(rlp3.RLP.encode(message));
  }
  getSenderPublicKey() {
    const msgHash = this.getMessageToVerifySignature();
    const { v, r, s } = this;
    this._validateHighS();
    try {
      return ecrecover(msgHash, v, bigIntToUnpaddedUint8Array(r), bigIntToUnpaddedUint8Array(s), this.supports(Capability.EIP155ReplayProtection) ? this.common.chainId() : undefined);
    } catch (e) {
      const msg = this._errorMsg("Invalid Signature");
      throw new Error(msg);
    }
  }
  _processSignature(_v, r, s) {
    let v = _v;
    if (this.supports(Capability.EIP155ReplayProtection)) {
      v += this.common.chainId() * BigInt(2) + BigInt(8);
    }
    const opts = Object.assign(Object.assign({}, this.txOptions), { common: this.common });
    return Transaction.fromTxData({
      nonce: this.nonce,
      gasPrice: this.gasPrice,
      gasLimit: this.gasLimit,
      to: this.to,
      value: this.value,
      data: this.data,
      v,
      r: uint8ArrayToBigInt(r),
      s: uint8ArrayToBigInt(s)
    }, opts);
  }
  toJSON() {
    return {
      nonce: bigIntToHex(this.nonce),
      gasPrice: bigIntToHex(this.gasPrice),
      gasLimit: bigIntToHex(this.gasLimit),
      to: this.to !== undefined ? this.to.toString() : undefined,
      value: bigIntToHex(this.value),
      data: bytesToHex2(this.data),
      v: this.v !== undefined ? bigIntToHex(this.v) : undefined,
      r: this.r !== undefined ? bigIntToHex(this.r) : undefined,
      s: this.s !== undefined ? bigIntToHex(this.s) : undefined
    };
  }
  _validateTxV(_v, common2) {
    let chainIdBigInt;
    const v = _v !== undefined ? Number(_v) : undefined;
    if (v !== undefined) {
      if (v < 37 && v !== 27 && v !== 28) {
        throw new Error(`Legacy txs need either v = 27/28 or v >= 37 (EIP-155 replay protection), got v = ${v}`);
      }
    }
    if (v !== undefined && v !== 0 && (!common2 || common2.gteHardfork("spuriousDragon")) && v !== 27 && v !== 28) {
      if (common2) {
        if (!meetsEIP155(BigInt(v), common2.chainId())) {
          throw new Error(`Incompatible EIP155-based V ${v} and chain id ${common2.chainId()}. See the Common parameter of the Transaction constructor to set the chain id.`);
        }
      } else {
        let numSub;
        if ((v - 35) % 2 === 0) {
          numSub = 35;
        } else {
          numSub = 36;
        }
        chainIdBigInt = BigInt(v - numSub) / BigInt(2);
      }
    }
    return this._getCommon(common2, chainIdBigInt);
  }
  errorStr() {
    let errorStr = this._getSharedErrorPostfix();
    errorStr += ` gasPrice=${this.gasPrice}`;
    return errorStr;
  }
  _errorMsg(msg) {
    return `${msg} (${this.errorStr()})`;
  }
}

// node_modules/web3-eth-accounts/lib/esm/tx/transactionFactory.js
var extraTxTypes = new Map;

class TransactionFactory {
  constructor() {
  }
  static typeToInt(txType) {
    return Number(uint8ArrayToBigInt(toUint8Array(txType)));
  }
  static registerTransactionType(type, txClass) {
    const txType = TransactionFactory.typeToInt(type);
    extraTxTypes.set(txType, txClass);
  }
  static fromTxData(txData, txOptions = {}) {
    if (!("type" in txData) || txData.type === undefined) {
      return Transaction.fromTxData(txData, txOptions);
    }
    const txType = TransactionFactory.typeToInt(txData.type);
    if (txType === 0) {
      return Transaction.fromTxData(txData, txOptions);
    }
    if (txType === 1) {
      return AccessListEIP2930Transaction.fromTxData(txData, txOptions);
    }
    if (txType === 2) {
      return FeeMarketEIP1559Transaction.fromTxData(txData, txOptions);
    }
    const ExtraTransaction = extraTxTypes.get(txType);
    if (ExtraTransaction === null || ExtraTransaction === undefined ? undefined : ExtraTransaction.fromTxData) {
      return ExtraTransaction.fromTxData(txData, txOptions);
    }
    throw new Error(`Tx instantiation with type ${txType} not supported`);
  }
  static fromSerializedData(data, txOptions = {}) {
    if (data[0] <= 127) {
      switch (data[0]) {
        case 1:
          return AccessListEIP2930Transaction.fromSerializedTx(data, txOptions);
        case 2:
          return FeeMarketEIP1559Transaction.fromSerializedTx(data, txOptions);
        default: {
          const ExtraTransaction = extraTxTypes.get(Number(data[0]));
          if (ExtraTransaction === null || ExtraTransaction === undefined ? undefined : ExtraTransaction.fromSerializedTx) {
            return ExtraTransaction.fromSerializedTx(data, txOptions);
          }
          throw new Error(`TypedTransaction with ID ${data[0]} unknown`);
        }
      }
    } else {
      return Transaction.fromSerializedTx(data, txOptions);
    }
  }
  static fromBlockBodyData(data, txOptions = {}) {
    if (isUint8Array2(data)) {
      return this.fromSerializedData(data, txOptions);
    }
    if (Array.isArray(data)) {
      return Transaction.fromValuesArray(data, txOptions);
    }
    throw new Error("Cannot decode transaction: unknown type input");
  }
}

// node_modules/web3-eth-accounts/lib/esm/account.js
var __awaiter11 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parseAndValidatePrivateKey = (data, ignoreLength) => {
  let privateKeyUint8Array;
  if (!ignoreLength && typeof data === "string" && isHexStrict(data) && data.length !== 66) {
    throw new PrivateKeyLengthError;
  }
  try {
    privateKeyUint8Array = isUint8Array2(data) ? data : bytesToUint8Array(data);
  } catch (_a3) {
    throw new InvalidPrivateKeyError;
  }
  if (!ignoreLength && privateKeyUint8Array.byteLength !== 32) {
    throw new PrivateKeyLengthError;
  }
  return privateKeyUint8Array;
};
var hashMessage = (message) => {
  const messageHex = isHexStrict(message) ? message : utf8ToHex(message);
  const messageBytes = hexToBytes(messageHex);
  const preamble = hexToBytes(fromUtf8(`\x19Ethereum Signed Message:
${messageBytes.byteLength}`));
  const ethMessage = uint8ArrayConcat(preamble, messageBytes);
  return sha3Raw(ethMessage);
};
var sign = (data, privateKey) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  const hash3 = hashMessage(data);
  const signature = secp256k12.sign(hash3.substring(2), privateKeyUint8Array);
  const signatureBytes = signature.toCompactRawBytes();
  const r = signature.r.toString(16).padStart(64, "0");
  const s = signature.s.toString(16).padStart(64, "0");
  const v = signature.recovery + 27;
  return {
    message: data,
    messageHash: hash3,
    v: numberToHex2(v),
    r: `0x${r}`,
    s: `0x${s}`,
    signature: `${bytesToHex2(signatureBytes)}${v.toString(16)}`
  };
};
var signTransaction = (transaction, privateKey) => __awaiter11(undefined, undefined, undefined, function* () {
  const signedTx = transaction.sign(hexToBytes(privateKey));
  if (isNullish(signedTx.v) || isNullish(signedTx.r) || isNullish(signedTx.s))
    throw new TransactionSigningError("Signer Error");
  const validationErrors = signedTx.validate(true);
  if (validationErrors.length > 0) {
    let errorString = "Signer Error ";
    for (const validationError of validationErrors) {
      errorString += `${errorString} ${validationError}.`;
    }
    throw new TransactionSigningError(errorString);
  }
  const rawTx = bytesToHex2(signedTx.serialize());
  const txHash = sha3Raw(rawTx);
  return {
    messageHash: bytesToHex2(signedTx.getMessageToSign(true)),
    v: `0x${signedTx.v.toString(16)}`,
    r: `0x${signedTx.r.toString(16).padStart(64, "0")}`,
    s: `0x${signedTx.s.toString(16).padStart(64, "0")}`,
    rawTransaction: rawTx,
    transactionHash: bytesToHex2(txHash)
  };
});
var recoverTransaction = (rawTransaction) => {
  if (isNullish(rawTransaction))
    throw new UndefinedRawTransactionError;
  const tx = TransactionFactory.fromSerializedData(hexToBytes(rawTransaction));
  return toChecksumAddress(tx.getSenderAddress().toString());
};
var recover = (data, signatureOrV, prefixedOrR, s, prefixed) => {
  if (typeof data === "object") {
    const signatureStr = `${data.r}${data.s.slice(2)}${data.v.slice(2)}`;
    return recover(data.messageHash, signatureStr, prefixedOrR);
  }
  if (typeof signatureOrV === "string" && typeof prefixedOrR === "string" && !isNullish(s)) {
    const signatureStr = `${prefixedOrR}${s.slice(2)}${signatureOrV.slice(2)}`;
    return recover(data, signatureStr, prefixed);
  }
  if (isNullish(signatureOrV))
    throw new InvalidSignatureError("signature string undefined");
  const V_INDEX = 130;
  const hashedMessage = prefixedOrR ? data : hashMessage(data);
  let v = parseInt(signatureOrV.substring(V_INDEX), 16);
  if (v > 26) {
    v -= 27;
  }
  const ecPublicKey = secp256k12.Signature.fromCompact(signatureOrV.slice(2, V_INDEX)).addRecoveryBit(v).recoverPublicKey(hashedMessage.replace("0x", "")).toRawBytes(false);
  const publicHash = sha3Raw(ecPublicKey.subarray(1));
  const address6 = toChecksumAddress(`0x${publicHash.slice(-40)}`);
  return address6;
};
var privateKeyToAddress = (privateKey) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  const publicKey = secp256k12.getPublicKey(privateKeyUint8Array, false);
  const publicKeyHash = sha3Raw(publicKey.slice(1));
  const address6 = publicKeyHash.slice(-40);
  return toChecksumAddress(`0x${address6}`);
};
var privateKeyToPublicKey = (privateKey, isCompressed) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  return `0x${bytesToHex2(secp256k12.getPublicKey(privateKeyUint8Array, isCompressed)).slice(4)}`;
};
var encrypt2 = (privateKey, password, options) => __awaiter11(undefined, undefined, undefined, function* () {
  var _a3, _b, _c, _d, _e, _f, _g;
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey);
  let salt;
  if (options === null || options === undefined ? undefined : options.salt) {
    salt = typeof options.salt === "string" ? hexToBytes(options.salt) : options.salt;
  } else {
    salt = randomBytes2(32);
  }
  if (!(isString(password) || isUint8Array2(password))) {
    throw new InvalidPasswordError;
  }
  const uint8ArrayPassword = typeof password === "string" ? hexToBytes(utf8ToHex(password)) : password;
  let initializationVector;
  if (options === null || options === undefined ? undefined : options.iv) {
    initializationVector = typeof options.iv === "string" ? hexToBytes(options.iv) : options.iv;
    if (initializationVector.length !== 16) {
      throw new IVLengthError;
    }
  } else {
    initializationVector = randomBytes2(16);
  }
  const kdf = (_a3 = options === null || options === undefined ? undefined : options.kdf) !== null && _a3 !== undefined ? _a3 : "scrypt";
  let derivedKey;
  let kdfparams;
  if (kdf === "pbkdf2") {
    kdfparams = {
      dklen: (_b = options === null || options === undefined ? undefined : options.dklen) !== null && _b !== undefined ? _b : 32,
      salt: bytesToHex2(salt).replace("0x", ""),
      c: (_c = options === null || options === undefined ? undefined : options.c) !== null && _c !== undefined ? _c : 262144,
      prf: "hmac-sha256"
    };
    if (kdfparams.c < 1000) {
      throw new PBKDF2IterationsError;
    }
    derivedKey = pbkdf2Sync(uint8ArrayPassword, salt, kdfparams.c, kdfparams.dklen, "sha256");
  } else if (kdf === "scrypt") {
    kdfparams = {
      n: (_d = options === null || options === undefined ? undefined : options.n) !== null && _d !== undefined ? _d : 8192,
      r: (_e = options === null || options === undefined ? undefined : options.r) !== null && _e !== undefined ? _e : 8,
      p: (_f = options === null || options === undefined ? undefined : options.p) !== null && _f !== undefined ? _f : 1,
      dklen: (_g = options === null || options === undefined ? undefined : options.dklen) !== null && _g !== undefined ? _g : 32,
      salt: bytesToHex2(salt).replace("0x", "")
    };
    derivedKey = scryptSync(uint8ArrayPassword, salt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
  } else {
    throw new InvalidKdfError;
  }
  const cipher = yield encrypt(privateKeyUint8Array, derivedKey.slice(0, 16), initializationVector, "aes-128-ctr");
  const ciphertext = bytesToHex2(cipher).slice(2);
  const mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), cipher)).replace("0x", "");
  return {
    version: 3,
    id: uuidV4(),
    address: privateKeyToAddress(privateKeyUint8Array).toLowerCase().replace("0x", ""),
    crypto: {
      ciphertext,
      cipherparams: {
        iv: bytesToHex2(initializationVector).replace("0x", "")
      },
      cipher: "aes-128-ctr",
      kdf,
      kdfparams,
      mac
    }
  };
});
var privateKeyToAccount = (privateKey, ignoreLength) => {
  const privateKeyUint8Array = parseAndValidatePrivateKey(privateKey, ignoreLength);
  return {
    address: privateKeyToAddress(privateKeyUint8Array),
    privateKey: bytesToHex2(privateKeyUint8Array),
    signTransaction: (_tx) => {
      throw new TransactionSigningError("Do not have network access to sign the transaction");
    },
    sign: (data) => sign(typeof data === "string" ? data : JSON.stringify(data), privateKeyUint8Array),
    encrypt: (password, options) => __awaiter11(undefined, undefined, undefined, function* () {
      return encrypt2(privateKeyUint8Array, password, options);
    })
  };
};
var create = () => {
  const privateKey = secp256k12.utils.randomPrivateKey();
  return privateKeyToAccount(`${bytesToHex2(privateKey)}`);
};
var decrypt2 = (keystore, password, nonStrict) => __awaiter11(undefined, undefined, undefined, function* () {
  const json = typeof keystore === "object" ? keystore : JSON.parse(nonStrict ? keystore.toLowerCase() : keystore);
  validator2.validateJSONSchema(keyStoreSchema, json);
  if (json.version !== 3)
    throw new KeyStoreVersionError;
  const uint8ArrayPassword = typeof password === "string" ? hexToBytes(utf8ToHex(password)) : password;
  validator2.validate(["bytes"], [uint8ArrayPassword]);
  let derivedKey;
  if (json.crypto.kdf === "scrypt") {
    const kdfparams = json.crypto.kdfparams;
    const uint8ArraySalt = typeof kdfparams.salt === "string" ? hexToBytes(kdfparams.salt) : kdfparams.salt;
    derivedKey = scryptSync(uint8ArrayPassword, uint8ArraySalt, kdfparams.n, kdfparams.p, kdfparams.r, kdfparams.dklen);
  } else if (json.crypto.kdf === "pbkdf2") {
    const kdfparams = json.crypto.kdfparams;
    const uint8ArraySalt = typeof kdfparams.salt === "string" ? hexToBytes(kdfparams.salt) : kdfparams.salt;
    derivedKey = pbkdf2Sync(uint8ArrayPassword, uint8ArraySalt, kdfparams.c, kdfparams.dklen, "sha256");
  } else {
    throw new InvalidKdfError;
  }
  const ciphertext = hexToBytes(json.crypto.ciphertext);
  const mac = sha3Raw(uint8ArrayConcat(derivedKey.slice(16, 32), ciphertext)).replace("0x", "");
  if (mac !== json.crypto.mac) {
    throw new KeyDerivationError;
  }
  const seed = yield decrypt(hexToBytes(json.crypto.ciphertext), derivedKey.slice(0, 16), hexToBytes(json.crypto.cipherparams.iv));
  return privateKeyToAccount(seed);
});
// node_modules/web3-core/lib/esm/web3_batch_request.js
var __awaiter12 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var DEFAULT_BATCH_REQUEST_TIMEOUT = 1000;

class Web3BatchRequest {
  constructor(requestManager) {
    this._requestManager = requestManager;
    this._requests = new Map;
  }
  get requests() {
    return [...this._requests.values()].map((r) => r.payload);
  }
  add(request) {
    const payload = exports_json_rpc.toPayload(request);
    const promise = new Web3DeferredPromise;
    this._requests.set(payload.id, { payload, promise });
    return promise;
  }
  execute(options) {
    var _a3;
    return __awaiter12(this, undefined, undefined, function* () {
      if (this.requests.length === 0) {
        return Promise.resolve([]);
      }
      const request = new Web3DeferredPromise({
        timeout: (_a3 = options === null || options === undefined ? undefined : options.timeout) !== null && _a3 !== undefined ? _a3 : DEFAULT_BATCH_REQUEST_TIMEOUT,
        eagerStart: true,
        timeoutMessage: "Batch request timeout"
      });
      this._processBatchRequest(request).catch((err) => request.reject(err));
      request.catch((err) => {
        if (err instanceof OperationTimeoutError) {
          this._abortAllRequests("Batch request timeout");
        }
        request.reject(err);
      });
      return request;
    });
  }
  _processBatchRequest(promise) {
    var _a3, _b;
    return __awaiter12(this, undefined, undefined, function* () {
      const response = yield this._requestManager.sendBatch([...this._requests.values()].map((r) => r.payload));
      if (response.length !== this._requests.size) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request size mismatch the results size. Requests: ${this._requests.size}, Responses: ${response.length}`);
      }
      const requestIds = this.requests.map((r) => r.id).map(Number).sort((a, b) => a - b);
      const responseIds = response.map((r) => r.id).map(Number).sort((a, b) => a - b);
      if (JSON.stringify(requestIds) !== JSON.stringify(responseIds)) {
        this._abortAllRequests("Invalid batch response");
        throw new ResponseError(response, `Batch request mismatch the results. Requests: [${requestIds.join()}], Responses: [${responseIds.join()}]`);
      }
      for (const res of response) {
        if (exports_json_rpc.isResponseWithResult(res)) {
          (_a3 = this._requests.get(res.id)) === null || _a3 === undefined || _a3.promise.resolve(res.result);
        } else if (exports_json_rpc.isResponseWithError(res)) {
          (_b = this._requests.get(res.id)) === null || _b === undefined || _b.promise.reject(res.error);
        }
      }
      promise.resolve(response);
    });
  }
  _abortAllRequests(msg) {
    for (const { promise } of this._requests.values()) {
      promise.reject(new OperationAbortError(msg));
    }
  }
}

// node_modules/web3-core/lib/esm/web3_context.js
var __awaiter13 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Web3Context extends Web3Config {
  constructor(providerOrContext) {
    var _a3;
    super();
    this.providers = Web3RequestManager.providers;
    if (isNullish2(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() !== "" || isSupportedProvider(providerOrContext)) {
      this._requestManager = new Web3RequestManager(providerOrContext);
      this._subscriptionManager = new Web3SubscriptionManager(this._requestManager, {});
      return;
    }
    const { config, provider, requestManager, subscriptionManager, registeredSubscriptions, accountProvider, wallet: wallet2 } = providerOrContext;
    this.setConfig(config !== null && config !== undefined ? config : {});
    this._requestManager = requestManager !== null && requestManager !== undefined ? requestManager : new Web3RequestManager(provider, (_a3 = config === null || config === undefined ? undefined : config.enableExperimentalFeatures) === null || _a3 === undefined ? undefined : _a3.useSubscriptionWhenCheckingBlockTimeout);
    if (subscriptionManager) {
      this._subscriptionManager = subscriptionManager;
    } else {
      this._subscriptionManager = new Web3SubscriptionManager(this.requestManager, registeredSubscriptions !== null && registeredSubscriptions !== undefined ? registeredSubscriptions : {});
    }
    if (accountProvider) {
      this._accountProvider = accountProvider;
    }
    if (wallet2) {
      this._wallet = wallet2;
    }
  }
  get requestManager() {
    return this._requestManager;
  }
  get subscriptionManager() {
    return this._subscriptionManager;
  }
  get wallet() {
    return this._wallet;
  }
  get accountProvider() {
    return this._accountProvider;
  }
  static fromContextObject(...args) {
    return new this(...args.reverse());
  }
  getContextObject() {
    var _a3;
    return {
      config: this.config,
      provider: this.provider,
      requestManager: this.requestManager,
      subscriptionManager: this.subscriptionManager,
      registeredSubscriptions: (_a3 = this.subscriptionManager) === null || _a3 === undefined ? undefined : _a3.registeredSubscriptions,
      providers: this.providers,
      wallet: this.wallet,
      accountProvider: this.accountProvider
    };
  }
  use(ContextRef, ...args) {
    const newContextChild = new ContextRef(...[...args, this.getContextObject()]);
    this.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
      newContextChild.setConfig({ [event.name]: event.newValue });
    });
    return newContextChild;
  }
  link(parentContext) {
    this.setConfig(parentContext.config);
    this._requestManager = parentContext.requestManager;
    this.provider = parentContext.provider;
    this._subscriptionManager = parentContext.subscriptionManager;
    this._wallet = parentContext.wallet;
    this._accountProvider = parentContext._accountProvider;
    parentContext.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
      this.setConfig({ [event.name]: event.newValue });
    });
  }
  registerPlugin(plugin) {
    if (this[plugin.pluginNamespace] !== undefined)
      throw new ExistingPluginNamespaceError(plugin.pluginNamespace);
    const _pluginObject = {
      [plugin.pluginNamespace]: plugin
    };
    _pluginObject[plugin.pluginNamespace].link(this);
    Object.assign(this, _pluginObject);
  }
  get provider() {
    return this.currentProvider;
  }
  set provider(provider) {
    this.requestManager.setProvider(provider);
  }
  get currentProvider() {
    return this.requestManager.provider;
  }
  set currentProvider(provider) {
    this.requestManager.setProvider(provider);
  }
  get givenProvider() {
    return Web3Context.givenProvider;
  }
  setProvider(provider) {
    this.provider = provider;
    return true;
  }
  get BatchRequest() {
    return Web3BatchRequest.bind(undefined, this._requestManager);
  }
  extend(extendObj) {
    var _a3;
    if (extendObj.property && !this[extendObj.property])
      this[extendObj.property] = {};
    (_a3 = extendObj.methods) === null || _a3 === undefined || _a3.forEach((element) => {
      const method = (...givenParams) => __awaiter13(this, undefined, undefined, function* () {
        return this.requestManager.send({
          method: element.call,
          params: givenParams
        });
      });
      if (extendObj.property)
        this[extendObj.property][element.name] = method;
      else
        this[element.name] = method;
    });
    return this;
  }
}
Web3Context.providers = Web3RequestManager.providers;
// node_modules/web3-eth-iban/lib/esm/iban.js
class Iban {
  constructor(iban) {
    this.toAddress = () => {
      if (this.isDirect()) {
        const base36 = this._iban.slice(4);
        const parsedBigInt = Iban._parseInt(base36, 36);
        const paddedBigInt = leftPad(parsedBigInt, 40);
        return toChecksumAddress(paddedBigInt);
      }
      throw new Error("Iban is indirect and cannot be converted. Must be length of 34 or 35");
    };
    if (Iban.isIndirect(iban) || Iban.isDirect(iban)) {
      this._iban = iban;
    } else {
      throw new Error("Invalid IBAN was provided");
    }
  }
  static isDirect(iban) {
    return iban.length === 34 || iban.length === 35;
  }
  isDirect() {
    return Iban.isDirect(this._iban);
  }
  static isIndirect(iban) {
    return iban.length === 20;
  }
  isIndirect() {
    return Iban.isIndirect(this._iban);
  }
  static isValid(iban) {
    return /^XE[0-9]{2}(ETH[0-9A-Z]{13}|[0-9A-Z]{30,31})$/.test(iban) && Iban._mod9710(Iban._iso13616Prepare(iban)) === 1;
  }
  isValid() {
    return Iban.isValid(this._iban);
  }
  static fromBban(bban) {
    const countryCode = "XE";
    const remainder = this._mod9710(this._iso13616Prepare(`${countryCode}00${bban}`));
    const checkDigit = `0${(98 - remainder).toString()}`.slice(-2);
    return new Iban(`${countryCode}${checkDigit}${bban}`);
  }
  static createIndirect(options) {
    return Iban.fromBban(`ETH${options.institution}${options.identifier}`);
  }
  static fromAddress(address6) {
    if (!isAddress(address6)) {
      throw new InvalidAddressError(address6);
    }
    const num = BigInt(hexToNumber2(address6));
    const base36 = num.toString(36);
    const padded = leftPad(base36, 15);
    return Iban.fromBban(padded.toUpperCase());
  }
  static toIban(address6) {
    return Iban.fromAddress(address6).toString();
  }
  client() {
    return this.isIndirect() ? this._iban.slice(11) : "";
  }
  checksum() {
    return this._iban.slice(2, 4);
  }
  institution() {
    return this.isIndirect() ? this._iban.slice(7, 11) : "";
  }
  toString() {
    return this._iban;
  }
}
Iban._iso13616Prepare = (iban) => {
  const A = "A".charCodeAt(0);
  const Z = "Z".charCodeAt(0);
  const upperIban = iban.toUpperCase();
  const modifiedIban = `${upperIban.slice(4)}${upperIban.slice(0, 4)}`;
  return modifiedIban.split("").map((n) => {
    const code = n.charCodeAt(0);
    if (code >= A && code <= Z) {
      return code - A + 10;
    }
    return n;
  }).join("");
};
Iban._parseInt = (str, base) => [...str].reduce((acc, curr) => BigInt(parseInt(curr, base)) + BigInt(base) * acc, BigInt(0));
Iban._mod9710 = (iban) => {
  let remainder = iban;
  let block4;
  while (remainder.length > 2) {
    block4 = remainder.slice(0, 9);
    remainder = `${(parseInt(block4, 10) % 97).toString()}${remainder.slice(block4.length)}`;
  }
  return parseInt(remainder, 10) % 97;
};
Iban.toAddress = (iban) => {
  const ibanObject = new Iban(iban);
  return ibanObject.toAddress();
};
// node_modules/web3-core/lib/esm/web3_promi_event.js
var __awaiter14 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var _a3;

class Web3PromiEvent extends Web3EventEmitter {
  constructor(executor) {
    super();
    this[_a3] = "Promise";
    this._promise = new Promise(executor);
  }
  then(onfulfilled, onrejected) {
    return __awaiter14(this, undefined, undefined, function* () {
      return this._promise.then(onfulfilled, onrejected);
    });
  }
  catch(onrejected) {
    return __awaiter14(this, undefined, undefined, function* () {
      return this._promise.catch(onrejected);
    });
  }
  finally(onfinally) {
    return __awaiter14(this, undefined, undefined, function* () {
      return this._promise.finally(onfinally);
    });
  }
  on(eventName, fn) {
    super.on(eventName, fn);
    return this;
  }
  once(eventName, fn) {
    super.once(eventName, fn);
    return this;
  }
}
_a3 = Symbol.toStringTag;
// node_modules/web3-eth/lib/esm/index.js
var import_setimmediate = __toESM(require_setImmediate(), 1);

// node_modules/web3-rpc-methods/lib/esm/eth_rpc_methods.js
var exports_eth_rpc_methods = {};
__export(exports_eth_rpc_methods, {
  uninstallFilter: () => {
    {
      return uninstallFilter;
    }
  },
  submitWork: () => {
    {
      return submitWork;
    }
  },
  submitHashrate: () => {
    {
      return submitHashrate;
    }
  },
  signTypedData: () => {
    {
      return signTypedData;
    }
  },
  signTransaction: () => {
    {
      return signTransaction2;
    }
  },
  sign: () => {
    {
      return sign2;
    }
  },
  sendTransaction: () => {
    {
      return sendTransaction;
    }
  },
  sendRawTransaction: () => {
    {
      return sendRawTransaction;
    }
  },
  requestAccounts: () => {
    {
      return requestAccounts;
    }
  },
  newPendingTransactionFilter: () => {
    {
      return newPendingTransactionFilter;
    }
  },
  newFilter: () => {
    {
      return newFilter;
    }
  },
  newBlockFilter: () => {
    {
      return newBlockFilter;
    }
  },
  getWork: () => {
    {
      return getWork;
    }
  },
  getUncleCountByBlockNumber: () => {
    {
      return getUncleCountByBlockNumber;
    }
  },
  getUncleCountByBlockHash: () => {
    {
      return getUncleCountByBlockHash;
    }
  },
  getUncleByBlockNumberAndIndex: () => {
    {
      return getUncleByBlockNumberAndIndex;
    }
  },
  getUncleByBlockHashAndIndex: () => {
    {
      return getUncleByBlockHashAndIndex;
    }
  },
  getTransactionReceipt: () => {
    {
      return getTransactionReceipt;
    }
  },
  getTransactionCount: () => {
    {
      return getTransactionCount;
    }
  },
  getTransactionByHash: () => {
    {
      return getTransactionByHash;
    }
  },
  getTransactionByBlockNumberAndIndex: () => {
    {
      return getTransactionByBlockNumberAndIndex;
    }
  },
  getTransactionByBlockHashAndIndex: () => {
    {
      return getTransactionByBlockHashAndIndex;
    }
  },
  getSyncing: () => {
    {
      return getSyncing;
    }
  },
  getStorageAt: () => {
    {
      return getStorageAt;
    }
  },
  getProtocolVersion: () => {
    {
      return getProtocolVersion;
    }
  },
  getProof: () => {
    {
      return getProof;
    }
  },
  getPendingTransactions: () => {
    {
      return getPendingTransactions;
    }
  },
  getNodeInfo: () => {
    {
      return getNodeInfo;
    }
  },
  getMining: () => {
    {
      return getMining;
    }
  },
  getMaxPriorityFeePerGas: () => {
    {
      return getMaxPriorityFeePerGas;
    }
  },
  getLogs: () => {
    {
      return getLogs;
    }
  },
  getHashRate: () => {
    {
      return getHashRate;
    }
  },
  getGasPrice: () => {
    {
      return getGasPrice;
    }
  },
  getFilterLogs: () => {
    {
      return getFilterLogs;
    }
  },
  getFilterChanges: () => {
    {
      return getFilterChanges;
    }
  },
  getFeeHistory: () => {
    {
      return getFeeHistory;
    }
  },
  getCompilers: () => {
    {
      return getCompilers;
    }
  },
  getCoinbase: () => {
    {
      return getCoinbase;
    }
  },
  getCode: () => {
    {
      return getCode;
    }
  },
  getChainId: () => {
    {
      return getChainId;
    }
  },
  getBlockTransactionCountByNumber: () => {
    {
      return getBlockTransactionCountByNumber;
    }
  },
  getBlockTransactionCountByHash: () => {
    {
      return getBlockTransactionCountByHash;
    }
  },
  getBlockNumber: () => {
    {
      return getBlockNumber;
    }
  },
  getBlockByNumber: () => {
    {
      return getBlockByNumber;
    }
  },
  getBlockByHash: () => {
    {
      return getBlockByHash;
    }
  },
  getBalance: () => {
    {
      return getBalance;
    }
  },
  getAccounts: () => {
    {
      return getAccounts;
    }
  },
  estimateGas: () => {
    {
      return estimateGas;
    }
  },
  createAccessList: () => {
    {
      return createAccessList;
    }
  },
  compileSolidity: () => {
    {
      return compileSolidity;
    }
  },
  compileSerpent: () => {
    {
      return compileSerpent;
    }
  },
  compileLLL: () => {
    {
      return compileLLL;
    }
  },
  call: () => {
    {
      return call;
    }
  }
});
function getProtocolVersion(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_protocolVersion",
      params: []
    });
  });
}
function getSyncing(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_syncing",
      params: []
    });
  });
}
function getCoinbase(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_coinbase",
      params: []
    });
  });
}
function getMining(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_mining",
      params: []
    });
  });
}
function getHashRate(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_hashrate",
      params: []
    });
  });
}
function getGasPrice(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_gasPrice",
      params: []
    });
  });
}
function getMaxPriorityFeePerGas(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_maxPriorityFeePerGas",
      params: []
    });
  });
}
function getAccounts(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_accounts",
      params: []
    });
  });
}
function getBlockNumber(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_blockNumber",
      params: []
    });
  });
}
function getBalance(requestManager, address6, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "blockNumberOrTag"], [address6, blockNumber]);
    return requestManager.send({
      method: "eth_getBalance",
      params: [address6, blockNumber]
    });
  });
}
function getStorageAt(requestManager, address6, storageSlot, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "hex", "blockNumberOrTag"], [address6, storageSlot, blockNumber]);
    return requestManager.send({
      method: "eth_getStorageAt",
      params: [address6, storageSlot, blockNumber]
    });
  });
}
function getTransactionCount(requestManager, address6, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "blockNumberOrTag"], [address6, blockNumber]);
    return requestManager.send({
      method: "eth_getTransactionCount",
      params: [address6, blockNumber]
    });
  });
}
function getBlockTransactionCountByHash(requestManager, blockHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [blockHash]);
    return requestManager.send({
      method: "eth_getBlockTransactionCountByHash",
      params: [blockHash]
    });
  });
}
function getBlockTransactionCountByNumber(requestManager, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_getBlockTransactionCountByNumber",
      params: [blockNumber]
    });
  });
}
function getUncleCountByBlockHash(requestManager, blockHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [blockHash]);
    return requestManager.send({
      method: "eth_getUncleCountByBlockHash",
      params: [blockHash]
    });
  });
}
function getUncleCountByBlockNumber(requestManager, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_getUncleCountByBlockNumber",
      params: [blockNumber]
    });
  });
}
function getCode(requestManager, address6, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "blockNumberOrTag"], [address6, blockNumber]);
    return requestManager.send({
      method: "eth_getCode",
      params: [address6, blockNumber]
    });
  });
}
function sign2(requestManager, address6, message) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "hex"], [address6, message]);
    return requestManager.send({
      method: "eth_sign",
      params: [address6, message]
    });
  });
}
function signTransaction2(requestManager, transaction) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_signTransaction",
      params: [transaction]
    });
  });
}
function sendTransaction(requestManager, transaction) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_sendTransaction",
      params: [transaction]
    });
  });
}
function sendRawTransaction(requestManager, transaction) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [transaction]);
    return requestManager.send({
      method: "eth_sendRawTransaction",
      params: [transaction]
    });
  });
}
function call(requestManager, transaction, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_call",
      params: [transaction, blockNumber]
    });
  });
}
function estimateGas(requestManager, transaction, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_estimateGas",
      params: [transaction, blockNumber]
    });
  });
}
function getBlockByHash(requestManager, blockHash, hydrated) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "bool"], [blockHash, hydrated]);
    return requestManager.send({
      method: "eth_getBlockByHash",
      params: [blockHash, hydrated]
    });
  });
}
function getBlockByNumber(requestManager, blockNumber, hydrated) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag", "bool"], [blockNumber, hydrated]);
    return requestManager.send({
      method: "eth_getBlockByNumber",
      params: [blockNumber, hydrated]
    });
  });
}
function getTransactionByHash(requestManager, transactionHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [transactionHash]);
    return requestManager.send({
      method: "eth_getTransactionByHash",
      params: [transactionHash]
    });
  });
}
function getTransactionByBlockHashAndIndex(requestManager, blockHash, transactionIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "hex"], [blockHash, transactionIndex]);
    return requestManager.send({
      method: "eth_getTransactionByBlockHashAndIndex",
      params: [blockHash, transactionIndex]
    });
  });
}
function getTransactionByBlockNumberAndIndex(requestManager, blockNumber, transactionIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag", "hex"], [blockNumber, transactionIndex]);
    return requestManager.send({
      method: "eth_getTransactionByBlockNumberAndIndex",
      params: [blockNumber, transactionIndex]
    });
  });
}
function getTransactionReceipt(requestManager, transactionHash) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32"], [transactionHash]);
    return requestManager.send({
      method: "eth_getTransactionReceipt",
      params: [transactionHash]
    });
  });
}
function getUncleByBlockHashAndIndex(requestManager, blockHash, uncleIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "hex"], [blockHash, uncleIndex]);
    return requestManager.send({
      method: "eth_getUncleByBlockHashAndIndex",
      params: [blockHash, uncleIndex]
    });
  });
}
function getUncleByBlockNumberAndIndex(requestManager, blockNumber, uncleIndex) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag", "hex"], [blockNumber, uncleIndex]);
    return requestManager.send({
      method: "eth_getUncleByBlockNumberAndIndex",
      params: [blockNumber, uncleIndex]
    });
  });
}
function getCompilers(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_getCompilers",
      params: []
    });
  });
}
function compileSolidity(requestManager, code) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileSolidity",
      params: [code]
    });
  });
}
function compileLLL(requestManager, code) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileLLL",
      params: [code]
    });
  });
}
function compileSerpent(requestManager, code) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["string"], [code]);
    return requestManager.send({
      method: "eth_compileSerpent",
      params: [code]
    });
  });
}
function newFilter(requestManager, filter3) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["filter"], [filter3]);
    return requestManager.send({
      method: "eth_newFilter",
      params: [filter3]
    });
  });
}
function newBlockFilter(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_newBlockFilter",
      params: []
    });
  });
}
function newPendingTransactionFilter(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_newPendingTransactionFilter",
      params: []
    });
  });
}
function uninstallFilter(requestManager, filterIdentifier) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_uninstallFilter",
      params: [filterIdentifier]
    });
  });
}
function getFilterChanges(requestManager, filterIdentifier) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_getFilterChanges",
      params: [filterIdentifier]
    });
  });
}
function getFilterLogs(requestManager, filterIdentifier) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex"], [filterIdentifier]);
    return requestManager.send({
      method: "eth_getFilterLogs",
      params: [filterIdentifier]
    });
  });
}
function getLogs(requestManager, filter3) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["filter"], [filter3]);
    return requestManager.send({
      method: "eth_getLogs",
      params: [filter3]
    });
  });
}
function getWork(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_getWork",
      params: []
    });
  });
}
function submitWork(requestManager, nonce, hash3, digest) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes8", "bytes32", "bytes32"], [nonce, hash3, digest]);
    return requestManager.send({
      method: "eth_submitWork",
      params: [nonce, hash3, digest]
    });
  });
}
function submitHashrate(requestManager, hashRate, id) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["bytes32", "bytes32"], [hashRate, id]);
    return requestManager.send({
      method: "eth_submitHashrate",
      params: [hashRate, id]
    });
  });
}
function getFeeHistory(requestManager, blockCount, newestBlock, rewardPercentiles) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["hex", "blockNumberOrTag"], [blockCount, newestBlock]);
    for (const rewardPercentile of rewardPercentiles) {
      validator2.validate(["number"], [rewardPercentile]);
    }
    return requestManager.send({
      method: "eth_feeHistory",
      params: [blockCount, newestBlock, rewardPercentiles]
    });
  });
}
function getPendingTransactions(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_pendingTransactions",
      params: []
    });
  });
}
function requestAccounts(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_requestAccounts",
      params: []
    });
  });
}
function getChainId(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "eth_chainId",
      params: []
    });
  });
}
function getProof(requestManager, address6, storageKeys, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address", "bytes32[]", "blockNumberOrTag"], [address6, storageKeys, blockNumber]);
    return requestManager.send({
      method: "eth_getProof",
      params: [address6, storageKeys, blockNumber]
    });
  });
}
function getNodeInfo(requestManager) {
  return __awaiter15(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "web3_clientVersion",
      params: []
    });
  });
}
function createAccessList(requestManager, transaction, blockNumber) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["blockNumberOrTag"], [blockNumber]);
    return requestManager.send({
      method: "eth_createAccessList",
      params: [transaction, blockNumber]
    });
  });
}
function signTypedData(requestManager, address6, typedData, useLegacy = false) {
  return __awaiter15(this, undefined, undefined, function* () {
    validator2.validate(["address"], [address6]);
    return requestManager.send({
      method: `eth_signTypedData${useLegacy ? "" : "_v4"}`,
      params: [address6, typedData]
    });
  });
}
var __awaiter15 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-rpc-methods/lib/esm/net_rpc_methods.js
var exports_net_rpc_methods = {};
__export(exports_net_rpc_methods, {
  isListening: () => {
    {
      return isListening;
    }
  },
  getPeerCount: () => {
    {
      return getPeerCount;
    }
  },
  getId: () => {
    {
      return getId;
    }
  }
});
function getId(requestManager) {
  return __awaiter16(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "net_version",
      params: []
    });
  });
}
function getPeerCount(requestManager) {
  return __awaiter16(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "net_peerCount",
      params: []
    });
  });
}
function isListening(requestManager) {
  return __awaiter16(this, undefined, undefined, function* () {
    return requestManager.send({
      method: "net_listening",
      params: []
    });
  });
}
var __awaiter16 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-rpc-methods/lib/esm/personal_rpc_methods.js
var exports_personal_rpc_methods = {};
__export(exports_personal_rpc_methods, {
  unlockAccount: () => {
    {
      return unlockAccount;
    }
  },
  signTransaction: () => {
    {
      return signTransaction3;
    }
  },
  sign: () => {
    {
      return sign3;
    }
  },
  sendTransaction: () => {
    {
      return sendTransaction2;
    }
  },
  newAccount: () => {
    {
      return newAccount;
    }
  },
  lockAccount: () => {
    {
      return lockAccount;
    }
  },
  importRawKey: () => {
    {
      return importRawKey;
    }
  },
  getAccounts: () => {
    {
      return getAccounts2;
    }
  },
  ecRecover: () => {
    {
      return ecRecover;
    }
  }
});
var __awaiter17 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccounts2 = (requestManager) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_listAccounts",
    params: []
  });
});
var newAccount = (requestManager, password) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_newAccount",
    params: [password]
  });
});
var unlockAccount = (requestManager, address6, password, unlockDuration) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_unlockAccount",
    params: [address6, password, unlockDuration]
  });
});
var lockAccount = (requestManager, address6) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_lockAccount",
    params: [address6]
  });
});
var importRawKey = (requestManager, keyData, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_importRawKey",
    params: [keyData, passphrase]
  });
});
var sendTransaction2 = (requestManager, tx2, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_sendTransaction",
    params: [tx2, passphrase]
  });
});
var signTransaction3 = (requestManager, tx2, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_signTransaction",
    params: [tx2, passphrase]
  });
});
var sign3 = (requestManager, data, address6, passphrase) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_sign",
    params: [data, address6, passphrase]
  });
});
var ecRecover = (requestManager, signedData, signature) => __awaiter17(undefined, undefined, undefined, function* () {
  return requestManager.send({
    method: "personal_ecRecover",
    params: [signedData, signature]
  });
});

// node_modules/web3-eth/lib/esm/utils/detect_transaction_type.js
var transactionType0x0Schema = {
  type: "object",
  properties: {
    accessList: {
      type: "null"
    },
    maxFeePerGas: {
      type: "null"
    },
    maxPriorityFeePerGas: {
      type: "null"
    }
  }
};
var transactionType0x1Schema = {
  type: "object",
  properties: {
    maxFeePerGas: {
      type: "null"
    },
    maxPriorityFeePerGas: {
      type: "null"
    }
  }
};
var transactionType0x2Schema = {
  type: "object",
  properties: {
    gasPrice: {
      type: "null"
    }
  }
};
var validateTxTypeAndHandleErrors = (txSchema, tx2, txType) => {
  try {
    validator2.validateJSONSchema(txSchema, tx2);
  } catch (error) {
    if (error instanceof Web3ValidatorError)
      throw new InvalidPropertiesForTransactionTypeError(error.errors, txType);
    throw error;
  }
};
var defaultTransactionTypeParser = (transaction) => {
  var _a4, _b;
  const tx2 = transaction;
  if (!isNullish(tx2.type)) {
    let txSchema;
    switch (tx2.type) {
      case "0x0":
        txSchema = transactionType0x0Schema;
        break;
      case "0x1":
        txSchema = transactionType0x1Schema;
        break;
      case "0x2":
        txSchema = transactionType0x2Schema;
        break;
      default:
        return format({ format: "uint" }, tx2.type, ETH_DATA_FORMAT);
    }
    validateTxTypeAndHandleErrors(txSchema, tx2, tx2.type);
    return format({ format: "uint" }, tx2.type, ETH_DATA_FORMAT);
  }
  if (!isNullish(tx2.maxFeePerGas) || !isNullish(tx2.maxPriorityFeePerGas)) {
    validateTxTypeAndHandleErrors(transactionType0x2Schema, tx2, "0x2");
    return "0x2";
  }
  if (!isNullish(tx2.accessList)) {
    validateTxTypeAndHandleErrors(transactionType0x1Schema, tx2, "0x1");
    return "0x1";
  }
  const givenHardfork = (_a4 = tx2.hardfork) !== null && _a4 !== undefined ? _a4 : (_b = tx2.common) === null || _b === undefined ? undefined : _b.hardfork;
  if (!isNullish(givenHardfork)) {
    const hardforkIndex = Object.keys(HardforksOrdered).indexOf(givenHardfork);
    if (hardforkIndex >= Object.keys(HardforksOrdered).indexOf("london"))
      return !isNullish(tx2.gasPrice) ? "0x0" : "0x2";
    if (hardforkIndex === Object.keys(HardforksOrdered).indexOf("berlin"))
      return "0x0";
  }
  if (!isNullish(tx2.gasPrice)) {
    validateTxTypeAndHandleErrors(transactionType0x0Schema, tx2, "0x0");
    return "0x0";
  }
  return;
};
var detectTransactionType = (transaction, web3Context) => {
  var _a4;
  return ((_a4 = web3Context === null || web3Context === undefined ? undefined : web3Context.transactionTypeParser) !== null && _a4 !== undefined ? _a4 : defaultTransactionTypeParser)(transaction);
};
var detectRawTransactionType = (transaction) => transaction[0] > 127 ? "0x0" : toHex(transaction[0]);

// node_modules/web3-eth/lib/esm/schemas.js
var accessListItemSchema = {
  type: "object",
  properties: {
    address: {
      format: "address"
    },
    storageKeys: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var accessListSchema = {
  type: "array",
  items: Object.assign({}, accessListItemSchema)
};
var accessListResultSchema = {
  type: "object",
  properties: {
    accessList: Object.assign({}, accessListSchema),
    gasUsed: {
      type: "string"
    }
  }
};
var chainSchema = {
  type: "string",
  enum: ["goerli", "kovan", "mainnet", "rinkeby", "ropsten", "sepolia"]
};
var hardforkSchema = {
  type: "string",
  enum: [
    "arrowGlacier",
    "berlin",
    "byzantium",
    "chainstart",
    "constantinople",
    "dao",
    "homestead",
    "istanbul",
    "london",
    "merge",
    "muirGlacier",
    "petersburg",
    "shanghai",
    "spuriousDragon",
    "tangerineWhistle"
  ]
};
var customChainSchema = {
  type: "object",
  properties: {
    name: {
      format: "string"
    },
    networkId: {
      format: "uint"
    },
    chainId: {
      format: "uint"
    }
  }
};
var transactionSchema = {
  type: "object",
  properties: {
    from: {
      format: "address"
    },
    to: {
      oneOf: [{ format: "address" }, { type: "null" }]
    },
    value: {
      format: "uint"
    },
    gas: {
      format: "uint"
    },
    gasPrice: {
      format: "uint"
    },
    effectiveGasPrice: {
      format: "uint"
    },
    type: {
      format: "uint"
    },
    maxFeePerGas: {
      format: "uint"
    },
    maxPriorityFeePerGas: {
      format: "uint"
    },
    accessList: Object.assign({}, accessListSchema),
    data: {
      format: "bytes"
    },
    input: {
      format: "bytes"
    },
    nonce: {
      format: "uint"
    },
    chain: Object.assign({}, chainSchema),
    hardfork: Object.assign({}, hardforkSchema),
    chainId: {
      format: "uint"
    },
    networkId: {
      format: "uint"
    },
    common: {
      type: "object",
      properties: {
        customChain: Object.assign({}, customChainSchema),
        baseChain: Object.assign({}, chainSchema),
        hardfork: Object.assign({}, hardforkSchema)
      }
    },
    gasLimit: {
      format: "uint"
    },
    v: {
      format: "uint"
    },
    r: {
      format: "bytes32"
    },
    s: {
      format: "bytes32"
    }
  }
};
var transactionInfoSchema = {
  type: "object",
  properties: Object.assign(Object.assign({}, transactionSchema.properties), { blockHash: {
    format: "bytes32"
  }, blockNumber: {
    format: "uint"
  }, hash: {
    format: "bytes32"
  }, transactionIndex: {
    format: "uint"
  }, from: {
    format: "address"
  }, to: {
    oneOf: [{ format: "address" }, { type: "null" }]
  }, value: {
    format: "uint"
  }, gas: {
    format: "uint"
  }, gasPrice: {
    format: "uint"
  }, effectiveGasPrice: {
    format: "uint"
  }, type: {
    format: "uint"
  }, maxFeePerGas: {
    format: "uint"
  }, maxPriorityFeePerGas: {
    format: "uint"
  }, accessList: Object.assign({}, accessListSchema), data: {
    format: "bytes"
  }, input: {
    format: "bytes"
  }, nonce: {
    format: "uint"
  }, gasLimit: {
    format: "uint"
  }, v: {
    format: "uint"
  }, r: {
    format: "bytes32"
  }, s: {
    format: "bytes32"
  } })
};
var blockSchema = {
  type: "object",
  properties: {
    parentHash: {
      format: "bytes32"
    },
    sha3Uncles: {
      format: "bytes32"
    },
    miner: {
      format: "bytes"
    },
    stateRoot: {
      format: "bytes32"
    },
    transactionsRoot: {
      format: "bytes32"
    },
    receiptsRoot: {
      format: "bytes32"
    },
    logsBloom: {
      format: "bytes256"
    },
    difficulty: {
      format: "uint"
    },
    number: {
      format: "uint"
    },
    gasLimit: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    timestamp: {
      format: "uint"
    },
    extraData: {
      format: "bytes"
    },
    mixHash: {
      format: "bytes32"
    },
    nonce: {
      format: "uint"
    },
    totalDifficulty: {
      format: "uint"
    },
    baseFeePerGas: {
      format: "uint"
    },
    size: {
      format: "uint"
    },
    transactions: {
      oneOf: [
        {
          type: "array",
          items: Object.assign({}, transactionInfoSchema)
        },
        {
          type: "array",
          items: {
            format: "bytes32"
          }
        }
      ]
    },
    uncles: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    hash: {
      format: "bytes32"
    }
  }
};
var withdrawalsSchema = {
  type: "object",
  properties: {
    index: {
      format: "uint"
    },
    validatorIndex: {
      format: "uint"
    },
    address: {
      format: "address"
    },
    amount: {
      format: "uint"
    }
  }
};
var blockHeaderSchema = {
  type: "object",
  properties: {
    author: {
      format: "bytes32"
    },
    hash: {
      format: "bytes32"
    },
    parentHash: {
      format: "bytes32"
    },
    receiptsRoot: {
      format: "bytes32"
    },
    miner: {
      format: "bytes"
    },
    stateRoot: {
      format: "bytes32"
    },
    transactionsRoot: {
      format: "bytes32"
    },
    withdrawalsRoot: {
      format: "bytes32"
    },
    logsBloom: {
      format: "bytes256"
    },
    difficulty: {
      format: "uint"
    },
    totalDifficulty: {
      format: "uint"
    },
    number: {
      format: "uint"
    },
    gasLimit: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    timestamp: {
      format: "uint"
    },
    extraData: {
      format: "bytes"
    },
    nonce: {
      format: "uint"
    },
    sha3Uncles: {
      format: "bytes32"
    },
    size: {
      format: "uint"
    },
    baseFeePerGas: {
      format: "uint"
    },
    excessDataGas: {
      format: "uint"
    },
    mixHash: {
      format: "bytes32"
    },
    transactions: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    uncles: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    withdrawals: {
      type: "array",
      items: Object.assign({}, withdrawalsSchema)
    }
  }
};
var logSchema = {
  type: "object",
  properties: {
    removed: {
      format: "bool"
    },
    logIndex: {
      format: "uint"
    },
    transactionIndex: {
      format: "uint"
    },
    transactionHash: {
      format: "bytes32"
    },
    blockHash: {
      format: "bytes32"
    },
    blockNumber: {
      format: "uint"
    },
    address: {
      format: "address"
    },
    data: {
      format: "bytes"
    },
    topics: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var syncSchema = {
  type: "object",
  properties: {
    startingBlock: {
      format: "string"
    },
    currentBlock: {
      format: "string"
    },
    highestBlock: {
      format: "string"
    },
    knownStates: {
      format: "string"
    },
    pulledStates: {
      format: "string"
    }
  }
};
var transactionReceiptSchema = {
  type: "object",
  properties: {
    transactionHash: {
      format: "bytes32"
    },
    transactionIndex: {
      format: "uint"
    },
    blockHash: {
      format: "bytes32"
    },
    blockNumber: {
      format: "uint"
    },
    from: {
      format: "address"
    },
    to: {
      format: "address"
    },
    cumulativeGasUsed: {
      format: "uint"
    },
    gasUsed: {
      format: "uint"
    },
    effectiveGasPrice: {
      format: "uint"
    },
    contractAddress: {
      format: "address"
    },
    logs: {
      type: "array",
      items: Object.assign({}, logSchema)
    },
    logsBloom: {
      format: "bytes"
    },
    root: {
      format: "bytes"
    },
    status: {
      format: "uint"
    },
    type: {
      format: "uint"
    }
  }
};
var SignatureObjectSchema = {
  type: "object",
  properties: {
    messageHash: {
      format: "bytes"
    },
    r: {
      format: "bytes32"
    },
    s: {
      format: "bytes32"
    },
    v: {
      format: "bytes"
    },
    message: {
      format: "bytes"
    },
    signature: {
      format: "bytes"
    }
  }
};
var feeHistorySchema = {
  type: "object",
  properties: {
    oldestBlock: {
      format: "uint"
    },
    baseFeePerGas: {
      type: "array",
      items: {
        format: "uint"
      }
    },
    reward: {
      type: "array",
      items: {
        type: "array",
        items: {
          format: "uint"
        }
      }
    },
    gasUsedRatio: {
      type: "array",
      items: {
        type: "number"
      }
    }
  }
};
var storageProofSchema = {
  type: "object",
  properties: {
    key: {
      format: "bytes32"
    },
    value: {
      format: "uint"
    },
    proof: {
      type: "array",
      items: {
        format: "bytes32"
      }
    }
  }
};
var accountSchema = {
  type: "object",
  properties: {
    balance: {
      format: "uint"
    },
    codeHash: {
      format: "bytes32"
    },
    nonce: {
      format: "uint"
    },
    storageHash: {
      format: "bytes32"
    },
    accountProof: {
      type: "array",
      items: {
        format: "bytes32"
      }
    },
    storageProof: {
      type: "array",
      items: Object.assign({}, storageProofSchema)
    }
  }
};

// node_modules/web3-eth/lib/esm/utils/format_transaction.js
function formatTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options = {
  transactionSchema: transactionInfoSchema,
  fillInputAndData: false
}) {
  var _a4, _b;
  let formattedTransaction = mergeDeep({}, transaction);
  if (!isNullish(transaction === null || transaction === undefined ? undefined : transaction.common)) {
    formattedTransaction.common = Object.assign({}, transaction.common);
    if (!isNullish((_a4 = transaction.common) === null || _a4 === undefined ? undefined : _a4.customChain))
      formattedTransaction.common.customChain = Object.assign({}, transaction.common.customChain);
  }
  formattedTransaction = format((_b = options.transactionSchema) !== null && _b !== undefined ? _b : transactionInfoSchema, formattedTransaction, returnFormat);
  if (!isNullish(formattedTransaction.data) && !isNullish(formattedTransaction.input) && toHex(formattedTransaction.data) !== toHex(formattedTransaction.input))
    throw new TransactionDataAndInputError({
      data: bytesToHex2(formattedTransaction.data),
      input: bytesToHex2(formattedTransaction.input)
    });
  if (options.fillInputAndData) {
    if (!isNullish(formattedTransaction.data)) {
      formattedTransaction.input = formattedTransaction.data;
    } else if (!isNullish(formattedTransaction.input)) {
      formattedTransaction.data = formattedTransaction.input;
    }
  }
  if (!isNullish(formattedTransaction.gasLimit)) {
    formattedTransaction.gas = formattedTransaction.gasLimit;
    delete formattedTransaction.gasLimit;
  }
  return formattedTransaction;
}

// node_modules/web3-eth/lib/esm/utils/decode_signed_transaction.js
function decodeSignedTransaction(encodedSignedTransaction, returnFormat, options = { fillInputAndData: false }) {
  return {
    raw: format({ format: "bytes" }, encodedSignedTransaction, returnFormat),
    tx: formatTransaction(Object.assign(Object.assign({}, TransactionFactory.fromSerializedData(hexToBytes(encodedSignedTransaction)).toJSON()), { hash: bytesToHex2(keccak256Wrapper(hexToBytes(encodedSignedTransaction))), type: detectRawTransactionType(hexToBytes(encodedSignedTransaction)) }), returnFormat, { fillInputAndData: options.fillInputAndData })
  };
}

// node_modules/web3-net/lib/esm/rpc_method_wrappers.js
function getId2(web3Context, returnFormat) {
  return __awaiter18(this, undefined, undefined, function* () {
    const response = yield exports_net_rpc_methods.getId(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getPeerCount2(web3Context, returnFormat) {
  return __awaiter18(this, undefined, undefined, function* () {
    const response = yield exports_net_rpc_methods.getPeerCount(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
var __awaiter18 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var isListening2 = (web3Context) => __awaiter18(undefined, undefined, undefined, function* () {
  return exports_net_rpc_methods.isListening(web3Context.requestManager);
});

// node_modules/web3-net/lib/esm/net.js
var __awaiter19 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Net extends Web3Context {
  getId(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter19(this, undefined, undefined, function* () {
      return getId2(this, returnFormat);
    });
  }
  getPeerCount(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter19(this, undefined, undefined, function* () {
      return getPeerCount2(this, returnFormat);
    });
  }
  isListening() {
    return __awaiter19(this, undefined, undefined, function* () {
      return isListening2(this);
    });
  }
}
// node_modules/web3-eth/lib/esm/constants.js
var ALL_EVENTS = "ALLEVENTS";
var ALL_EVENTS_ABI = {
  name: ALL_EVENTS,
  signature: "",
  type: "event",
  inputs: []
};
var NUMBER_DATA_FORMAT = { bytes: FMT_BYTES.HEX, number: FMT_NUMBER.NUMBER };

// node_modules/web3-eth/lib/esm/utils/get_transaction_gas_pricing.js
var getEip1559GasPricing = function(transaction, web3Context, returnFormat) {
  var _a4, _b, _c;
  return __awaiter20(this, undefined, undefined, function* () {
    const block4 = yield getBlock(web3Context, web3Context.defaultBlock, false, returnFormat);
    if (isNullish(block4.baseFeePerGas))
      throw new Eip1559NotSupportedError;
    if (!isNullish(transaction.gasPrice)) {
      const convertedTransactionGasPrice = format({ format: "uint" }, transaction.gasPrice, returnFormat);
      return {
        maxPriorityFeePerGas: convertedTransactionGasPrice,
        maxFeePerGas: convertedTransactionGasPrice
      };
    }
    return {
      maxPriorityFeePerGas: format({ format: "uint" }, (_a4 = transaction.maxPriorityFeePerGas) !== null && _a4 !== undefined ? _a4 : web3Context.defaultMaxPriorityFeePerGas, returnFormat),
      maxFeePerGas: format({ format: "uint" }, (_b = transaction.maxFeePerGas) !== null && _b !== undefined ? _b : BigInt(block4.baseFeePerGas) * BigInt(2) + BigInt((_c = transaction.maxPriorityFeePerGas) !== null && _c !== undefined ? _c : web3Context.defaultMaxPriorityFeePerGas), returnFormat)
    };
  });
};
function getTransactionGasPricing(transaction, web3Context, returnFormat) {
  return __awaiter20(this, undefined, undefined, function* () {
    const transactionType = getTransactionType(transaction, web3Context);
    if (!isNullish(transactionType)) {
      if (transactionType.startsWith("-"))
        throw new UnsupportedTransactionTypeError(transactionType);
      if (Number(transactionType) < 0 || Number(transactionType) > 127)
        throw new UnsupportedTransactionTypeError(transactionType);
      if (isNullish(transaction.gasPrice) && (transactionType === "0x0" || transactionType === "0x1"))
        return {
          gasPrice: yield getGasPrice2(web3Context, returnFormat),
          maxPriorityFeePerGas: undefined,
          maxFeePerGas: undefined
        };
      if (transactionType === "0x2") {
        return Object.assign({ gasPrice: undefined }, yield getEip1559GasPricing(transaction, web3Context, returnFormat));
      }
    }
    return;
  });
}
var __awaiter20 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/transaction_builder.js
function defaultTransactionBuilder(options) {
  var _a4, _b;
  return __awaiter21(this, undefined, undefined, function* () {
    let populatedTransaction = format(transactionSchema, options.transaction, DEFAULT_RETURN_FORMAT);
    if (isNullish(populatedTransaction.from)) {
      populatedTransaction.from = getTransactionFromOrToAttr("from", options.web3Context, undefined, options.privateKey);
    }
    if (isNullish(populatedTransaction.nonce)) {
      populatedTransaction.nonce = yield getTransactionNonce(options.web3Context, populatedTransaction.from, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.value)) {
      populatedTransaction.value = "0x0";
    }
    if (!isNullish(populatedTransaction.data)) {
      if (!isNullish(populatedTransaction.input) && populatedTransaction.data !== populatedTransaction.input)
        throw new TransactionDataAndInputError({
          data: bytesToHex2(populatedTransaction.data),
          input: bytesToHex2(populatedTransaction.input)
        });
      if (!populatedTransaction.data.startsWith("0x"))
        populatedTransaction.data = `0x${populatedTransaction.data}`;
    } else if (!isNullish(populatedTransaction.input)) {
      if (!populatedTransaction.input.startsWith("0x"))
        populatedTransaction.input = `0x${populatedTransaction.input}`;
    } else {
      populatedTransaction.input = "0x";
    }
    if (isNullish(populatedTransaction.common)) {
      if (options.web3Context.defaultCommon) {
        const common4 = options.web3Context.defaultCommon;
        const chainId = common4.customChain.chainId;
        const networkId = common4.customChain.networkId;
        const name = common4.customChain.name;
        populatedTransaction.common = Object.assign(Object.assign({}, common4), { customChain: { chainId, networkId, name } });
      }
      if (isNullish(populatedTransaction.chain)) {
        populatedTransaction.chain = options.web3Context.defaultChain;
      }
      if (isNullish(populatedTransaction.hardfork)) {
        populatedTransaction.hardfork = options.web3Context.defaultHardfork;
      }
    }
    if (isNullish(populatedTransaction.chainId) && isNullish((_a4 = populatedTransaction.common) === null || _a4 === undefined ? undefined : _a4.customChain.chainId)) {
      populatedTransaction.chainId = yield getChainId2(options.web3Context, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.networkId)) {
      populatedTransaction.networkId = (_b = options.web3Context.defaultNetworkId) !== null && _b !== undefined ? _b : yield getId2(options.web3Context, ETH_DATA_FORMAT);
    }
    if (isNullish(populatedTransaction.gasLimit) && !isNullish(populatedTransaction.gas)) {
      populatedTransaction.gasLimit = populatedTransaction.gas;
    }
    populatedTransaction.type = getTransactionType(populatedTransaction, options.web3Context);
    if (isNullish(populatedTransaction.accessList) && (populatedTransaction.type === "0x1" || populatedTransaction.type === "0x2")) {
      populatedTransaction.accessList = [];
    }
    if (options.fillGasPrice)
      populatedTransaction = Object.assign(Object.assign({}, populatedTransaction), yield getTransactionGasPricing(populatedTransaction, options.web3Context, ETH_DATA_FORMAT));
    if (isNullish(populatedTransaction.gas) && isNullish(populatedTransaction.gasLimit) && options.fillGasLimit) {
      const fillGasLimit = yield estimateGas2(options.web3Context, populatedTransaction, "latest", ETH_DATA_FORMAT);
      populatedTransaction = Object.assign(Object.assign({}, populatedTransaction), { gas: format({ format: "uint" }, fillGasLimit, ETH_DATA_FORMAT) });
    }
    return populatedTransaction;
  });
}
var __awaiter21 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getTransactionFromOrToAttr = (attr, web3Context, transaction, privateKey) => {
  if (transaction !== undefined && attr in transaction && transaction[attr] !== undefined) {
    if (typeof transaction[attr] === "string" && isAddress(transaction[attr])) {
      return transaction[attr];
    }
    if (!isHexStrict(transaction[attr]) && isNumber(transaction[attr])) {
      if (web3Context.wallet) {
        const account2 = web3Context.wallet.get(format({ format: "uint" }, transaction[attr], NUMBER_DATA_FORMAT));
        if (!isNullish(account2)) {
          return account2.address;
        }
        throw new LocalWalletNotAvailableError;
      }
      throw new LocalWalletNotAvailableError;
    } else {
      throw attr === "from" ? new InvalidTransactionWithSender(transaction.from) : new InvalidTransactionWithReceiver(transaction.to);
    }
  }
  if (attr === "from") {
    if (!isNullish(privateKey))
      return privateKeyToAddress(privateKey);
    if (!isNullish(web3Context.defaultAccount))
      return web3Context.defaultAccount;
  }
  return;
};
var getTransactionNonce = (web3Context, address6, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter21(undefined, undefined, undefined, function* () {
  if (isNullish(address6)) {
    throw new UnableToPopulateNonceError;
  }
  return getTransactionCount2(web3Context, address6, web3Context.defaultBlock, returnFormat);
});
var getTransactionType = (transaction, web3Context) => {
  const inferredType = detectTransactionType(transaction, web3Context);
  if (!isNullish(inferredType))
    return inferredType;
  if (!isNullish(web3Context.defaultTransactionType))
    return format({ format: "uint" }, web3Context.defaultTransactionType, ETH_DATA_FORMAT);
  return;
};
var transactionBuilder = (options) => __awaiter21(undefined, undefined, undefined, function* () {
  var _a4;
  return ((_a4 = options.web3Context.transactionBuilder) !== null && _a4 !== undefined ? _a4 : defaultTransactionBuilder)(Object.assign(Object.assign({}, options), { transaction: options.transaction }));
});

// node_modules/web3-eth/lib/esm/utils/reject_if_block_timeout.js
var resolveByPolling = function(web3Context, starterBlockNumber, transactionHash) {
  const pollingInterval = web3Context.transactionPollingInterval;
  const [intervalId, promiseToError] = rejectIfConditionAtInterval(() => __awaiter22(this, undefined, undefined, function* () {
    let lastBlockNumber;
    try {
      lastBlockNumber = yield getBlockNumber2(web3Context, NUMBER_DATA_FORMAT);
    } catch (error) {
      console.warn("An error happen while trying to get the block number", error);
      return;
    }
    const numberOfBlocks = lastBlockNumber - starterBlockNumber;
    if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
      return new TransactionBlockTimeoutError({
        starterBlockNumber,
        numberOfBlocks,
        transactionHash
      });
    }
    return;
  }), pollingInterval);
  const clean = () => {
    clearInterval(intervalId);
  };
  return [promiseToError, { clean }];
};
var resolveBySubscription = function(web3Context, starterBlockNumber, transactionHash) {
  var _a4;
  return __awaiter22(this, undefined, undefined, function* () {
    let needToWatchLater = true;
    let subscription;
    let resourceCleaner;
    function revertToPolling(reject, previousError) {
      if (previousError) {
        console.warn("error happened at subscription. So revert to polling...", previousError);
      }
      resourceCleaner.clean();
      needToWatchLater = false;
      const [promiseToError2, newResourceCleaner] = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
      resourceCleaner.clean = newResourceCleaner.clean;
      promiseToError2.catch((error) => reject(error));
    }
    try {
      subscription = yield (_a4 = web3Context.subscriptionManager) === null || _a4 === undefined ? undefined : _a4.subscribe("newHeads");
      resourceCleaner = {
        clean: () => {
          var _a5;
          if (subscription.id) {
            (_a5 = web3Context.subscriptionManager) === null || _a5 === undefined || _a5.removeSubscription(subscription).then(() => {
            }).catch(() => {
            });
          }
        }
      };
    } catch (error) {
      return resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    const promiseToError = new Promise((_, reject) => {
      try {
        subscription.on("data", (lastBlockHeader) => {
          needToWatchLater = false;
          if (!(lastBlockHeader === null || lastBlockHeader === undefined ? undefined : lastBlockHeader.number)) {
            return;
          }
          const numberOfBlocks = Number(BigInt(lastBlockHeader.number) - BigInt(starterBlockNumber));
          if (numberOfBlocks >= web3Context.transactionBlockTimeout) {
            reject(new TransactionBlockTimeoutError({
              starterBlockNumber,
              numberOfBlocks,
              transactionHash
            }));
          }
        });
        subscription.on("error", (error) => {
          revertToPolling(reject, error);
        });
      } catch (error) {
        revertToPolling(reject, error);
      }
      setTimeout(() => {
        if (needToWatchLater) {
          revertToPolling(reject);
        }
      }, web3Context.blockHeaderTimeout * 1000);
    });
    return [promiseToError, resourceCleaner];
  });
};
function rejectIfBlockTimeout(web3Context, transactionHash) {
  var _a4, _b;
  return __awaiter22(this, undefined, undefined, function* () {
    const { provider } = web3Context.requestManager;
    let callingRes;
    const starterBlockNumber = yield getBlockNumber2(web3Context, NUMBER_DATA_FORMAT);
    if (((_b = (_a4 = provider).supportsSubscriptions) === null || _b === undefined ? undefined : _b.call(_a4)) && web3Context.enableExperimentalFeatures.useSubscriptionWhenCheckingBlockTimeout) {
      callingRes = yield resolveBySubscription(web3Context, starterBlockNumber, transactionHash);
    } else {
      callingRes = resolveByPolling(web3Context, starterBlockNumber, transactionHash);
    }
    return callingRes;
  });
}
var __awaiter22 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/try_send_transaction.js
function trySendTransaction(web3Context, sendTransactionFunc, transactionHash) {
  return __awaiter23(this, undefined, undefined, function* () {
    const [timeoutId, rejectOnTimeout] = rejectIfTimeout(web3Context.transactionSendTimeout, new TransactionSendTimeoutError({
      numberOfSeconds: web3Context.transactionSendTimeout / 1000,
      transactionHash
    }));
    const [rejectOnBlockTimeout, blockTimeoutResourceCleaner] = yield rejectIfBlockTimeout(web3Context, transactionHash);
    try {
      return yield Promise.race([
        sendTransactionFunc(),
        rejectOnTimeout,
        rejectOnBlockTimeout
      ]);
    } finally {
      clearTimeout(timeoutId);
      blockTimeoutResourceCleaner.clean();
    }
  });
}
var __awaiter23 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/wait_for_transaction_receipt.js
function waitForTransactionReceipt(web3Context, transactionHash, returnFormat) {
  var _a4;
  return __awaiter24(this, undefined, undefined, function* () {
    const pollingInterval = (_a4 = web3Context.transactionReceiptPollingInterval) !== null && _a4 !== undefined ? _a4 : web3Context.transactionPollingInterval;
    const [awaitableTransactionReceipt, IntervalId] = pollTillDefinedAndReturnIntervalId(() => __awaiter24(this, undefined, undefined, function* () {
      try {
        return getTransactionReceipt2(web3Context, transactionHash, returnFormat);
      } catch (error) {
        console.warn("An error happen while trying to get the transaction receipt", error);
        return;
      }
    }), pollingInterval);
    const [timeoutId, rejectOnTimeout] = rejectIfTimeout(web3Context.transactionPollingTimeout, new TransactionPollingTimeoutError({
      numberOfSeconds: web3Context.transactionPollingTimeout / 1000,
      transactionHash
    }));
    const [rejectOnBlockTimeout, blockTimeoutResourceCleaner] = yield rejectIfBlockTimeout(web3Context, transactionHash);
    try {
      return yield Promise.race([
        awaitableTransactionReceipt,
        rejectOnTimeout,
        rejectOnBlockTimeout
      ]);
    } finally {
      if (timeoutId)
        clearTimeout(timeoutId);
      if (IntervalId)
        clearInterval(IntervalId);
      blockTimeoutResourceCleaner.clean();
    }
  });
}
var __awaiter24 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_by_polling.js
var __awaiter25 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var watchTransactionByPolling = ({ web3Context, transactionReceipt, transactionPromiEvent, returnFormat }) => {
  var _a4;
  let confirmations = 1;
  const intervalId = setInterval(() => {
    (() => __awaiter25(undefined, undefined, undefined, function* () {
      if (confirmations >= web3Context.transactionConfirmationBlocks)
        clearInterval(intervalId);
      const nextBlock = yield exports_eth_rpc_methods.getBlockByNumber(web3Context.requestManager, numberToHex2(BigInt(transactionReceipt.blockNumber) + BigInt(confirmations)), false);
      if (nextBlock === null || nextBlock === undefined ? undefined : nextBlock.hash) {
        confirmations += 1;
        transactionPromiEvent.emit("confirmation", {
          confirmations: format({ format: "uint" }, confirmations, returnFormat),
          receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),
          latestBlockHash: format({ format: "bytes32" }, nextBlock.hash, returnFormat)
        });
      }
    }))();
  }, (_a4 = web3Context.transactionReceiptPollingInterval) !== null && _a4 !== undefined ? _a4 : web3Context.transactionPollingInterval);
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_by_subscription.js
var __awaiter26 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var watchTransactionBySubscription = ({ web3Context, transactionReceipt, transactionPromiEvent, returnFormat }) => {
  let needToWatchLater = true;
  let lastCaughtBlockHash;
  setImmediate(() => {
    var _a4;
    (_a4 = web3Context.subscriptionManager) === null || _a4 === undefined || _a4.subscribe("newHeads").then((subscription) => {
      subscription.on("data", (newBlockHeader) => __awaiter26(undefined, undefined, undefined, function* () {
        var _a5;
        needToWatchLater = false;
        if (!(newBlockHeader === null || newBlockHeader === undefined ? undefined : newBlockHeader.number) || lastCaughtBlockHash === (newBlockHeader === null || newBlockHeader === undefined ? undefined : newBlockHeader.parentHash)) {
          return;
        }
        lastCaughtBlockHash = newBlockHeader === null || newBlockHeader === undefined ? undefined : newBlockHeader.parentHash;
        const confirmations = BigInt(newBlockHeader.number) - BigInt(transactionReceipt.blockNumber) + BigInt(1);
        transactionPromiEvent.emit("confirmation", {
          confirmations: format({ format: "uint" }, confirmations, returnFormat),
          receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),
          latestBlockHash: format({ format: "bytes32" }, newBlockHeader.parentHash, returnFormat)
        });
        if (confirmations >= web3Context.transactionConfirmationBlocks) {
          yield (_a5 = web3Context.subscriptionManager) === null || _a5 === undefined ? undefined : _a5.removeSubscription(subscription);
        }
      }));
      subscription.on("error", () => __awaiter26(undefined, undefined, undefined, function* () {
        var _b;
        yield (_b = web3Context.subscriptionManager) === null || _b === undefined ? undefined : _b.removeSubscription(subscription);
        needToWatchLater = false;
        watchTransactionByPolling({
          web3Context,
          transactionReceipt,
          transactionPromiEvent,
          returnFormat
        });
      }));
    }).catch(() => {
      needToWatchLater = false;
      watchTransactionByPolling({
        web3Context,
        transactionReceipt,
        transactionPromiEvent,
        returnFormat
      });
    });
  });
  setTimeout(() => {
    if (needToWatchLater) {
      watchTransactionByPolling({
        web3Context,
        transactionReceipt,
        transactionPromiEvent,
        returnFormat
      });
    }
  }, web3Context.blockHeaderTimeout * 1000);
};

// node_modules/web3-eth/lib/esm/utils/watch_transaction_for_confirmations.js
function watchTransactionForConfirmations(web3Context, transactionPromiEvent, transactionReceipt, transactionHash, returnFormat) {
  if (isNullish(transactionReceipt) || isNullish(transactionReceipt.blockHash))
    throw new TransactionMissingReceiptOrBlockHashError({
      receipt: transactionReceipt,
      blockHash: format({ format: "bytes32" }, transactionReceipt === null || transactionReceipt === undefined ? undefined : transactionReceipt.blockHash, returnFormat),
      transactionHash: format({ format: "bytes32" }, transactionHash, returnFormat)
    });
  if (!transactionReceipt.blockNumber)
    throw new TransactionReceiptMissingBlockNumberError({ receipt: transactionReceipt });
  transactionPromiEvent.emit("confirmation", {
    confirmations: format({ format: "uint" }, 1, returnFormat),
    receipt: format(transactionReceiptSchema, transactionReceipt, returnFormat),
    latestBlockHash: format({ format: "bytes32" }, transactionReceipt.blockHash, returnFormat)
  });
  const provider = web3Context.requestManager.provider;
  if (provider && "supportsSubscriptions" in provider && provider.supportsSubscriptions()) {
    watchTransactionBySubscription({
      web3Context,
      transactionReceipt,
      transactionPromiEvent,
      returnFormat
    });
  } else {
    watchTransactionByPolling({
      web3Context,
      transactionReceipt,
      transactionPromiEvent,
      returnFormat
    });
  }
}

// node_modules/web3-eth-abi/lib/esm/utils.js
var isAbiErrorFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "error";
var isAbiEventFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "event";
var isAbiFunctionFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "function";
var isAbiConstructorFragment = (item) => !isNullish2(item) && typeof item === "object" && !isNullish2(item.type) && item.type === "constructor";
var isSimplifiedStructFormat = (type) => typeof type === "object" && typeof type.components === "undefined" && typeof type.name === "undefined";
var mapStructNameAndType = (structName) => structName.includes("[]") ? { type: "tuple[]", name: structName.slice(0, -2) } : { type: "tuple", name: structName };
var mapStructToCoderFormat = (struct) => {
  const components = [];
  for (const key of Object.keys(struct)) {
    const item = struct[key];
    if (typeof item === "object") {
      components.push(Object.assign(Object.assign({}, mapStructNameAndType(key)), { components: mapStructToCoderFormat(item) }));
    } else {
      components.push({
        name: key,
        type: struct[key]
      });
    }
  }
  return components;
};
var flattenTypes = (includeTuple, puts) => {
  const types12 = [];
  puts.forEach((param) => {
    if (typeof param.components === "object") {
      if (!param.type.startsWith("tuple")) {
        throw new AbiError(`Invalid value given "${param.type}". Error: components found but type is not tuple.`);
      }
      const arrayBracket = param.type.indexOf("[");
      const suffix = arrayBracket >= 0 ? param.type.substring(arrayBracket) : "";
      const result = flattenTypes(includeTuple, param.components);
      if (Array.isArray(result) && includeTuple) {
        types12.push(`tuple(${result.join(",")})${suffix}`);
      } else if (!includeTuple) {
        types12.push(`(${result.join(",")})${suffix}`);
      } else {
        types12.push(`(${result.join()})`);
      }
    } else {
      types12.push(param.type);
    }
  });
  return types12;
};
var jsonInterfaceMethodToString = (json) => {
  var _a4, _b, _c, _d;
  if (isAbiErrorFragment(json) || isAbiEventFragment(json) || isAbiFunctionFragment(json)) {
    if ((_a4 = json.name) === null || _a4 === undefined ? undefined : _a4.includes("(")) {
      return json.name;
    }
    return `${(_b = json.name) !== null && _b !== undefined ? _b : ""}(${flattenTypes(false, (_c = json.inputs) !== null && _c !== undefined ? _c : []).join(",")})`;
  }
  return `(${flattenTypes(false, (_d = json.inputs) !== null && _d !== undefined ? _d : []).join(",")})`;
};

// node_modules/web3-eth-abi/lib/esm/api/errors_api.js
var encodeErrorSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiErrorFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeErrorSignature");
  }
  let name;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name = jsonInterfaceMethodToString(functionName);
  } else {
    name = functionName;
  }
  return sha3Raw(name);
};
// node_modules/web3-eth-abi/lib/esm/api/events_api.js
var encodeEventSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiEventFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeEventSignature");
  }
  let name;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name = jsonInterfaceMethodToString(functionName);
  } else {
    name = functionName;
  }
  return sha3Raw(name);
};
// node_modules/web3-eth-abi/lib/esm/coders/utils.js
var import_abitype = __toESM(require_dist2(), 1);
function alloc(size = 0) {
  var _a4;
  if (((_a4 = globalThis.Buffer) === null || _a4 === undefined ? undefined : _a4.alloc) !== undefined) {
    const buf = globalThis.Buffer.alloc(size);
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength);
  }
  return new Uint8Array(size);
}
function convertExternalAbiParameter(abiParam) {
  var _a4, _b;
  return Object.assign(Object.assign({}, abiParam), { name: (_a4 = abiParam.name) !== null && _a4 !== undefined ? _a4 : "", components: (_b = abiParam.components) === null || _b === undefined ? undefined : _b.map((c) => convertExternalAbiParameter(c)) });
}
function isAbiParameter(param) {
  return !isNullish2(param) && typeof param === "object" && !isNullish2(param.type) && typeof param.type === "string";
}
function toAbiParams(abi2) {
  return abi2.map((input) => {
    var _a4;
    if (isAbiParameter(input)) {
      return input;
    }
    if (typeof input === "string") {
      return convertExternalAbiParameter(import_abitype.parseAbiParameter(input.replace(/tuple/, "")));
    }
    if (isSimplifiedStructFormat(input)) {
      const structName = Object.keys(input)[0];
      const structInfo = mapStructNameAndType(structName);
      structInfo.name = (_a4 = structInfo.name) !== null && _a4 !== undefined ? _a4 : "";
      return Object.assign(Object.assign({}, structInfo), { components: mapStructToCoderFormat(input[structName]) });
    }
    throw new AbiError("Invalid abi");
  });
}
function extractArrayType(param) {
  const arrayParenthesisStart = param.type.lastIndexOf("[");
  const arrayParamType = param.type.substring(0, arrayParenthesisStart);
  const sizeString = param.type.substring(arrayParenthesisStart);
  let size = -1;
  if (sizeString !== "[]") {
    size = Number(sizeString.slice(1, -1));
    if (isNaN(size)) {
      throw new AbiError("Invalid fixed array size", { size: sizeString });
    }
  }
  return {
    param: { type: arrayParamType, name: "", components: param.components },
    size
  };
}
function isDynamic(param) {
  var _a4, _b;
  if (param.type === "string" || param.type === "bytes" || param.type.endsWith("[]"))
    return true;
  if (param.type === "tuple") {
    return (_b = (_a4 = param.components) === null || _a4 === undefined ? undefined : _a4.some(isDynamic)) !== null && _b !== undefined ? _b : false;
  }
  if (param.type.endsWith("]")) {
    return isDynamic(extractArrayType(param).param);
  }
  return false;
}
var WORD_SIZE = 32;

// node_modules/web3-eth-abi/lib/esm/coders/base/address.js
function encodeAddress(param, input) {
  if (typeof input !== "string") {
    throw new AbiError("address type expects string as input type", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  let address6 = input.toLowerCase();
  if (!address6.startsWith("0x")) {
    address6 = `0x${address6}`;
  }
  if (!isAddress(address6)) {
    throw new AbiError("provided input is not valid address", {
      value: input,
      name: param.name,
      type: param.type
    });
  }
  const addressBytes = exports_utils.hexToUint8Array(address6);
  const encoded = alloc(WORD_SIZE);
  encoded.set(addressBytes, ADDRESS_OFFSET);
  return {
    dynamic: false,
    encoded
  };
}
function decodeAddress(_param, bytes5) {
  const addressBytes = bytes5.subarray(ADDRESS_OFFSET, WORD_SIZE);
  if (addressBytes.length !== ADDRESS_BYTES_COUNT) {
    throw new AbiError("Invalid decoding input, not enough bytes to decode address", { bytes: bytes5 });
  }
  const result = exports_utils.uint8ArrayToHexString(addressBytes);
  return {
    result: toChecksumAddress(result),
    encoded: bytes5.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}
var ADDRESS_BYTES_COUNT = 20;
var ADDRESS_OFFSET = WORD_SIZE - ADDRESS_BYTES_COUNT;

// node_modules/web3-eth-abi/lib/esm/coders/base/numbersLimits.js
var numberLimits = new Map;
var base = BigInt(256);
for (let i = 8;i <= 256; i += 8) {
  numberLimits.set(`uint${i}`, {
    min: BigInt(0),
    max: base - BigInt(1)
  });
  numberLimits.set(`int${i}`, {
    min: -base / BigInt(2),
    max: base / BigInt(2) - BigInt(1)
  });
  base *= BigInt(256);
}
numberLimits.set(`int`, numberLimits.get("int256"));
numberLimits.set(`uint`, numberLimits.get("uint256"));

// node_modules/web3-eth-abi/lib/esm/coders/base/number.js
var bigIntToUint8Array2 = function(value, byteLength = WORD_SIZE) {
  let hexValue;
  if (value < 0) {
    hexValue = (mask + value).toString(16);
  } else {
    hexValue = value.toString(16);
  }
  hexValue = padLeft2(hexValue, byteLength * 2);
  return exports_utils.hexToUint8Array(hexValue);
};
var uint8ArrayToBigInt2 = function(value, max) {
  const hexValue = exports_utils.uint8ArrayToHexString(value);
  const result = BigInt(hexValue);
  if (result <= max)
    return result;
  return result - mask;
};
function encodeNumber(param, input) {
  let value;
  try {
    value = toBigInt(input);
  } catch (e) {
    throw new AbiError("provided input is not number value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  if (value < limit.min) {
    throw new AbiError("provided input is less then minimum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (value > limit.max) {
    throw new AbiError("provided input is greater then maximum for given type", {
      type: param.type,
      value: input,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    dynamic: false,
    encoded: bigIntToUint8Array2(value)
  };
}
function decodeNumber(param, bytes5) {
  if (bytes5.length < WORD_SIZE) {
    throw new AbiError("Not enough bytes left to decode", { param, bytesLeft: bytes5.length });
  }
  const boolBytes = bytes5.subarray(0, WORD_SIZE);
  const limit = numberLimits.get(param.type);
  if (!limit) {
    throw new AbiError("provided abi contains invalid number datatype", { type: param.type });
  }
  const numberResult = uint8ArrayToBigInt2(boolBytes, limit.max);
  if (numberResult < limit.min) {
    throw new AbiError("decoded value is less then minimum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      minimum: limit.min.toString()
    });
  }
  if (numberResult > limit.max) {
    throw new AbiError("decoded value is greater then maximum for given type", {
      type: param.type,
      value: numberResult,
      name: param.name,
      maximum: limit.max.toString()
    });
  }
  return {
    result: numberResult,
    encoded: bytes5.subarray(WORD_SIZE),
    consumed: WORD_SIZE
  };
}
var mask = BigInt(1) << BigInt(256);

// node_modules/web3-eth-abi/lib/esm/coders/base/bool.js
function encodeBoolean(param, input) {
  let value;
  try {
    value = toBool(input);
  } catch (e) {
    if (e instanceof InvalidBooleanError) {
      throw new AbiError("provided input is not valid boolean value", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
  }
  return encodeNumber({ type: "uint8", name: "" }, Number(value));
}
function decodeBool(_param, bytes5) {
  const numberResult = decodeNumber({ type: "uint8", name: "" }, bytes5);
  if (numberResult.result > 1 || numberResult.result < 0) {
    throw new AbiError("Invalid boolean value encoded", {
      boolBytes: bytes5.subarray(0, WORD_SIZE),
      numberResult
    });
  }
  return {
    result: numberResult.result === BigInt(1),
    encoded: numberResult.encoded,
    consumed: WORD_SIZE
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/bytes.js
function encodeBytes(param, input) {
  if (typeof input === "string" && input.length % 2 !== 0) {
    input += "0";
  }
  if (!isBytes3(input)) {
    throw new AbiError("provided input is not valid bytes value", {
      type: param.type,
      value: input,
      name: param.name
    });
  }
  const bytes5 = bytesToUint8Array(input);
  const [, size] = param.type.split("bytes");
  if (size) {
    if (Number(size) > MAX_STATIC_BYTES_COUNT || Number(size) < 1) {
      throw new AbiError("invalid bytes type. Static byte type can have between 1 and 32 bytes", {
        type: param.type
      });
    }
    if (Number(size) < bytes5.length) {
      throw new AbiError("provided input size is different than type size", {
        type: param.type,
        value: input,
        name: param.name
      });
    }
    const encoded2 = alloc(WORD_SIZE);
    encoded2.set(bytes5);
    return {
      dynamic: false,
      encoded: encoded2
    };
  }
  const partsLength = Math.ceil(bytes5.length / WORD_SIZE);
  const encoded = alloc(WORD_SIZE + partsLength * WORD_SIZE);
  encoded.set(encodeNumber({ type: "uint32", name: "" }, bytes5.length).encoded);
  encoded.set(bytes5, WORD_SIZE);
  return {
    dynamic: true,
    encoded
  };
}
function decodeBytes(param, bytes5) {
  const [, sizeString] = param.type.split("bytes");
  let size = Number(sizeString);
  let remainingBytes = bytes5;
  let partsCount = 1;
  let consumed = 0;
  if (!size) {
    const result = decodeNumber({ type: "uint32", name: "" }, remainingBytes);
    size = Number(result.result);
    consumed += result.consumed;
    remainingBytes = result.encoded;
    partsCount = Math.ceil(size / WORD_SIZE);
  }
  if (size > bytes5.length) {
    throw new AbiError("there is not enough data to decode", {
      type: param.type,
      encoded: bytes5,
      size
    });
  }
  return {
    result: bytesToHex2(remainingBytes.subarray(0, size)),
    encoded: remainingBytes.subarray(partsCount * WORD_SIZE),
    consumed: consumed + partsCount * WORD_SIZE
  };
}
var MAX_STATIC_BYTES_COUNT = 32;

// node_modules/web3-eth-abi/lib/esm/coders/base/string.js
function encodeString(_param, input) {
  if (typeof input !== "string") {
    throw new AbiError("invalid input, should be string", { input });
  }
  const bytes6 = utf8ToBytes2(input);
  return encodeBytes({ type: "bytes", name: "" }, bytes6);
}
function decodeString(_param, bytes6) {
  const r = decodeBytes({ type: "bytes", name: "" }, bytes6);
  return {
    result: hexToUtf8(r.result),
    encoded: r.encoded,
    consumed: r.consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/utils.js
function encodeDynamicParams(encodedParams) {
  let staticSize = 0;
  let dynamicSize = 0;
  const staticParams = [];
  const dynamicParams = [];
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticSize += WORD_SIZE;
    } else {
      staticSize += encodedParam.encoded.length;
    }
  }
  for (const encodedParam of encodedParams) {
    if (encodedParam.dynamic) {
      staticParams.push(encodeNumber({ type: "uint256", name: "" }, staticSize + dynamicSize));
      dynamicParams.push(encodedParam);
      dynamicSize += encodedParam.encoded.length;
    } else {
      staticParams.push(encodedParam);
    }
  }
  return uint8ArrayConcat(...staticParams.map((p) => p.encoded), ...dynamicParams.map((p) => p.encoded));
}

// node_modules/web3-eth-abi/lib/esm/coders/base/array.js
function encodeArray(param, values) {
  if (!Array.isArray(values)) {
    throw new AbiError("Expected value to be array", { abi: param, values });
  }
  const { size, param: arrayItemParam } = extractArrayType(param);
  const encodedParams = values.map((v) => encodeParamFromAbiParameter(arrayItemParam, v));
  const dynamic = size === -1;
  const dynamicItems = encodedParams.length > 0 && encodedParams[0].dynamic;
  if (!dynamic && values.length !== size) {
    throw new AbiError("Given arguments count doesn't match array length", {
      arrayLength: size,
      argumentsLength: values.length
    });
  }
  if (dynamic || dynamicItems) {
    const encodingResult = encodeDynamicParams(encodedParams);
    if (dynamic) {
      const encodedLength = encodeNumber({ type: "uint256", name: "" }, encodedParams.length).encoded;
      return {
        dynamic: true,
        encoded: encodedParams.length > 0 ? uint8ArrayConcat(encodedLength, encodingResult) : encodedLength
      };
    }
    return {
      dynamic: true,
      encoded: encodingResult
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat(...encodedParams.map((p) => p.encoded))
  };
}
function decodeArray(param, bytes6) {
  let { size, param: arrayItemParam } = extractArrayType(param);
  const dynamic = size === -1;
  let consumed = 0;
  const result = [];
  let remaining = bytes6;
  if (dynamic) {
    const lengthResult = decodeNumber({ type: "uint32", name: "" }, bytes6);
    size = Number(lengthResult.result);
    consumed = lengthResult.consumed;
    remaining = lengthResult.encoded;
  }
  const hasDynamicChild = isDynamic(arrayItemParam);
  if (hasDynamicChild) {
    for (let i = 0;i < size; i += 1) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, remaining.subarray(i * WORD_SIZE));
      consumed += offsetResult.consumed;
      const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, remaining.subarray(Number(offsetResult.result)));
      consumed += decodedChildResult.consumed;
      result.push(decodedChildResult.result);
    }
    return {
      result,
      encoded: remaining.subarray(consumed),
      consumed
    };
  }
  for (let i = 0;i < size; i += 1) {
    const decodedChildResult = decodeParamFromAbiParameter(arrayItemParam, bytes6.subarray(consumed));
    consumed += decodedChildResult.consumed;
    result.push(decodedChildResult.result);
  }
  return {
    result,
    encoded: bytes6.subarray(consumed),
    consumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/base/index.js
function encodeParamFromAbiParameter(param, value) {
  if (param.type === "string") {
    return encodeString(param, value);
  }
  if (param.type === "bool") {
    return encodeBoolean(param, value);
  }
  if (param.type === "address") {
    return encodeAddress(param, value);
  }
  if (param.type === "tuple") {
    return encodeTuple(param, value);
  }
  if (param.type.endsWith("]")) {
    return encodeArray(param, value);
  }
  if (param.type.startsWith("bytes")) {
    return encodeBytes(param, value);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return encodeNumber(param, value);
  }
  throw new AbiError("Unsupported", {
    param,
    value
  });
}
function decodeParamFromAbiParameter(param, bytes7) {
  if (param.type === "string") {
    return decodeString(param, bytes7);
  }
  if (param.type === "bool") {
    return decodeBool(param, bytes7);
  }
  if (param.type === "address") {
    return decodeAddress(param, bytes7);
  }
  if (param.type === "tuple") {
    return decodeTuple(param, bytes7);
  }
  if (param.type.endsWith("]")) {
    return decodeArray(param, bytes7);
  }
  if (param.type.startsWith("bytes")) {
    return decodeBytes(param, bytes7);
  }
  if (param.type.startsWith("uint") || param.type.startsWith("int")) {
    return decodeNumber(param, bytes7);
  }
  throw new AbiError("Unsupported", {
    param,
    bytes: bytes7
  });
}

// node_modules/web3-eth-abi/lib/esm/coders/base/tuple.js
function encodeTuple(param, input) {
  var _a4, _b, _c;
  let dynamic = false;
  if (!Array.isArray(input) && typeof input !== "object") {
    throw new AbiError("param must be either Array or Object", {
      param,
      input
    });
  }
  const narrowedInput = input;
  const encoded = [];
  for (let i = 0;i < ((_b = (_a4 = param.components) === null || _a4 === undefined ? undefined : _a4.length) !== null && _b !== undefined ? _b : 0); i += 1) {
    const paramComponent = param.components[i];
    let result;
    if (Array.isArray(narrowedInput)) {
      if (i >= narrowedInput.length) {
        throw new AbiError("input param length missmatch", {
          param,
          input
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, narrowedInput[i]);
    } else {
      const paramInput = narrowedInput[(_c = paramComponent.name) !== null && _c !== undefined ? _c : ""];
      if (paramInput === undefined || paramInput === null) {
        throw new AbiError("missing input defined in abi", {
          param,
          input,
          paramName: paramComponent.name
        });
      }
      result = encodeParamFromAbiParameter(paramComponent, paramInput);
    }
    if (result.dynamic) {
      dynamic = true;
    }
    encoded.push(result);
  }
  if (dynamic) {
    return {
      dynamic: true,
      encoded: encodeDynamicParams(encoded)
    };
  }
  return {
    dynamic: false,
    encoded: uint8ArrayConcat(...encoded.map((e) => e.encoded))
  };
}
function decodeTuple(param, bytes7) {
  const result = {
    __length__: 0
  };
  let consumed = 0;
  if (!param.components) {
    return {
      result,
      encoded: bytes7,
      consumed
    };
  }
  let dynamicConsumed = 0;
  for (const [index, childParam] of param.components.entries()) {
    let decodedResult;
    if (isDynamic(childParam)) {
      const offsetResult = decodeNumber({ type: "uint32", name: "" }, bytes7.subarray(consumed));
      decodedResult = decodeParamFromAbiParameter(childParam, bytes7.subarray(Number(offsetResult.result)));
      consumed += offsetResult.consumed;
      dynamicConsumed += decodedResult.consumed;
    } else {
      decodedResult = decodeParamFromAbiParameter(childParam, bytes7.subarray(consumed));
      consumed += decodedResult.consumed;
    }
    result.__length__ += 1;
    result[index] = decodedResult.result;
    if (childParam.name && childParam.name !== "") {
      result[childParam.name] = decodedResult.result;
    }
  }
  return {
    encoded: bytes7.subarray(consumed + dynamicConsumed),
    result,
    consumed: consumed + dynamicConsumed
  };
}

// node_modules/web3-eth-abi/lib/esm/coders/decode.js
function decodeParameters(abis, bytes7, _loose) {
  const abiParams = toAbiParams(abis);
  const bytesArray = exports_utils.hexToUint8Array(bytes7);
  return decodeTuple({ type: "tuple", name: "", components: abiParams }, bytesArray).result;
}

// node_modules/web3-eth-abi/lib/esm/coders/encode.js
var inferParamsAbi = function(params) {
  const abi2 = [];
  params.forEach((param) => {
    if (Array.isArray(param)) {
      const inferredParams = inferParamsAbi(param);
      abi2.push({
        type: "tuple",
        components: inferredParams,
        name: ""
      });
    } else {
      abi2.push({ type: toHex(param, true) });
    }
  });
  return abi2;
};
function encodeParameters(abi2, params) {
  if ((abi2 === null || abi2 === undefined ? undefined : abi2.length) !== params.length) {
    throw new AbiError("Invalid number of values received for given ABI", {
      expected: abi2 === null || abi2 === undefined ? undefined : abi2.length,
      received: params.length
    });
  }
  const abiParams = toAbiParams(abi2);
  return exports_utils.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
}
function inferTypesAndEncodeParameters(params) {
  try {
    const abiParams = inferParamsAbi(params);
    return exports_utils.uint8ArrayToHexString(encodeTuple({ type: "tuple", name: "", components: abiParams }, params).encoded);
  } catch (e) {
    throw new AbiError("Could not infer types from given params", {
      params
    });
  }
}

// node_modules/web3-eth-abi/lib/esm/api/parameters_api.js
var encodeParameter = (abi2, param) => encodeParameters([abi2], [param]);
var decodeParametersWith = (abis, bytes7, loose) => {
  try {
    if (abis.length > 0 && (!bytes7 || bytes7 === "0x" || bytes7 === "0X")) {
      throw new AbiError("Returned values aren't valid, did it run Out of Gas? You might also see this error if you are not using the correct ABI for the contract you are retrieving data from, requesting data from a block number that does not exist, or querying a node which is not fully synced.");
    }
    return decodeParameters(abis, `0x${bytes7.replace(/0x/i, "")}`, loose);
  } catch (err) {
    throw new AbiError(`Parameter decoding error: ${err.message}`, {
      internalErr: err
    });
  }
};
var decodeParameters2 = (abi2, bytes7) => decodeParametersWith(abi2, bytes7, false);
var decodeParameter = (abi2, bytes7) => decodeParameters2([abi2], bytes7)["0"];

// node_modules/web3-eth-abi/lib/esm/api/functions_api.js
var encodeFunctionSignature = (functionName) => {
  if (typeof functionName !== "string" && !isAbiFunctionFragment(functionName)) {
    throw new AbiError("Invalid parameter value in encodeFunctionSignature");
  }
  let name;
  if (functionName && (typeof functionName === "function" || typeof functionName === "object")) {
    name = jsonInterfaceMethodToString(functionName);
  } else {
    name = functionName;
  }
  return sha3Raw(name).slice(0, 10);
};
var encodeFunctionCall = (jsonInterface, params) => {
  var _a4;
  if (!isAbiFunctionFragment(jsonInterface)) {
    throw new AbiError("Invalid parameter value in encodeFunctionCall");
  }
  return `${encodeFunctionSignature(jsonInterface)}${encodeParameters((_a4 = jsonInterface.inputs) !== null && _a4 !== undefined ? _a4 : [], params !== null && params !== undefined ? params : []).replace("0x", "")}`;
};
// node_modules/web3-eth-abi/lib/esm/api/logs_api.js
var STATIC_TYPES = ["bool", "string", "int", "uint", "address", "fixed", "ufixed"];
var _decodeParameter = (inputType, clonedTopic) => inputType === "string" ? clonedTopic : decodeParameter(inputType, clonedTopic);
var decodeLog = (inputs, data, topics) => {
  const clonedTopics = Array.isArray(topics) ? topics : [topics];
  const indexedInputs = {};
  const nonIndexedInputs = {};
  for (const [i, input] of inputs.entries()) {
    if (input.indexed) {
      indexedInputs[i] = input;
    } else {
      nonIndexedInputs[i] = input;
    }
  }
  const decodedNonIndexedInputs = data ? decodeParametersWith(Object.values(nonIndexedInputs), data, true) : { __length__: 0 };
  const offset = clonedTopics.length - Object.keys(indexedInputs).length;
  const decodedIndexedInputs = Object.values(indexedInputs).map((input, index) => STATIC_TYPES.some((s) => input.type.startsWith(s)) ? _decodeParameter(input.type, clonedTopics[index + offset]) : clonedTopics[index + offset]);
  const returnValues = { __length__: 0 };
  let indexedCounter = 0;
  let nonIndexedCounter = 0;
  for (const [i, res] of inputs.entries()) {
    returnValues[i] = res.type === "string" ? "" : undefined;
    if (indexedInputs[i]) {
      returnValues[i] = decodedIndexedInputs[indexedCounter];
      indexedCounter += 1;
    }
    if (nonIndexedInputs[i]) {
      returnValues[i] = decodedNonIndexedInputs[String(nonIndexedCounter)];
      nonIndexedCounter += 1;
    }
    if (res.name) {
      returnValues[res.name] = returnValues[i];
    }
    returnValues.__length__ += 1;
  }
  return returnValues;
};
// node_modules/web3-eth-abi/lib/esm/decode_contract_error_data.js
var decodeContractErrorData = (errorsAbi, error) => {
  if (error === null || error === undefined ? undefined : error.data) {
    let errorName;
    let errorSignature;
    let errorArgs;
    try {
      const errorSha = error.data.slice(0, 10);
      const errorAbi = errorsAbi.find((abi2) => encodeErrorSignature(abi2).startsWith(errorSha));
      if (errorAbi === null || errorAbi === undefined ? undefined : errorAbi.inputs) {
        errorName = errorAbi.name;
        errorSignature = jsonInterfaceMethodToString(errorAbi);
        errorArgs = decodeParameters2([...errorAbi.inputs], error.data.substring(10));
      }
    } catch (err) {
      console.error(err);
    }
    if (errorName) {
      error.setDecodedProperties(errorName, errorSignature, errorArgs);
    }
  }
};
// node_modules/web3-eth/lib/esm/utils/get_revert_reason.js
function getRevertReason(web3Context, transaction, contractAbi, returnFormat = DEFAULT_RETURN_FORMAT) {
  return __awaiter27(this, undefined, undefined, function* () {
    try {
      yield call2(web3Context, transaction, web3Context.defaultBlock, returnFormat);
      return;
    } catch (error) {
      return parseTransactionError(error, contractAbi);
    }
  });
}
var __awaiter27 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var parseTransactionError = (error, contractAbi) => {
  var _a4, _b, _c, _d, _e;
  if (error instanceof ContractExecutionError && error.cause instanceof Eip838ExecutionError) {
    if (contractAbi !== undefined) {
      const errorsAbi = contractAbi.filter((abi2) => isAbiErrorFragment(abi2));
      decodeContractErrorData(errorsAbi, error.cause);
      return {
        reason: error.cause.message,
        signature: (_a4 = error.cause.data) === null || _a4 === undefined ? undefined : _a4.slice(0, 10),
        data: (_b = error.cause.data) === null || _b === undefined ? undefined : _b.substring(10),
        customErrorName: error.cause.errorName,
        customErrorDecodedSignature: error.cause.errorSignature,
        customErrorArguments: error.cause.errorArgs
      };
    }
    return {
      reason: error.cause.message,
      signature: (_c = error.cause.data) === null || _c === undefined ? undefined : _c.slice(0, 10),
      data: (_d = error.cause.data) === null || _d === undefined ? undefined : _d.substring(10)
    };
  }
  if (error instanceof InvalidResponseError && !Array.isArray((_e = error.cause) === null || _e === undefined ? undefined : _e.errors) && error.cause !== undefined) {
    return error.cause.message;
  }
  throw error;
};

// node_modules/web3-eth/lib/esm/utils/get_transaction_error.js
function getTransactionError(web3Context, transactionFormatted, transactionReceiptFormatted, receivedError, contractAbi, knownReason) {
  return __awaiter28(this, undefined, undefined, function* () {
    let _reason = knownReason;
    if (_reason === undefined) {
      if (receivedError !== undefined) {
        _reason = parseTransactionError(receivedError);
      } else if (web3Context.handleRevert && transactionFormatted !== undefined) {
        _reason = yield getRevertReason(web3Context, transactionFormatted, contractAbi);
      }
    }
    let error;
    if (_reason === undefined) {
      error = new TransactionRevertedWithoutReasonError(transactionReceiptFormatted);
    } else if (typeof _reason === "string") {
      error = new TransactionRevertInstructionError(_reason, undefined, transactionReceiptFormatted);
    } else if (_reason.customErrorName !== undefined && _reason.customErrorDecodedSignature !== undefined && _reason.customErrorArguments !== undefined) {
      const reasonWithCustomError = _reason;
      error = new TransactionRevertWithCustomError(reasonWithCustomError.reason, reasonWithCustomError.customErrorName, reasonWithCustomError.customErrorDecodedSignature, reasonWithCustomError.customErrorArguments, reasonWithCustomError.signature, transactionReceiptFormatted, reasonWithCustomError.data);
    } else {
      error = new TransactionRevertInstructionError(_reason.reason, _reason.signature, transactionReceiptFormatted, _reason.data);
    }
    return error;
  });
}
var __awaiter28 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

// node_modules/web3-eth/lib/esm/utils/decoding.js
var decodeEventABI = (event, data, jsonInterface, returnFormat = DEFAULT_RETURN_FORMAT) => {
  var _a4, _b, _c, _d, _e;
  let modifiedEvent = Object.assign({}, event);
  const result = format(logSchema, data, returnFormat);
  if ([ALL_EVENTS, "allEvents"].includes(modifiedEvent.name)) {
    const matchedEvent = jsonInterface.find((j) => j.signature === data.topics[0]);
    if (matchedEvent) {
      modifiedEvent = matchedEvent;
    } else {
      modifiedEvent = { anonymous: true };
    }
  }
  modifiedEvent.inputs = (_b = (_a4 = modifiedEvent.inputs) !== null && _a4 !== undefined ? _a4 : event.inputs) !== null && _b !== undefined ? _b : [];
  if (!modifiedEvent.anonymous) {
    let indexedInputs = 0;
    ((_c = modifiedEvent.inputs) !== null && _c !== undefined ? _c : []).forEach((input) => {
      if (input.indexed) {
        indexedInputs += 1;
      }
    });
    if (indexedInputs > 0 && (data === null || data === undefined ? undefined : data.topics) && (data === null || data === undefined ? undefined : data.topics.length) !== indexedInputs + 1) {
      modifiedEvent = Object.assign(Object.assign({}, modifiedEvent), { anonymous: true, inputs: [] });
    }
  }
  const argTopics = modifiedEvent.anonymous ? data.topics : ((_d = data.topics) !== null && _d !== undefined ? _d : []).slice(1);
  return Object.assign(Object.assign({}, result), { returnValues: decodeLog([...(_e = modifiedEvent.inputs) !== null && _e !== undefined ? _e : []], data.data, argTopics), event: modifiedEvent.name, signature: modifiedEvent.anonymous || !data.topics || data.topics.length === 0 || !data.topics[0] ? undefined : data.topics[0], raw: {
    data: data.data,
    topics: data.topics
  } });
};

// node_modules/web3-eth/lib/esm/utils/send_tx_helper.js
var __awaiter29 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class SendTxHelper {
  constructor({ options, web3Context, promiEvent, returnFormat }) {
    this.options = {
      checkRevertBeforeSending: true
    };
    this.options = options;
    this.web3Context = web3Context;
    this.promiEvent = promiEvent;
    this.returnFormat = returnFormat;
  }
  getReceiptWithEvents(data) {
    var _a4, _b;
    const result = Object.assign({}, data !== null && data !== undefined ? data : {});
    if (((_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.contractAbi) && result.logs && result.logs.length > 0) {
      result.events = {};
      for (const log of result.logs) {
        const event = decodeEventABI(ALL_EVENTS_ABI, log, (_b = this.options) === null || _b === undefined ? undefined : _b.contractAbi, this.returnFormat);
        if (event.event) {
          result.events[event.event] = event;
        }
      }
    }
    return result;
  }
  checkRevertBeforeSending(tx2) {
    return __awaiter29(this, undefined, undefined, function* () {
      if (this.options.checkRevertBeforeSending !== false) {
        const reason = yield getRevertReason(this.web3Context, tx2, this.options.contractAbi);
        if (reason !== undefined) {
          throw yield getTransactionError(this.web3Context, tx2, undefined, undefined, this.options.contractAbi, reason);
        }
      }
    });
  }
  emitSending(tx2) {
    if (this.promiEvent.listenerCount("sending") > 0) {
      this.promiEvent.emit("sending", tx2);
    }
  }
  populateGasPrice({ transactionFormatted, transaction }) {
    var _a4;
    return __awaiter29(this, undefined, undefined, function* () {
      let result = transactionFormatted;
      if (!((_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.ignoreGasPricing) && isNullish(transactionFormatted.gasPrice) && (isNullish(transaction.maxPriorityFeePerGas) || isNullish(transaction.maxFeePerGas))) {
        result = Object.assign(Object.assign({}, transactionFormatted), yield getTransactionGasPricing(transactionFormatted, this.web3Context, ETH_DATA_FORMAT));
      }
      return result;
    });
  }
  signAndSend({ wallet: wallet2, tx: tx2 }) {
    return __awaiter29(this, undefined, undefined, function* () {
      if (wallet2) {
        const signedTransaction = yield wallet2.signTransaction(tx2);
        return trySendTransaction(this.web3Context, () => __awaiter29(this, undefined, undefined, function* () {
          return exports_eth_rpc_methods.sendRawTransaction(this.web3Context.requestManager, signedTransaction.rawTransaction);
        }), signedTransaction.transactionHash);
      }
      return trySendTransaction(this.web3Context, () => __awaiter29(this, undefined, undefined, function* () {
        return exports_eth_rpc_methods.sendTransaction(this.web3Context.requestManager, tx2);
      }));
    });
  }
  emitSent(tx2) {
    if (this.promiEvent.listenerCount("sent") > 0) {
      this.promiEvent.emit("sent", tx2);
    }
  }
  emitTransactionHash(hash3) {
    if (this.promiEvent.listenerCount("transactionHash") > 0) {
      this.promiEvent.emit("transactionHash", hash3);
    }
  }
  emitReceipt(receipt) {
    if (this.promiEvent.listenerCount("receipt") > 0) {
      this.promiEvent.emit("receipt", receipt);
    }
  }
  handleError({ error, tx: tx2 }) {
    var _a4;
    return __awaiter29(this, undefined, undefined, function* () {
      let _error = error;
      if (_error instanceof ContractExecutionError && this.web3Context.handleRevert) {
        _error = yield getTransactionError(this.web3Context, tx2, undefined, undefined, (_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.contractAbi);
      }
      if ((_error instanceof InvalidResponseError || _error instanceof ContractExecutionError || _error instanceof TransactionRevertWithCustomError || _error instanceof TransactionRevertedWithoutReasonError || _error instanceof TransactionRevertInstructionError || _error instanceof TransactionPollingTimeoutError) && this.promiEvent.listenerCount("error") > 0) {
        this.promiEvent.emit("error", _error);
      }
      return _error;
    });
  }
  emitConfirmation({ receipt, transactionHash }) {
    if (this.promiEvent.listenerCount("confirmation") > 0) {
      watchTransactionForConfirmations(this.web3Context, this.promiEvent, receipt, transactionHash, this.returnFormat);
    }
  }
  handleResolve({ receipt, tx: tx2 }) {
    var _a4, _b, _c;
    return __awaiter29(this, undefined, undefined, function* () {
      if ((_a4 = this.options) === null || _a4 === undefined ? undefined : _a4.transactionResolver) {
        return (_b = this.options) === null || _b === undefined ? undefined : _b.transactionResolver(receipt);
      }
      if (receipt.status === BigInt(0)) {
        const error = yield getTransactionError(this.web3Context, tx2, receipt, undefined, (_c = this.options) === null || _c === undefined ? undefined : _c.contractAbi);
        if (this.promiEvent.listenerCount("error") > 0) {
          this.promiEvent.emit("error", error);
        }
        throw error;
      } else {
        return receipt;
      }
    });
  }
}

// node_modules/web3-eth/lib/esm/rpc_method_wrappers.js
function getHashRate2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getHashRate(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getGasPrice2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getGasPrice(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getMaxPriorityFeePerGas2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getMaxPriorityFeePerGas(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getBlockNumber2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getBlockNumber(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getBalance2(web3Context, address7, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getBalance(web3Context.requestManager, address7, blockNumberFormatted);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getStorageAt2(web3Context, address7, storageSlot, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const storageSlotFormatted = format({ format: "uint" }, storageSlot, ETH_DATA_FORMAT);
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getStorageAt(web3Context.requestManager, address7, storageSlotFormatted, blockNumberFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function getCode2(web3Context, address7, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getCode(web3Context.requestManager, address7, blockNumberFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function getBlock(web3Context, block4 = web3Context.defaultBlock, hydrated = false, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockByHash(web3Context.requestManager, blockHashFormatted, hydrated);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockByNumber(web3Context.requestManager, blockNumberFormatted, hydrated);
    }
    return format(blockSchema, response, returnFormat);
  });
}
function getBlockTransactionCount(web3Context, block4 = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockTransactionCountByHash(web3Context.requestManager, blockHashFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getBlockTransactionCountByNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getBlockUncleCount(web3Context, block4 = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleCountByBlockHash(web3Context.requestManager, blockHashFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleCountByBlockNumber(web3Context.requestManager, blockNumberFormatted);
    }
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getUncle(web3Context, block4 = web3Context.defaultBlock, uncleIndex, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const uncleIndexFormatted = format({ format: "uint" }, uncleIndex, ETH_DATA_FORMAT);
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, uncleIndexFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getUncleByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, uncleIndexFormatted);
    }
    return format(blockSchema, response, returnFormat);
  });
}
function getTransaction(web3Context, transactionHash, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, DEFAULT_RETURN_FORMAT);
    const response = yield exports_eth_rpc_methods.getTransactionByHash(web3Context.requestManager, transactionHashFormatted);
    return isNullish(response) ? response : formatTransaction(response, returnFormat, { fillInputAndData: true });
  });
}
function getPendingTransactions2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getPendingTransactions(web3Context.requestManager);
    return response.map((transaction) => formatTransaction(transaction, returnFormat, {
      fillInputAndData: true
    }));
  });
}
function getTransactionFromBlock(web3Context, block4 = web3Context.defaultBlock, transactionIndex, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionIndexFormatted = format({ format: "uint" }, transactionIndex, ETH_DATA_FORMAT);
    let response;
    if (isBytes3(block4)) {
      const blockHashFormatted = format({ format: "bytes32" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getTransactionByBlockHashAndIndex(web3Context.requestManager, blockHashFormatted, transactionIndexFormatted);
    } else {
      const blockNumberFormatted = isBlockTag(block4) ? block4 : format({ format: "uint" }, block4, ETH_DATA_FORMAT);
      response = yield exports_eth_rpc_methods.getTransactionByBlockNumberAndIndex(web3Context.requestManager, blockNumberFormatted, transactionIndexFormatted);
    }
    return isNullish(response) ? response : formatTransaction(response, returnFormat, { fillInputAndData: true });
  });
}
function getTransactionReceipt2(web3Context, transactionHash, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, DEFAULT_RETURN_FORMAT);
    const response = yield exports_eth_rpc_methods.getTransactionReceipt(web3Context.requestManager, transactionHashFormatted);
    return isNullish(response) ? response : format(transactionReceiptSchema, response, returnFormat);
  });
}
function getTransactionCount2(web3Context, address7, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getTransactionCount(web3Context.requestManager, address7, blockNumberFormatted);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function sendTransaction3(web3Context, transaction, returnFormat, options = { checkRevertBeforeSending: true }) {
  const promiEvent = new Web3PromiEvent((resolve, reject) => {
    setImmediate(() => {
      (() => __awaiter30(this, undefined, undefined, function* () {
        const sendTxHelper = new SendTxHelper({
          web3Context,
          promiEvent,
          options,
          returnFormat
        });
        let transactionFormatted = formatTransaction(Object.assign(Object.assign({}, transaction), { from: getTransactionFromOrToAttr("from", web3Context, transaction), to: getTransactionFromOrToAttr("to", web3Context, transaction) }), ETH_DATA_FORMAT);
        try {
          transactionFormatted = yield sendTxHelper.populateGasPrice({
            transaction,
            transactionFormatted
          });
          yield sendTxHelper.checkRevertBeforeSending(transactionFormatted);
          sendTxHelper.emitSending(transactionFormatted);
          let wallet2;
          if (web3Context.wallet && !isNullish(transactionFormatted.from)) {
            wallet2 = web3Context.wallet.get(transactionFormatted.from);
          }
          const transactionHash = yield sendTxHelper.signAndSend({
            wallet: wallet2,
            tx: transactionFormatted
          });
          const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, returnFormat);
          sendTxHelper.emitSent(transactionFormatted);
          sendTxHelper.emitTransactionHash(transactionHashFormatted);
          const transactionReceipt = yield waitForTransactionReceipt(web3Context, transactionHash, returnFormat);
          const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents(format(transactionReceiptSchema, transactionReceipt, returnFormat));
          sendTxHelper.emitReceipt(transactionReceiptFormatted);
          resolve(yield sendTxHelper.handleResolve({
            receipt: transactionReceiptFormatted,
            tx: transactionFormatted
          }));
          sendTxHelper.emitConfirmation({
            receipt: transactionReceiptFormatted,
            transactionHash
          });
        } catch (error) {
          reject(yield sendTxHelper.handleError({
            error,
            tx: transactionFormatted
          }));
        }
      }))();
    });
  });
  return promiEvent;
}
function sendSignedTransaction(web3Context, signedTransaction, returnFormat, options = { checkRevertBeforeSending: true }) {
  const promiEvent = new Web3PromiEvent((resolve, reject) => {
    setImmediate(() => {
      (() => __awaiter30(this, undefined, undefined, function* () {
        const sendTxHelper = new SendTxHelper({
          web3Context,
          promiEvent,
          options,
          returnFormat
        });
        const signedTransactionFormattedHex = format({ format: "bytes" }, signedTransaction, ETH_DATA_FORMAT);
        const unSerializedTransaction = TransactionFactory.fromSerializedData(bytesToUint8Array(hexToBytes(signedTransactionFormattedHex)));
        const unSerializedTransactionWithFrom = Object.assign(Object.assign({}, unSerializedTransaction.toJSON()), {
          from: unSerializedTransaction.getSenderAddress().toString()
        });
        try {
          const { v, r, s } = unSerializedTransactionWithFrom, txWithoutSigParams = __rest(unSerializedTransactionWithFrom, ["v", "r", "s"]);
          yield sendTxHelper.checkRevertBeforeSending(txWithoutSigParams);
          sendTxHelper.emitSending(signedTransactionFormattedHex);
          const transactionHash = yield trySendTransaction(web3Context, () => __awaiter30(this, undefined, undefined, function* () {
            return exports_eth_rpc_methods.sendRawTransaction(web3Context.requestManager, signedTransactionFormattedHex);
          }));
          sendTxHelper.emitSent(signedTransactionFormattedHex);
          const transactionHashFormatted = format({ format: "bytes32" }, transactionHash, returnFormat);
          sendTxHelper.emitTransactionHash(transactionHashFormatted);
          const transactionReceipt = yield waitForTransactionReceipt(web3Context, transactionHash, returnFormat);
          const transactionReceiptFormatted = sendTxHelper.getReceiptWithEvents(format(transactionReceiptSchema, transactionReceipt, returnFormat));
          sendTxHelper.emitReceipt(transactionReceiptFormatted);
          resolve(yield sendTxHelper.handleResolve({
            receipt: transactionReceiptFormatted,
            tx: unSerializedTransactionWithFrom
          }));
          sendTxHelper.emitConfirmation({
            receipt: transactionReceiptFormatted,
            transactionHash
          });
        } catch (error) {
          reject(yield sendTxHelper.handleError({
            error,
            tx: unSerializedTransactionWithFrom
          }));
        }
      }))();
    });
  });
  return promiEvent;
}
function sign4(web3Context, message, addressOrIndex, returnFormat) {
  var _a4;
  return __awaiter30(this, undefined, undefined, function* () {
    const messageFormatted = format({ format: "bytes" }, message, DEFAULT_RETURN_FORMAT);
    if ((_a4 = web3Context.wallet) === null || _a4 === undefined ? undefined : _a4.get(addressOrIndex)) {
      const wallet2 = web3Context.wallet.get(addressOrIndex);
      const signed = wallet2.sign(messageFormatted);
      return format(SignatureObjectSchema, signed, returnFormat);
    }
    if (typeof addressOrIndex === "number") {
      throw new SignatureError(message, 'RPC method "eth_sign" does not support index signatures');
    }
    const response = yield exports_eth_rpc_methods.sign(web3Context.requestManager, addressOrIndex, messageFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function signTransaction4(web3Context, transaction, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.signTransaction(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT));
    return isString(response) ? decodeSignedTransaction(response, returnFormat, {
      fillInputAndData: true
    }) : {
      raw: format({ format: "bytes" }, response.raw, returnFormat),
      tx: formatTransaction(response.tx, returnFormat, {
        fillInputAndData: true
      })
    };
  });
}
function call2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.call(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT), blockNumberFormatted);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
function estimateGas2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const transactionFormatted = formatTransaction(transaction, ETH_DATA_FORMAT);
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.estimateGas(web3Context.requestManager, transactionFormatted, blockNumberFormatted);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getLogs2(web3Context, filter3, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    let { toBlock, fromBlock } = filter3;
    if (!isNullish(toBlock)) {
      if (typeof toBlock === "number" || typeof toBlock === "bigint") {
        toBlock = numberToHex2(toBlock);
      }
    }
    if (!isNullish(fromBlock)) {
      if (typeof fromBlock === "number" || typeof fromBlock === "bigint") {
        fromBlock = numberToHex2(fromBlock);
      }
    }
    const formattedFilter = Object.assign(Object.assign({}, filter3), { fromBlock, toBlock });
    const response = yield exports_eth_rpc_methods.getLogs(web3Context.requestManager, formattedFilter);
    const result = response.map((res) => {
      if (typeof res === "string") {
        return res;
      }
      return format(logSchema, res, returnFormat);
    });
    return result;
  });
}
function getChainId2(web3Context, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.getChainId(web3Context.requestManager);
    return format({ format: "uint" }, response, returnFormat);
  });
}
function getProof2(web3Context, address7, storageKeys, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const storageKeysFormatted = storageKeys.map((storageKey) => format({ format: "bytes" }, storageKey, ETH_DATA_FORMAT));
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getProof(web3Context.requestManager, address7, storageKeysFormatted, blockNumberFormatted);
    return format(accountSchema, response, returnFormat);
  });
}
function getFeeHistory2(web3Context, blockCount, newestBlock = web3Context.defaultBlock, rewardPercentiles, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockCountFormatted = format({ format: "uint" }, blockCount, ETH_DATA_FORMAT);
    const newestBlockFormatted = isBlockTag(newestBlock) ? newestBlock : format({ format: "uint" }, newestBlock, ETH_DATA_FORMAT);
    const rewardPercentilesFormatted = format({
      type: "array",
      items: {
        format: "uint"
      }
    }, rewardPercentiles, NUMBER_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.getFeeHistory(web3Context.requestManager, blockCountFormatted, newestBlockFormatted, rewardPercentilesFormatted);
    return format(feeHistorySchema, response, returnFormat);
  });
}
function createAccessList2(web3Context, transaction, blockNumber = web3Context.defaultBlock, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const blockNumberFormatted = isBlockTag(blockNumber) ? blockNumber : format({ format: "uint" }, blockNumber, ETH_DATA_FORMAT);
    const response = yield exports_eth_rpc_methods.createAccessList(web3Context.requestManager, formatTransaction(transaction, ETH_DATA_FORMAT), blockNumberFormatted);
    return format(accessListResultSchema, response, returnFormat);
  });
}
function signTypedData2(web3Context, address7, typedData, useLegacy, returnFormat) {
  return __awaiter30(this, undefined, undefined, function* () {
    const response = yield exports_eth_rpc_methods.signTypedData(web3Context.requestManager, address7, typedData, useLegacy);
    return format({ format: "bytes" }, response, returnFormat);
  });
}
var __awaiter30 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var __rest = function(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s);i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
};
var isSyncing = (web3Context) => __awaiter30(undefined, undefined, undefined, function* () {
  return exports_eth_rpc_methods.getSyncing(web3Context.requestManager);
});

// node_modules/web3-eth/lib/esm/web3_subscriptions.js
class LogsSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["logs", this.args];
  }
  formatSubscriptionResult(data) {
    return format(logSchema, data, super.returnFormat);
  }
}

class NewPendingTransactionsSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["newPendingTransactions"];
  }
  formatSubscriptionResult(data) {
    return format({ format: "string" }, data, super.returnFormat);
  }
}

class NewHeadsSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["newHeads"];
  }
  formatSubscriptionResult(data) {
    return format(blockHeaderSchema, data, super.returnFormat);
  }
}

class SyncingSubscription extends Web3Subscription {
  _buildSubscriptionParams() {
    return ["syncing"];
  }
  _processSubscriptionResult(data) {
    if (typeof data === "boolean") {
      this.emit("changed", data);
    } else {
      const mappedData = Object.fromEntries(Object.entries(data.status).map(([key, value]) => [
        key.charAt(0).toLowerCase() + key.substring(1),
        value
      ]));
      this.emit("changed", data.syncing);
      this.emit("data", format(syncSchema, mappedData, super.returnFormat));
    }
  }
}

// node_modules/web3-eth/lib/esm/web3_eth.js
var __awaiter31 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var registeredSubscriptions = {
  logs: LogsSubscription,
  newPendingTransactions: NewPendingTransactionsSubscription,
  newHeads: NewHeadsSubscription,
  syncing: SyncingSubscription,
  pendingTransactions: NewPendingTransactionsSubscription,
  newBlockHeaders: NewHeadsSubscription
};

class Web3Eth extends Web3Context {
  constructor(providerOrContext) {
    if (typeof providerOrContext === "string" || isSupportedProvider(providerOrContext)) {
      super({
        provider: providerOrContext,
        registeredSubscriptions
      });
      return;
    }
    if (providerOrContext.registeredSubscriptions) {
      super(providerOrContext);
      return;
    }
    super(Object.assign(Object.assign({}, providerOrContext), { registeredSubscriptions }));
    this.getFeeData = this.calculateFeeData;
  }
  getProtocolVersion() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getProtocolVersion(this.requestManager);
    });
  }
  isSyncing() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getSyncing(this.requestManager);
    });
  }
  getCoinbase() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getCoinbase(this.requestManager);
    });
  }
  isMining() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getMining(this.requestManager);
    });
  }
  getHashrate(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return this.getHashRate(returnFormat);
    });
  }
  getHashRate(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getHashRate2(this, returnFormat);
    });
  }
  getGasPrice(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getGasPrice2(this, returnFormat);
    });
  }
  getMaxPriorityFeePerGas(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getMaxPriorityFeePerGas2(this, returnFormat);
    });
  }
  calculateFeeData(baseFeePerGasFactor = BigInt(2), alternativeMaxPriorityFeePerGas = ethUnitMap.Gwei) {
    var _a4;
    return __awaiter31(this, undefined, undefined, function* () {
      const block4 = yield this.getBlock(undefined, false);
      const baseFeePerGas = (_a4 = block4 === null || block4 === undefined ? undefined : block4.baseFeePerGas) !== null && _a4 !== undefined ? _a4 : undefined;
      let gasPrice;
      try {
        gasPrice = yield this.getGasPrice();
      } catch (error) {
      }
      let maxPriorityFeePerGas;
      try {
        maxPriorityFeePerGas = yield this.getMaxPriorityFeePerGas();
      } catch (error) {
      }
      let maxFeePerGas;
      if (baseFeePerGas) {
        maxPriorityFeePerGas = maxPriorityFeePerGas !== null && maxPriorityFeePerGas !== undefined ? maxPriorityFeePerGas : alternativeMaxPriorityFeePerGas;
        maxFeePerGas = baseFeePerGas * baseFeePerGasFactor + maxPriorityFeePerGas;
      }
      return { gasPrice, maxFeePerGas, maxPriorityFeePerGas, baseFeePerGas };
    });
  }
  getAccounts() {
    var _a4;
    return __awaiter31(this, undefined, undefined, function* () {
      const hexAddresses = (_a4 = yield exports_eth_rpc_methods.getAccounts(this.requestManager)) !== null && _a4 !== undefined ? _a4 : [];
      return hexAddresses.map((address7) => toChecksumAddress(address7));
    });
  }
  getBlockNumber(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlockNumber2(this, returnFormat);
    });
  }
  getBalance(address7, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBalance2(this, address7, blockNumber, returnFormat);
    });
  }
  getStorageAt(address7, storageSlot, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getStorageAt2(this, address7, storageSlot, blockNumber, returnFormat);
    });
  }
  getCode(address7, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getCode2(this, address7, blockNumber, returnFormat);
    });
  }
  getBlock(block4 = this.defaultBlock, hydrated = false, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlock(this, block4, hydrated, returnFormat);
    });
  }
  getBlockTransactionCount(block4 = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlockTransactionCount(this, block4, returnFormat);
    });
  }
  getBlockUncleCount(block4 = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getBlockUncleCount(this, block4, returnFormat);
    });
  }
  getUncle(block4 = this.defaultBlock, uncleIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getUncle(this, block4, uncleIndex, returnFormat);
    });
  }
  getTransaction(transactionHash, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      const response = yield getTransaction(this, transactionHash, returnFormat);
      if (!response)
        throw new TransactionNotFound;
      return response;
    });
  }
  getPendingTransactions(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getPendingTransactions2(this, returnFormat);
    });
  }
  getTransactionFromBlock(block4 = this.defaultBlock, transactionIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getTransactionFromBlock(this, block4, transactionIndex, returnFormat);
    });
  }
  getTransactionReceipt(transactionHash, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      const response = yield getTransactionReceipt2(this, transactionHash, returnFormat);
      if (!response)
        throw new TransactionNotFound;
      return response;
    });
  }
  getTransactionCount(address7, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getTransactionCount2(this, address7, blockNumber, returnFormat);
    });
  }
  sendTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options) {
    return sendTransaction3(this, transaction, returnFormat, options);
  }
  sendSignedTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT, options) {
    return sendSignedTransaction(this, transaction, returnFormat, options);
  }
  sign(message, addressOrIndex, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return sign4(this, message, addressOrIndex, returnFormat);
    });
  }
  signTransaction(transaction, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return signTransaction4(this, transaction, returnFormat);
    });
  }
  call(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return call2(this, transaction, blockNumber, returnFormat);
    });
  }
  estimateGas(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return estimateGas2(this, transaction, blockNumber, returnFormat);
    });
  }
  getPastLogs(filter3, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getLogs2(this, filter3, returnFormat);
    });
  }
  getWork() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getWork(this.requestManager);
    });
  }
  submitWork(nonce, hash3, digest) {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.submitWork(this.requestManager, nonce, hash3, digest);
    });
  }
  requestAccounts() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.requestAccounts(this.requestManager);
    });
  }
  getChainId(returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getChainId2(this, returnFormat);
    });
  }
  getNodeInfo() {
    return __awaiter31(this, undefined, undefined, function* () {
      return exports_eth_rpc_methods.getNodeInfo(this.requestManager);
    });
  }
  getProof(address7, storageKeys, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getProof2(this, address7, storageKeys, blockNumber, returnFormat);
    });
  }
  getFeeHistory(blockCount, newestBlock = this.defaultBlock, rewardPercentiles, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return getFeeHistory2(this, blockCount, newestBlock, rewardPercentiles, returnFormat);
    });
  }
  createAccessList(transaction, blockNumber = this.defaultBlock, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return createAccessList2(this, transaction, blockNumber, returnFormat);
    });
  }
  signTypedData(address7, typedData, useLegacy = false, returnFormat = DEFAULT_RETURN_FORMAT) {
    return __awaiter31(this, undefined, undefined, function* () {
      return signTypedData2(this, address7, typedData, useLegacy, returnFormat);
    });
  }
  subscribe(name, args, returnFormat = DEFAULT_RETURN_FORMAT) {
    var _a4;
    return __awaiter31(this, undefined, undefined, function* () {
      const subscription = yield (_a4 = this.subscriptionManager) === null || _a4 === undefined ? undefined : _a4.subscribe(name, args, returnFormat);
      if (subscription instanceof LogsSubscription && name === "logs" && typeof args === "object" && !isNullish2(args.fromBlock) && Number.isFinite(Number(args.fromBlock))) {
        setImmediate(() => {
          this.getPastLogs(args).then((logs) => {
            for (const log of logs) {
              subscription._processSubscriptionResult(log);
            }
          }).catch((e) => {
            subscription._processSubscriptionError(e);
          });
        });
      }
      return subscription;
    });
  }
  static shouldClearSubscription({ sub }) {
    return !(sub instanceof SyncingSubscription);
  }
  clearSubscriptions(notClearSyncing = false) {
    var _a4;
    return (_a4 = this.subscriptionManager) === null || _a4 === undefined ? undefined : _a4.unsubscribe(notClearSyncing ? Web3Eth.shouldClearSubscription : undefined);
  }
}
// node_modules/web3-eth/lib/esm/validation.js
var validateCustomChainInfo = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (isNullish(transaction.common.customChain))
      throw new MissingCustomChainError;
    if (isNullish(transaction.common.customChain.chainId))
      throw new MissingCustomChainIdError;
    if (!isNullish(transaction.chainId) && transaction.chainId !== transaction.common.customChain.chainId)
      throw new ChainIdMismatchError({
        txChainId: transaction.chainId,
        customChainId: transaction.common.customChain.chainId
      });
  }
};
var validateChainInfo = (transaction) => {
  if (!isNullish(transaction.common) && !isNullish(transaction.chain) && !isNullish(transaction.hardfork)) {
    throw new CommonOrChainAndHardforkError;
  }
  if (!isNullish(transaction.chain) && isNullish(transaction.hardfork) || !isNullish(transaction.hardfork) && isNullish(transaction.chain))
    throw new MissingChainOrHardforkError({
      chain: transaction.chain,
      hardfork: transaction.hardfork
    });
};
var validateBaseChain = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (!isNullish(transaction.common.baseChain)) {
      if (!isNullish(transaction.chain) && transaction.chain !== transaction.common.baseChain) {
        throw new ChainMismatchError({
          txChain: transaction.chain,
          baseChain: transaction.common.baseChain
        });
      }
    }
  }
};
var validateHardfork = (transaction) => {
  if (!isNullish(transaction.common)) {
    if (!isNullish(transaction.common.hardfork)) {
      if (!isNullish(transaction.hardfork) && transaction.hardfork !== transaction.common.hardfork) {
        throw new HardforkMismatchError({
          txHardfork: transaction.hardfork,
          commonHardfork: transaction.common.hardfork
        });
      }
    }
  }
};
var validateLegacyGas = (transaction) => {
  if (isNullish(transaction.gas) || !isUInt(transaction.gas) || isNullish(transaction.gasPrice) || !isUInt(transaction.gasPrice))
    throw new InvalidGasOrGasPrice({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice
    });
  if (!isNullish(transaction.maxFeePerGas) || !isNullish(transaction.maxPriorityFeePerGas))
    throw new UnsupportedFeeMarketError({
      maxFeePerGas: transaction.maxFeePerGas,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
    });
};
var validateFeeMarketGas = (transaction) => {
  if (!isNullish(transaction.gasPrice) && transaction.type === "0x2")
    throw new Eip1559GasPriceError(transaction.gasPrice);
  if (transaction.type === "0x0" || transaction.type === "0x1")
    throw new UnsupportedFeeMarketError({
      maxFeePerGas: transaction.maxFeePerGas,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas
    });
  if (isNullish(transaction.maxFeePerGas) || !isUInt(transaction.maxFeePerGas) || isNullish(transaction.maxPriorityFeePerGas) || !isUInt(transaction.maxPriorityFeePerGas))
    throw new InvalidMaxPriorityFeePerGasOrMaxFeePerGas({
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
};
var validateGas = (transaction) => {
  const gasPresent = !isNullish(transaction.gas) || !isNullish(transaction.gasLimit);
  const legacyGasPresent = gasPresent && !isNullish(transaction.gasPrice);
  const feeMarketGasPresent = gasPresent && !isNullish(transaction.maxPriorityFeePerGas) && !isNullish(transaction.maxFeePerGas);
  if (!legacyGasPresent && !feeMarketGasPresent)
    throw new MissingGasError({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
  if (legacyGasPresent && feeMarketGasPresent)
    throw new TransactionGasMismatchError({
      gas: transaction.gas,
      gasPrice: transaction.gasPrice,
      maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
      maxFeePerGas: transaction.maxFeePerGas
    });
  (legacyGasPresent ? validateLegacyGas : validateFeeMarketGas)(transaction);
  (!isNullish(transaction.type) && transaction.type > "0x1" ? validateFeeMarketGas : validateLegacyGas)(transaction);
};
var validateTransactionForSigning = (transaction, overrideMethod) => {
  if (!isNullish(overrideMethod)) {
    overrideMethod(transaction);
    return;
  }
  if (typeof transaction !== "object" || isNullish(transaction))
    throw new InvalidTransactionObjectError(transaction);
  validateCustomChainInfo(transaction);
  validateChainInfo(transaction);
  validateBaseChain(transaction);
  validateHardfork(transaction);
  const formattedTransaction = formatTransaction(transaction, ETH_DATA_FORMAT);
  validateGas(formattedTransaction);
  if (isNullish(formattedTransaction.nonce) || isNullish(formattedTransaction.chainId) || formattedTransaction.nonce.startsWith("-") || formattedTransaction.chainId.startsWith("-"))
    throw new InvalidNonceOrChainIdError({
      nonce: transaction.nonce,
      chainId: transaction.chainId
    });
};
// node_modules/web3-eth/lib/esm/utils/prepare_transaction_for_signing.js
var __awaiter32 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getEthereumjsTxDataFromTransaction = (transaction) => {
  var _a4, _b;
  return {
    nonce: transaction.nonce,
    gasPrice: transaction.gasPrice,
    gasLimit: (_a4 = transaction.gasLimit) !== null && _a4 !== undefined ? _a4 : transaction.gas,
    to: transaction.to,
    value: transaction.value,
    data: (_b = transaction.data) !== null && _b !== undefined ? _b : transaction.input,
    type: transaction.type,
    chainId: transaction.chainId,
    accessList: transaction.accessList,
    maxPriorityFeePerGas: transaction.maxPriorityFeePerGas,
    maxFeePerGas: transaction.maxFeePerGas
  };
};
var getEthereumjsTransactionOptions = (transaction, web3Context) => {
  var _a4, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t;
  const hasTransactionSigningOptions = !isNullish(transaction.chain) && !isNullish(transaction.hardfork) || !isNullish(transaction.common);
  let common4;
  if (!hasTransactionSigningOptions) {
    if (web3Context.defaultCommon) {
      common4 = Object.assign({}, web3Context.defaultCommon);
      if (isNullish(common4.hardfork))
        common4.hardfork = (_a4 = transaction.hardfork) !== null && _a4 !== undefined ? _a4 : web3Context.defaultHardfork;
      if (isNullish(common4.baseChain))
        common4.baseChain = web3Context.defaultChain;
    } else {
      common4 = Common.custom({
        name: "custom-network",
        chainId: toNumber(transaction.chainId),
        networkId: !isNullish(transaction.networkId) ? toNumber(transaction.networkId) : undefined,
        defaultHardfork: (_b = transaction.hardfork) !== null && _b !== undefined ? _b : web3Context.defaultHardfork
      }, {
        baseChain: web3Context.defaultChain
      });
    }
  } else {
    const name = (_f = (_e = (_d = (_c = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _c === undefined ? undefined : _c.customChain) === null || _d === undefined ? undefined : _d.name) !== null && _e !== undefined ? _e : transaction.chain) !== null && _f !== undefined ? _f : "custom-network";
    const chainId = toNumber((_j = (_h = (_g = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _g === undefined ? undefined : _g.customChain) === null || _h === undefined ? undefined : _h.chainId) !== null && _j !== undefined ? _j : transaction === null || transaction === undefined ? undefined : transaction.chainId);
    const networkId = toNumber((_m = (_l = (_k = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _k === undefined ? undefined : _k.customChain) === null || _l === undefined ? undefined : _l.networkId) !== null && _m !== undefined ? _m : transaction === null || transaction === undefined ? undefined : transaction.networkId);
    const defaultHardfork = (_q = (_p = (_o = transaction === null || transaction === undefined ? undefined : transaction.common) === null || _o === undefined ? undefined : _o.hardfork) !== null && _p !== undefined ? _p : transaction === null || transaction === undefined ? undefined : transaction.hardfork) !== null && _q !== undefined ? _q : web3Context.defaultHardfork;
    const baseChain = (_t = (_s = (_r = transaction.common) === null || _r === undefined ? undefined : _r.baseChain) !== null && _s !== undefined ? _s : transaction.chain) !== null && _t !== undefined ? _t : web3Context.defaultChain;
    if (chainId && networkId && name) {
      common4 = Common.custom({
        name,
        chainId,
        networkId,
        defaultHardfork
      }, {
        baseChain
      });
    }
  }
  return { common: common4 };
};
var prepareTransactionForSigning = (transaction, web3Context, privateKey, fillGasPrice = false, fillGasLimit = true) => __awaiter32(undefined, undefined, undefined, function* () {
  const populatedTransaction = yield transactionBuilder({
    transaction,
    web3Context,
    privateKey,
    fillGasPrice,
    fillGasLimit
  });
  const formattedTransaction = formatTransaction(populatedTransaction, ETH_DATA_FORMAT);
  validateTransactionForSigning(formattedTransaction);
  return TransactionFactory.fromTxData(getEthereumjsTxDataFromTransaction(formattedTransaction), getEthereumjsTransactionOptions(formattedTransaction, web3Context));
});
// node_modules/web3-eth-contract/lib/esm/encoding.js
var encodeEventABI = ({ address: address7 }, event, options) => {
  var _a4, _b;
  const topics = options === null || options === undefined ? undefined : options.topics;
  const filter3 = (_a4 = options === null || options === undefined ? undefined : options.filter) !== null && _a4 !== undefined ? _a4 : {};
  const opts = {};
  if (!isNullish2(options === null || options === undefined ? undefined : options.fromBlock)) {
    opts.fromBlock = format(blockSchema.properties.number, options === null || options === undefined ? undefined : options.fromBlock, {
      number: FMT_NUMBER.HEX,
      bytes: FMT_BYTES.HEX
    });
  }
  if (!isNullish2(options === null || options === undefined ? undefined : options.toBlock)) {
    opts.toBlock = format(blockSchema.properties.number, options === null || options === undefined ? undefined : options.toBlock, {
      number: FMT_NUMBER.HEX,
      bytes: FMT_BYTES.HEX
    });
  }
  if (topics && Array.isArray(topics)) {
    opts.topics = [...topics];
  } else {
    opts.topics = [];
    if (event && !event.anonymous && ![ALL_EVENTS, "allEvents"].includes(event.name)) {
      opts.topics.push((_b = event.signature) !== null && _b !== undefined ? _b : encodeEventSignature(jsonInterfaceMethodToString(event)));
    }
    if (![ALL_EVENTS, "allEvents"].includes(event.name) && event.inputs) {
      for (const input of event.inputs) {
        if (!input.indexed) {
          continue;
        }
        const value = filter3[input.name];
        if (!value) {
          opts.topics.push(null);
          continue;
        }
        if (Array.isArray(value)) {
          opts.topics.push(value.map((v) => encodeParameter(input.type, v)));
        } else if (input.type === "string") {
          opts.topics.push(keccak256Wrapper(value));
        } else {
          opts.topics.push(encodeParameter(input.type, value));
        }
      }
    }
  }
  if (!opts.topics.length)
    delete opts.topics;
  if (address7) {
    opts.address = address7.toLowerCase();
  }
  return opts;
};
var encodeMethodABI = (abi2, args, deployData) => {
  const inputLength = Array.isArray(abi2.inputs) ? abi2.inputs.length : 0;
  if (abi2.inputs && inputLength !== args.length) {
    throw new Web3ContractError(`The number of arguments is not matching the methods required number. You need to pass ${inputLength} arguments.`);
  }
  let params;
  if (abi2.inputs) {
    params = encodeParameters(Array.isArray(abi2.inputs) ? abi2.inputs : [], args).replace("0x", "");
  } else {
    params = inferTypesAndEncodeParameters(args).replace("0x", "");
  }
  if (isAbiConstructorFragment(abi2)) {
    if (!deployData)
      throw new Web3ContractError("The contract has no contract data option set. This is necessary to append the constructor parameters.");
    if (!deployData.startsWith("0x")) {
      return `0x${deployData}${params}`;
    }
    return `${deployData}${params}`;
  }
  return `${encodeFunctionSignature(abi2)}${params}`;
};
var decodeMethodReturn = (abi2, returnValues) => {
  if (abi2.type === "constructor") {
    return returnValues;
  }
  if (!returnValues) {
    return null;
  }
  const value = returnValues.length >= 2 ? returnValues.slice(2) : returnValues;
  if (!abi2.outputs) {
    return null;
  }
  const result = decodeParameters2([...abi2.outputs], value);
  if (result.__length__ === 1) {
    return result[0];
  }
  return result;
};

// node_modules/web3-eth-contract/lib/esm/log_subscription.js
class LogsSubscription2 extends Web3Subscription {
  constructor(args, options) {
    super(args, options);
    this.address = args.address;
    this.topics = args.topics;
    this.abi = args.abi;
    this.jsonInterface = args.jsonInterface;
  }
  _buildSubscriptionParams() {
    return ["logs", { address: this.address, topics: this.topics }];
  }
  formatSubscriptionResult(data) {
    return decodeEventABI(this.abi, data, this.jsonInterface, super.returnFormat);
  }
}

// node_modules/web3-eth-contract/lib/esm/utils.js
var dataInputEncodeMethodHelper = (txParams, abi2, params, dataInputFill) => {
  var _a4, _b;
  const tx2 = {};
  if (!isNullish2(txParams.data) || dataInputFill === "both") {
    tx2.data = encodeMethodABI(abi2, params, (_a4 = txParams.data) !== null && _a4 !== undefined ? _a4 : txParams.input);
  }
  if (!isNullish2(txParams.input) || dataInputFill === "both") {
    tx2.input = encodeMethodABI(abi2, params, (_b = txParams.input) !== null && _b !== undefined ? _b : txParams.data);
  }
  if (isNullish2(tx2.input) && isNullish2(tx2.data)) {
    tx2[dataInputFill] = encodeMethodABI(abi2, params);
  }
  return { data: tx2.data, input: tx2.input };
};
var getSendTxParams = ({ abi: abi2, params, options, contractOptions }) => {
  var _a4, _b, _c;
  const deploymentCall = (_c = (_b = (_a4 = options === null || options === undefined ? undefined : options.input) !== null && _a4 !== undefined ? _a4 : options === null || options === undefined ? undefined : options.data) !== null && _b !== undefined ? _b : contractOptions.input) !== null && _c !== undefined ? _c : contractOptions.data;
  if (!deploymentCall && !(options === null || options === undefined ? undefined : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  if (!(options === null || options === undefined ? undefined : options.from) && !contractOptions.from) {
    throw new Web3ContractError('Contract "from" address not specified');
  }
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var getEthTxCallParams = ({ abi: abi2, params, options, contractOptions }) => {
  if (!(options === null || options === undefined ? undefined : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var getEstimateGasParams = ({ abi: abi2, params, options, contractOptions }) => {
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};
var isWeb3ContractContext = (options) => typeof options === "object" && !isNullish2(options) && Object.keys(options).length !== 0 && !isContractInitOptions(options);
var getCreateAccessListParams = ({ abi: abi2, params, options, contractOptions }) => {
  if (!(options === null || options === undefined ? undefined : options.to) && !contractOptions.address) {
    throw new Web3ContractError("Contract address not specified");
  }
  if (!(options === null || options === undefined ? undefined : options.from) && !contractOptions.from) {
    throw new Web3ContractError('Contract "from" address not specified');
  }
  let txParams = mergeDeep({
    to: contractOptions.address,
    gas: contractOptions.gas,
    gasPrice: contractOptions.gasPrice,
    from: contractOptions.from,
    input: contractOptions.input,
    maxPriorityFeePerGas: contractOptions.maxPriorityFeePerGas,
    maxFeePerGas: contractOptions.maxFeePerGas,
    data: contractOptions.data
  }, options);
  const dataInput = dataInputEncodeMethodHelper(txParams, abi2, params, options === null || options === undefined ? undefined : options.dataInputFill);
  txParams = Object.assign(Object.assign({}, txParams), { data: dataInput.data, input: dataInput.input });
  return txParams;
};

// node_modules/web3-eth-contract/lib/esm/contract.js
var __awaiter33 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var contractSubscriptions = {
  logs: LogsSubscription2,
  newHeads: NewHeadsSubscription,
  newBlockHeaders: NewHeadsSubscription
};

class Contract extends Web3Context {
  constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {
    var _a4, _b, _c;
    const options = isContractInitOptions(addressOrOptionsOrContext) ? addressOrOptionsOrContext : isContractInitOptions(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : undefined;
    let contractContext;
    if (isWeb3ContractContext(addressOrOptionsOrContext)) {
      contractContext = addressOrOptionsOrContext;
    } else if (isWeb3ContractContext(optionsOrContextOrReturnFormat)) {
      contractContext = optionsOrContextOrReturnFormat;
    } else {
      contractContext = contextOrReturnFormat;
    }
    let provider;
    if (typeof addressOrOptionsOrContext === "object" && "provider" in addressOrOptionsOrContext) {
      provider = addressOrOptionsOrContext.provider;
    } else if (typeof optionsOrContextOrReturnFormat === "object" && "provider" in optionsOrContextOrReturnFormat) {
      provider = optionsOrContextOrReturnFormat.provider;
    } else if (typeof contextOrReturnFormat === "object" && "provider" in contextOrReturnFormat) {
      provider = contextOrReturnFormat.provider;
    } else {
      provider = Contract.givenProvider;
    }
    super(Object.assign(Object.assign({}, contractContext), { provider, registeredSubscriptions: contractSubscriptions }));
    this.syncWithContext = false;
    this._functions = {};
    if (contractContext === null || contractContext === undefined ? undefined : contractContext.wallet) {
      this._wallet = contractContext.wallet;
    }
    if (contractContext === null || contractContext === undefined ? undefined : contractContext.accountProvider) {
      this._accountProvider = contractContext.accountProvider;
    }
    if (!isNullish(options) && !isNullish(options.data) && !isNullish(options.input) && this.config.contractDataInputFill !== "both")
      throw new ContractTransactionDataAndInputError({
        data: options.data,
        input: options.input
      });
    this._overloadedMethodAbis = new Map;
    const returnDataFormat = isDataFormat(contextOrReturnFormat) ? contextOrReturnFormat : isDataFormat(optionsOrContextOrReturnFormat) ? optionsOrContextOrReturnFormat : returnFormat !== null && returnFormat !== undefined ? returnFormat : DEFAULT_RETURN_FORMAT;
    const address7 = typeof addressOrOptionsOrContext === "string" ? addressOrOptionsOrContext : undefined;
    this.config.contractDataInputFill = (_a4 = options === null || options === undefined ? undefined : options.dataInputFill) !== null && _a4 !== undefined ? _a4 : this.config.contractDataInputFill;
    this._parseAndSetJsonInterface(jsonInterface, returnDataFormat);
    if (!isNullish(address7)) {
      this._parseAndSetAddress(address7, returnDataFormat);
    }
    this.options = {
      address: address7,
      jsonInterface: this._jsonInterface,
      gas: (_b = options === null || options === undefined ? undefined : options.gas) !== null && _b !== undefined ? _b : options === null || options === undefined ? undefined : options.gasLimit,
      gasPrice: options === null || options === undefined ? undefined : options.gasPrice,
      from: options === null || options === undefined ? undefined : options.from,
      input: options === null || options === undefined ? undefined : options.input,
      data: options === null || options === undefined ? undefined : options.data
    };
    this.syncWithContext = (_c = options === null || options === undefined ? undefined : options.syncWithContext) !== null && _c !== undefined ? _c : false;
    if (contractContext instanceof Web3Context) {
      this.subscribeToContextEvents(contractContext);
    }
    Object.defineProperty(this.options, "address", {
      set: (value) => this._parseAndSetAddress(value, returnDataFormat),
      get: () => this._address
    });
    Object.defineProperty(this.options, "jsonInterface", {
      set: (value) => this._parseAndSetJsonInterface(value, returnDataFormat),
      get: () => this._jsonInterface
    });
    if (contractContext instanceof Web3Context) {
      contractContext.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
        this.setConfig({ [event.name]: event.newValue });
      });
    }
  }
  get events() {
    return this._events;
  }
  get methods() {
    return this._methods;
  }
  clone() {
    let newContract;
    if (this.options.address) {
      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], this.options.address, {
        gas: this.options.gas,
        gasPrice: this.options.gasPrice,
        from: this.options.from,
        input: this.options.input,
        data: this.options.data,
        provider: this.currentProvider,
        syncWithContext: this.syncWithContext,
        dataInputFill: this.config.contractDataInputFill
      }, this.getContextObject());
    } else {
      newContract = new Contract([...this._jsonInterface, ...this._errorsInterface], {
        gas: this.options.gas,
        gasPrice: this.options.gasPrice,
        from: this.options.from,
        input: this.options.input,
        data: this.options.data,
        provider: this.currentProvider,
        syncWithContext: this.syncWithContext,
        dataInputFill: this.config.contractDataInputFill
      }, this.getContextObject());
    }
    if (this.context)
      newContract.subscribeToContextEvents(this.context);
    return newContract;
  }
  deploy(deployOptions) {
    var _a4, _b, _c;
    let abi2 = this._jsonInterface.find((j) => j.type === "constructor");
    if (!abi2) {
      abi2 = {
        type: "constructor",
        stateMutability: ""
      };
    }
    const _input = format({ format: "bytes" }, (_a4 = deployOptions === null || deployOptions === undefined ? undefined : deployOptions.input) !== null && _a4 !== undefined ? _a4 : this.options.input, DEFAULT_RETURN_FORMAT);
    const _data = format({ format: "bytes" }, (_b = deployOptions === null || deployOptions === undefined ? undefined : deployOptions.data) !== null && _b !== undefined ? _b : this.options.data, DEFAULT_RETURN_FORMAT);
    if ((!_input || _input.trim() === "0x") && (!_data || _data.trim() === "0x")) {
      throw new Web3ContractError("contract creation without any data provided.");
    }
    const args = (_c = deployOptions === null || deployOptions === undefined ? undefined : deployOptions.arguments) !== null && _c !== undefined ? _c : [];
    const contractOptions = Object.assign(Object.assign({}, this.options), { input: _input, data: _data });
    const deployData = _input !== null && _input !== undefined ? _input : _data;
    return {
      arguments: args,
      send: (options) => {
        const modifiedOptions = Object.assign({}, options);
        return this._contractMethodDeploySend(abi2, args, modifiedOptions, contractOptions);
      },
      estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter33(this, undefined, undefined, function* () {
        const modifiedOptions = Object.assign({}, options);
        return this._contractMethodEstimateGas({
          abi: abi2,
          params: args,
          returnFormat,
          options: modifiedOptions,
          contractOptions
        });
      }),
      encodeABI: () => encodeMethodABI(abi2, args, format({ format: "bytes" }, deployData, DEFAULT_RETURN_FORMAT))
    };
  }
  getPastEvents(param1, param2, param3) {
    var _a4;
    return __awaiter33(this, undefined, undefined, function* () {
      const eventName = typeof param1 === "string" ? param1 : ALL_EVENTS;
      const options = typeof param1 !== "string" && !isDataFormat(param1) ? param1 : !isDataFormat(param2) ? param2 : {};
      const returnFormat = isDataFormat(param1) ? param1 : isDataFormat(param2) ? param2 : param3 !== null && param3 !== undefined ? param3 : DEFAULT_RETURN_FORMAT;
      const abi2 = eventName === "allEvents" || eventName === ALL_EVENTS ? ALL_EVENTS_ABI : this._jsonInterface.find((j) => ("name" in j) && j.name === eventName);
      if (!abi2) {
        throw new Web3ContractError(`Event ${eventName} not found.`);
      }
      const { fromBlock, toBlock, topics, address: address7 } = encodeEventABI(this.options, abi2, options !== null && options !== undefined ? options : {});
      const logs = yield getLogs2(this, { fromBlock, toBlock, topics, address: address7 }, returnFormat);
      const decodedLogs = logs ? logs.map((log) => typeof log === "string" ? log : decodeEventABI(abi2, log, this._jsonInterface, returnFormat)) : [];
      const filter3 = (_a4 = options === null || options === undefined ? undefined : options.filter) !== null && _a4 !== undefined ? _a4 : {};
      const filterKeys = Object.keys(filter3);
      if (filterKeys.length > 0) {
        return decodedLogs.filter((log) => {
          if (typeof log === "string")
            return true;
          return filterKeys.every((key) => {
            var _a5;
            if (Array.isArray(filter3[key])) {
              return filter3[key].some((v) => String(log.returnValues[key]).toUpperCase() === String(v).toUpperCase());
            }
            const inputAbi = (_a5 = abi2.inputs) === null || _a5 === undefined ? undefined : _a5.filter((input) => input.name === key)[0];
            if ((inputAbi === null || inputAbi === undefined ? undefined : inputAbi.indexed) && inputAbi.type === "string") {
              const hashedIndexedString = keccak256Wrapper(filter3[key]);
              if (hashedIndexedString === String(log.returnValues[key]))
                return true;
            }
            return String(log.returnValues[key]).toUpperCase() === String(filter3[key]).toUpperCase();
          });
        });
      }
      return decodedLogs;
    });
  }
  _parseAndSetAddress(value, returnFormat = DEFAULT_RETURN_FORMAT) {
    this._address = value ? toChecksumAddress(format({ format: "address" }, value, returnFormat)) : value;
  }
  _parseAndSetJsonInterface(abis, returnFormat = DEFAULT_RETURN_FORMAT) {
    var _a4, _b, _c, _d, _e;
    this._functions = {};
    this._methods = {};
    this._events = {};
    let result = [];
    const functionsAbi = abis.filter((abi2) => abi2.type !== "error");
    const errorsAbi = abis.filter((abi2) => isAbiErrorFragment(abi2));
    for (const a of functionsAbi) {
      const abi2 = Object.assign(Object.assign({}, a), { signature: "" });
      if (isAbiFunctionFragment(abi2)) {
        const methodName = jsonInterfaceMethodToString(abi2);
        const methodSignature = encodeFunctionSignature(methodName);
        abi2.signature = methodSignature;
        abi2.constant = (_b = (_a4 = abi2.stateMutability === "view") !== null && _a4 !== undefined ? _a4 : abi2.stateMutability === "pure") !== null && _b !== undefined ? _b : abi2.constant;
        abi2.payable = (_c = abi2.stateMutability === "payable") !== null && _c !== undefined ? _c : abi2.payable;
        this._overloadedMethodAbis.set(abi2.name, [
          ...(_d = this._overloadedMethodAbis.get(abi2.name)) !== null && _d !== undefined ? _d : [],
          abi2
        ]);
        const abiFragment = (_e = this._overloadedMethodAbis.get(abi2.name)) !== null && _e !== undefined ? _e : [];
        const contractMethod = this._createContractMethod(abiFragment, errorsAbi);
        this._functions[methodName] = {
          signature: methodSignature,
          method: contractMethod
        };
        this._methods[abi2.name] = this._functions[methodName].method;
        this._methods[methodName] = this._functions[methodName].method;
        this._methods[methodSignature] = this._functions[methodName].method;
      } else if (isAbiEventFragment(abi2)) {
        const eventName = jsonInterfaceMethodToString(abi2);
        const eventSignature = encodeEventSignature(eventName);
        const event = this._createContractEvent(abi2, returnFormat);
        abi2.signature = eventSignature;
        if (!(eventName in this._events) || abi2.name === "bound") {
          this._events[eventName] = event;
        }
        this._events[abi2.name] = event;
        this._events[eventSignature] = event;
      }
      result = [...result, abi2];
    }
    this._events.allEvents = this._createContractEvent(ALL_EVENTS_ABI, returnFormat);
    this._jsonInterface = [...result];
    this._errorsInterface = errorsAbi;
  }
  _getAbiParams(abi2, params) {
    var _a4;
    try {
      return exports_utils.transformJsonDataToAbiFormat((_a4 = abi2.inputs) !== null && _a4 !== undefined ? _a4 : [], params);
    } catch (error) {
      throw new Web3ContractError(`Invalid parameters for method ${abi2.name}: ${error.message}`);
    }
  }
  _createContractMethod(abiArr, errorsAbis) {
    const abi2 = abiArr[abiArr.length - 1];
    return (...params) => {
      var _a4, _b;
      let abiParams;
      const abis = (_a4 = this._overloadedMethodAbis.get(abi2.name)) !== null && _a4 !== undefined ? _a4 : [];
      let methodAbi = abis[0];
      const internalErrorsAbis = errorsAbis;
      const arrayOfAbis = abis.filter((_abi) => {
        var _a5;
        return ((_a5 = _abi.inputs) !== null && _a5 !== undefined ? _a5 : []).length === params.length;
      });
      if (abis.length === 1 || arrayOfAbis.length === 0) {
        abiParams = this._getAbiParams(methodAbi, params);
        validator2.validate((_b = abi2.inputs) !== null && _b !== undefined ? _b : [], abiParams);
      } else {
        const errors5 = [];
        for (const _abi of arrayOfAbis) {
          try {
            abiParams = this._getAbiParams(_abi, params);
            validator2.validate(_abi.inputs, abiParams);
            methodAbi = _abi;
            break;
          } catch (e) {
            errors5.push(e);
          }
        }
        if (errors5.length === arrayOfAbis.length) {
          throw new Web3ValidatorError(errors5);
        }
      }
      const methods = {
        arguments: abiParams,
        call: (options, block4) => __awaiter33(this, undefined, undefined, function* () {
          return this._contractMethodCall(methodAbi, abiParams, internalErrorsAbis, options, block4);
        }),
        send: (options) => this._contractMethodSend(methodAbi, abiParams, internalErrorsAbis, options),
        estimateGas: (options, returnFormat = DEFAULT_RETURN_FORMAT) => __awaiter33(this, undefined, undefined, function* () {
          return this._contractMethodEstimateGas({
            abi: methodAbi,
            params: abiParams,
            returnFormat,
            options
          });
        }),
        encodeABI: () => encodeMethodABI(methodAbi, abiParams),
        createAccessList: (options, block4) => __awaiter33(this, undefined, undefined, function* () {
          return this._contractMethodCreateAccessList(methodAbi, abiParams, internalErrorsAbis, options, block4);
        })
      };
      if (methodAbi.stateMutability === "payable") {
        return methods;
      }
      return methods;
    };
  }
  _contractMethodCall(abi2, params, errorsAbi, options, block4) {
    var _a4;
    return __awaiter33(this, undefined, undefined, function* () {
      const tx2 = getEthTxCallParams({
        abi: abi2,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a4 = this.options.from) !== null && _a4 !== undefined ? _a4 : this.config.defaultAccount })
      });
      try {
        const result = yield call2(this, tx2, block4, DEFAULT_RETURN_FORMAT);
        return decodeMethodReturn(abi2, result);
      } catch (error) {
        if (error instanceof ContractExecutionError) {
          decodeContractErrorData(errorsAbi, error.cause);
        }
        throw error;
      }
    });
  }
  _contractMethodCreateAccessList(abi2, params, errorsAbi, options, block4) {
    var _a4;
    return __awaiter33(this, undefined, undefined, function* () {
      const tx2 = getCreateAccessListParams({
        abi: abi2,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: Object.assign(Object.assign({}, this.options), { from: (_a4 = this.options.from) !== null && _a4 !== undefined ? _a4 : this.config.defaultAccount })
      });
      try {
        return createAccessList2(this, tx2, block4, DEFAULT_RETURN_FORMAT);
      } catch (error) {
        if (error instanceof ContractExecutionError) {
          decodeContractErrorData(errorsAbi, error.cause);
        }
        throw error;
      }
    });
  }
  _contractMethodSend(abi2, params, errorsAbi, options, contractOptions) {
    var _a4, _b;
    let modifiedContractOptions = contractOptions !== null && contractOptions !== undefined ? contractOptions : this.options;
    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { input: undefined, from: (_b = (_a4 = modifiedContractOptions.from) !== null && _a4 !== undefined ? _a4 : this.defaultAccount) !== null && _b !== undefined ? _b : undefined });
    const tx2 = getSendTxParams({
      abi: abi2,
      params,
      options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
      contractOptions: modifiedContractOptions
    });
    const transactionToSend = sendTransaction3(this, tx2, DEFAULT_RETURN_FORMAT, {
      checkRevertBeforeSending: false,
      contractAbi: this._jsonInterface
    });
    transactionToSend.on("error", (error) => {
      if (error instanceof ContractExecutionError) {
        decodeContractErrorData(errorsAbi, error.cause);
      }
    });
    return transactionToSend;
  }
  _contractMethodDeploySend(abi2, params, options, contractOptions) {
    var _a4, _b;
    let modifiedContractOptions = contractOptions !== null && contractOptions !== undefined ? contractOptions : this.options;
    modifiedContractOptions = Object.assign(Object.assign({}, modifiedContractOptions), { from: (_b = (_a4 = modifiedContractOptions.from) !== null && _a4 !== undefined ? _a4 : this.defaultAccount) !== null && _b !== undefined ? _b : undefined });
    const tx2 = getSendTxParams({
      abi: abi2,
      params,
      options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
      contractOptions: modifiedContractOptions
    });
    return sendTransaction3(this, tx2, DEFAULT_RETURN_FORMAT, {
      transactionResolver: (receipt) => {
        if (receipt.status === BigInt(0)) {
          throw new Web3ContractError("code couldn't be stored", receipt);
        }
        const newContract = this.clone();
        newContract.options.address = receipt.contractAddress;
        return newContract;
      },
      contractAbi: this._jsonInterface,
      checkRevertBeforeSending: false
    });
  }
  _contractMethodEstimateGas({ abi: abi2, params, returnFormat, options, contractOptions }) {
    return __awaiter33(this, undefined, undefined, function* () {
      const tx2 = getEstimateGasParams({
        abi: abi2,
        params,
        options: Object.assign(Object.assign({}, options), { dataInputFill: this.config.contractDataInputFill }),
        contractOptions: contractOptions !== null && contractOptions !== undefined ? contractOptions : this.options
      });
      return estimateGas2(this, tx2, BlockTags.LATEST, returnFormat);
    });
  }
  _createContractEvent(abi2, returnFormat = DEFAULT_RETURN_FORMAT) {
    return (...params) => {
      var _a4;
      const { topics, fromBlock } = encodeEventABI(this.options, abi2, params[0]);
      const sub = new LogsSubscription2({
        address: this.options.address,
        topics,
        abi: abi2,
        jsonInterface: this._jsonInterface
      }, {
        subscriptionManager: this.subscriptionManager,
        returnFormat
      });
      if (!isNullish(fromBlock)) {
        this.getPastEvents(abi2.name, { fromBlock, topics }, returnFormat).then((logs) => {
          if (logs) {
            logs.forEach((log) => sub.emit("data", log));
          }
        }).catch((error) => {
          sub.emit("error", new SubscriptionError("Failed to get past events.", error));
        });
      }
      (_a4 = this.subscriptionManager) === null || _a4 === undefined || _a4.addSubscription(sub).catch((error) => {
        sub.emit("error", new SubscriptionError("Failed to subscribe.", error));
      });
      return sub;
    };
  }
  subscribeToContextEvents(context) {
    const contractThis = this;
    this.context = context;
    if (contractThis.syncWithContext) {
      context.on(Web3ConfigEvent.CONFIG_CHANGE, (event) => {
        contractThis.setConfig({ [event.name]: event.newValue });
      });
    }
  }
}

// node_modules/web3-eth-contract/lib/esm/index.js
var esm_default = Contract;

// node_modules/web3-eth-ens/lib/esm/config.js
var interfaceIds = {
  addr: "0x3b3b57de",
  name: "0x691f3431",
  abi: "0x2203ab56",
  pubkey: "0xc8690233",
  text: "0x59d1d43c",
  contenthash: "0xbc1c58d1"
};
var methodsInInterface = {
  setAddr: "addr",
  addr: "addr",
  setPubkey: "pubkey",
  pubkey: "pubkey",
  setContenthash: "contenthash",
  contenthash: "contenthash",
  text: "text",
  name: "name"
};
var registryAddresses = {
  main: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
  goerli: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
};
var networkIds = {
  "0x1": "main",
  "0x5": "goerli"
};

// node_modules/web3-eth-ens/lib/esm/abi/ens/ENSRegistry.js
var ENSRegistryAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes32",
        name: "label",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "NewOwner",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "resolver",
        type: "address"
      }
    ],
    name: "NewResolver",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "owner",
        type: "address"
      }
    ],
    name: "Transfer",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "recordExists",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "resolver",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "ttl",
    outputs: [
      {
        internalType: "uint64",
        name: "",
        type: "uint64"
      }
    ],
    stateMutability: "view",
    type: "function"
  }
];

// node_modules/web3-eth-ens/lib/esm/abi/ens/PublicResolver.js
var PublicResolverAbi = [
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "AddrChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "newAddress",
        type: "bytes"
      }
    ],
    name: "AddressChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "owner",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "operator",
        type: "address"
      },
      {
        indexed: false,
        internalType: "bool",
        name: "approved",
        type: "bool"
      }
    ],
    name: "ApprovalForAll",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "hash",
        type: "bytes"
      }
    ],
    name: "ContenthashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "record",
        type: "bytes"
      }
    ],
    name: "DNSRecordChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "name",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "DNSRecordDeleted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "DNSZoneCleared",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "lastzonehash",
        type: "bytes"
      },
      {
        indexed: false,
        internalType: "bytes",
        name: "zonehash",
        type: "bytes"
      }
    ],
    name: "DNSZonehashChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      },
      {
        indexed: false,
        internalType: "address",
        name: "implementer",
        type: "address"
      }
    ],
    name: "InterfaceChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "string",
        name: "name",
        type: "string"
      }
    ],
    name: "NameChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    name: "PubkeyChanged",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        indexed: true,
        internalType: "string",
        name: "indexedKey",
        type: "string"
      },
      {
        indexed: false,
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "TextChanged",
    type: "event"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "contentTypes",
        type: "uint256"
      }
    ],
    name: "ABI",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "address payable",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "uint256",
        name: "coinType",
        type: "uint256"
      }
    ],
    name: "addr",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "contenthash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      },
      {
        internalType: "uint16",
        name: "resource",
        type: "uint16"
      }
    ],
    name: "dnsRecord",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "name",
        type: "bytes32"
      }
    ],
    name: "hasDNSRecords",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "interfaceImplementer",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "account",
        type: "address"
      },
      {
        internalType: "address",
        name: "operator",
        type: "address"
      }
    ],
    name: "isApprovedForAll",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "name",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "pubkey",
    outputs: [
      {
        internalType: "bytes32",
        name: "x",
        type: "bytes32"
      },
      {
        internalType: "bytes32",
        name: "y",
        type: "bytes32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes4",
        name: "interfaceID",
        type: "bytes4"
      }
    ],
    name: "supportsInterface",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "string",
        name: "key",
        type: "string"
      }
    ],
    name: "text",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      }
    ],
    name: "zonehash",
    outputs: [
      {
        internalType: "bytes",
        name: "",
        type: "bytes"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "node",
        type: "bytes32"
      },
      {
        internalType: "address",
        name: "a",
        type: "address"
      }
    ],
    name: "setAddr",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// node_modules/@adraffy/ens-normalize/dist/index.mjs
var decode_arithmetic = function(bytes7) {
  let pos = 0;
  function u16() {
    return bytes7[pos++] << 8 | bytes7[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1;i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes7[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N = 31;
  const FULL = 2 ** N;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0;i < N; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b = b << 1 & MASK | 1;
    }
    while (a & ~b & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b = (b ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes7[pos_payload++] << 16 | bytes7[pos_payload++] << 8 | bytes7[pos_payload++]);
      case 2:
        return offset + 256 + (bytes7[pos_payload++] << 8 | bytes7[pos_payload++]);
      case 1:
        return offset + bytes7[pos_payload++];
      default:
        return x - 1;
    }
  });
};
var read_payload = function(v) {
  let pos = 0;
  return () => v[pos++];
};
var read_compressed_payload = function(s) {
  return read_payload(decode_arithmetic(unsafe_atob(s)));
};
var unsafe_atob = function(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n = s.length;
  let ret = new Uint8Array(6 * n >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0;i < n; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
};
var signed = function(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
};
var read_deltas = function(n, next) {
  let v = Array(n);
  for (let i = 0, x = 0;i < n; i++)
    v[i] = x += signed(next());
  return v;
};
var read_sorted = function(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n = next();
    if (!n)
      break;
    prev += x;
    for (let i = 0;i < n; i++) {
      ret.push(prev + i);
    }
    prev += n + 1;
  }
  return ret;
};
var read_sorted_arrays = function(next) {
  return read_array_while(() => {
    let v = read_sorted(next);
    if (v.length)
      return v;
  });
};
var read_mapped = function(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table(w, next));
  }
  return ret.flat();
};
var read_array_while = function(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
};
var read_transposed = function(n, w, next) {
  let m = Array(n).fill().map(() => []);
  for (let i = 0;i < w; i++) {
    read_deltas(n, next).forEach((x, j) => m[j].push(x));
  }
  return m;
};
var read_linear_table = function(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m = read_transposed(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
};
var read_replacement_table = function(w, next) {
  let n = 1 + next();
  let m = read_transposed(n, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
};
var read_trie = function(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode2([]), []);
  return ret;
  function decode2(Q) {
    let S = next();
    let B = read_array_while(() => {
      let cps = read_sorted(next).map((i) => sorted[i]);
      if (cps.length)
        return decode2(cps);
    });
    return { S, B, Q };
  }
  function expand({ S, B }, cps, saved) {
    if (S & 4 && saved === cps[cps.length - 1])
      return;
    if (S & 2)
      saved = cps[cps.length - 1];
    if (S & 1)
      ret.push(cps);
    for (let br of B) {
      for (let cp of br.Q) {
        expand(br, [...cps, cp], saved);
      }
    }
  }
};
var hex_cp = function(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
};
var quote_cp = function(cp) {
  return `{${hex_cp(cp)}}`;
};
var explode_cp = function(s) {
  let cps = [];
  for (let pos = 0, len = s.length;pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
};
var str_from_cps = function(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0;i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
};
var compare_arrays = function(a, b) {
  let n = a.length;
  let c = n - b.length;
  for (let i = 0;c == 0 && i < n; i++)
    c = a[i] - b[i];
  return c;
};
var unpack_cc = function(packed) {
  return packed >> 24 & 255;
};
var unpack_cp = function(packed) {
  return packed & 16777215;
};
var init$1 = function() {
  let r = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r));
  DECOMP = new Map;
  RECOMP = new Map;
  for (let [cp, cps] of read_mapped(r)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a, b] = cps;
      let bucket = RECOMP.get(a);
      if (!bucket) {
        bucket = new Map;
        RECOMP.set(a, bucket);
      }
      bucket.set(b, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
};
var is_hangul = function(cp) {
  return cp >= S0 && cp < S1;
};
var compose_pair = function(a, b) {
  if (a >= L0 && a < L1 && b >= V0 && b < V1) {
    return S0 + (a - L0) * N_COUNT + (b - V0) * T_COUNT;
  } else if (is_hangul(a) && b > T0 && b < T1 && (a - S0) % T_COUNT == 0) {
    return a + (b - T0);
  } else {
    let recomp = RECOMP.get(a);
    if (recomp) {
      recomp = recomp.get(b);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
};
var decomposed = function(cps) {
  if (!SHIFTED_RANK)
    init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add2(cp) {
    let cc = SHIFTED_RANK.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add2(L0 + l_index);
        add2(V0 + v_index);
        if (t_index > 0)
          add2(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add2(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i = 1;i < ret.length; i++) {
      let cc = unpack_cc(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc(ret[i]);
    }
  }
  return ret;
};
var composed_from_decomposed = function(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
};
var nfd = function(cps) {
  return decomposed(cps).map(unpack_cp);
};
var nfc = function(cps) {
  return composed_from_decomposed(decomposed(cps));
};
var group_has_cp = function(g, cp) {
  return g.P.has(cp) || g.Q.has(cp);
};
var init = function() {
  if (MAPPED)
    return;
  let r = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v) => v.forEach((x) => set.add(x));
  MAPPED = new Map(read_mapped(r));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i) => CM[i]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r);
  let unrestricted = r();
  const read_chunked = () => {
    let set = new Set;
    read_sorted_array().forEach((i) => set_add_many(set, chunks[i]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i) => {
    let N = read_array_while(r).map((x) => x + 96);
    if (N.length) {
      let R = i >= unrestricted;
      N[0] -= 32;
      N = str_from_cps(N);
      if (R)
        N = `Restricted[${N}]`;
      let P = read_chunked();
      let Q = read_chunked();
      let M = !r();
      return { N, P, Q, M, R };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = new Map;
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a, b) => a - b);
  wholes.forEach((cp, i) => {
    let d = r();
    let w = wholes[i] = d ? wholes[i - d] : { V: [], M: new Map };
    w.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w);
    }
  });
  for (let { V, M } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V) {
      let gs = GROUPS.filter((g) => group_has_cp(g, cp));
      let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
      if (!rec) {
        rec = { G: new Set, V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs);
    }
    let union = recs.flatMap((x) => Array_from(x.G));
    for (let { G, V: V2 } of recs) {
      let complement = new Set(union.filter((g) => !G.has(g)));
      for (let cp of V2) {
        M.set(cp, complement);
      }
    }
  }
  VALID = new Set;
  let multi = new Set;
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g of GROUPS) {
    for (let cp of g.P)
      add_to_union(cp);
    for (let cp of g.Q)
      add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r).map((v) => Emoji.from(v)).sort(compare_arrays);
  EMOJI_ROOT = new Map;
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = new Map;
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x of prev) {
      x.V = cps;
    }
  }
};
var quoted_cp = function(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
};
var bidi_qq = function(s) {
  return `"${s}"\u200E`;
};
var check_label_extension = function(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
};
var check_leading_underscore = function(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE);i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
};
var check_fenced = function(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev)
    throw error_placement(`leading ${prev}`);
  let n = cps.length;
  let last = -1;
  for (let i = 1;i < n; i++) {
    cp = cps[i];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i)
        throw error_placement(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n)
    throw error_placement(`trailing ${prev}`);
};
var safe_str_from_cps = function(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0]))
    buf.push("\u25CC");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n = cps.length;
  for (let i = 0;i < n; i++) {
    let cp = cps[i];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n)));
  return buf.join("");
};
var is_combining_mark = function(cp) {
  init();
  return CM.has(cp);
};
var should_escape = function(cp) {
  init();
  return ESCAPE.has(cp);
};
var ens_normalize = function(name) {
  return flatten(split2(name, nfc, filter_fe0f));
};
var split2 = function(name, nf, ef) {
  if (!name)
    return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type = "ASCII";
      } else {
        let chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
        if (!chars.length) {
          type = "Emoji";
        } else {
          if (CM.has(norm[0]))
            throw error_placement("leading combining mark");
          for (let i = 1;i < token_count; i++) {
            let cps = tokens[i];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique = Array_from(new Set(chars));
          let [g] = determine_group(unique);
          check_group(g, chars);
          check_whole(g, unique);
          type = g.N;
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
};
var check_whole = function(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : Array_from(set);
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => group_has_cp(g, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
};
var determine_group = function(unique) {
  let groups = GROUPS;
  for (let cp of unique) {
    let gs = groups.filter((g) => group_has_cp(g, cp));
    if (!gs.length) {
      if (!GROUPS.some((g) => group_has_cp(g, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
};
var flatten = function(split3) {
  return split3.map(({ input, error, output: output2 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split3.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output2);
  }).join(STOP_CH);
};
var error_disallowed = function(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
};
var error_group_member = function(g, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
};
var error_placement = function(where) {
  return new Error(`illegal placement: ${where}`);
};
var check_group = function(g, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g, cp)) {
      throw error_group_member(g, cp);
    }
  }
  if (g.M) {
    let decomposed2 = nfd(cps);
    for (let i = 1, e = decomposed2.length;i < e; i++) {
      if (NSM.has(decomposed2[i])) {
        let j = i + 1;
        for (let cp;j < e && NSM.has(cp = decomposed2[j]); j++) {
          for (let k = i;k < j; k++) {
            if (decomposed2[k] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i - 1, j)))} (${j - i}/${NSM_MAX})`);
        }
        i = j;
      }
    }
  }
};
var tokens_from_str = function(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
};
var filter_fe0f = function(cps) {
  return cps.filter((cp) => cp != FE0F);
};
var consume_emoji_reversed = function(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node)
      break;
    let { V } = node;
    if (V) {
      emoji = V;
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
};
var COMPRESSED$1 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
var FENCED = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
var COMPRESSED = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x) => Array.from(x);

class Emoji extends Array {
  get is_emoji() {
    return true;
  }
}
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;

// node_modules/web3-eth-ens/lib/esm/utils.js
var normalize = (name) => ens_normalize(name);
var namehash = (inputName) => {
  let node = "";
  for (let i = 0;i < 32; i += 1) {
    node += "00";
  }
  if (inputName) {
    const name = normalize(inputName);
    const labels = name.split(".");
    for (let i = labels.length - 1;i >= 0; i -= 1) {
      const labelSha = sha3Raw(labels[i]).slice(2);
      node = sha3Raw(`0x${node}${labelSha}`).slice(2);
    }
  }
  return `0x${node}`;
};

// node_modules/web3-eth-ens/lib/esm/registry.js
var __awaiter34 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Registry {
  constructor(context, customRegistryAddress) {
    this.contract = new Contract(ENSRegistryAbi, customRegistryAddress !== null && customRegistryAddress !== undefined ? customRegistryAddress : registryAddresses.main, context);
    this.context = context;
  }
  getOwner(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        const result = this.contract.methods.owner(namehash(name)).call();
        return result;
      } catch (error) {
        throw new Error;
      }
    });
  }
  getTTL(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        return this.contract.methods.ttl(namehash(name)).call();
      } catch (error) {
        throw new Error;
      }
    });
  }
  recordExists(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        const promise = this.contract.methods.recordExists(namehash(name)).call();
        return promise;
      } catch (error) {
        throw new Error;
      }
    });
  }
  getResolver(name) {
    return __awaiter34(this, undefined, undefined, function* () {
      try {
        return this.contract.methods.resolver(namehash(name)).call().then((address7) => {
          if (typeof address7 === "string") {
            const contract3 = new Contract(PublicResolverAbi, address7, this.context);
            return contract3;
          }
          throw new Error;
        });
      } catch (error) {
        throw new Error;
      }
    });
  }
  get events() {
    return this.contract.events;
  }
}

// node_modules/web3-eth-ens/lib/esm/resolver.js
var __awaiter35 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Resolver {
  constructor(registry) {
    this.registry = registry;
  }
  getResolverContractAdapter(ENSName) {
    return __awaiter35(this, undefined, undefined, function* () {
      return this.registry.getResolver(ENSName);
    });
  }
  checkInterfaceSupport(resolverContract, methodName) {
    var _a4, _b;
    return __awaiter35(this, undefined, undefined, function* () {
      if (isNullish2(interfaceIds[methodName]))
        throw new ResolverMethodMissingError((_a4 = resolverContract.options.address) !== null && _a4 !== undefined ? _a4 : "", methodName);
      const supported = yield resolverContract.methods.supportsInterface(interfaceIds[methodName]).call();
      if (!supported)
        throw new ResolverMethodMissingError((_b = resolverContract.options.address) !== null && _b !== undefined ? _b : "", methodName);
    });
  }
  supportsInterface(ENSName, interfaceId) {
    var _a4;
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      let interfaceIdParam = interfaceId;
      if (!isHexStrict(interfaceIdParam)) {
        interfaceIdParam = (_a4 = sha32(interfaceId)) !== null && _a4 !== undefined ? _a4 : "";
        if (interfaceId === "")
          throw new Error("Invalid interface Id");
        interfaceIdParam = interfaceIdParam.slice(0, 10);
      }
      return resolverContract.methods.supportsInterface(interfaceIdParam).call();
    });
  }
  getAddress(ENSName, coinType = 60) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.addr);
      return resolverContract.methods.addr(namehash(ENSName), coinType).call();
    });
  }
  getPubkey(ENSName) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.pubkey);
      return resolverContract.methods.pubkey(namehash(ENSName)).call();
    });
  }
  getContenthash(ENSName) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.contenthash);
      return resolverContract.methods.contenthash(namehash(ENSName)).call();
    });
  }
  setAddress(ENSName, address7, txConfig) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.setAddr);
      return resolverContract.methods.setAddr(namehash(ENSName), address7).send(txConfig);
    });
  }
  getText(ENSName, key) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(ENSName);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.text);
      return resolverContract.methods.text(namehash(ENSName), key).call();
    });
  }
  getName(address7) {
    return __awaiter35(this, undefined, undefined, function* () {
      const resolverContract = yield this.getResolverContractAdapter(address7);
      yield this.checkInterfaceSupport(resolverContract, methodsInInterface.name);
      return resolverContract.methods.name(namehash(address7)).call();
    });
  }
}

// node_modules/web3-eth-ens/lib/esm/ens.js
var __awaiter36 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class ENS extends Web3Context {
  constructor(registryAddr, provider) {
    super(provider !== null && provider !== undefined ? provider : "");
    this.registryAddress = registryAddr !== null && registryAddr !== undefined ? registryAddr : registryAddresses.main;
    this._registry = new Registry(this.getContextObject(), registryAddr);
    this._resolver = new Resolver(this._registry);
  }
  getResolver(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.getResolver(name);
    });
  }
  recordExists(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.recordExists(name);
    });
  }
  getTTL(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.getTTL(name);
    });
  }
  getOwner(name) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._registry.getOwner(name);
    });
  }
  getAddress(ENSName, coinType = 60) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getAddress(ENSName, coinType);
    });
  }
  getText(ENSName, key) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getText(ENSName, key);
    });
  }
  getName(ENSName) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getName(ENSName);
    });
  }
  getPubkey(ENSName) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getPubkey(ENSName);
    });
  }
  getContenthash(ENSName) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.getContenthash(ENSName);
    });
  }
  checkNetwork() {
    return __awaiter36(this, undefined, undefined, function* () {
      const now = Date.now() / 1000;
      if (!this._lastSyncCheck || now - this._lastSyncCheck > 3600) {
        const syncInfo = yield isSyncing(this);
        if (!(typeof syncInfo === "boolean" && !syncInfo)) {
          throw new ENSNetworkNotSyncedError;
        }
        this._lastSyncCheck = now;
      }
      if (this._detectedAddress) {
        return this._detectedAddress;
      }
      const networkType = yield getId2(this, Object.assign(Object.assign({}, DEFAULT_RETURN_FORMAT), { number: FMT_NUMBER.HEX }));
      const addr = registryAddresses[networkIds[networkType]];
      if (typeof addr === "undefined") {
        throw new ENSUnsupportedNetworkError(networkType);
      }
      this._detectedAddress = addr;
      return this._detectedAddress;
    });
  }
  supportsInterface(ENSName, interfaceId) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.supportsInterface(ENSName, interfaceId);
    });
  }
  get events() {
    return this._registry.events;
  }
  setAddress(name, address7, txConfig) {
    return __awaiter36(this, undefined, undefined, function* () {
      return this._resolver.setAddress(name, address7, txConfig);
    });
  }
}
// node_modules/web3-eth-personal/lib/esm/rpc_method_wrappers.js
var __awaiter37 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var getAccounts3 = (requestManager) => __awaiter37(undefined, undefined, undefined, function* () {
  const result = yield exports_personal_rpc_methods.getAccounts(requestManager);
  return result.map(toChecksumAddress);
});
var newAccount2 = (requestManager, password) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string"], [password]);
  const result = yield exports_personal_rpc_methods.newAccount(requestManager, password);
  return toChecksumAddress(result);
});
var unlockAccount2 = (requestManager, address7, password, unlockDuration) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["address", "string", "uint"], [address7, password, unlockDuration]);
  return exports_personal_rpc_methods.unlockAccount(requestManager, address7, password, unlockDuration);
});
var lockAccount2 = (requestManager, address7) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["address"], [address7]);
  return exports_personal_rpc_methods.lockAccount(requestManager, address7);
});
var importRawKey2 = (requestManager, keyData, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string", "string"], [keyData, passphrase]);
  return exports_personal_rpc_methods.importRawKey(requestManager, keyData, passphrase);
});
var sendTransaction4 = (requestManager, tx2, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  const formattedTx = formatTransaction(tx2, ETH_DATA_FORMAT);
  return exports_personal_rpc_methods.sendTransaction(requestManager, formattedTx, passphrase);
});
var signTransaction5 = (requestManager, tx2, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  const formattedTx = formatTransaction(tx2, ETH_DATA_FORMAT);
  return exports_personal_rpc_methods.signTransaction(requestManager, formattedTx, passphrase);
});
var sign5 = (requestManager, data, address7, passphrase) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string", "address", "string"], [data, address7, passphrase]);
  const dataToSign = isHexStrict(data) ? data : utf8ToHex(data);
  return exports_personal_rpc_methods.sign(requestManager, dataToSign, address7, passphrase);
});
var ecRecover2 = (requestManager, signedData, signature) => __awaiter37(undefined, undefined, undefined, function* () {
  validator2.validate(["string", "string"], [signedData, signature]);
  const signedDataString = isHexStrict(signedData) ? signedData : utf8ToHex(signedData);
  return exports_personal_rpc_methods.ecRecover(requestManager, signedDataString, signature);
});

// node_modules/web3-eth-personal/lib/esm/personal.js
var __awaiter38 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};

class Personal extends Web3Context {
  getAccounts() {
    return __awaiter38(this, undefined, undefined, function* () {
      return getAccounts3(this.requestManager);
    });
  }
  newAccount(password) {
    return __awaiter38(this, undefined, undefined, function* () {
      return newAccount2(this.requestManager, password);
    });
  }
  unlockAccount(address7, password, unlockDuration) {
    return __awaiter38(this, undefined, undefined, function* () {
      return unlockAccount2(this.requestManager, address7, password, unlockDuration);
    });
  }
  lockAccount(address7) {
    return __awaiter38(this, undefined, undefined, function* () {
      return lockAccount2(this.requestManager, address7);
    });
  }
  importRawKey(keyData, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return importRawKey2(this.requestManager, keyData, passphrase);
    });
  }
  sendTransaction(tx2, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return sendTransaction4(this.requestManager, tx2, passphrase);
    });
  }
  signTransaction(tx2, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return signTransaction5(this.requestManager, tx2, passphrase);
    });
  }
  sign(data, address7, passphrase) {
    return __awaiter38(this, undefined, undefined, function* () {
      return sign5(this.requestManager, data, address7, passphrase);
    });
  }
  ecRecover(signedData, signature) {
    return __awaiter38(this, undefined, undefined, function* () {
      return ecRecover2(this.requestManager, signedData, signature);
    });
  }
}
// node_modules/web3/lib/esm/abi.js
var abi_default = {
  encodeEventSignature,
  encodeFunctionCall,
  encodeFunctionSignature,
  encodeParameter,
  encodeParameters,
  decodeParameter,
  decodeParameters: decodeParameters2,
  decodeLog
};

// node_modules/web3/lib/esm/accounts.js
var __awaiter39 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var initAccountsForContext = (context) => {
  const signTransactionWithContext = (transaction, privateKey) => __awaiter39(undefined, undefined, undefined, function* () {
    const tx2 = yield prepareTransactionForSigning(transaction, context);
    const privateKeyBytes = format({ format: "bytes" }, privateKey, ETH_DATA_FORMAT);
    return signTransaction(tx2, privateKeyBytes);
  });
  const privateKeyToAccountWithContext = (privateKey) => {
    const account2 = privateKeyToAccount(privateKey);
    return Object.assign(Object.assign({}, account2), { signTransaction: (transaction) => __awaiter39(undefined, undefined, undefined, function* () {
      return signTransactionWithContext(transaction, account2.privateKey);
    }) });
  };
  const decryptWithContext = (keystore, password, options) => __awaiter39(undefined, undefined, undefined, function* () {
    var _a4;
    const account2 = yield decrypt2(keystore, password, (_a4 = options === null || options === undefined ? undefined : options.nonStrict) !== null && _a4 !== undefined ? _a4 : true);
    return Object.assign(Object.assign({}, account2), { signTransaction: (transaction) => __awaiter39(undefined, undefined, undefined, function* () {
      return signTransactionWithContext(transaction, account2.privateKey);
    }) });
  });
  const createWithContext = () => {
    const account2 = create();
    return Object.assign(Object.assign({}, account2), { signTransaction: (transaction) => __awaiter39(undefined, undefined, undefined, function* () {
      return signTransactionWithContext(transaction, account2.privateKey);
    }) });
  };
  const wallet2 = new Wallet({
    create: createWithContext,
    privateKeyToAccount: privateKeyToAccountWithContext,
    decrypt: decryptWithContext
  });
  return {
    signTransaction: signTransactionWithContext,
    create: createWithContext,
    privateKeyToAccount: privateKeyToAccountWithContext,
    decrypt: decryptWithContext,
    recoverTransaction,
    hashMessage,
    sign,
    recover,
    encrypt: encrypt2,
    wallet: wallet2,
    privateKeyToAddress,
    parseAndValidatePrivateKey,
    privateKeyToPublicKey
  };
};

// node_modules/web3/lib/esm/version.js
var Web3PkgInfo = { version: "4.7.0" };

// node_modules/web3/lib/esm/web3_eip6963.js
var __awaiter40 = function(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value) {
      try {
        step(generator["throw"](value));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
};
var Eip6963EventName;
(function(Eip6963EventName2) {
  Eip6963EventName2["eip6963announceProvider"] = "eip6963:announceProvider";
  Eip6963EventName2["eip6963requestProvider"] = "eip6963:requestProvider";
})(Eip6963EventName || (Eip6963EventName = {}));
var eip6963ProvidersMap = new Map;
var web3ProvidersMapUpdated = "web3:providersMapUpdated";
var requestEIP6963Providers = () => __awaiter40(undefined, undefined, undefined, function* () {
  return new Promise((resolve, reject) => {
    if (typeof window === "undefined") {
      reject(new Error("window object not available, EIP-6963 is intended to be used within a browser"));
    }
    window.addEventListener(Eip6963EventName.eip6963announceProvider, (event) => {
      eip6963ProvidersMap.set(event.detail.info.uuid, event.detail);
      const newEvent = new CustomEvent(web3ProvidersMapUpdated, { detail: eip6963ProvidersMap });
      window.dispatchEvent(newEvent);
      resolve(eip6963ProvidersMap);
    });
    window.dispatchEvent(new Event(Eip6963EventName.eip6963requestProvider));
  });
});
var onNewProviderDiscovered = (callback) => {
  if (typeof window === "undefined") {
    throw new Error("window object not available, EIP-6963 is intended to be used within a browser");
  }
  window.addEventListener(web3ProvidersMapUpdated, callback);
};

// node_modules/web3/lib/esm/web3.js
class Web3 extends Web3Context {
  constructor(providerOrContext) {
    var _a4;
    if (isNullish2(providerOrContext) || typeof providerOrContext === "string" && providerOrContext.trim() === "" || typeof providerOrContext !== "string" && !isSupportedProvider(providerOrContext) && !providerOrContext.provider) {
      console.warn("NOTE: web3.js is running without provider. You need to pass a provider in order to interact with the network!");
    }
    let contextInitOptions = {};
    if (typeof providerOrContext === "string" || isSupportedProvider(providerOrContext)) {
      contextInitOptions.provider = providerOrContext;
    } else if (providerOrContext) {
      contextInitOptions = providerOrContext;
    } else {
      contextInitOptions = {};
    }
    contextInitOptions.registeredSubscriptions = Object.assign(Object.assign({}, registeredSubscriptions), (_a4 = contextInitOptions.registeredSubscriptions) !== null && _a4 !== undefined ? _a4 : {});
    super(contextInitOptions);
    const accounts2 = initAccountsForContext(this);
    this._wallet = accounts2.wallet;
    this._accountProvider = accounts2;
    this.utils = exports_esm;
    const self2 = this;

    class ContractBuilder extends esm_default {
      constructor(jsonInterface, addressOrOptionsOrContext, optionsOrContextOrReturnFormat, contextOrReturnFormat, returnFormat) {
        if (isContractInitOptions(addressOrOptionsOrContext) && isContractInitOptions(optionsOrContextOrReturnFormat)) {
          throw new InvalidMethodParamsError("Should not provide options at both 2nd and 3rd parameters");
        }
        let address7;
        let options = {};
        let context;
        let dataFormat = DEFAULT_RETURN_FORMAT;
        if (!isNullish2(addressOrOptionsOrContext) && typeof addressOrOptionsOrContext !== "object" && typeof addressOrOptionsOrContext !== "string") {
          throw new InvalidMethodParamsError;
        }
        if (typeof addressOrOptionsOrContext === "string") {
          address7 = addressOrOptionsOrContext;
        }
        if (isContractInitOptions(addressOrOptionsOrContext)) {
          options = addressOrOptionsOrContext;
        } else if (isContractInitOptions(optionsOrContextOrReturnFormat)) {
          options = optionsOrContextOrReturnFormat;
        } else {
          options = {};
        }
        if (addressOrOptionsOrContext instanceof Web3Context) {
          context = addressOrOptionsOrContext;
        } else if (optionsOrContextOrReturnFormat instanceof Web3Context) {
          context = optionsOrContextOrReturnFormat;
        } else if (contextOrReturnFormat instanceof Web3Context) {
          context = contextOrReturnFormat;
        } else {
          context = self2.getContextObject();
        }
        if (returnFormat) {
          dataFormat = returnFormat;
        } else if (isDataFormat(optionsOrContextOrReturnFormat)) {
          dataFormat = optionsOrContextOrReturnFormat;
        } else if (isDataFormat(contextOrReturnFormat)) {
          dataFormat = contextOrReturnFormat;
        }
        super(jsonInterface, address7, options, context, dataFormat);
        super.subscribeToContextEvents(self2);
      }
    }
    const eth2 = self2.use(Web3Eth);
    this.eth = Object.assign(eth2, {
      ens: self2.use(ENS, registryAddresses.main),
      Iban,
      net: self2.use(Net),
      personal: self2.use(Personal),
      Contract: ContractBuilder,
      abi: abi_default,
      accounts: accounts2
    });
  }
}
Web3.version = Web3PkgInfo.version;
Web3.utils = exports_esm;
Web3.requestEIP6963Providers = requestEIP6963Providers;
Web3.onNewProviderDiscovered = onNewProviderDiscovered;
Web3.modules = {
  Web3Eth,
  Iban,
  Net,
  ENS,
  Personal
};
var web3_default = Web3;
// packages/compound-v2-liquidator/utils/helpers/array.helpers.ts
function findIndexByAddr(arr, _address) {
  return arr.findIndex(({ address: address7 }) => address7 === _address);
}
function findAsset(account2, cToken) {
  const index = findIndexByAddr(account2.assets, cToken);
  return account2.assets[index];
}
function sortLogs(events) {
  return events.sort((a, b) => {
    if (a.blockNumber !== b.blockNumber) {
      return a.blockNumber - b.blockNumber;
    }
    if (a.transactionIndex !== b.transactionIndex) {
      return a.transactionIndex - b.transactionIndex;
    }
    return a.logIndex - b.logIndex;
  });
}
function filterAbi(abi3, eventNames) {
  return abi3.filter((item) => item.type === "event" && eventNames.includes(item.name));
}
function getAbiItem(abi3, type, name) {
  return abi3.find((item) => item.type === type && item.name === name);
}

// ../../node_modules/ethers/lib.esm/ethers.js
var exports_ethers = {};
__export(exports_ethers, {
  zeroPadValue: () => {
    {
      return zeroPadValue;
    }
  },
  zeroPadBytes: () => {
    {
      return zeroPadBytes;
    }
  },
  wordlists: () => {
    {
      return wordlists2;
    }
  },
  version: () => {
    {
      return version2;
    }
  },
  verifyTypedData: () => {
    {
      return verifyTypedData;
    }
  },
  verifyMessage: () => {
    {
      return verifyMessage;
    }
  },
  uuidV4: () => {
    {
      return uuidV42;
    }
  },
  toUtf8String: () => {
    {
      return toUtf8String;
    }
  },
  toUtf8CodePoints: () => {
    {
      return toUtf8CodePoints;
    }
  },
  toUtf8Bytes: () => {
    {
      return toUtf8Bytes;
    }
  },
  toTwos: () => {
    {
      return toTwos;
    }
  },
  toQuantity: () => {
    {
      return toQuantity;
    }
  },
  toNumber: () => {
    {
      return toNumber2;
    }
  },
  toBigInt: () => {
    {
      return toBigInt2;
    }
  },
  toBeHex: () => {
    {
      return toBeHex;
    }
  },
  toBeArray: () => {
    {
      return toBeArray;
    }
  },
  stripZerosLeft: () => {
    {
      return stripZerosLeft;
    }
  },
  solidityPackedSha256: () => {
    {
      return solidityPackedSha256;
    }
  },
  solidityPackedKeccak256: () => {
    {
      return solidityPackedKeccak256;
    }
  },
  solidityPacked: () => {
    {
      return solidityPacked;
    }
  },
  showThrottleMessage: () => {
    {
      return showThrottleMessage;
    }
  },
  sha512: () => {
    {
      return sha5123;
    }
  },
  sha256: () => {
    {
      return sha2567;
    }
  },
  scryptSync: () => {
    {
      return scryptSync2;
    }
  },
  scrypt: () => {
    {
      return scrypt6;
    }
  },
  ripemd160: () => {
    {
      return ripemd1603;
    }
  },
  resolveProperties: () => {
    {
      return resolveProperties;
    }
  },
  resolveAddress: () => {
    {
      return resolveAddress;
    }
  },
  recoverAddress: () => {
    {
      return recoverAddress;
    }
  },
  randomBytes: () => {
    {
      return randomBytes4;
    }
  },
  pbkdf2: () => {
    {
      return pbkdf25;
    }
  },
  parseUnits: () => {
    {
      return parseUnits;
    }
  },
  parseEther: () => {
    {
      return parseEther;
    }
  },
  namehash: () => {
    {
      return namehash2;
    }
  },
  mask: () => {
    {
      return mask2;
    }
  },
  makeError: () => {
    {
      return makeError;
    }
  },
  lock: () => {
    {
      return lock;
    }
  },
  keccak256: () => {
    {
      return keccak2562;
    }
  },
  isValidName: () => {
    {
      return isValidName;
    }
  },
  isKeystoreJson: () => {
    {
      return isKeystoreJson;
    }
  },
  isHexString: () => {
    {
      return isHexString2;
    }
  },
  isError: () => {
    {
      return isError;
    }
  },
  isCrowdsaleJson: () => {
    {
      return isCrowdsaleJson;
    }
  },
  isCallException: () => {
    {
      return isCallException;
    }
  },
  isBytesLike: () => {
    {
      return isBytesLike;
    }
  },
  isAddressable: () => {
    {
      return isAddressable;
    }
  },
  isAddress: () => {
    {
      return isAddress3;
    }
  },
  id: () => {
    {
      return id;
    }
  },
  hexlify: () => {
    {
      return hexlify;
    }
  },
  hashMessage: () => {
    {
      return hashMessage2;
    }
  },
  getUint: () => {
    {
      return getUint;
    }
  },
  getNumber: () => {
    {
      return getNumber;
    }
  },
  getIndexedAccountPath: () => {
    {
      return getIndexedAccountPath;
    }
  },
  getIcapAddress: () => {
    {
      return getIcapAddress;
    }
  },
  getDefaultProvider: () => {
    {
      return getDefaultProvider;
    }
  },
  getCreateAddress: () => {
    {
      return getCreateAddress;
    }
  },
  getCreate2Address: () => {
    {
      return getCreate2Address;
    }
  },
  getBytesCopy: () => {
    {
      return getBytesCopy;
    }
  },
  getBytes: () => {
    {
      return getBytes;
    }
  },
  getBigInt: () => {
    {
      return getBigInt;
    }
  },
  getAddress: () => {
    {
      return getAddress;
    }
  },
  getAccountPath: () => {
    {
      return getAccountPath;
    }
  },
  fromTwos: () => {
    {
      return fromTwos;
    }
  },
  formatUnits: () => {
    {
      return formatUnits;
    }
  },
  formatEther: () => {
    {
      return formatEther;
    }
  },
  ensNormalize: () => {
    {
      return ensNormalize;
    }
  },
  encryptKeystoreJsonSync: () => {
    {
      return encryptKeystoreJsonSync;
    }
  },
  encryptKeystoreJson: () => {
    {
      return encryptKeystoreJson;
    }
  },
  encodeRlp: () => {
    {
      return encodeRlp;
    }
  },
  encodeBytes32String: () => {
    {
      return encodeBytes32String;
    }
  },
  encodeBase64: () => {
    {
      return encodeBase64;
    }
  },
  encodeBase58: () => {
    {
      return encodeBase58;
    }
  },
  dnsEncode: () => {
    {
      return dnsEncode;
    }
  },
  defineProperties: () => {
    {
      return defineProperties;
    }
  },
  defaultPath: () => {
    {
      return defaultPath2;
    }
  },
  decryptKeystoreJsonSync: () => {
    {
      return decryptKeystoreJsonSync;
    }
  },
  decryptKeystoreJson: () => {
    {
      return decryptKeystoreJson;
    }
  },
  decryptCrowdsaleJson: () => {
    {
      return decryptCrowdsaleJson;
    }
  },
  decodeRlp: () => {
    {
      return decodeRlp;
    }
  },
  decodeBytes32String: () => {
    {
      return decodeBytes32String;
    }
  },
  decodeBase64: () => {
    {
      return decodeBase64;
    }
  },
  decodeBase58: () => {
    {
      return decodeBase58;
    }
  },
  dataSlice: () => {
    {
      return dataSlice;
    }
  },
  dataLength: () => {
    {
      return dataLength;
    }
  },
  copyRequest: () => {
    {
      return copyRequest;
    }
  },
  concat: () => {
    {
      return concat;
    }
  },
  computeHmac: () => {
    {
      return computeHmac;
    }
  },
  computeAddress: () => {
    {
      return computeAddress;
    }
  },
  checkResultErrors: () => {
    {
      return checkResultErrors;
    }
  },
  assertPrivate: () => {
    {
      return assertPrivate;
    }
  },
  assertNormalize: () => {
    {
      return assertNormalize;
    }
  },
  assertArgumentCount: () => {
    {
      return assertArgumentCount;
    }
  },
  assertArgument: () => {
    {
      return assertArgument;
    }
  },
  assert: () => {
    {
      return assert2;
    }
  },
  accessListify: () => {
    {
      return accessListify;
    }
  },
  ZeroHash: () => {
    {
      return ZeroHash;
    }
  },
  ZeroAddress: () => {
    {
      return ZeroAddress;
    }
  },
  WordlistOwlA: () => {
    {
      return WordlistOwlA;
    }
  },
  WordlistOwl: () => {
    {
      return WordlistOwl;
    }
  },
  Wordlist: () => {
    {
      return Wordlist;
    }
  },
  WeiPerEther: () => {
    {
      return WeiPerEther;
    }
  },
  WebSocketProvider: () => {
    {
      return WebSocketProvider2;
    }
  },
  Wallet: () => {
    {
      return Wallet2;
    }
  },
  VoidSigner: () => {
    {
      return VoidSigner;
    }
  },
  Utf8ErrorFuncs: () => {
    {
      return Utf8ErrorFuncs;
    }
  },
  UnmanagedSubscriber: () => {
    {
      return UnmanagedSubscriber;
    }
  },
  UndecodedEventLog: () => {
    {
      return UndecodedEventLog;
    }
  },
  TypedDataEncoder: () => {
    {
      return TypedDataEncoder;
    }
  },
  Typed: () => {
    {
      return Typed;
    }
  },
  TransactionResponse: () => {
    {
      return TransactionResponse;
    }
  },
  TransactionReceipt: () => {
    {
      return TransactionReceipt;
    }
  },
  TransactionDescription: () => {
    {
      return TransactionDescription;
    }
  },
  Transaction: () => {
    {
      return Transaction2;
    }
  },
  StructFragment: () => {
    {
      return StructFragment;
    }
  },
  SocketSubscriber: () => {
    {
      return SocketSubscriber;
    }
  },
  SocketProvider: () => {
    {
      return SocketProvider2;
    }
  },
  SocketPendingSubscriber: () => {
    {
      return SocketPendingSubscriber;
    }
  },
  SocketEventSubscriber: () => {
    {
      return SocketEventSubscriber;
    }
  },
  SocketBlockSubscriber: () => {
    {
      return SocketBlockSubscriber;
    }
  },
  SigningKey: () => {
    {
      return SigningKey;
    }
  },
  Signature: () => {
    {
      return Signature2;
    }
  },
  Result: () => {
    {
      return Result;
    }
  },
  QuickNodeProvider: () => {
    {
      return QuickNodeProvider;
    }
  },
  PocketProvider: () => {
    {
      return PocketProvider;
    }
  },
  ParamType: () => {
    {
      return ParamType;
    }
  },
  NonceManager: () => {
    {
      return NonceManager;
    }
  },
  NetworkPlugin: () => {
    {
      return NetworkPlugin;
    }
  },
  Network: () => {
    {
      return Network;
    }
  },
  NamedFragment: () => {
    {
      return NamedFragment;
    }
  },
  N: () => {
    {
      return N;
    }
  },
  MulticoinProviderPlugin: () => {
    {
      return MulticoinProviderPlugin;
    }
  },
  Mnemonic: () => {
    {
      return Mnemonic;
    }
  },
  MinInt256: () => {
    {
      return MinInt256;
    }
  },
  MessagePrefix: () => {
    {
      return MessagePrefix;
    }
  },
  MaxUint256: () => {
    {
      return MaxUint256;
    }
  },
  MaxInt256: () => {
    {
      return MaxInt256;
    }
  },
  LogDescription: () => {
    {
      return LogDescription;
    }
  },
  Log: () => {
    {
      return Log;
    }
  },
  LangEn: () => {
    {
      return LangEn;
    }
  },
  JsonRpcSigner: () => {
    {
      return JsonRpcSigner;
    }
  },
  JsonRpcProvider: () => {
    {
      return JsonRpcProvider;
    }
  },
  JsonRpcApiProvider: () => {
    {
      return JsonRpcApiProvider;
    }
  },
  IpcSocketProvider: () => {
    {
      return IpcSocketProvider;
    }
  },
  Interface: () => {
    {
      return Interface;
    }
  },
  InfuraWebSocketProvider: () => {
    {
      return InfuraWebSocketProvider;
    }
  },
  InfuraProvider: () => {
    {
      return InfuraProvider;
    }
  },
  Indexed: () => {
    {
      return Indexed;
    }
  },
  HDNodeWallet: () => {
    {
      return HDNodeWallet;
    }
  },
  HDNodeVoidWallet: () => {
    {
      return HDNodeVoidWallet;
    }
  },
  GasCostPlugin: () => {
    {
      return GasCostPlugin;
    }
  },
  FunctionFragment: () => {
    {
      return FunctionFragment;
    }
  },
  Fragment: () => {
    {
      return Fragment;
    }
  },
  FixedNumber: () => {
    {
      return FixedNumber;
    }
  },
  FetchUrlFeeDataNetworkPlugin: () => {
    {
      return FetchUrlFeeDataNetworkPlugin;
    }
  },
  FetchResponse: () => {
    {
      return FetchResponse;
    }
  },
  FetchRequest: () => {
    {
      return FetchRequest;
    }
  },
  FetchCancelSignal: () => {
    {
      return FetchCancelSignal;
    }
  },
  FeeDataNetworkPlugin: () => {
    {
      return FeeDataNetworkPlugin;
    }
  },
  FeeData: () => {
    {
      return FeeData;
    }
  },
  FallbackProvider: () => {
    {
      return FallbackProvider;
    }
  },
  FallbackFragment: () => {
    {
      return FallbackFragment;
    }
  },
  EventPayload: () => {
    {
      return EventPayload;
    }
  },
  EventLog: () => {
    {
      return EventLog;
    }
  },
  EventFragment: () => {
    {
      return EventFragment;
    }
  },
  EtherscanProvider: () => {
    {
      return EtherscanProvider;
    }
  },
  EtherscanPlugin: () => {
    {
      return EtherscanPlugin;
    }
  },
  EtherSymbol: () => {
    {
      return EtherSymbol;
    }
  },
  ErrorFragment: () => {
    {
      return ErrorFragment;
    }
  },
  ErrorDescription: () => {
    {
      return ErrorDescription;
    }
  },
  EnsResolver: () => {
    {
      return EnsResolver;
    }
  },
  EnsPlugin: () => {
    {
      return EnsPlugin;
    }
  },
  ContractUnknownEventPayload: () => {
    {
      return ContractUnknownEventPayload;
    }
  },
  ContractTransactionResponse: () => {
    {
      return ContractTransactionResponse;
    }
  },
  ContractTransactionReceipt: () => {
    {
      return ContractTransactionReceipt;
    }
  },
  ContractFactory: () => {
    {
      return ContractFactory;
    }
  },
  ContractEventPayload: () => {
    {
      return ContractEventPayload;
    }
  },
  Contract: () => {
    {
      return Contract2;
    }
  },
  ConstructorFragment: () => {
    {
      return ConstructorFragment;
    }
  },
  CloudflareProvider: () => {
    {
      return CloudflareProvider;
    }
  },
  BrowserProvider: () => {
    {
      return BrowserProvider;
    }
  },
  Block: () => {
    {
      return Block;
    }
  },
  BaseWallet: () => {
    {
      return BaseWallet;
    }
  },
  BaseContract: () => {
    {
      return BaseContract;
    }
  },
  AnkrProvider: () => {
    {
      return AnkrProvider;
    }
  },
  AlchemyProvider: () => {
    {
      return AlchemyProvider;
    }
  },
  AbstractSigner: () => {
    {
      return AbstractSigner;
    }
  },
  AbstractProvider: () => {
    {
      return AbstractProvider;
    }
  },
  AbiCoder: () => {
    {
      return AbiCoder;
    }
  }
});

// ../../node_modules/ethers/lib.esm/_version.js
var version2 = "6.7.0";

// ../../node_modules/ethers/lib.esm/utils/properties.js
var checkType = function(value, type, name) {
  const types15 = type.split("|").map((t) => t.trim());
  for (let i = 0;i < types15.length; i++) {
    switch (type) {
      case "any":
        return;
      case "bigint":
      case "boolean":
      case "number":
      case "string":
        if (typeof value === type) {
          return;
        }
    }
  }
  const error = new Error(`invalid value for type ${type}`);
  error.code = "INVALID_ARGUMENT";
  error.argument = `value.${name}`;
  error.value = value;
  throw error;
};
async function resolveProperties(value) {
  const keys = Object.keys(value);
  const results = await Promise.all(keys.map((k) => Promise.resolve(value[k])));
  return results.reduce((accum, v, index) => {
    accum[keys[index]] = v;
    return accum;
  }, {});
}
function defineProperties(target, values, types15) {
  for (let key in values) {
    let value = values[key];
    const type = types15 ? types15[key] : null;
    if (type) {
      checkType(value, type, key);
    }
    Object.defineProperty(target, key, { enumerable: true, value, writable: false });
  }
}

// ../../node_modules/ethers/lib.esm/utils/errors.js
var stringify = function(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[ " + value.map(stringify).join(", ") + " ]";
  }
  if (value instanceof Uint8Array) {
    const HEX = "0123456789abcdef";
    let result = "0x";
    for (let i = 0;i < value.length; i++) {
      result += HEX[value[i] >> 4];
      result += HEX[value[i] & 15];
    }
    return result;
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return stringify(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
      return BigInt(value).toString();
    case "number":
      return value.toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{ " + keys.map((k) => `${stringify(k)}: ${stringify(value[k])}`).join(", ") + " }";
    }
  }
  return `[ COULD NOT SERIALIZE ]`;
};
function isError(error, code) {
  return error && error.code === code;
}
function isCallException(error) {
  return isError(error, "CALL_EXCEPTION");
}
function makeError(message, code, info) {
  {
    const details = [];
    if (info) {
      if ("message" in info || "code" in info || "name" in info) {
        throw new Error(`value will overwrite populated values: ${stringify(info)}`);
      }
      for (const key in info) {
        const value = info[key];
        details.push(key + "=" + stringify(value));
      }
    }
    details.push(`code=${code}`);
    details.push(`version=${version2}`);
    if (details.length) {
      message += " (" + details.join(", ") + ")";
    }
  }
  let error;
  switch (code) {
    case "INVALID_ARGUMENT":
      error = new TypeError(message);
      break;
    case "NUMERIC_FAULT":
    case "BUFFER_OVERRUN":
      error = new RangeError(message);
      break;
    default:
      error = new Error(message);
  }
  defineProperties(error, { code });
  if (info) {
    Object.assign(error, info);
  }
  return error;
}
function assert2(check, message, code, info) {
  if (!check) {
    throw makeError(message, code, info);
  }
}
function assertArgument(check, message, name, value) {
  assert2(check, message, "INVALID_ARGUMENT", { argument: name, value });
}
function assertArgumentCount(count, expectedCount, message) {
  if (message == null) {
    message = "";
  }
  if (message) {
    message = ": " + message;
  }
  assert2(count >= expectedCount, "missing arguemnt" + message, "MISSING_ARGUMENT", {
    count,
    expectedCount
  });
  assert2(count <= expectedCount, "too many arguemnts" + message, "UNEXPECTED_ARGUMENT", {
    count,
    expectedCount
  });
}
function assertNormalize(form) {
  assert2(_normalizeForms.indexOf(form) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
    operation: "String.prototype.normalize",
    info: { form }
  });
}
function assertPrivate(givenGuard, guard, className) {
  if (className == null) {
    className = "";
  }
  if (givenGuard !== guard) {
    let method = className, operation = "new";
    if (className) {
      method += ".";
      operation += " " + className;
    }
    assert2(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
      operation
    });
  }
}
var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form) => {
  try {
    if ("test".normalize(form) !== "test") {
      throw new Error("bad");
    }
    if (form === "NFD") {
      const check = String.fromCharCode(233).normalize("NFD");
      const expected = String.fromCharCode(101, 769);
      if (check !== expected) {
        throw new Error("broken");
      }
    }
    accum.push(form);
  } catch (error) {
  }
  return accum;
}, []);

// ../../node_modules/ethers/lib.esm/utils/data.js
var _getBytes = function(value, name, copy) {
  if (value instanceof Uint8Array) {
    if (copy) {
      return new Uint8Array(value);
    }
    return value;
  }
  if (typeof value === "string" && value.match(/^0x([0-9a-f][0-9a-f])*$/i)) {
    const result = new Uint8Array((value.length - 2) / 2);
    let offset = 2;
    for (let i = 0;i < result.length; i++) {
      result[i] = parseInt(value.substring(offset, offset + 2), 16);
      offset += 2;
    }
    return result;
  }
  assertArgument(false, "invalid BytesLike value", name || "value", value);
};
function getBytes(value, name) {
  return _getBytes(value, name, false);
}
function getBytesCopy(value, name) {
  return _getBytes(value, name, true);
}
function isHexString2(value, length) {
  if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
    return false;
  }
  if (typeof length === "number" && value.length !== 2 + 2 * length) {
    return false;
  }
  if (length === true && value.length % 2 !== 0) {
    return false;
  }
  return true;
}
function isBytesLike(value) {
  return isHexString2(value, true) || value instanceof Uint8Array;
}
function hexlify(data) {
  const bytes7 = getBytes(data);
  let result = "0x";
  for (let i = 0;i < bytes7.length; i++) {
    const v = bytes7[i];
    result += HexCharacters[(v & 240) >> 4] + HexCharacters[v & 15];
  }
  return result;
}
function concat(datas) {
  return "0x" + datas.map((d) => hexlify(d).substring(2)).join("");
}
function dataLength(data) {
  if (isHexString2(data, true)) {
    return (data.length - 2) / 2;
  }
  return getBytes(data).length;
}
function dataSlice(data, start, end) {
  const bytes7 = getBytes(data);
  if (end != null && end > bytes7.length) {
    assert2(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
      buffer: bytes7,
      length: bytes7.length,
      offset: end
    });
  }
  return hexlify(bytes7.slice(start == null ? 0 : start, end == null ? bytes7.length : end));
}
function stripZerosLeft(data) {
  let bytes7 = hexlify(data).substring(2);
  while (bytes7.startsWith("00")) {
    bytes7 = bytes7.substring(2);
  }
  return "0x" + bytes7;
}
var zeroPad = function(data, length, left) {
  const bytes7 = getBytes(data);
  assert2(length >= bytes7.length, "padding exceeds data length", "BUFFER_OVERRUN", {
    buffer: new Uint8Array(bytes7),
    length,
    offset: length + 1
  });
  const result = new Uint8Array(length);
  result.fill(0);
  if (left) {
    result.set(bytes7, length - bytes7.length);
  } else {
    result.set(bytes7, 0);
  }
  return hexlify(result);
};
function zeroPadValue(data, length) {
  return zeroPad(data, length, true);
}
function zeroPadBytes(data, length) {
  return zeroPad(data, length, false);
}
var HexCharacters = "0123456789abcdef";

// ../../node_modules/ethers/lib.esm/utils/maths.js
function fromTwos(_value, _width) {
  const value = getUint(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  assert2(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
    operation: "fromTwos",
    fault: "overflow",
    value: _value
  });
  if (value >> width - BN_1) {
    const mask2 = (BN_1 << width) - BN_1;
    return -((~value & mask2) + BN_1);
  }
  return value;
}
function toTwos(_value, _width) {
  let value = getBigInt(_value, "value");
  const width = BigInt(getNumber(_width, "width"));
  const limit = BN_1 << width - BN_1;
  if (value < BN_0) {
    value = -value;
    assert2(value <= limit, "too low", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
    const mask2 = (BN_1 << width) - BN_1;
    return (~value & mask2) + BN_1;
  } else {
    assert2(value < limit, "too high", "NUMERIC_FAULT", {
      operation: "toTwos",
      fault: "overflow",
      value: _value
    });
  }
  return value;
}
function mask2(_value, _bits) {
  const value = getUint(_value, "value");
  const bits = BigInt(getNumber(_bits, "bits"));
  return value & (BN_1 << bits) - BN_1;
}
function getBigInt(value, name) {
  switch (typeof value) {
    case "bigint":
      return value;
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return BigInt(value);
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        if (value[0] === "-" && value[1] !== "-") {
          return -BigInt(value.substring(1));
        }
        return BigInt(value);
      } catch (e) {
        assertArgument(false, `invalid BigNumberish string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid BigNumberish value", name || "value", value);
}
function getUint(value, name) {
  const result = getBigInt(value, name);
  assert2(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
    fault: "overflow",
    operation: "getUint",
    value
  });
  return result;
}
function toBigInt2(value) {
  if (value instanceof Uint8Array) {
    let result = "0x0";
    for (const v of value) {
      result += Nibbles[v >> 4];
      result += Nibbles[v & 15];
    }
    return BigInt(result);
  }
  return getBigInt(value);
}
function getNumber(value, name) {
  switch (typeof value) {
    case "bigint":
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return Number(value);
    case "number":
      assertArgument(Number.isInteger(value), "underflow", name || "value", value);
      assertArgument(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
      return value;
    case "string":
      try {
        if (value === "") {
          throw new Error("empty string");
        }
        return getNumber(BigInt(value), name);
      } catch (e) {
        assertArgument(false, `invalid numeric string: ${e.message}`, name || "value", value);
      }
  }
  assertArgument(false, "invalid numeric value", name || "value", value);
}
function toNumber2(value) {
  return getNumber(toBigInt2(value));
}
function toBeHex(_value, _width) {
  const value = getUint(_value, "value");
  let result = value.toString(16);
  if (_width == null) {
    if (result.length % 2) {
      result = "0" + result;
    }
  } else {
    const width = getNumber(_width, "width");
    assert2(width * 2 >= result.length, `value exceeds width (${width} bits)`, "NUMERIC_FAULT", {
      operation: "toBeHex",
      fault: "overflow",
      value: _value
    });
    while (result.length < width * 2) {
      result = "0" + result;
    }
  }
  return "0x" + result;
}
function toBeArray(_value) {
  const value = getUint(_value, "value");
  if (value === BN_0) {
    return new Uint8Array([]);
  }
  let hex = value.toString(16);
  if (hex.length % 2) {
    hex = "0" + hex;
  }
  const result = new Uint8Array(hex.length / 2);
  for (let i = 0;i < result.length; i++) {
    const offset = i * 2;
    result[i] = parseInt(hex.substring(offset, offset + 2), 16);
  }
  return result;
}
function toQuantity(value) {
  let result = hexlify(isBytesLike(value) ? value : toBeArray(value)).substring(2);
  while (result.startsWith("0")) {
    result = result.substring(1);
  }
  if (result === "") {
    result = "0";
  }
  return "0x" + result;
}
var BN_0 = BigInt(0);
var BN_1 = BigInt(1);
var maxValue = 9007199254740991;
var Nibbles = "0123456789abcdef";

// ../../node_modules/ethers/lib.esm/utils/base58.js
var getAlpha = function(letter) {
  if (Lookup == null) {
    Lookup = {};
    for (let i = 0;i < Alphabet.length; i++) {
      Lookup[Alphabet[i]] = BigInt(i);
    }
  }
  const result = Lookup[letter];
  assertArgument(result != null, `invalid base58 value`, "letter", letter);
  return result;
};
function encodeBase58(_value) {
  let value = toBigInt2(getBytes(_value));
  let result = "";
  while (value) {
    result = Alphabet[Number(value % BN_58)] + result;
    value /= BN_58;
  }
  return result;
}
function decodeBase58(value) {
  let result = BN_02;
  for (let i = 0;i < value.length; i++) {
    result *= BN_58;
    result += getAlpha(value[i]);
  }
  return result;
}
var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var Lookup = null;
var BN_02 = BigInt(0);
var BN_58 = BigInt(58);
// ../../node_modules/ethers/lib.esm/utils/base64.js
function decodeBase64(value) {
  return getBytesCopy(Buffer.from(value, "base64"));
}
function encodeBase64(data4) {
  return Buffer.from(getBytes(data4)).toString("base64");
}
// ../../node_modules/ethers/lib.esm/utils/events.js
class EventPayload {
  filter;
  emitter;
  #listener;
  constructor(emitter, listener, filter3) {
    this.#listener = listener;
    defineProperties(this, { emitter, filter: filter3 });
  }
  async removeListener() {
    if (this.#listener == null) {
      return;
    }
    await this.emitter.off(this.filter, this.#listener);
  }
}
// ../../node_modules/ethers/lib.esm/utils/utf8.js
var errorFunc = function(reason, offset, bytes7, output2, badCodepoint) {
  assertArgument(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes7);
};
var ignoreFunc = function(reason, offset, bytes7, output2, badCodepoint) {
  if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
    let i = 0;
    for (let o = offset + 1;o < bytes7.length; o++) {
      if (bytes7[o] >> 6 !== 2) {
        break;
      }
      i++;
    }
    return i;
  }
  if (reason === "OVERRUN") {
    return bytes7.length - offset - 1;
  }
  return 0;
};
var replaceFunc = function(reason, offset, bytes7, output2, badCodepoint) {
  if (reason === "OVERLONG") {
    assertArgument(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
    output2.push(badCodepoint);
    return 0;
  }
  output2.push(65533);
  return ignoreFunc(reason, offset, bytes7, output2, badCodepoint);
};
var getUtf8CodePoints = function(_bytes, onError) {
  if (onError == null) {
    onError = Utf8ErrorFuncs.error;
  }
  const bytes7 = getBytes(_bytes, "bytes");
  const result = [];
  let i = 0;
  while (i < bytes7.length) {
    const c = bytes7[i++];
    if (c >> 7 === 0) {
      result.push(c);
      continue;
    }
    let extraLength = null;
    let overlongMask = null;
    if ((c & 224) === 192) {
      extraLength = 1;
      overlongMask = 127;
    } else if ((c & 240) === 224) {
      extraLength = 2;
      overlongMask = 2047;
    } else if ((c & 248) === 240) {
      extraLength = 3;
      overlongMask = 65535;
    } else {
      if ((c & 192) === 128) {
        i += onError("UNEXPECTED_CONTINUE", i - 1, bytes7, result);
      } else {
        i += onError("BAD_PREFIX", i - 1, bytes7, result);
      }
      continue;
    }
    if (i - 1 + extraLength >= bytes7.length) {
      i += onError("OVERRUN", i - 1, bytes7, result);
      continue;
    }
    let res = c & (1 << 8 - extraLength - 1) - 1;
    for (let j = 0;j < extraLength; j++) {
      let nextChar = bytes7[i];
      if ((nextChar & 192) != 128) {
        i += onError("MISSING_CONTINUE", i, bytes7, result);
        res = null;
        break;
      }
      res = res << 6 | nextChar & 63;
      i++;
    }
    if (res === null) {
      continue;
    }
    if (res > 1114111) {
      i += onError("OUT_OF_RANGE", i - 1 - extraLength, bytes7, result, res);
      continue;
    }
    if (res >= 55296 && res <= 57343) {
      i += onError("UTF16_SURROGATE", i - 1 - extraLength, bytes7, result, res);
      continue;
    }
    if (res <= overlongMask) {
      i += onError("OVERLONG", i - 1 - extraLength, bytes7, result, res);
      continue;
    }
    result.push(res);
  }
  return result;
};
function toUtf8Bytes(str, form) {
  if (form != null) {
    assertNormalize(form);
    str = str.normalize(form);
  }
  let result = [];
  for (let i = 0;i < str.length; i++) {
    const c = str.charCodeAt(i);
    if (c < 128) {
      result.push(c);
    } else if (c < 2048) {
      result.push(c >> 6 | 192);
      result.push(c & 63 | 128);
    } else if ((c & 64512) == 55296) {
      i++;
      const c2 = str.charCodeAt(i);
      assertArgument(i < str.length && (c2 & 64512) === 56320, "invalid surrogate pair", "str", str);
      const pair = 65536 + ((c & 1023) << 10) + (c2 & 1023);
      result.push(pair >> 18 | 240);
      result.push(pair >> 12 & 63 | 128);
      result.push(pair >> 6 & 63 | 128);
      result.push(pair & 63 | 128);
    } else {
      result.push(c >> 12 | 224);
      result.push(c >> 6 & 63 | 128);
      result.push(c & 63 | 128);
    }
  }
  return new Uint8Array(result);
}
var _toUtf8String = function(codePoints) {
  return codePoints.map((codePoint) => {
    if (codePoint <= 65535) {
      return String.fromCharCode(codePoint);
    }
    codePoint -= 65536;
    return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
  }).join("");
};
function toUtf8String(bytes7, onError) {
  return _toUtf8String(getUtf8CodePoints(bytes7, onError));
}
function toUtf8CodePoints(str, form) {
  return getUtf8CodePoints(toUtf8Bytes(str, form));
}
var Utf8ErrorFuncs = Object.freeze({
  error: errorFunc,
  ignore: ignoreFunc,
  replace: replaceFunc
});

// ../../node_modules/ethers/lib.esm/utils/geturl.js
import http from "http";
import https from "https";
import {gunzipSync} from "zlib";
async function getUrl(req, signal) {
  const protocol = req.url.split(":")[0].toLowerCase();
  assert2(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
    info: { protocol },
    operation: "request"
  });
  assert2(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
    operation: "request"
  });
  const method = req.method;
  const headers = Object.assign({}, req.headers);
  const options = { method, headers };
  const request = (protocol === "http" ? http : https).request(req.url, options);
  request.setTimeout(req.timeout);
  const body = req.body;
  if (body) {
    request.write(Buffer.from(body));
  }
  request.end();
  return new Promise((resolve, reject) => {
    request.once("response", (resp) => {
      const statusCode = resp.statusCode || 0;
      const statusMessage = resp.statusMessage || "";
      const headers2 = Object.keys(resp.headers || {}).reduce((accum, name) => {
        let value = resp.headers[name] || "";
        if (Array.isArray(value)) {
          value = value.join(", ");
        }
        accum[name] = value;
        return accum;
      }, {});
      let body2 = null;
      resp.on("data", (chunk) => {
        if (signal) {
          try {
            signal.checkSignal();
          } catch (error) {
            return reject(error);
          }
        }
        if (body2 == null) {
          body2 = chunk;
        } else {
          const newBody = new Uint8Array(body2.length + chunk.length);
          newBody.set(body2, 0);
          newBody.set(chunk, body2.length);
          body2 = newBody;
        }
      });
      resp.on("end", () => {
        if (headers2["content-encoding"] === "gzip" && body2) {
          body2 = getBytes(gunzipSync(body2));
        }
        resolve({ statusCode, statusMessage, headers: headers2, body: body2 });
      });
      resp.on("error", (error) => {
        error.response = { statusCode, statusMessage, headers: headers2, body: body2 };
        reject(error);
      });
    });
    request.on("error", (error) => {
      reject(error);
    });
  });
}

// ../../node_modules/ethers/lib.esm/utils/fetch.js
async function dataGatewayFunc(url, signal) {
  try {
    const match = url.match(reData);
    if (!match) {
      throw new Error("invalid data");
    }
    return new FetchResponse(200, "OK", {
      "content-type": match[1] || "text/plain"
    }, match[2] ? decodeBase64(match[3]) : unpercent(match[3]));
  } catch (error) {
    return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
  }
}
var getIpfsGatewayFunc = function(baseUrl) {
  async function gatewayIpfs(url, signal) {
    try {
      const match = url.match(reIpfs);
      if (!match) {
        throw new Error("invalid link");
      }
      return new FetchRequest(`${baseUrl}${match[2]}`);
    } catch (error) {
      return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
    }
  }
  return gatewayIpfs;
};
var checkSignal = function(signal) {
  if (signal == null) {
    throw new Error("missing signal; should not happen");
  }
  signal.checkSignal();
  return signal;
};
var getTime = function() {
  return new Date().getTime();
};
var unpercent = function(value) {
  return toUtf8Bytes(value.replace(/%([0-9a-f][0-9a-f])/gi, (all, code) => {
    return String.fromCharCode(parseInt(code, 16));
  }));
};
var wait = function(delay4) {
  return new Promise((resolve) => setTimeout(resolve, delay4));
};
var MAX_ATTEMPTS = 12;
var SLOT_INTERVAL = 250;
var getUrlFunc = getUrl;
var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
var locked = false;
var Gateways = {
  data: dataGatewayFunc,
  ipfs: getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
};
var fetchSignals = new WeakMap;

class FetchCancelSignal {
  #listeners;
  #cancelled;
  constructor(request) {
    this.#listeners = [];
    this.#cancelled = false;
    fetchSignals.set(request, () => {
      if (this.#cancelled) {
        return;
      }
      this.#cancelled = true;
      for (const listener of this.#listeners) {
        setTimeout(() => {
          listener();
        }, 0);
      }
      this.#listeners = [];
    });
  }
  addListener(listener) {
    assert2(!this.#cancelled, "singal already cancelled", "UNSUPPORTED_OPERATION", {
      operation: "fetchCancelSignal.addCancelListener"
    });
    this.#listeners.push(listener);
  }
  get cancelled() {
    return this.#cancelled;
  }
  checkSignal() {
    assert2(!this.cancelled, "cancelled", "CANCELLED", {});
  }
}

class FetchRequest {
  #allowInsecure;
  #gzip;
  #headers;
  #method;
  #timeout;
  #url;
  #body;
  #bodyType;
  #creds;
  #preflight;
  #process;
  #retry;
  #signal;
  #throttle;
  get url() {
    return this.#url;
  }
  set url(url) {
    this.#url = String(url);
  }
  get body() {
    if (this.#body == null) {
      return null;
    }
    return new Uint8Array(this.#body);
  }
  set body(body) {
    if (body == null) {
      this.#body = undefined;
      this.#bodyType = undefined;
    } else if (typeof body === "string") {
      this.#body = toUtf8Bytes(body);
      this.#bodyType = "text/plain";
    } else if (body instanceof Uint8Array) {
      this.#body = body;
      this.#bodyType = "application/octet-stream";
    } else if (typeof body === "object") {
      this.#body = toUtf8Bytes(JSON.stringify(body));
      this.#bodyType = "application/json";
    } else {
      throw new Error("invalid body");
    }
  }
  hasBody() {
    return this.#body != null;
  }
  get method() {
    if (this.#method) {
      return this.#method;
    }
    if (this.hasBody()) {
      return "POST";
    }
    return "GET";
  }
  set method(method) {
    if (method == null) {
      method = "";
    }
    this.#method = String(method).toUpperCase();
  }
  get headers() {
    const headers = Object.assign({}, this.#headers);
    if (this.#creds) {
      headers["authorization"] = `Basic ${encodeBase64(toUtf8Bytes(this.#creds))}`;
    }
    if (this.allowGzip) {
      headers["accept-encoding"] = "gzip";
    }
    if (headers["content-type"] == null && this.#bodyType) {
      headers["content-type"] = this.#bodyType;
    }
    if (this.body) {
      headers["content-length"] = String(this.body.length);
    }
    return headers;
  }
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  setHeader(key, value) {
    this.#headers[String(key).toLowerCase()] = String(value);
  }
  clearHeaders() {
    this.#headers = {};
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get credentials() {
    return this.#creds || null;
  }
  setCredentials(username, password) {
    assertArgument(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
    this.#creds = `${username}:${password}`;
  }
  get allowGzip() {
    return this.#gzip;
  }
  set allowGzip(value) {
    this.#gzip = !!value;
  }
  get allowInsecureAuthentication() {
    return !!this.#allowInsecure;
  }
  set allowInsecureAuthentication(value) {
    this.#allowInsecure = !!value;
  }
  get timeout() {
    return this.#timeout;
  }
  set timeout(timeout) {
    assertArgument(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
    this.#timeout = timeout;
  }
  get preflightFunc() {
    return this.#preflight || null;
  }
  set preflightFunc(preflight) {
    this.#preflight = preflight;
  }
  get processFunc() {
    return this.#process || null;
  }
  set processFunc(process2) {
    this.#process = process2;
  }
  get retryFunc() {
    return this.#retry || null;
  }
  set retryFunc(retry) {
    this.#retry = retry;
  }
  constructor(url) {
    this.#url = String(url);
    this.#allowInsecure = false;
    this.#gzip = true;
    this.#headers = {};
    this.#method = "";
    this.#timeout = 300000;
    this.#throttle = {
      slotInterval: SLOT_INTERVAL,
      maxAttempts: MAX_ATTEMPTS
    };
  }
  toString() {
    return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  setThrottleParams(params) {
    if (params.slotInterval != null) {
      this.#throttle.slotInterval = params.slotInterval;
    }
    if (params.maxAttempts != null) {
      this.#throttle.maxAttempts = params.maxAttempts;
    }
  }
  async#send(attempt, expires, delay4, _request, _response) {
    if (attempt >= this.#throttle.maxAttempts) {
      return _response.makeServerError("exceeded maximum retry limit");
    }
    assert2(getTime() <= expires, "timeout", "TIMEOUT", {
      operation: "request.send",
      reason: "timeout",
      request: _request
    });
    if (delay4 > 0) {
      await wait(delay4);
    }
    let req = this.clone();
    const scheme = (req.url.split(":")[0] || "").toLowerCase();
    if (scheme in Gateways) {
      const result = await Gateways[scheme](req.url, checkSignal(_request.#signal));
      if (result instanceof FetchResponse) {
        let response2 = result;
        if (this.processFunc) {
          checkSignal(_request.#signal);
          try {
            response2 = await this.processFunc(req, response2);
          } catch (error) {
            if (error.throttle == null || typeof error.stall !== "number") {
              response2.makeServerError("error in post-processing function", error).assertOk();
            }
          }
        }
        return response2;
      }
      req = result;
    }
    if (this.preflightFunc) {
      req = await this.preflightFunc(req);
    }
    const resp = await getUrlFunc(req, checkSignal(_request.#signal));
    let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request);
    if (response.statusCode === 301 || response.statusCode === 302) {
      try {
        const location = response.headers.location || "";
        return req.redirect(location).#send(attempt + 1, expires, 0, _request, response);
      } catch (error) {
      }
      return response;
    } else if (response.statusCode === 429) {
      if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
        const retryAfter = response.headers["retry-after"];
        let delay5 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
          delay5 = parseInt(retryAfter);
        }
        return req.clone().#send(attempt + 1, expires, delay5, _request, response);
      }
    }
    if (this.processFunc) {
      checkSignal(_request.#signal);
      try {
        response = await this.processFunc(req, response);
      } catch (error) {
        if (error.throttle == null || typeof error.stall !== "number") {
          response.makeServerError("error in post-processing function", error).assertOk();
        }
        let delay5 = this.#throttle.slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
        if (error.stall >= 0) {
          delay5 = error.stall;
        }
        return req.clone().#send(attempt + 1, expires, delay5, _request, response);
      }
    }
    return response;
  }
  send() {
    assert2(this.#signal == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
    this.#signal = new FetchCancelSignal(this);
    return this.#send(0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
  }
  cancel() {
    assert2(this.#signal != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
    const signal = fetchSignals.get(this);
    if (!signal) {
      throw new Error("missing signal; should not happen");
    }
    signal();
  }
  redirect(location) {
    const current = this.url.split(":")[0].toLowerCase();
    const target = location.split(":")[0].toLowerCase();
    assert2(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
      operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
    });
    const req = new FetchRequest(location);
    req.method = "GET";
    req.allowGzip = this.allowGzip;
    req.timeout = this.timeout;
    req.#headers = Object.assign({}, this.#headers);
    if (this.#body) {
      req.#body = new Uint8Array(this.#body);
    }
    req.#bodyType = this.#bodyType;
    return req;
  }
  clone() {
    const clone = new FetchRequest(this.url);
    clone.#method = this.#method;
    if (this.#body) {
      clone.#body = this.#body;
    }
    clone.#bodyType = this.#bodyType;
    clone.#headers = Object.assign({}, this.#headers);
    clone.#creds = this.#creds;
    if (this.allowGzip) {
      clone.allowGzip = true;
    }
    clone.timeout = this.timeout;
    if (this.allowInsecureAuthentication) {
      clone.allowInsecureAuthentication = true;
    }
    clone.#preflight = this.#preflight;
    clone.#process = this.#process;
    clone.#retry = this.#retry;
    return clone;
  }
  static lockConfig() {
    locked = true;
  }
  static getGateway(scheme) {
    return Gateways[scheme.toLowerCase()] || null;
  }
  static registerGateway(scheme, func) {
    scheme = scheme.toLowerCase();
    if (scheme === "http" || scheme === "https") {
      throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
    }
    if (locked) {
      throw new Error("gateways locked");
    }
    Gateways[scheme] = func;
  }
  static registerGetUrl(getUrl2) {
    if (locked) {
      throw new Error("gateways locked");
    }
    getUrlFunc = getUrl2;
  }
  static createDataGateway() {
    return dataGatewayFunc;
  }
  static createIpfsGatewayFunc(baseUrl) {
    return getIpfsGatewayFunc(baseUrl);
  }
}

class FetchResponse {
  #statusCode;
  #statusMessage;
  #headers;
  #body;
  #request;
  #error;
  toString() {
    return `<FetchResponse status=${this.statusCode} body=${this.#body ? hexlify(this.#body) : "null"}>`;
  }
  get statusCode() {
    return this.#statusCode;
  }
  get statusMessage() {
    return this.#statusMessage;
  }
  get headers() {
    return Object.assign({}, this.#headers);
  }
  get body() {
    return this.#body == null ? null : new Uint8Array(this.#body);
  }
  get bodyText() {
    try {
      return this.#body == null ? "" : toUtf8String(this.#body);
    } catch (error) {
      assert2(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
        operation: "bodyText",
        info: { response: this }
      });
    }
  }
  get bodyJson() {
    try {
      return JSON.parse(this.bodyText);
    } catch (error) {
      assert2(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
        operation: "bodyJson",
        info: { response: this }
      });
    }
  }
  [Symbol.iterator]() {
    const headers = this.headers;
    const keys = Object.keys(headers);
    let index = 0;
    return {
      next: () => {
        if (index < keys.length) {
          const key = keys[index++];
          return {
            value: [key, headers[key]],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  constructor(statusCode, statusMessage, headers, body, request) {
    this.#statusCode = statusCode;
    this.#statusMessage = statusMessage;
    this.#headers = Object.keys(headers).reduce((accum, k) => {
      accum[k.toLowerCase()] = String(headers[k]);
      return accum;
    }, {});
    this.#body = body == null ? null : new Uint8Array(body);
    this.#request = request || null;
    this.#error = { message: "" };
  }
  makeServerError(message, error) {
    let statusMessage;
    if (!message) {
      message = `${this.statusCode} ${this.statusMessage}`;
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
    } else {
      statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
    }
    const response = new FetchResponse(599, statusMessage, this.headers, this.body, this.#request || undefined);
    response.#error = { message, error };
    return response;
  }
  throwThrottleError(message, stall) {
    if (stall == null) {
      stall = -1;
    } else {
      assertArgument(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
    }
    const error = new Error(message || "throttling requests");
    defineProperties(error, { stall, throttle: true });
    throw error;
  }
  getHeader(key) {
    return this.headers[key.toLowerCase()];
  }
  hasBody() {
    return this.#body != null;
  }
  get request() {
    return this.#request;
  }
  ok() {
    return this.#error.message === "" && this.statusCode >= 200 && this.statusCode < 300;
  }
  assertOk() {
    if (this.ok()) {
      return;
    }
    let { message, error } = this.#error;
    if (message === "") {
      message = `server response ${this.statusCode} ${this.statusMessage}`;
    }
    assert2(false, message, "SERVER_ERROR", {
      request: this.request || "unknown request",
      response: this,
      error
    });
  }
}
// ../../node_modules/ethers/lib.esm/utils/fixednumber.js
var getTens = function(decimals) {
  let result = Zeros;
  while (result.length < decimals) {
    result += result;
  }
  return BigInt("1" + result.substring(0, decimals));
};
var checkValue = function(val, format2, safeOp) {
  const width = BigInt(format2.width);
  if (format2.signed) {
    const limit = BN_12 << width - BN_12;
    assert2(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    if (val > BN_03) {
      val = fromTwos(mask2(val, width), width);
    } else {
      val = -fromTwos(mask2(-val, width), width);
    }
  } else {
    const limit = BN_12 << width;
    assert2(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
      operation: safeOp,
      fault: "overflow",
      value: val
    });
    val = (val % limit + limit) % limit & limit - BN_12;
  }
  return val;
};
var getFormat = function(value) {
  if (typeof value === "number") {
    value = `fixed128x${value}`;
  }
  let signed2 = true;
  let width = 128;
  let decimals = 18;
  if (typeof value === "string") {
    if (value === "fixed") {
    } else if (value === "ufixed") {
      signed2 = false;
    } else {
      const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
      assertArgument(match, "invalid fixed format", "format", value);
      signed2 = match[1] !== "u";
      width = parseInt(match[2]);
      decimals = parseInt(match[3]);
    }
  } else if (value) {
    const v = value;
    const check = (key, type, defaultValue) => {
      if (v[key] == null) {
        return defaultValue;
      }
      assertArgument(typeof v[key] === type, "invalid fixed format (" + key + " not " + type + ")", "format." + key, v[key]);
      return v[key];
    };
    signed2 = check("signed", "boolean", signed2);
    width = check("width", "number", width);
    decimals = check("decimals", "number", decimals);
  }
  assertArgument(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
  assertArgument(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
  const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
  return { signed: signed2, width, decimals, name };
};
var toString = function(val, decimals) {
  let negative = "";
  if (val < BN_03) {
    negative = "-";
    val *= BN_N1;
  }
  let str = val.toString();
  if (decimals === 0) {
    return negative + str;
  }
  while (str.length <= decimals) {
    str = Zeros + str;
  }
  const index = str.length - decimals;
  str = str.substring(0, index) + "." + str.substring(index);
  while (str[0] === "0" && str[1] !== ".") {
    str = str.substring(1);
  }
  while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
    str = str.substring(0, str.length - 1);
  }
  return negative + str;
};
var BN_N1 = BigInt(-1);
var BN_03 = BigInt(0);
var BN_12 = BigInt(1);
var BN_5 = BigInt(5);
var _guard = {};
var Zeros = "0000";
while (Zeros.length < 80) {
  Zeros += Zeros;
}

class FixedNumber {
  format;
  #format;
  #val;
  #tens;
  _value;
  constructor(guard, value, format2) {
    assertPrivate(guard, _guard, "FixedNumber");
    this.#val = value;
    this.#format = format2;
    const _value = toString(value, format2.decimals);
    defineProperties(this, { format: format2.name, _value });
    this.#tens = getTens(format2.decimals);
  }
  get signed() {
    return this.#format.signed;
  }
  get width() {
    return this.#format.width;
  }
  get decimals() {
    return this.#format.decimals;
  }
  get value() {
    return this.#val;
  }
  #checkFormat(other) {
    assertArgument(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
  }
  #checkValue(val, safeOp) {
    val = checkValue(val, this.#format, safeOp);
    return new FixedNumber(_guard, val, this.#format);
  }
  #add(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val + o.#val, safeOp);
  }
  addUnsafe(other) {
    return this.#add(other);
  }
  add(other) {
    return this.#add(other, "add");
  }
  #sub(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val - o.#val, safeOp);
  }
  subUnsafe(other) {
    return this.#sub(other);
  }
  sub(other) {
    return this.#sub(other, "sub");
  }
  #mul(o, safeOp) {
    this.#checkFormat(o);
    return this.#checkValue(this.#val * o.#val / this.#tens, safeOp);
  }
  mulUnsafe(other) {
    return this.#mul(other);
  }
  mul(other) {
    return this.#mul(other, "mul");
  }
  mulSignal(other) {
    this.#checkFormat(other);
    const value = this.#val * other.#val;
    assert2(value % this.#tens === BN_03, "precision lost during signalling mul", "NUMERIC_FAULT", {
      operation: "mulSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / this.#tens, "mulSignal");
  }
  #div(o, safeOp) {
    assert2(o.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(o);
    return this.#checkValue(this.#val * this.#tens / o.#val, safeOp);
  }
  divUnsafe(other) {
    return this.#div(other);
  }
  div(other) {
    return this.#div(other, "div");
  }
  divSignal(other) {
    assert2(other.#val !== BN_03, "division by zero", "NUMERIC_FAULT", {
      operation: "div",
      fault: "divide-by-zero",
      value: this
    });
    this.#checkFormat(other);
    const value = this.#val * this.#tens;
    assert2(value % other.#val === BN_03, "precision lost during signalling div", "NUMERIC_FAULT", {
      operation: "divSignal",
      fault: "underflow",
      value: this
    });
    return this.#checkValue(value / other.#val, "divSignal");
  }
  cmp(other) {
    let a = this.value, b = other.value;
    const delta = this.decimals - other.decimals;
    if (delta > 0) {
      b *= getTens(delta);
    } else if (delta < 0) {
      a *= getTens(-delta);
    }
    if (a < b) {
      return -1;
    }
    if (a > b) {
      return 1;
    }
    return 0;
  }
  eq(other) {
    return this.cmp(other) === 0;
  }
  lt(other) {
    return this.cmp(other) < 0;
  }
  lte(other) {
    return this.cmp(other) <= 0;
  }
  gt(other) {
    return this.cmp(other) > 0;
  }
  gte(other) {
    return this.cmp(other) >= 0;
  }
  floor() {
    let val = this.#val;
    if (this.#val < BN_03) {
      val -= this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "floor");
  }
  ceiling() {
    let val = this.#val;
    if (this.#val > BN_03) {
      val += this.#tens - BN_12;
    }
    val = this.#val / this.#tens * this.#tens;
    return this.#checkValue(val, "ceiling");
  }
  round(decimals) {
    if (decimals == null) {
      decimals = 0;
    }
    if (decimals >= this.decimals) {
      return this;
    }
    const delta = this.decimals - decimals;
    const bump = BN_5 * getTens(delta - 1);
    let value = this.value + bump;
    const tens = getTens(delta);
    value = value / tens * tens;
    checkValue(value, this.#format, "round");
    return new FixedNumber(_guard, value, this.#format);
  }
  isZero() {
    return this.#val === BN_03;
  }
  isNegative() {
    return this.#val < BN_03;
  }
  toString() {
    return this._value;
  }
  toUnsafeFloat() {
    return parseFloat(this.toString());
  }
  toFormat(format2) {
    return FixedNumber.fromString(this.toString(), format2);
  }
  static fromValue(_value, _decimals, _format) {
    const decimals = _decimals == null ? 0 : getNumber(_decimals);
    const format2 = getFormat(_format);
    let value = getBigInt(_value, "value");
    const delta = decimals - format2.decimals;
    if (delta > 0) {
      const tens = getTens(delta);
      assert2(value % tens === BN_03, "value loses precision for format", "NUMERIC_FAULT", {
        operation: "fromValue",
        fault: "underflow",
        value: _value
      });
      value /= tens;
    } else if (delta < 0) {
      value *= getTens(-delta);
    }
    checkValue(value, format2, "fromValue");
    return new FixedNumber(_guard, value, format2);
  }
  static fromString(_value, _format) {
    const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
    assertArgument(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
    const format2 = getFormat(_format);
    let whole = match[2] || "0", decimal = match[3] || "";
    while (decimal.length < format2.decimals) {
      decimal += Zeros;
    }
    assert2(decimal.substring(format2.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
      operation: "fromString",
      fault: "underflow",
      value: _value
    });
    decimal = decimal.substring(0, format2.decimals);
    const value = BigInt(match[1] + whole + decimal);
    checkValue(value, format2, "fromString");
    return new FixedNumber(_guard, value, format2);
  }
  static fromBytes(_value, _format) {
    let value = toBigInt2(getBytes(_value, "value"));
    const format2 = getFormat(_format);
    if (format2.signed) {
      value = fromTwos(value, format2.width);
    }
    checkValue(value, format2, "fromBytes");
    return new FixedNumber(_guard, value, format2);
  }
}
// ../../node_modules/ethers/lib.esm/utils/rlp-decode.js
var hexlifyByte = function(value) {
  let result = value.toString(16);
  while (result.length < 2) {
    result = "0" + result;
  }
  return "0x" + result;
};
var unarrayifyInteger = function(data10, offset, length) {
  let result = 0;
  for (let i = 0;i < length; i++) {
    result = result * 256 + data10[offset + i];
  }
  return result;
};
var _decodeChildren = function(data10, offset, childOffset, length) {
  const result = [];
  while (childOffset < offset + 1 + length) {
    const decoded = _decode(data10, childOffset);
    result.push(decoded.result);
    childOffset += decoded.consumed;
    assert2(childOffset <= offset + 1 + length, "child data too short", "BUFFER_OVERRUN", {
      buffer: data10,
      length,
      offset
    });
  }
  return { consumed: 1 + length, result };
};
var _decode = function(data10, offset) {
  assert2(data10.length !== 0, "data too short", "BUFFER_OVERRUN", {
    buffer: data10,
    length: 0,
    offset: 1
  });
  const checkOffset = (offset2) => {
    assert2(offset2 <= data10.length, "data short segment too short", "BUFFER_OVERRUN", {
      buffer: data10,
      length: data10.length,
      offset: offset2
    });
  };
  if (data10[offset] >= 248) {
    const lengthLength = data10[offset] - 247;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data10, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    return _decodeChildren(data10, offset, offset + 1 + lengthLength, lengthLength + length);
  } else if (data10[offset] >= 192) {
    const length = data10[offset] - 192;
    checkOffset(offset + 1 + length);
    return _decodeChildren(data10, offset, offset + 1, length);
  } else if (data10[offset] >= 184) {
    const lengthLength = data10[offset] - 183;
    checkOffset(offset + 1 + lengthLength);
    const length = unarrayifyInteger(data10, offset + 1, lengthLength);
    checkOffset(offset + 1 + lengthLength + length);
    const result = hexlify(data10.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
    return { consumed: 1 + lengthLength + length, result };
  } else if (data10[offset] >= 128) {
    const length = data10[offset] - 128;
    checkOffset(offset + 1 + length);
    const result = hexlify(data10.slice(offset + 1, offset + 1 + length));
    return { consumed: 1 + length, result };
  }
  return { consumed: 1, result: hexlifyByte(data10[offset]) };
};
function decodeRlp(_data) {
  const data10 = getBytes(_data, "data");
  const decoded = _decode(data10, 0);
  assertArgument(decoded.consumed === data10.length, "unexpected junk after rlp payload", "data", _data);
  return decoded.result;
}
// ../../node_modules/ethers/lib.esm/utils/rlp-encode.js
var arrayifyInteger = function(value) {
  const result = [];
  while (value) {
    result.unshift(value & 255);
    value >>= 8;
  }
  return result;
};
var _encode = function(object3) {
  if (Array.isArray(object3)) {
    let payload = [];
    object3.forEach(function(child) {
      payload = payload.concat(_encode(child));
    });
    if (payload.length <= 55) {
      payload.unshift(192 + payload.length);
      return payload;
    }
    const length2 = arrayifyInteger(payload.length);
    length2.unshift(247 + length2.length);
    return length2.concat(payload);
  }
  const data11 = Array.prototype.slice.call(getBytes(object3, "object"));
  if (data11.length === 1 && data11[0] <= 127) {
    return data11;
  } else if (data11.length <= 55) {
    data11.unshift(128 + data11.length);
    return data11;
  }
  const length = arrayifyInteger(data11.length);
  length.unshift(183 + length.length);
  return length.concat(data11);
};
function encodeRlp(object3) {
  let result = "0x";
  for (const v of _encode(object3)) {
    result += nibbles[v >> 4];
    result += nibbles[v & 15];
  }
  return result;
}
var nibbles = "0123456789abcdef";
// ../../node_modules/ethers/lib.esm/utils/units.js
function formatUnits(value, unit) {
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
}
function parseUnits(value, unit) {
  assertArgument(typeof value === "string", "value must be a string", "value", value);
  let decimals = 18;
  if (typeof unit === "string") {
    const index = names.indexOf(unit);
    assertArgument(index >= 0, "invalid unit", "unit", unit);
    decimals = 3 * index;
  } else if (unit != null) {
    decimals = getNumber(unit, "unit");
  }
  return FixedNumber.fromString(value, { decimals, width: 512 }).value;
}
function formatEther(wei) {
  return formatUnits(wei, 18);
}
function parseEther(ether) {
  return parseUnits(ether, 18);
}
var names = [
  "wei",
  "kwei",
  "mwei",
  "gwei",
  "szabo",
  "finney",
  "ether"
];
// ../../node_modules/ethers/lib.esm/utils/uuid.js
function uuidV42(randomBytes3) {
  const bytes7 = getBytes(randomBytes3, "randomBytes");
  bytes7[6] = bytes7[6] & 15 | 64;
  bytes7[8] = bytes7[8] & 63 | 128;
  const value = hexlify(bytes7);
  return [
    value.substring(2, 10),
    value.substring(10, 14),
    value.substring(14, 18),
    value.substring(18, 22),
    value.substring(22, 34)
  ].join("-");
}
// ../../node_modules/ethers/lib.esm/abi/coders/abstract-coder.js
var throwError = function(name, error) {
  const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
  wrapped.error = error;
  throw wrapped;
};
function checkResultErrors(result) {
  const errors14 = [];
  const checkErrors = function(path, object3) {
    if (!Array.isArray(object3)) {
      return;
    }
    for (let key in object3) {
      const childPath = path.slice();
      childPath.push(key);
      try {
        checkErrors(childPath, object3[key]);
      } catch (error) {
        errors14.push({ path: childPath, error });
      }
    }
  };
  checkErrors([], result);
  return errors14;
}
var getValue = function(value) {
  let bytes7 = toBeArray(value);
  assert2(bytes7.length <= WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes7, length: WordSize, offset: bytes7.length });
  if (bytes7.length !== WordSize) {
    bytes7 = getBytesCopy(concat([Padding.slice(bytes7.length % WordSize), bytes7]));
  }
  return bytes7;
};
var WordSize = 32;
var Padding = new Uint8Array(WordSize);
var passProperties = ["then"];
var _guard2 = {};

class Result extends Array {
  #names;
  constructor(...args) {
    const guard = args[0];
    let items = args[1];
    let names2 = (args[2] || []).slice();
    let wrap = true;
    if (guard !== _guard2) {
      items = args;
      names2 = [];
      wrap = false;
    }
    super(items.length);
    items.forEach((item, index) => {
      this[index] = item;
    });
    const nameCounts = names2.reduce((accum, name) => {
      if (typeof name === "string") {
        accum.set(name, (accum.get(name) || 0) + 1);
      }
      return accum;
    }, new Map);
    this.#names = Object.freeze(items.map((item, index) => {
      const name = names2[index];
      if (name != null && nameCounts.get(name) === 1) {
        return name;
      }
      return null;
    }));
    if (!wrap) {
      return;
    }
    Object.freeze(this);
    return new Proxy(this, {
      get: (target, prop, receiver) => {
        if (typeof prop === "string") {
          if (prop.match(/^[0-9]+$/)) {
            const index = getNumber(prop, "%index");
            if (index < 0 || index >= this.length) {
              throw new RangeError("out of result range");
            }
            const item = target[index];
            if (item instanceof Error) {
              throwError(`index ${index}`, item);
            }
            return item;
          }
          if (passProperties.indexOf(prop) >= 0) {
            return Reflect.get(target, prop, receiver);
          }
          const value = target[prop];
          if (value instanceof Function) {
            return function(...args2) {
              return value.apply(this === receiver ? target : this, args2);
            };
          } else if (!(prop in target)) {
            return target.getValue.apply(this === receiver ? target : this, [prop]);
          }
        }
        return Reflect.get(target, prop, receiver);
      }
    });
  }
  toArray() {
    const result = [];
    this.forEach((item, index) => {
      if (item instanceof Error) {
        throwError(`index ${index}`, item);
      }
      result.push(item);
    });
    return result;
  }
  toObject() {
    return this.#names.reduce((accum, name, index) => {
      assert2(name != null, "value at index ${ index } unnamed", "UNSUPPORTED_OPERATION", {
        operation: "toObject()"
      });
      if (!(name in accum)) {
        accum[name] = this.getValue(name);
      }
      return accum;
    }, {});
  }
  slice(start, end) {
    if (start == null) {
      start = 0;
    }
    if (start < 0) {
      start += this.length;
      if (start < 0) {
        start = 0;
      }
    }
    if (end == null) {
      end = this.length;
    }
    if (end < 0) {
      end += this.length;
      if (end < 0) {
        end = 0;
      }
    }
    if (end > this.length) {
      end = this.length;
    }
    const result = [], names2 = [];
    for (let i = start;i < end; i++) {
      result.push(this[i]);
      names2.push(this.#names[i]);
    }
    return new Result(_guard2, result, names2);
  }
  filter(callback, thisArg) {
    const result = [], names2 = [];
    for (let i = 0;i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      if (callback.call(thisArg, item, i, this)) {
        result.push(item);
        names2.push(this.#names[i]);
      }
    }
    return new Result(_guard2, result, names2);
  }
  map(callback, thisArg) {
    const result = [];
    for (let i = 0;i < this.length; i++) {
      const item = this[i];
      if (item instanceof Error) {
        throwError(`index ${i}`, item);
      }
      result.push(callback.call(thisArg, item, i, this));
    }
    return result;
  }
  getValue(name) {
    const index = this.#names.indexOf(name);
    if (index === -1) {
      return;
    }
    const value = this[index];
    if (value instanceof Error) {
      throwError(`property ${JSON.stringify(name)}`, value.error);
    }
    return value;
  }
  static fromItems(items, keys) {
    return new Result(_guard2, items, keys);
  }
}

class Coder {
  name;
  type;
  localName;
  dynamic;
  constructor(name, type, localName, dynamic) {
    defineProperties(this, { name, type, localName, dynamic }, {
      name: "string",
      type: "string",
      localName: "string",
      dynamic: "boolean"
    });
  }
  _throwError(message, value) {
    assertArgument(false, message, this.localName, value);
  }
}

class Writer {
  #data;
  #dataLength;
  constructor() {
    this.#data = [];
    this.#dataLength = 0;
  }
  get data() {
    return concat(this.#data);
  }
  get length() {
    return this.#dataLength;
  }
  #writeData(data12) {
    this.#data.push(data12);
    this.#dataLength += data12.length;
    return data12.length;
  }
  appendWriter(writer) {
    return this.#writeData(getBytesCopy(writer.data));
  }
  writeBytes(value) {
    let bytes7 = getBytesCopy(value);
    const paddingOffset = bytes7.length % WordSize;
    if (paddingOffset) {
      bytes7 = getBytesCopy(concat([bytes7, Padding.slice(paddingOffset)]));
    }
    return this.#writeData(bytes7);
  }
  writeValue(value) {
    return this.#writeData(getValue(value));
  }
  writeUpdatableValue() {
    const offset = this.#data.length;
    this.#data.push(Padding);
    this.#dataLength += WordSize;
    return (value) => {
      this.#data[offset] = getValue(value);
    };
  }
}

class Reader {
  allowLoose;
  #data;
  #offset;
  constructor(data12, allowLoose) {
    defineProperties(this, { allowLoose: !!allowLoose });
    this.#data = getBytesCopy(data12);
    this.#offset = 0;
  }
  get data() {
    return hexlify(this.#data);
  }
  get dataLength() {
    return this.#data.length;
  }
  get consumed() {
    return this.#offset;
  }
  get bytes() {
    return new Uint8Array(this.#data);
  }
  #peekBytes(offset, length, loose) {
    let alignedLength = Math.ceil(length / WordSize) * WordSize;
    if (this.#offset + alignedLength > this.#data.length) {
      if (this.allowLoose && loose && this.#offset + length <= this.#data.length) {
        alignedLength = length;
      } else {
        assert2(false, "data out-of-bounds", "BUFFER_OVERRUN", {
          buffer: getBytesCopy(this.#data),
          length: this.#data.length,
          offset: this.#offset + alignedLength
        });
      }
    }
    return this.#data.slice(this.#offset, this.#offset + alignedLength);
  }
  subReader(offset) {
    return new Reader(this.#data.slice(this.#offset + offset), this.allowLoose);
  }
  readBytes(length, loose) {
    let bytes7 = this.#peekBytes(0, length, !!loose);
    this.#offset += bytes7.length;
    return bytes7.slice(0, length);
  }
  readValue() {
    return toBigInt2(this.readBytes(WordSize));
  }
  readIndex() {
    return toNumber2(this.readBytes(WordSize));
  }
}

// ../../node_modules/ethers/lib.esm/crypto/crypto.js
import {createHash, createHmac, pbkdf2Sync as pbkdf2Sync2, randomBytes as randomBytes3} from "crypto";

// ../../node_modules/ethers/lib.esm/crypto/hmac.js
function computeHmac(algorithm, _key, _data) {
  const key = getBytes(_key, "key");
  const data12 = getBytes(_data, "data");
  return hexlify(__computeHmac(algorithm, key, data12));
}
var locked2 = false;
var _computeHmac = function(algorithm, key, data12) {
  return createHmac(algorithm, key).update(data12).digest();
};
var __computeHmac = _computeHmac;
computeHmac._ = _computeHmac;
computeHmac.lock = function() {
  locked2 = true;
};
computeHmac.register = function(func) {
  if (locked2) {
    throw new Error("computeHmac is locked");
  }
  __computeHmac = func;
};
Object.freeze(computeHmac);

// ../../node_modules/@noble/hashes/esm/_assert.js
function number8(n) {
  if (!Number.isSafeInteger(n) || n < 0)
    throw new Error(`Wrong positive integer: ${n}`);
}
function bool3(b) {
  if (typeof b !== "boolean")
    throw new Error(`Expected boolean, not ${b}`);
}
function bytes7(b, ...lengths) {
  if (!(b instanceof Uint8Array))
    throw new TypeError("Expected Uint8Array");
  if (lengths.length > 0 && !lengths.includes(b.length))
    throw new TypeError(`Expected Uint8Array of length ${lengths}, not of length=${b.length}`);
}
function hash3(hash4) {
  if (typeof hash4 !== "function" || typeof hash4.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  number8(hash4.outputLen);
  number8(hash4.blockLen);
}
function exists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function output2(out, instance) {
  bytes7(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error(`digestInto() expects output buffer of length at least ${min}`);
  }
}
var assert3 = {
  number: number8,
  bool: bool3,
  bytes: bytes7,
  hash: hash3,
  exists: exists2,
  output: output2
};
var _assert_default2 = assert3;

// ../../node_modules/@noble/hashes/esm/_u64.js
function fromBig2(n, le = false) {
  if (le)
    return { h: Number(n & U32_MASK642), l: Number(n >> _32n2 & U32_MASK642) };
  return { h: Number(n >> _32n2 & U32_MASK642) | 0, l: Number(n & U32_MASK642) | 0 };
}
function split3(lst, le = false) {
  let Ah = new Uint32Array(lst.length);
  let Al = new Uint32Array(lst.length);
  for (let i = 0;i < lst.length; i++) {
    const { h, l } = fromBig2(lst[i], le);
    [Ah[i], Al[i]] = [h, l];
  }
  return [Ah, Al];
}
function add2(Ah, Al, Bh, Bl) {
  const l = (Al >>> 0) + (Bl >>> 0);
  return { h: Ah + Bh + (l / 2 ** 32 | 0) | 0, l: l | 0 };
}
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
var toBig2 = (h, l) => BigInt(h >>> 0) << _32n2 | BigInt(l >>> 0);
var shrSH2 = (h, l, s) => h >>> s;
var shrSL2 = (h, l, s) => h << 32 - s | l >>> s;
var rotrSH2 = (h, l, s) => h >>> s | l << 32 - s;
var rotrSL2 = (h, l, s) => h << 32 - s | l >>> s;
var rotrBH2 = (h, l, s) => h << 64 - s | l >>> s - 32;
var rotrBL2 = (h, l, s) => h >>> s - 32 | l << 64 - s;
var rotr32H2 = (h, l) => l;
var rotr32L2 = (h, l) => h;
var rotlSH2 = (h, l, s) => h << s | l >>> 32 - s;
var rotlSL2 = (h, l, s) => l << s | h >>> 32 - s;
var rotlBH2 = (h, l, s) => l << s - 32 | h >>> 64 - s;
var rotlBL2 = (h, l, s) => h << s - 32 | l >>> 64 - s;
var add3L2 = (Al, Bl, Cl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al, Bl, Cl, Dl) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al, Bl, Cl, Dl, El) => (Al >>> 0) + (Bl >>> 0) + (Cl >>> 0) + (Dl >>> 0) + (El >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u642 = {
  fromBig: fromBig2,
  split: split3,
  toBig: toBig2,
  shrSH: shrSH2,
  shrSL: shrSL2,
  rotrSH: rotrSH2,
  rotrSL: rotrSL2,
  rotrBH: rotrBH2,
  rotrBL: rotrBL2,
  rotr32H: rotr32H2,
  rotr32L: rotr32L2,
  rotlSH: rotlSH2,
  rotlSL: rotlSL2,
  rotlBH: rotlBH2,
  rotlBL: rotlBL2,
  add: add2,
  add3L: add3L2,
  add3H: add3H2,
  add4L: add4L2,
  add4H: add4H2,
  add5H: add5H2,
  add5L: add5L2
};
var _u64_default2 = u642;

// ../../node_modules/@noble/hashes/esm/utils.js
async function asyncLoop2(iters, tick, cb) {
  let ts = Date.now();
  for (let i = 0;i < iters; i++) {
    cb(i);
    const diff = Date.now() - ts;
    if (diff >= 0 && diff < tick)
      continue;
    await nextTick();
    ts += diff;
  }
}
function utf8ToBytes4(str) {
  if (typeof str !== "string") {
    throw new TypeError(`utf8ToBytes expected string, got ${typeof str}`);
  }
  return new TextEncoder().encode(str);
}
function toBytes2(data12) {
  if (typeof data12 === "string")
    data12 = utf8ToBytes4(data12);
  if (!(data12 instanceof Uint8Array))
    throw new TypeError(`Expected input type is Uint8Array (got ${typeof data12})`);
  return data12;
}
function checkOpts2(defaults, opts) {
  if (opts !== undefined && (typeof opts !== "object" || !isPlainObject(opts)))
    throw new TypeError("Options should be object or undefined");
  const merged = Object.assign(defaults, opts);
  return merged;
}
function wrapConstructor2(hashConstructor) {
  const hashC = (message) => hashConstructor().update(toBytes2(message)).digest();
  const tmp = hashConstructor();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashConstructor();
  return hashC;
}
function wrapConstructorWithOpts(hashCons) {
  const hashC = (msg, opts) => hashCons(opts).update(toBytes2(msg)).digest();
  const tmp = hashCons({});
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = (opts) => hashCons(opts);
  return hashC;
}
/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */
var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
var createView2 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
var rotr2 = (word, shift) => word << 32 - shift | word >>> shift;
var isLE2 = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
if (!isLE2)
  throw new Error("Non little-endian hardware is not supported");
var hexes2 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
var nextTick = async () => {
};

class Hash2 {
  clone() {
    return this._cloneInto();
  }
}
var isPlainObject = (obj) => Object.prototype.toString.call(obj) === "[object Object]" && obj.constructor === Object;

// ../../node_modules/@noble/hashes/esm/sha3.js
function keccakP2(s, rounds = 24) {
  const B = new Uint32Array(5 * 2);
  for (let round = 24 - rounds;round < 24; round++) {
    for (let x = 0;x < 10; x++)
      B[x] = s[x] ^ s[x + 10] ^ s[x + 20] ^ s[x + 30] ^ s[x + 40];
    for (let x = 0;x < 10; x += 2) {
      const idx1 = (x + 8) % 10;
      const idx0 = (x + 2) % 10;
      const B0 = B[idx0];
      const B1 = B[idx0 + 1];
      const Th = rotlH2(B0, B1, 1) ^ B[idx1];
      const Tl = rotlL2(B0, B1, 1) ^ B[idx1 + 1];
      for (let y = 0;y < 50; y += 10) {
        s[x + y] ^= Th;
        s[x + y + 1] ^= Tl;
      }
    }
    let curH = s[2];
    let curL = s[3];
    for (let t = 0;t < 24; t++) {
      const shift = SHA3_ROTL2[t];
      const Th = rotlH2(curH, curL, shift);
      const Tl = rotlL2(curH, curL, shift);
      const PI = SHA3_PI2[t];
      curH = s[PI];
      curL = s[PI + 1];
      s[PI] = Th;
      s[PI + 1] = Tl;
    }
    for (let y = 0;y < 50; y += 10) {
      for (let x = 0;x < 10; x++)
        B[x] = s[y + x];
      for (let x = 0;x < 10; x++)
        s[y + x] ^= ~B[(x + 2) % 10] & B[(x + 4) % 10];
    }
    s[0] ^= SHA3_IOTA_H2[round];
    s[1] ^= SHA3_IOTA_L2[round];
  }
  B.fill(0);
}
var [SHA3_PI2, SHA3_ROTL2, _SHA3_IOTA2] = [[], [], []];
var _0n7 = BigInt(0);
var _1n7 = BigInt(1);
var _2n6 = BigInt(2);
var _7n2 = BigInt(7);
var _256n2 = BigInt(256);
var _0x71n2 = BigInt(113);
for (let round = 0, R = _1n7, x = 1, y = 0;round < 24; round++) {
  [x, y] = [y, (2 * x + 3 * y) % 5];
  SHA3_PI2.push(2 * (5 * y + x));
  SHA3_ROTL2.push((round + 1) * (round + 2) / 2 % 64);
  let t = _0n7;
  for (let j = 0;j < 7; j++) {
    R = (R << _1n7 ^ (R >> _7n2) * _0x71n2) % _256n2;
    if (R & _2n6)
      t ^= _1n7 << (_1n7 << BigInt(j)) - _1n7;
  }
  _SHA3_IOTA2.push(t);
}
var [SHA3_IOTA_H2, SHA3_IOTA_L2] = _u64_default2.split(_SHA3_IOTA2, true);
var rotlH2 = (h, l, s) => s > 32 ? _u64_default2.rotlBH(h, l, s) : _u64_default2.rotlSH(h, l, s);
var rotlL2 = (h, l, s) => s > 32 ? _u64_default2.rotlBL(h, l, s) : _u64_default2.rotlSL(h, l, s);

class Keccak2 extends Hash2 {
  constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
    super();
    this.blockLen = blockLen;
    this.suffix = suffix;
    this.outputLen = outputLen;
    this.enableXOF = enableXOF;
    this.rounds = rounds;
    this.pos = 0;
    this.posOut = 0;
    this.finished = false;
    this.destroyed = false;
    _assert_default2.number(outputLen);
    if (0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200);
    this.state32 = u322(this.state);
  }
  keccak() {
    keccakP2(this.state32, this.rounds);
    this.posOut = 0;
    this.pos = 0;
  }
  update(data12) {
    _assert_default2.exists(this);
    const { blockLen, state } = this;
    data12 = toBytes2(data12);
    const len = data12.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      for (let i = 0;i < take; i++)
        state[this.pos++] ^= data12[pos++];
      if (this.pos === blockLen)
        this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state, suffix, pos, blockLen } = this;
    state[pos] ^= suffix;
    if ((suffix & 128) !== 0 && pos === blockLen - 1)
      this.keccak();
    state[blockLen - 1] ^= 128;
    this.keccak();
  }
  writeInto(out) {
    _assert_default2.exists(this, false);
    _assert_default2.bytes(out);
    this.finish();
    const bufferOut = this.state;
    const { blockLen } = this;
    for (let pos = 0, len = out.length;pos < len; ) {
      if (this.posOut >= blockLen)
        this.keccak();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(out);
  }
  xof(bytes8) {
    _assert_default2.number(bytes8);
    return this.xofInto(new Uint8Array(bytes8));
  }
  digestInto(out) {
    _assert_default2.output(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true;
    this.state.fill(0);
  }
  _cloneInto(to) {
    const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
    to || (to = new Keccak2(blockLen, suffix, outputLen, enableXOF, rounds));
    to.state32.set(this.state32);
    to.pos = this.pos;
    to.posOut = this.posOut;
    to.finished = this.finished;
    to.rounds = rounds;
    to.suffix = suffix;
    to.outputLen = outputLen;
    to.enableXOF = enableXOF;
    to.destroyed = this.destroyed;
    return to;
  }
}
var gen2 = (suffix, blockLen, outputLen) => wrapConstructor2(() => new Keccak2(blockLen, suffix, outputLen));
var sha3_2242 = gen2(6, 144, 224 / 8);
var sha3_2562 = gen2(6, 136, 256 / 8);
var sha3_3842 = gen2(6, 104, 384 / 8);
var sha3_5122 = gen2(6, 72, 512 / 8);
var keccak_2242 = gen2(1, 144, 224 / 8);
var keccak_2562 = gen2(1, 136, 256 / 8);
var keccak_3842 = gen2(1, 104, 384 / 8);
var keccak_5122 = gen2(1, 72, 512 / 8);
var genShake2 = (suffix, blockLen, outputLen) => wrapConstructorWithOpts((opts = {}) => new Keccak2(blockLen, suffix, opts.dkLen === undefined ? outputLen : opts.dkLen, true));
var shake1282 = genShake2(31, 168, 128 / 8);
var shake2562 = genShake2(31, 136, 256 / 8);

// ../../node_modules/ethers/lib.esm/crypto/keccak.js
function keccak2562(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__keccak256(data12));
}
var locked3 = false;
var _keccak256 = function(data12) {
  return keccak_2562(data12);
};
var __keccak256 = _keccak256;
keccak2562._ = _keccak256;
keccak2562.lock = function() {
  locked3 = true;
};
keccak2562.register = function(func) {
  if (locked3) {
    throw new TypeError("keccak256 is locked");
  }
  __keccak256 = func;
};
Object.freeze(keccak2562);

// ../../node_modules/@noble/hashes/esm/_sha2.js
var setBigUint642 = function(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l, wl, isLE3);
};

class SHA22 extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data12) {
    _assert_default2.exists(this);
    const { view, buffer, blockLen } = this;
    data12 = toBytes2(data12);
    const len = data12.length;
    for (let pos = 0;pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data12);
        for (;blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer.set(data12.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data12.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    _assert_default2.exists(this);
    _assert_default2.output(out, this);
    this.finished = true;
    const { buffer, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i = pos;i < blockLen; i++)
      buffer[i] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    this.get().forEach((v, i) => oview.setUint32(4 * i, v, isLE3));
  }
  digest() {
    const { buffer, outputLen } = this;
    this.digestInto(buffer);
    const res = buffer.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to) {
    to || (to = new this.constructor);
    to.set(...this.get());
    const { blockLen, buffer, length, finished, destroyed, pos } = this;
    to.length = length;
    to.pos = pos;
    to.finished = finished;
    to.destroyed = destroyed;
    if (length % blockLen)
      to.buffer.set(buffer);
    return to;
  }
}

// ../../node_modules/@noble/hashes/esm/ripemd160.js
var f = function(group, x, y, z2) {
  if (group === 0)
    return x ^ y ^ z2;
  else if (group === 1)
    return x & y | ~x & z2;
  else if (group === 2)
    return (x | ~y) ^ z2;
  else if (group === 3)
    return x & z2 | y & ~z2;
  else
    return x ^ (y | ~z2);
};
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = Uint8Array.from({ length: 16 }, (_, i) => i);
var Pi = Id.map((i) => (9 * i + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i = 0;i < 4; i++)
  for (let j of [idxL, idxR])
    j.push(j[i].map((k) => Rho[k]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i) => new Uint8Array(i));
var shiftsL = idxL.map((idx, i) => idx.map((j) => shifts[i][j]));
var shiftsR = idxR.map((idx, i) => idx.map((j) => shifts[i][j]));
var Kl = new Uint32Array([0, 1518500249, 1859775393, 2400959708, 2840853838]);
var Kr = new Uint32Array([1352829926, 1548603684, 1836072691, 2053994217, 0]);
var rotl2 = (word, shift) => word << shift | word >>> 32 - shift;
var BUF = new Uint32Array(16);

class RIPEMD160 extends SHA22 {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      BUF[i] = view.getUint32(offset, true);
    let al = this.h0 | 0, ar = al, bl = this.h1 | 0, br = bl, cl = this.h2 | 0, cr = cl, dl = this.h3 | 0, dr = dl, el = this.h4 | 0, er = el;
    for (let group = 0;group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl = idxL[group], rr = idxR[group];
      const sl = shiftsL[group], sr = shiftsR[group];
      for (let i = 0;i < 16; i++) {
        const tl = rotl2(al + f(group, bl, cl, dl) + BUF[rl[i]] + hbl, sl[i]) + el | 0;
        al = el, el = dl, dl = rotl2(cl, 10) | 0, cl = bl, bl = tl;
      }
      for (let i = 0;i < 16; i++) {
        const tr = rotl2(ar + f(rGroup, br, cr, dr) + BUF[rr[i]] + hbr, sr[i]) + er | 0;
        ar = er, er = dr, dr = rotl2(cr, 10) | 0, cr = br, br = tr;
      }
    }
    this.set(this.h1 + cl + dr | 0, this.h2 + dl + er | 0, this.h3 + el + ar | 0, this.h4 + al + br | 0, this.h0 + bl + cr | 0);
  }
  roundClean() {
    BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
}
var ripemd160 = wrapConstructor2(() => new RIPEMD160);

// ../../node_modules/ethers/lib.esm/crypto/ripemd160.js
function ripemd1603(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__ripemd160(data12));
}
var locked4 = false;
var _ripemd160 = function(data12) {
  return ripemd160(data12);
};
var __ripemd160 = _ripemd160;
ripemd1603._ = _ripemd160;
ripemd1603.lock = function() {
  locked4 = true;
};
ripemd1603.register = function(func) {
  if (locked4) {
    throw new TypeError("ripemd160 is locked");
  }
  __ripemd160 = func;
};
Object.freeze(ripemd1603);

// ../../node_modules/ethers/lib.esm/crypto/pbkdf2.js
function pbkdf25(_password, _salt, iterations, keylen, algo) {
  const password = getBytes(_password, "password");
  const salt = getBytes(_salt, "salt");
  return hexlify(__pbkdf2(password, salt, iterations, keylen, algo));
}
var locked5 = false;
var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
  return pbkdf2Sync2(password, salt, iterations, keylen, algo);
};
var __pbkdf2 = _pbkdf2;
pbkdf25._ = _pbkdf2;
pbkdf25.lock = function() {
  locked5 = true;
};
pbkdf25.register = function(func) {
  if (locked5) {
    throw new Error("pbkdf2 is locked");
  }
  __pbkdf2 = func;
};
Object.freeze(pbkdf25);

// ../../node_modules/ethers/lib.esm/crypto/random.js
function randomBytes4(length) {
  return __randomBytes(length);
}
var locked6 = false;
var _randomBytes = function(length) {
  return new Uint8Array(randomBytes3(length));
};
var __randomBytes = _randomBytes;
randomBytes4._ = _randomBytes;
randomBytes4.lock = function() {
  locked6 = true;
};
randomBytes4.register = function(func) {
  if (locked6) {
    throw new Error("randomBytes is locked");
  }
  __randomBytes = func;
};
Object.freeze(randomBytes4);

// ../../node_modules/@noble/hashes/esm/sha256.js
var Chi2 = (a, b, c) => a & b ^ ~a & c;
var Maj2 = (a, b, c) => a & b ^ a & c ^ b & c;
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);

class SHA2562 extends SHA22 {
  constructor() {
    super(64, 32, 8, false);
    this.A = IV2[0] | 0;
    this.B = IV2[1] | 0;
    this.C = IV2[2] | 0;
    this.D = IV2[3] | 0;
    this.E = IV2[4] | 0;
    this.F = IV2[5] | 0;
    this.G = IV2[6] | 0;
    this.H = IV2[7] | 0;
  }
  get() {
    const { A, B, C, D, E, F, G, H } = this;
    return [A, B, C, D, E, F, G, H];
  }
  set(A, B, C, D, E, F, G, H) {
    this.A = A | 0;
    this.B = B | 0;
    this.C = C | 0;
    this.D = D | 0;
    this.E = E | 0;
    this.F = F | 0;
    this.G = G | 0;
    this.H = H | 0;
  }
  process(view, offset) {
    for (let i = 0;i < 16; i++, offset += 4)
      SHA256_W2[i] = view.getUint32(offset, false);
    for (let i = 16;i < 64; i++) {
      const W15 = SHA256_W2[i - 15];
      const W2 = SHA256_W2[i - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W2, 17) ^ rotr2(W2, 19) ^ W2 >>> 10;
      SHA256_W2[i] = s1 + SHA256_W2[i - 7] + s0 + SHA256_W2[i - 16] | 0;
    }
    let { A, B, C, D, E, F, G, H } = this;
    for (let i = 0;i < 64; i++) {
      const sigma1 = rotr2(E, 6) ^ rotr2(E, 11) ^ rotr2(E, 25);
      const T12 = H + sigma1 + Chi2(E, F, G) + SHA256_K2[i] + SHA256_W2[i] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T2 = sigma0 + Maj2(A, B, C) | 0;
      H = G;
      G = F;
      F = E;
      E = D + T12 | 0;
      D = C;
      C = B;
      B = A;
      A = T12 + T2 | 0;
    }
    A = A + this.A | 0;
    B = B + this.B | 0;
    C = C + this.C | 0;
    D = D + this.D | 0;
    E = E + this.E | 0;
    F = F + this.F | 0;
    G = G + this.G | 0;
    H = H + this.H | 0;
    this.set(A, B, C, D, E, F, G, H);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
}
var sha2565 = wrapConstructor2(() => new SHA2562);

// ../../node_modules/@noble/hashes/esm/hmac.js
class HMAC2 extends Hash2 {
  constructor(hash4, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    _assert_default2.hash(hash4);
    const key = toBytes2(_key);
    this.iHash = hash4.create();
    if (!(this.iHash instanceof Hash2))
      throw new TypeError("Expected instance of class which extends utils.Hash");
    const blockLen = this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const pad = new Uint8Array(blockLen);
    pad.set(key.length > this.iHash.blockLen ? hash4.create().update(key).digest() : key);
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54;
    this.iHash.update(pad);
    this.oHash = hash4.create();
    for (let i = 0;i < pad.length; i++)
      pad[i] ^= 54 ^ 92;
    this.oHash.update(pad);
    pad.fill(0);
  }
  update(buf) {
    _assert_default2.exists(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    _assert_default2.exists(this);
    _assert_default2.bytes(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to) {
    to || (to = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to = to;
    to.finished = finished;
    to.destroyed = destroyed;
    to.blockLen = blockLen;
    to.outputLen = outputLen;
    to.oHash = oHash._cloneInto(to.oHash);
    to.iHash = iHash._cloneInto(to.iHash);
    return to;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
}
var hmac4 = (hash4, key, message) => new HMAC2(hash4, key).update(message).digest();
hmac4.create = (hash4, key) => new HMAC2(hash4, key);

// ../../node_modules/@noble/hashes/esm/pbkdf2.js
var pbkdf2Init2 = function(hash4, _password, _salt, _opts) {
  _assert_default2.hash(hash4);
  const opts = checkOpts2({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c, dkLen, asyncTick } = opts;
  _assert_default2.number(c);
  _assert_default2.number(dkLen);
  _assert_default2.number(asyncTick);
  if (c < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes2(_password);
  const salt = toBytes2(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac4.create(hash4, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c, dkLen, asyncTick, DK, PRF, PRFSalt };
};
var pbkdf2Output2 = function(PRF, PRFSalt, DK, prfW, u) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u.fill(0);
  return DK;
};
function pbkdf26(hash4, password, salt, opts) {
  const { c, dkLen, DK, PRF, PRFSalt } = pbkdf2Init2(hash4, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView2(arr);
  const u = new Uint8Array(PRF.outputLen);
  for (let ti = 1, pos = 0;pos < dkLen; ti++, pos += PRF.outputLen) {
    const Ti = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u);
    Ti.set(u.subarray(0, Ti.length));
    for (let ui = 1;ui < c; ui++) {
      PRF._cloneInto(prfW).update(u).digestInto(u);
      for (let i = 0;i < Ti.length; i++)
        Ti[i] ^= u[i];
    }
  }
  return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u);
}

// ../../node_modules/@noble/hashes/esm/scrypt.js
var XorAndSalsa2 = function(prev, pi, input, ii, out, oi) {
  let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
  let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
  let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
  let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
  let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
  let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
  let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
  let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
  let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
  for (let i = 0;i < 8; i += 2) {
    x04 ^= rotl3(x00 + x12 | 0, 7);
    x08 ^= rotl3(x04 + x00 | 0, 9);
    x12 ^= rotl3(x08 + x04 | 0, 13);
    x00 ^= rotl3(x12 + x08 | 0, 18);
    x09 ^= rotl3(x05 + x01 | 0, 7);
    x13 ^= rotl3(x09 + x05 | 0, 9);
    x01 ^= rotl3(x13 + x09 | 0, 13);
    x05 ^= rotl3(x01 + x13 | 0, 18);
    x14 ^= rotl3(x10 + x06 | 0, 7);
    x02 ^= rotl3(x14 + x10 | 0, 9);
    x06 ^= rotl3(x02 + x14 | 0, 13);
    x10 ^= rotl3(x06 + x02 | 0, 18);
    x03 ^= rotl3(x15 + x11 | 0, 7);
    x07 ^= rotl3(x03 + x15 | 0, 9);
    x11 ^= rotl3(x07 + x03 | 0, 13);
    x15 ^= rotl3(x11 + x07 | 0, 18);
    x01 ^= rotl3(x00 + x03 | 0, 7);
    x02 ^= rotl3(x01 + x00 | 0, 9);
    x03 ^= rotl3(x02 + x01 | 0, 13);
    x00 ^= rotl3(x03 + x02 | 0, 18);
    x06 ^= rotl3(x05 + x04 | 0, 7);
    x07 ^= rotl3(x06 + x05 | 0, 9);
    x04 ^= rotl3(x07 + x06 | 0, 13);
    x05 ^= rotl3(x04 + x07 | 0, 18);
    x11 ^= rotl3(x10 + x09 | 0, 7);
    x08 ^= rotl3(x11 + x10 | 0, 9);
    x09 ^= rotl3(x08 + x11 | 0, 13);
    x10 ^= rotl3(x09 + x08 | 0, 18);
    x12 ^= rotl3(x15 + x14 | 0, 7);
    x13 ^= rotl3(x12 + x15 | 0, 9);
    x14 ^= rotl3(x13 + x12 | 0, 13);
    x15 ^= rotl3(x14 + x13 | 0, 18);
  }
  out[oi++] = y00 + x00 | 0;
  out[oi++] = y01 + x01 | 0;
  out[oi++] = y02 + x02 | 0;
  out[oi++] = y03 + x03 | 0;
  out[oi++] = y04 + x04 | 0;
  out[oi++] = y05 + x05 | 0;
  out[oi++] = y06 + x06 | 0;
  out[oi++] = y07 + x07 | 0;
  out[oi++] = y08 + x08 | 0;
  out[oi++] = y09 + x09 | 0;
  out[oi++] = y10 + x10 | 0;
  out[oi++] = y11 + x11 | 0;
  out[oi++] = y12 + x12 | 0;
  out[oi++] = y13 + x13 | 0;
  out[oi++] = y14 + x14 | 0;
  out[oi++] = y15 + x15 | 0;
};
var BlockMix2 = function(input, ii, out, oi, r) {
  let head = oi + 0;
  let tail = oi + 16 * r;
  for (let i = 0;i < 16; i++)
    out[tail + i] = input[ii + (2 * r - 1) * 16 + i];
  for (let i = 0;i < r; i++, head += 16, ii += 16) {
    XorAndSalsa2(out, tail, input, ii, out, head);
    if (i > 0)
      tail += 16;
    XorAndSalsa2(out, head, input, ii += 16, out, tail);
  }
};
var scryptInit2 = function(password, salt, _opts) {
  const opts = checkOpts2({
    dkLen: 32,
    asyncTick: 10,
    maxmem: 1024 ** 3 + 1024
  }, _opts);
  const { N, r, p, dkLen, asyncTick, maxmem, onProgress } = opts;
  _assert_default2.number(N);
  _assert_default2.number(r);
  _assert_default2.number(p);
  _assert_default2.number(dkLen);
  _assert_default2.number(asyncTick);
  _assert_default2.number(maxmem);
  if (onProgress !== undefined && typeof onProgress !== "function")
    throw new Error("progressCb should be function");
  const blockSize = 128 * r;
  const blockSize32 = blockSize / 4;
  if (N <= 1 || (N & N - 1) !== 0 || N >= 2 ** (blockSize / 8) || N > 2 ** 32) {
    throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
  }
  if (p < 0 || p > (2 ** 32 - 1) * 32 / blockSize) {
    throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
  }
  if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
    throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
  }
  const memUsed = blockSize * (N + p);
  if (memUsed > maxmem) {
    throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
  }
  const B = pbkdf26(sha2565, password, salt, { c: 1, dkLen: blockSize * p });
  const B32 = u322(B);
  const V = u322(new Uint8Array(blockSize * N));
  const tmp = u322(new Uint8Array(blockSize));
  let blockMixCb = () => {
  };
  if (onProgress) {
    const totalBlockMix = 2 * N * p;
    const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
    let blockMixCnt = 0;
    blockMixCb = () => {
      blockMixCnt++;
      if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
        onProgress(blockMixCnt / totalBlockMix);
    };
  }
  return { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick };
};
var scryptOutput2 = function(password, dkLen, B, V, tmp) {
  const res = pbkdf26(sha2565, password, B, { c: 1, dkLen });
  B.fill(0);
  V.fill(0);
  tmp.fill(0);
  return res;
};
function scrypt4(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb } = scryptInit2(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    for (let i = 0, pos = 0;i < N - 1; i++) {
      BlockMix2(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    }
    BlockMix2(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    for (let i = 0;i < N; i++) {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix2(tmp, 0, B32, Pi2, r);
      blockMixCb();
    }
  }
  return scryptOutput2(password, dkLen, B, V, tmp);
}
async function scryptAsync2(password, salt, opts) {
  const { N, r, p, dkLen, blockSize32, V, B32, B, tmp, blockMixCb, asyncTick } = scryptInit2(password, salt, opts);
  for (let pi = 0;pi < p; pi++) {
    const Pi2 = blockSize32 * pi;
    for (let i = 0;i < blockSize32; i++)
      V[i] = B32[Pi2 + i];
    let pos = 0;
    await asyncLoop2(N - 1, asyncTick, (i) => {
      BlockMix2(V, pos, V, pos += blockSize32, r);
      blockMixCb();
    });
    BlockMix2(V, (N - 1) * blockSize32, B32, Pi2, r);
    blockMixCb();
    await asyncLoop2(N, asyncTick, (i) => {
      const j = B32[Pi2 + blockSize32 - 16] % N;
      for (let k = 0;k < blockSize32; k++)
        tmp[k] = B32[Pi2 + k] ^ V[j * blockSize32 + k];
      BlockMix2(tmp, 0, B32, Pi2, r);
      blockMixCb();
    });
  }
  return scryptOutput2(password, dkLen, B, V, tmp);
}
var rotl3 = (a, b) => a << b | a >>> 32 - b;

// ../../node_modules/ethers/lib.esm/crypto/scrypt.js
async function scrypt6(_passwd, _salt, N, r, p, dkLen, progress) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(await __scryptAsync(passwd, salt, N, r, p, dkLen, progress));
}
function scryptSync2(_passwd, _salt, N, r, p, dkLen) {
  const passwd = getBytes(_passwd, "passwd");
  const salt = getBytes(_salt, "salt");
  return hexlify(__scryptSync(passwd, salt, N, r, p, dkLen));
}
var lockedSync = false;
var lockedAsync = false;
var _scryptAsync = async function(passwd, salt, N, r, p, dkLen, onProgress) {
  return await scryptAsync2(passwd, salt, { N, r, p, dkLen, onProgress });
};
var _scryptSync = function(passwd, salt, N, r, p, dkLen) {
  return scrypt4(passwd, salt, { N, r, p, dkLen });
};
var __scryptAsync = _scryptAsync;
var __scryptSync = _scryptSync;
scrypt6._ = _scryptAsync;
scrypt6.lock = function() {
  lockedAsync = true;
};
scrypt6.register = function(func) {
  if (lockedAsync) {
    throw new Error("scrypt is locked");
  }
  __scryptAsync = func;
};
Object.freeze(scrypt6);
scryptSync2._ = _scryptSync;
scryptSync2.lock = function() {
  lockedSync = true;
};
scryptSync2.register = function(func) {
  if (lockedSync) {
    throw new Error("scryptSync is locked");
  }
  __scryptSync = func;
};
Object.freeze(scryptSync2);

// ../../node_modules/ethers/lib.esm/crypto/sha2.js
function sha2567(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__sha256(data12));
}
function sha5123(_data) {
  const data12 = getBytes(_data, "data");
  return hexlify(__sha512(data12));
}
var _sha256 = function(data12) {
  return createHash("sha256").update(data12).digest();
};
var _sha512 = function(data12) {
  return createHash("sha512").update(data12).digest();
};
var __sha256 = _sha256;
var __sha512 = _sha512;
var locked256 = false;
var locked512 = false;
sha2567._ = _sha256;
sha2567.lock = function() {
  locked256 = true;
};
sha2567.register = function(func) {
  if (locked256) {
    throw new Error("sha256 is locked");
  }
  __sha256 = func;
};
Object.freeze(sha2567);
sha5123._ = _sha512;
sha5123.lock = function() {
  locked512 = true;
};
sha5123.register = function(func) {
  if (locked512) {
    throw new Error("sha512 is locked");
  }
  __sha512 = func;
};
Object.freeze(sha2567);

// ../../node_modules/@noble/secp256k1/lib/esm/index.js
import * as nodeCrypto from "crypto";
var weierstrass3 = function(x) {
  const { a, b } = CURVE;
  const x2 = mod2(x * x);
  const x3 = mod2(x2 * x);
  return mod2(x3 + a * x + b);
};
var assertJacPoint = function(other) {
  if (!(other instanceof JacobianPoint))
    throw new TypeError("JacobianPoint expected");
};
var constTimeNegate = function(condition, item) {
  const neg = item.negate();
  return condition ? neg : item;
};
var sliceDER = function(s) {
  return Number.parseInt(s[0], 16) >= 8 ? "00" + s : s;
};
var parseDERInt = function(data12) {
  if (data12.length < 2 || data12[0] !== 2) {
    throw new Error(`Invalid signature integer tag: ${bytesToHex4(data12)}`);
  }
  const len = data12[1];
  const res = data12.subarray(2, len + 2);
  if (!len || res.length !== len) {
    throw new Error(`Invalid signature integer: wrong length`);
  }
  if (res[0] === 0 && res[1] <= 127) {
    throw new Error("Invalid signature integer: trailing length");
  }
  return { data: bytesToNumber(res), left: data12.subarray(len + 2) };
};
var parseDERSignature = function(data12) {
  if (data12.length < 2 || data12[0] != 48) {
    throw new Error(`Invalid signature tag: ${bytesToHex4(data12)}`);
  }
  if (data12[1] !== data12.length - 2) {
    throw new Error("Invalid signature: incorrect length");
  }
  const { data: r, left: sBytes } = parseDERInt(data12.subarray(2));
  const { data: s, left: rBytesLeft } = parseDERInt(sBytes);
  if (rBytesLeft.length) {
    throw new Error(`Invalid signature: left bytes after parsing: ${bytesToHex4(rBytesLeft)}`);
  }
  return { r, s };
};
var concatBytes3 = function(...arrays) {
  if (!arrays.every((b) => b instanceof Uint8Array))
    throw new Error("Uint8Array list expected");
  if (arrays.length === 1)
    return arrays[0];
  const length = arrays.reduce((a, arr) => a + arr.length, 0);
  const result = new Uint8Array(length);
  for (let i = 0, pad = 0;i < arrays.length; i++) {
    const arr = arrays[i];
    result.set(arr, pad);
    pad += arr.length;
  }
  return result;
};
var bytesToHex4 = function(uint8a) {
  if (!(uint8a instanceof Uint8Array))
    throw new Error("Expected Uint8Array");
  let hex = "";
  for (let i = 0;i < uint8a.length; i++) {
    hex += hexes3[uint8a[i]];
  }
  return hex;
};
var numTo32bStr = function(num) {
  if (typeof num !== "bigint")
    throw new Error("Expected bigint");
  if (!(_0n8 <= num && num < POW_2_256))
    throw new Error("Expected number 0 <= n < 2^256");
  return num.toString(16).padStart(64, "0");
};
var numTo32b = function(num) {
  const b = hexToBytes3(numTo32bStr(num));
  if (b.length !== 32)
    throw new Error("Error: expected 32 bytes");
  return b;
};
var numberToHexUnpadded2 = function(num) {
  const hex = num.toString(16);
  return hex.length & 1 ? `0${hex}` : hex;
};
var hexToNumber4 = function(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToNumber: expected string, got " + typeof hex);
  }
  return BigInt(`0x${hex}`);
};
var hexToBytes3 = function(hex) {
  if (typeof hex !== "string") {
    throw new TypeError("hexToBytes: expected string, got " + typeof hex);
  }
  if (hex.length % 2)
    throw new Error("hexToBytes: received invalid unpadded hex" + hex.length);
  const array2 = new Uint8Array(hex.length / 2);
  for (let i = 0;i < array2.length; i++) {
    const j = i * 2;
    const hexByte = hex.slice(j, j + 2);
    const byte = Number.parseInt(hexByte, 16);
    if (Number.isNaN(byte) || byte < 0)
      throw new Error("Invalid byte sequence");
    array2[i] = byte;
  }
  return array2;
};
var bytesToNumber = function(bytes8) {
  return hexToNumber4(bytesToHex4(bytes8));
};
var ensureBytes2 = function(hex) {
  return hex instanceof Uint8Array ? Uint8Array.from(hex) : hexToBytes3(hex);
};
var normalizeScalar = function(num) {
  if (typeof num === "number" && Number.isSafeInteger(num) && num > 0)
    return BigInt(num);
  if (typeof num === "bigint" && isWithinCurveOrder(num))
    return num;
  throw new TypeError("Expected valid private scalar: 0 < scalar < curve.n");
};
var mod2 = function(a, b = CURVE.P) {
  const result = a % b;
  return result >= _0n8 ? result : b + result;
};
var pow22 = function(x, power) {
  const { P } = CURVE;
  let res = x;
  while (power-- > _0n8) {
    res *= res;
    res %= P;
  }
  return res;
};
var sqrtMod2 = function(x) {
  const { P } = CURVE;
  const _6n = BigInt(6);
  const _11n = BigInt(11);
  const _22n = BigInt(22);
  const _23n = BigInt(23);
  const _44n = BigInt(44);
  const _88n = BigInt(88);
  const b2 = x * x * x % P;
  const b3 = b2 * b2 * x % P;
  const b6 = pow22(b3, _3n3) * b3 % P;
  const b9 = pow22(b6, _3n3) * b3 % P;
  const b11 = pow22(b9, _2n7) * b2 % P;
  const b22 = pow22(b11, _11n) * b11 % P;
  const b44 = pow22(b22, _22n) * b22 % P;
  const b88 = pow22(b44, _44n) * b44 % P;
  const b176 = pow22(b88, _88n) * b88 % P;
  const b220 = pow22(b176, _44n) * b44 % P;
  const b223 = pow22(b220, _3n3) * b3 % P;
  const t1 = pow22(b223, _23n) * b22 % P;
  const t2 = pow22(t1, _6n) * b2 % P;
  const rt = pow22(t2, _2n7);
  const xc = rt * rt % P;
  if (xc !== x)
    throw new Error("Cannot find square root");
  return rt;
};
var invert2 = function(number9, modulo = CURVE.P) {
  if (number9 === _0n8 || modulo <= _0n8) {
    throw new Error(`invert: expected positive integers, got n=${number9} mod=${modulo}`);
  }
  let a = mod2(number9, modulo);
  let b = modulo;
  let x = _0n8, y = _1n8, u = _1n8, v = _0n8;
  while (a !== _0n8) {
    const q = b / a;
    const r = b % a;
    const m = x - u * q;
    const n = y - v * q;
    b = a, a = r, x = u, y = v, u = m, v = n;
  }
  const gcd = b;
  if (gcd !== _1n8)
    throw new Error("invert: does not exist");
  return mod2(x, modulo);
};
var invertBatch = function(nums, p = CURVE.P) {
  const scratch = new Array(nums.length);
  const lastMultiplied = nums.reduce((acc, num, i) => {
    if (num === _0n8)
      return acc;
    scratch[i] = acc;
    return mod2(acc * num, p);
  }, _1n8);
  const inverted = invert2(lastMultiplied, p);
  nums.reduceRight((acc, num, i) => {
    if (num === _0n8)
      return acc;
    scratch[i] = mod2(acc * scratch[i], p);
    return mod2(acc * num, p);
  }, inverted);
  return scratch;
};
var bits2int_2 = function(bytes8) {
  const delta = bytes8.length * 8 - groupLen * 8;
  const num = bytesToNumber(bytes8);
  return delta > 0 ? num >> BigInt(delta) : num;
};
var truncateHash = function(hash4, truncateOnly = false) {
  const h = bits2int_2(hash4);
  if (truncateOnly)
    return h;
  const { n } = CURVE;
  return h >= n ? h - n : h;
};
var isWithinCurveOrder = function(num) {
  return _0n8 < num && num < CURVE.n;
};
var isValidFieldElement = function(num) {
  return _0n8 < num && num < CURVE.P;
};
var kmdToSig = function(kBytes, m, d, lowS = true) {
  const { n } = CURVE;
  const k = truncateHash(kBytes, true);
  if (!isWithinCurveOrder(k))
    return;
  const kinv = invert2(k, n);
  const q = Point2.BASE.multiply(k);
  const r = mod2(q.x, n);
  if (r === _0n8)
    return;
  const s = mod2(kinv * mod2(m + d * r, n), n);
  if (s === _0n8)
    return;
  let sig = new Signature(r, s);
  let recovery = (q.x === sig.r ? 0 : 2) | Number(q.y & _1n8);
  if (lowS && sig.hasHighS()) {
    sig = sig.normalizeS();
    recovery ^= 1;
  }
  return { sig, recovery };
};
var normalizePrivateKey = function(key) {
  let num;
  if (typeof key === "bigint") {
    num = key;
  } else if (typeof key === "number" && Number.isSafeInteger(key) && key > 0) {
    num = BigInt(key);
  } else if (typeof key === "string") {
    if (key.length !== 2 * groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = hexToNumber4(key);
  } else if (key instanceof Uint8Array) {
    if (key.length !== groupLen)
      throw new Error("Expected 32 bytes of private key");
    num = bytesToNumber(key);
  } else {
    throw new TypeError("Expected valid private key");
  }
  if (!isWithinCurveOrder(num))
    throw new Error("Expected private key: 0 < key < n");
  return num;
};
var normalizePublicKey = function(publicKey) {
  if (publicKey instanceof Point2) {
    publicKey.assertValidity();
    return publicKey;
  } else {
    return Point2.fromHex(publicKey);
  }
};
var normalizeSignature = function(signature) {
  if (signature instanceof Signature) {
    signature.assertValidity();
    return signature;
  }
  try {
    return Signature.fromDER(signature);
  } catch (error) {
    return Signature.fromCompact(signature);
  }
};
function getPublicKey(privateKey, isCompressed = false) {
  return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
}
function recoverPublicKey(msgHash, signature, recovery, isCompressed = false) {
  return Point2.fromSignature(msgHash, signature, recovery).toRawBytes(isCompressed);
}
var isProbPub = function(item) {
  const arr = item instanceof Uint8Array;
  const str = typeof item === "string";
  const len = (arr || str) && item.length;
  if (arr)
    return len === compressedLen || len === uncompressedLen;
  if (str)
    return len === compressedLen * 2 || len === uncompressedLen * 2;
  if (item instanceof Point2)
    return true;
  return false;
};
function getSharedSecret(privateA, publicB, isCompressed = false) {
  if (isProbPub(privateA))
    throw new TypeError("getSharedSecret: first arg must be private key");
  if (!isProbPub(publicB))
    throw new TypeError("getSharedSecret: second arg must be public key");
  const b = normalizePublicKey(publicB);
  b.assertValidity();
  return b.multiply(normalizePrivateKey(privateA)).toRawBytes(isCompressed);
}
var bits2int = function(bytes8) {
  const slice = bytes8.length > fieldLen ? bytes8.slice(0, fieldLen) : bytes8;
  return bytesToNumber(slice);
};
var bits2octets = function(bytes8) {
  const z1 = bits2int(bytes8);
  const z2 = mod2(z1, CURVE.n);
  return int2octets(z2 < _0n8 ? z1 : z2);
};
var int2octets = function(num) {
  return numTo32b(num);
};
var initSigArgs = function(msgHash, privateKey, extraEntropy) {
  if (msgHash == null)
    throw new Error(`sign: expected valid message hash, not "${msgHash}"`);
  const h1 = ensureBytes2(msgHash);
  const d = normalizePrivateKey(privateKey);
  const seedArgs = [int2octets(d), bits2octets(h1)];
  if (extraEntropy != null) {
    if (extraEntropy === true)
      extraEntropy = utils77.randomBytes(fieldLen);
    const e = ensureBytes2(extraEntropy);
    if (e.length !== fieldLen)
      throw new Error(`sign: Expected ${fieldLen} bytes of extra data`);
    seedArgs.push(e);
  }
  const seed = concatBytes3(...seedArgs);
  const m = bits2int(h1);
  return { seed, m, d };
};
var finalizeSig = function(recSig, opts) {
  const { sig, recovery } = recSig;
  const { der, recovered } = Object.assign({ canonical: true, der: true }, opts);
  const hashed = der ? sig.toDERRawBytes() : sig.toCompactRawBytes();
  return recovered ? [hashed, recovery] : hashed;
};
var signSync = function(msgHash, privKey, opts = {}) {
  const { seed, m, d } = initSigArgs(msgHash, privKey, opts.extraEntropy);
  const drbg = new HmacDrbg(hashLen, groupLen);
  drbg.reseedSync(seed);
  let sig;
  while (!(sig = kmdToSig(drbg.generateSync(), m, d, opts.canonical)))
    drbg.reseedSync();
  return finalizeSig(sig, opts);
};
/*! noble-secp256k1 - MIT License (c) 2019 Paul Miller (paulmillr.com) */
var _0n8 = BigInt(0);
var _1n8 = BigInt(1);
var _2n7 = BigInt(2);
var _3n3 = BigInt(3);
var _8n2 = BigInt(8);
var CURVE = Object.freeze({
  a: _0n8,
  b: BigInt(7),
  P: BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f"),
  n: BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141"),
  h: _1n8,
  Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
  Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee")
});
var divNearest2 = (a, b) => (a + b / _2n7) / b;
var endo = {
  beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
  splitScalar(k) {
    const { n } = CURVE;
    const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
    const b1 = -_1n8 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
    const a2 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
    const b2 = a1;
    const POW_2_128 = BigInt("0x100000000000000000000000000000000");
    const c1 = divNearest2(b2 * k, n);
    const c2 = divNearest2(-b1 * k, n);
    let k1 = mod2(k - c1 * a1 - c2 * a2, n);
    let k2 = mod2(-c1 * b1 - c2 * b2, n);
    const k1neg = k1 > POW_2_128;
    const k2neg = k2 > POW_2_128;
    if (k1neg)
      k1 = n - k1;
    if (k2neg)
      k2 = n - k2;
    if (k1 > POW_2_128 || k2 > POW_2_128) {
      throw new Error("splitScalarEndo: Endomorphism failed, k=" + k);
    }
    return { k1neg, k1, k2neg, k2 };
  }
};
var fieldLen = 32;
var groupLen = 32;
var hashLen = 32;
var compressedLen = fieldLen + 1;
var uncompressedLen = 2 * fieldLen + 1;
var USE_ENDOMORPHISM = CURVE.a === _0n8;

class ShaError extends Error {
  constructor(message) {
    super(message);
  }
}

class JacobianPoint {
  constructor(x, y, z2) {
    this.x = x;
    this.y = y;
    this.z = z2;
  }
  static fromAffine(p) {
    if (!(p instanceof Point2)) {
      throw new TypeError("JacobianPoint#fromAffine: expected Point");
    }
    if (p.equals(Point2.ZERO))
      return JacobianPoint.ZERO;
    return new JacobianPoint(p.x, p.y, _1n8);
  }
  static toAffineBatch(points) {
    const toInv = invertBatch(points.map((p) => p.z));
    return points.map((p, i) => p.toAffine(toInv[i]));
  }
  static normalizeZ(points) {
    return JacobianPoint.toAffineBatch(points).map(JacobianPoint.fromAffine);
  }
  equals(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S12 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    return U1 === U2 && S12 === S2;
  }
  negate() {
    return new JacobianPoint(this.x, mod2(-this.y), this.z);
  }
  double() {
    const { x: X1, y: Y1, z: Z1 } = this;
    const A = mod2(X1 * X1);
    const B = mod2(Y1 * Y1);
    const C = mod2(B * B);
    const x1b = X1 + B;
    const D = mod2(_2n7 * (mod2(x1b * x1b) - A - C));
    const E = mod2(_3n3 * A);
    const F = mod2(E * E);
    const X3 = mod2(F - _2n7 * D);
    const Y3 = mod2(E * (D - X3) - _8n2 * C);
    const Z3 = mod2(_2n7 * Y1 * Z1);
    return new JacobianPoint(X3, Y3, Z3);
  }
  add(other) {
    assertJacPoint(other);
    const { x: X1, y: Y1, z: Z1 } = this;
    const { x: X2, y: Y2, z: Z2 } = other;
    if (X2 === _0n8 || Y2 === _0n8)
      return this;
    if (X1 === _0n8 || Y1 === _0n8)
      return other;
    const Z1Z1 = mod2(Z1 * Z1);
    const Z2Z2 = mod2(Z2 * Z2);
    const U1 = mod2(X1 * Z2Z2);
    const U2 = mod2(X2 * Z1Z1);
    const S12 = mod2(mod2(Y1 * Z2) * Z2Z2);
    const S2 = mod2(mod2(Y2 * Z1) * Z1Z1);
    const H = mod2(U2 - U1);
    const r = mod2(S2 - S12);
    if (H === _0n8) {
      if (r === _0n8) {
        return this.double();
      } else {
        return JacobianPoint.ZERO;
      }
    }
    const HH = mod2(H * H);
    const HHH = mod2(H * HH);
    const V = mod2(U1 * HH);
    const X3 = mod2(r * r - HHH - _2n7 * V);
    const Y3 = mod2(r * (V - X3) - S12 * HHH);
    const Z3 = mod2(Z1 * Z2 * H);
    return new JacobianPoint(X3, Y3, Z3);
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiplyUnsafe(scalar) {
    const P0 = JacobianPoint.ZERO;
    if (typeof scalar === "bigint" && scalar === _0n8)
      return P0;
    let n = normalizeScalar(scalar);
    if (n === _1n8)
      return this;
    if (!USE_ENDOMORPHISM) {
      let p = P0;
      let d2 = this;
      while (n > _0n8) {
        if (n & _1n8)
          p = p.add(d2);
        d2 = d2.double();
        n >>= _1n8;
      }
      return p;
    }
    let { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
    let k1p = P0;
    let k2p = P0;
    let d = this;
    while (k1 > _0n8 || k2 > _0n8) {
      if (k1 & _1n8)
        k1p = k1p.add(d);
      if (k2 & _1n8)
        k2p = k2p.add(d);
      d = d.double();
      k1 >>= _1n8;
      k2 >>= _1n8;
    }
    if (k1neg)
      k1p = k1p.negate();
    if (k2neg)
      k2p = k2p.negate();
    k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
    return k1p.add(k2p);
  }
  precomputeWindow(W) {
    const windows = USE_ENDOMORPHISM ? 128 / W + 1 : 256 / W + 1;
    const points = [];
    let p = this;
    let base3 = p;
    for (let window2 = 0;window2 < windows; window2++) {
      base3 = p;
      points.push(base3);
      for (let i = 1;i < 2 ** (W - 1); i++) {
        base3 = base3.add(p);
        points.push(base3);
      }
      p = base3.double();
    }
    return points;
  }
  wNAF(n, affinePoint) {
    if (!affinePoint && this.equals(JacobianPoint.BASE))
      affinePoint = Point2.BASE;
    const W = affinePoint && affinePoint._WINDOW_SIZE || 1;
    if (256 % W) {
      throw new Error("Point#wNAF: Invalid precomputation window, must be power of 2");
    }
    let precomputes = affinePoint && pointPrecomputes.get(affinePoint);
    if (!precomputes) {
      precomputes = this.precomputeWindow(W);
      if (affinePoint && W !== 1) {
        precomputes = JacobianPoint.normalizeZ(precomputes);
        pointPrecomputes.set(affinePoint, precomputes);
      }
    }
    let p = JacobianPoint.ZERO;
    let f2 = JacobianPoint.BASE;
    const windows = 1 + (USE_ENDOMORPHISM ? 128 / W : 256 / W);
    const windowSize = 2 ** (W - 1);
    const mask3 = BigInt(2 ** W - 1);
    const maxNumber = 2 ** W;
    const shiftBy = BigInt(W);
    for (let window2 = 0;window2 < windows; window2++) {
      const offset = window2 * windowSize;
      let wbits = Number(n & mask3);
      n >>= shiftBy;
      if (wbits > windowSize) {
        wbits -= maxNumber;
        n += _1n8;
      }
      const offset1 = offset;
      const offset2 = offset + Math.abs(wbits) - 1;
      const cond1 = window2 % 2 !== 0;
      const cond2 = wbits < 0;
      if (wbits === 0) {
        f2 = f2.add(constTimeNegate(cond1, precomputes[offset1]));
      } else {
        p = p.add(constTimeNegate(cond2, precomputes[offset2]));
      }
    }
    return { p, f: f2 };
  }
  multiply(scalar, affinePoint) {
    let n = normalizeScalar(scalar);
    let point;
    let fake;
    if (USE_ENDOMORPHISM) {
      const { k1neg, k1, k2neg, k2 } = endo.splitScalar(n);
      let { p: k1p, f: f1p } = this.wNAF(k1, affinePoint);
      let { p: k2p, f: f2p } = this.wNAF(k2, affinePoint);
      k1p = constTimeNegate(k1neg, k1p);
      k2p = constTimeNegate(k2neg, k2p);
      k2p = new JacobianPoint(mod2(k2p.x * endo.beta), k2p.y, k2p.z);
      point = k1p.add(k2p);
      fake = f1p.add(f2p);
    } else {
      const { p, f: f2 } = this.wNAF(n, affinePoint);
      point = p;
      fake = f2;
    }
    return JacobianPoint.normalizeZ([point, fake])[0];
  }
  toAffine(invZ) {
    const { x, y, z: z2 } = this;
    const is0 = this.equals(JacobianPoint.ZERO);
    if (invZ == null)
      invZ = is0 ? _8n2 : invert2(z2);
    const iz1 = invZ;
    const iz2 = mod2(iz1 * iz1);
    const iz3 = mod2(iz2 * iz1);
    const ax = mod2(x * iz2);
    const ay = mod2(y * iz3);
    const zz = mod2(z2 * iz1);
    if (is0)
      return Point2.ZERO;
    if (zz !== _1n8)
      throw new Error("invZ was invalid");
    return new Point2(ax, ay);
  }
}
JacobianPoint.BASE = new JacobianPoint(CURVE.Gx, CURVE.Gy, _1n8);
JacobianPoint.ZERO = new JacobianPoint(_0n8, _1n8, _0n8);
var pointPrecomputes = new WeakMap;

class Point2 {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  _setWindowSize(windowSize) {
    this._WINDOW_SIZE = windowSize;
    pointPrecomputes.delete(this);
  }
  hasEvenY() {
    return this.y % _2n7 === _0n8;
  }
  static fromCompressedHex(bytes8) {
    const isShort = bytes8.length === 32;
    const x = bytesToNumber(isShort ? bytes8 : bytes8.subarray(1));
    if (!isValidFieldElement(x))
      throw new Error("Point is not on curve");
    const y2 = weierstrass3(x);
    let y = sqrtMod2(y2);
    const isYOdd = (y & _1n8) === _1n8;
    if (isShort) {
      if (isYOdd)
        y = mod2(-y);
    } else {
      const isFirstByteOdd = (bytes8[0] & 1) === 1;
      if (isFirstByteOdd !== isYOdd)
        y = mod2(-y);
    }
    const point = new Point2(x, y);
    point.assertValidity();
    return point;
  }
  static fromUncompressedHex(bytes8) {
    const x = bytesToNumber(bytes8.subarray(1, fieldLen + 1));
    const y = bytesToNumber(bytes8.subarray(fieldLen + 1, fieldLen * 2 + 1));
    const point = new Point2(x, y);
    point.assertValidity();
    return point;
  }
  static fromHex(hex) {
    const bytes8 = ensureBytes2(hex);
    const len = bytes8.length;
    const header = bytes8[0];
    if (len === fieldLen)
      return this.fromCompressedHex(bytes8);
    if (len === compressedLen && (header === 2 || header === 3)) {
      return this.fromCompressedHex(bytes8);
    }
    if (len === uncompressedLen && header === 4)
      return this.fromUncompressedHex(bytes8);
    throw new Error(`Point.fromHex: received invalid point. Expected 32-${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes, not ${len}`);
  }
  static fromPrivateKey(privateKey) {
    return Point2.BASE.multiply(normalizePrivateKey(privateKey));
  }
  static fromSignature(msgHash, signature, recovery) {
    const { r, s } = normalizeSignature(signature);
    if (![0, 1, 2, 3].includes(recovery))
      throw new Error("Cannot recover: invalid recovery bit");
    const h = truncateHash(ensureBytes2(msgHash));
    const { n } = CURVE;
    const radj = recovery === 2 || recovery === 3 ? r + n : r;
    const rinv = invert2(radj, n);
    const u1 = mod2(-h * rinv, n);
    const u2 = mod2(s * rinv, n);
    const prefix = recovery & 1 ? "03" : "02";
    const R = Point2.fromHex(prefix + numTo32bStr(radj));
    const Q = Point2.BASE.multiplyAndAddUnsafe(R, u1, u2);
    if (!Q)
      throw new Error("Cannot recover signature: point at infinify");
    Q.assertValidity();
    return Q;
  }
  toRawBytes(isCompressed = false) {
    return hexToBytes3(this.toHex(isCompressed));
  }
  toHex(isCompressed = false) {
    const x = numTo32bStr(this.x);
    if (isCompressed) {
      const prefix = this.hasEvenY() ? "02" : "03";
      return `${prefix}${x}`;
    } else {
      return `04${x}${numTo32bStr(this.y)}`;
    }
  }
  toHexX() {
    return this.toHex(true).slice(2);
  }
  toRawX() {
    return this.toRawBytes(true).slice(1);
  }
  assertValidity() {
    const msg = "Point is not on elliptic curve";
    const { x, y } = this;
    if (!isValidFieldElement(x) || !isValidFieldElement(y))
      throw new Error(msg);
    const left = mod2(y * y);
    const right = weierstrass3(x);
    if (mod2(left - right) !== _0n8)
      throw new Error(msg);
  }
  equals(other) {
    return this.x === other.x && this.y === other.y;
  }
  negate() {
    return new Point2(this.x, mod2(-this.y));
  }
  double() {
    return JacobianPoint.fromAffine(this).double().toAffine();
  }
  add(other) {
    return JacobianPoint.fromAffine(this).add(JacobianPoint.fromAffine(other)).toAffine();
  }
  subtract(other) {
    return this.add(other.negate());
  }
  multiply(scalar) {
    return JacobianPoint.fromAffine(this).multiply(scalar, this).toAffine();
  }
  multiplyAndAddUnsafe(Q, a, b) {
    const P = JacobianPoint.fromAffine(this);
    const aP = a === _0n8 || a === _1n8 || this !== Point2.BASE ? P.multiplyUnsafe(a) : P.multiply(a);
    const bQ = JacobianPoint.fromAffine(Q).multiplyUnsafe(b);
    const sum = aP.add(bQ);
    return sum.equals(JacobianPoint.ZERO) ? undefined : sum.toAffine();
  }
}
Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy);
Point2.ZERO = new Point2(_0n8, _0n8);

class Signature {
  constructor(r, s) {
    this.r = r;
    this.s = s;
    this.assertValidity();
  }
  static fromCompact(hex) {
    const arr = hex instanceof Uint8Array;
    const name = "Signature.fromCompact";
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`${name}: Expected string or Uint8Array`);
    const str = arr ? bytesToHex4(hex) : hex;
    if (str.length !== 128)
      throw new Error(`${name}: Expected 64-byte hex`);
    return new Signature(hexToNumber4(str.slice(0, 64)), hexToNumber4(str.slice(64, 128)));
  }
  static fromDER(hex) {
    const arr = hex instanceof Uint8Array;
    if (typeof hex !== "string" && !arr)
      throw new TypeError(`Signature.fromDER: Expected string or Uint8Array`);
    const { r, s } = parseDERSignature(arr ? hex : hexToBytes3(hex));
    return new Signature(r, s);
  }
  static fromHex(hex) {
    return this.fromDER(hex);
  }
  assertValidity() {
    const { r, s } = this;
    if (!isWithinCurveOrder(r))
      throw new Error("Invalid Signature: r must be 0 < r < n");
    if (!isWithinCurveOrder(s))
      throw new Error("Invalid Signature: s must be 0 < s < n");
  }
  hasHighS() {
    const HALF = CURVE.n >> _1n8;
    return this.s > HALF;
  }
  normalizeS() {
    return this.hasHighS() ? new Signature(this.r, mod2(-this.s, CURVE.n)) : this;
  }
  toDERRawBytes() {
    return hexToBytes3(this.toDERHex());
  }
  toDERHex() {
    const sHex = sliceDER(numberToHexUnpadded2(this.s));
    const rHex = sliceDER(numberToHexUnpadded2(this.r));
    const sHexL = sHex.length / 2;
    const rHexL = rHex.length / 2;
    const sLen = numberToHexUnpadded2(sHexL);
    const rLen = numberToHexUnpadded2(rHexL);
    const length = numberToHexUnpadded2(rHexL + sHexL + 4);
    return `30${length}02${rLen}${rHex}02${sLen}${sHex}`;
  }
  toRawBytes() {
    return this.toDERRawBytes();
  }
  toHex() {
    return this.toDERHex();
  }
  toCompactRawBytes() {
    return hexToBytes3(this.toCompactHex());
  }
  toCompactHex() {
    return numTo32bStr(this.r) + numTo32bStr(this.s);
  }
}
var hexes3 = Array.from({ length: 256 }, (v, i) => i.toString(16).padStart(2, "0"));
var POW_2_256 = BigInt("0x10000000000000000000000000000000000000000000000000000000000000000");
var _sha256Sync;
var _hmacSha256Sync;

class HmacDrbg {
  constructor(hashLen2, qByteLen) {
    this.hashLen = hashLen2;
    this.qByteLen = qByteLen;
    if (typeof hashLen2 !== "number" || hashLen2 < 2)
      throw new Error("hashLen must be a number");
    if (typeof qByteLen !== "number" || qByteLen < 2)
      throw new Error("qByteLen must be a number");
    this.v = new Uint8Array(hashLen2).fill(1);
    this.k = new Uint8Array(hashLen2).fill(0);
    this.counter = 0;
  }
  hmac(...values) {
    return utils77.hmacSha256(this.k, ...values);
  }
  hmacSync(...values) {
    return _hmacSha256Sync(this.k, ...values);
  }
  checkSync() {
    if (typeof _hmacSha256Sync !== "function")
      throw new ShaError("hmacSha256Sync needs to be set");
  }
  incr() {
    if (this.counter >= 1000)
      throw new Error("Tried 1,000 k values for sign(), all were invalid");
    this.counter += 1;
  }
  async reseed(seed = new Uint8Array) {
    this.k = await this.hmac(this.v, Uint8Array.from([0]), seed);
    this.v = await this.hmac(this.v);
    if (seed.length === 0)
      return;
    this.k = await this.hmac(this.v, Uint8Array.from([1]), seed);
    this.v = await this.hmac(this.v);
  }
  reseedSync(seed = new Uint8Array) {
    this.checkSync();
    this.k = this.hmacSync(this.v, Uint8Array.from([0]), seed);
    this.v = this.hmacSync(this.v);
    if (seed.length === 0)
      return;
    this.k = this.hmacSync(this.v, Uint8Array.from([1]), seed);
    this.v = this.hmacSync(this.v);
  }
  async generate() {
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = await this.hmac(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes3(...out);
  }
  generateSync() {
    this.checkSync();
    this.incr();
    let len = 0;
    const out = [];
    while (len < this.qByteLen) {
      this.v = this.hmacSync(this.v);
      const sl = this.v.slice();
      out.push(sl);
      len += this.v.length;
    }
    return concatBytes3(...out);
  }
}
Point2.BASE._setWindowSize(8);
var crypto12 = {
  node: nodeCrypto,
  web: typeof self === "object" && "crypto" in self ? self.crypto : undefined
};
var TAGGED_HASH_PREFIXES = {};
var utils77 = {
  bytesToHex: bytesToHex4,
  hexToBytes: hexToBytes3,
  concatBytes: concatBytes3,
  mod: mod2,
  invert: invert2,
  isValidPrivateKey(privateKey) {
    try {
      normalizePrivateKey(privateKey);
      return true;
    } catch (error) {
      return false;
    }
  },
  _bigintTo32Bytes: numTo32b,
  _normalizePrivateKey: normalizePrivateKey,
  hashToPrivateKey: (hash4) => {
    hash4 = ensureBytes2(hash4);
    const minLen = groupLen + 8;
    if (hash4.length < minLen || hash4.length > 1024) {
      throw new Error(`Expected valid bytes of private key as per FIPS 186`);
    }
    const num = mod2(bytesToNumber(hash4), CURVE.n - _1n8) + _1n8;
    return numTo32b(num);
  },
  randomBytes: (bytesLength = 32) => {
    if (crypto12.web) {
      return crypto12.web.getRandomValues(new Uint8Array(bytesLength));
    } else if (crypto12.node) {
      const { randomBytes: randomBytes5 } = crypto12.node;
      return Uint8Array.from(randomBytes5(bytesLength));
    } else {
      throw new Error("The environment doesn't have randomBytes function");
    }
  },
  randomPrivateKey: () => utils77.hashToPrivateKey(utils77.randomBytes(groupLen + 8)),
  precompute(windowSize = 8, point = Point2.BASE) {
    const cached = point === Point2.BASE ? point : new Point2(point.x, point.y);
    cached._setWindowSize(windowSize);
    cached.multiply(_3n3);
    return cached;
  },
  sha256: async (...messages) => {
    if (crypto12.web) {
      const buffer = await crypto12.web.subtle.digest("SHA-256", concatBytes3(...messages));
      return new Uint8Array(buffer);
    } else if (crypto12.node) {
      const { createHash: createHash2 } = crypto12.node;
      const hash4 = createHash2("sha256");
      messages.forEach((m) => hash4.update(m));
      return Uint8Array.from(hash4.digest());
    } else {
      throw new Error("The environment doesn't have sha256 function");
    }
  },
  hmacSha256: async (key, ...messages) => {
    if (crypto12.web) {
      const ckey = await crypto12.web.subtle.importKey("raw", key, { name: "HMAC", hash: { name: "SHA-256" } }, false, ["sign"]);
      const message = concatBytes3(...messages);
      const buffer = await crypto12.web.subtle.sign("HMAC", ckey, message);
      return new Uint8Array(buffer);
    } else if (crypto12.node) {
      const { createHmac: createHmac2 } = crypto12.node;
      const hash4 = createHmac2("sha256", key);
      messages.forEach((m) => hash4.update(m));
      return Uint8Array.from(hash4.digest());
    } else {
      throw new Error("The environment doesn't have hmac-sha256 function");
    }
  },
  sha256Sync: undefined,
  hmacSha256Sync: undefined,
  taggedHash: async (tag, ...messages) => {
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
      const tagH = await utils77.sha256(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return utils77.sha256(tagP, ...messages);
  },
  taggedHashSync: (tag, ...messages) => {
    if (typeof _sha256Sync !== "function")
      throw new ShaError("sha256Sync is undefined, you need to set it");
    let tagP = TAGGED_HASH_PREFIXES[tag];
    if (tagP === undefined) {
      const tagH = _sha256Sync(Uint8Array.from(tag, (c) => c.charCodeAt(0)));
      tagP = concatBytes3(tagH, tagH);
      TAGGED_HASH_PREFIXES[tag] = tagP;
    }
    return _sha256Sync(tagP, ...messages);
  },
  _JacobianPoint: JacobianPoint
};
Object.defineProperties(utils77, {
  sha256Sync: {
    configurable: false,
    get() {
      return _sha256Sync;
    },
    set(val) {
      if (!_sha256Sync)
        _sha256Sync = val;
    }
  },
  hmacSha256Sync: {
    configurable: false,
    get() {
      return _hmacSha256Sync;
    },
    set(val) {
      if (!_hmacSha256Sync)
        _hmacSha256Sync = val;
    }
  }
});

// ../../node_modules/ethers/lib.esm/constants/addresses.js
var ZeroAddress = "0x0000000000000000000000000000000000000000";
// ../../node_modules/ethers/lib.esm/constants/hashes.js
var ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
// ../../node_modules/ethers/lib.esm/constants/numbers.js
var N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var WeiPerEther = BigInt("1000000000000000000");
var MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
var MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
// ../../node_modules/ethers/lib.esm/constants/strings.js
var EtherSymbol = "\u039E";
var MessagePrefix = `\x19Ethereum Signed Message:
`;
// ../../node_modules/ethers/lib.esm/crypto/signature.js
var toUint256 = function(value) {
  return zeroPadValue(toBeArray(value), 32);
};
var BN_04 = BigInt(0);
var BN_13 = BigInt(1);
var BN_2 = BigInt(2);
var BN_27 = BigInt(27);
var BN_28 = BigInt(28);
var BN_35 = BigInt(35);
var _guard3 = {};

class Signature2 {
  #r;
  #s;
  #v;
  #networkV;
  get r() {
    return this.#r;
  }
  set r(value) {
    assertArgument(dataLength(value) === 32, "invalid r", "value", value);
    this.#r = hexlify(value);
  }
  get s() {
    return this.#s;
  }
  set s(_value) {
    assertArgument(dataLength(_value) === 32, "invalid s", "value", _value);
    const value = hexlify(_value);
    assertArgument(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
    this.#s = value;
  }
  get v() {
    return this.#v;
  }
  set v(value) {
    const v = getNumber(value, "value");
    assertArgument(v === 27 || v === 28, "invalid v", "v", value);
    this.#v = v;
  }
  get networkV() {
    return this.#networkV;
  }
  get legacyChainId() {
    const v = this.networkV;
    if (v == null) {
      return null;
    }
    return Signature2.getChainId(v);
  }
  get yParity() {
    return this.v === 27 ? 0 : 1;
  }
  get yParityAndS() {
    const yParityAndS = getBytes(this.s);
    if (this.yParity) {
      yParityAndS[0] |= 128;
    }
    return hexlify(yParityAndS);
  }
  get compactSerialized() {
    return concat([this.r, this.yParityAndS]);
  }
  get serialized() {
    return concat([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
  }
  constructor(guard, r, s, v) {
    assertPrivate(guard, _guard3, "Signature");
    this.#r = r;
    this.#s = s;
    this.#v = v;
    this.#networkV = null;
  }
  [Symbol.for("nodejs.util.inspect.custom")]() {
    return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
  }
  clone() {
    const clone = new Signature2(_guard3, this.r, this.s, this.v);
    if (this.networkV) {
      clone.#networkV = this.networkV;
    }
    return clone;
  }
  toJSON() {
    const networkV = this.networkV;
    return {
      _type: "signature",
      networkV: networkV != null ? networkV.toString() : null,
      r: this.r,
      s: this.s,
      v: this.v
    };
  }
  static getChainId(v) {
    const bv = getBigInt(v, "v");
    if (bv == BN_27 || bv == BN_28) {
      return BN_04;
    }
    assertArgument(bv >= BN_35, "invalid EIP-155 v", "v", v);
    return (bv - BN_35) / BN_2;
  }
  static getChainIdV(chainId, v) {
    return getBigInt(chainId) * BN_2 + BigInt(35 + v - 27);
  }
  static getNormalizedV(v) {
    const bv = getBigInt(v);
    if (bv === BN_04 || bv === BN_27) {
      return 27;
    }
    if (bv === BN_13 || bv === BN_28) {
      return 28;
    }
    assertArgument(bv >= BN_35, "invalid v", "v", v);
    return bv & BN_13 ? 27 : 28;
  }
  static from(sig) {
    function assertError(check, message) {
      assertArgument(check, message, "signature", sig);
    }
    if (sig == null) {
      return new Signature2(_guard3, ZeroHash, ZeroHash, 27);
    }
    if (typeof sig === "string") {
      const bytes8 = getBytes(sig, "signature");
      if (bytes8.length === 64) {
        const r2 = hexlify(bytes8.slice(0, 32));
        const s2 = bytes8.slice(32, 64);
        const v2 = s2[0] & 128 ? 28 : 27;
        s2[0] &= 127;
        return new Signature2(_guard3, r2, hexlify(s2), v2);
      }
      if (bytes8.length === 65) {
        const r2 = hexlify(bytes8.slice(0, 32));
        const s2 = bytes8.slice(32, 64);
        assertError((s2[0] & 128) === 0, "non-canonical s");
        const v2 = Signature2.getNormalizedV(bytes8[64]);
        return new Signature2(_guard3, r2, hexlify(s2), v2);
      }
      assertError(false, "invalid raw signature length");
    }
    if (sig instanceof Signature2) {
      return sig.clone();
    }
    const _r = sig.r;
    assertError(_r != null, "missing r");
    const r = toUint256(_r);
    const s = function(s2, yParityAndS) {
      if (s2 != null) {
        return toUint256(s2);
      }
      if (yParityAndS != null) {
        assertError(isHexString2(yParityAndS, 32), "invalid yParityAndS");
        const bytes8 = getBytes(yParityAndS);
        bytes8[0] &= 127;
        return hexlify(bytes8);
      }
      assertError(false, "missing s");
    }(sig.s, sig.yParityAndS);
    assertError((getBytes(s)[0] & 128) == 0, "non-canonical s");
    const { networkV, v } = function(_v, yParityAndS, yParity) {
      if (_v != null) {
        const v2 = getBigInt(_v);
        return {
          networkV: v2 >= BN_35 ? v2 : undefined,
          v: Signature2.getNormalizedV(v2)
        };
      }
      if (yParityAndS != null) {
        assertError(isHexString2(yParityAndS, 32), "invalid yParityAndS");
        return { v: getBytes(yParityAndS)[0] & 128 ? 28 : 27 };
      }
      if (yParity != null) {
        switch (getNumber(yParity, "sig.yParity")) {
          case 0:
            return { v: 27 };
          case 1:
            return { v: 28 };
        }
        assertError(false, "invalid yParity");
      }
      assertError(false, "missing v");
    }(sig.v, sig.yParityAndS, sig.yParity);
    const result = new Signature2(_guard3, r, s, v);
    if (networkV) {
      result.#networkV = networkV;
    }
    assertError(sig.yParity == null || getNumber(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
    assertError(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
    return result;
  }
}

// ../../node_modules/ethers/lib.esm/crypto/signing-key.js
utils77.hmacSha256Sync = function(key, ...messages) {
  return getBytes(computeHmac("sha256", key, concat(messages)));
};

class SigningKey {
  #privateKey;
  constructor(privateKey) {
    assertArgument(dataLength(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
    this.#privateKey = hexlify(privateKey);
  }
  get privateKey() {
    return this.#privateKey;
  }
  get publicKey() {
    return SigningKey.computePublicKey(this.#privateKey);
  }
  get compressedPublicKey() {
    return SigningKey.computePublicKey(this.#privateKey, true);
  }
  sign(digest) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const [sigDer, recid] = signSync(getBytesCopy(digest), getBytesCopy(this.#privateKey), {
      recovered: true,
      canonical: true
    });
    const sig = Signature.fromHex(sigDer);
    return Signature2.from({
      r: toBeHex("0x" + sig.r.toString(16), 32),
      s: toBeHex("0x" + sig.s.toString(16), 32),
      v: recid ? 28 : 27
    });
  }
  computeSharedSecret(other) {
    const pubKey = SigningKey.computePublicKey(other);
    return hexlify(getSharedSecret(getBytesCopy(this.#privateKey), getBytes(pubKey)));
  }
  static computePublicKey(key, compressed) {
    let bytes8 = getBytes(key, "key");
    if (bytes8.length === 32) {
      const pubKey = getPublicKey(bytes8, !!compressed);
      return hexlify(pubKey);
    }
    if (bytes8.length === 64) {
      const pub = new Uint8Array(65);
      pub[0] = 4;
      pub.set(bytes8, 1);
      bytes8 = pub;
    }
    const point = Point2.fromHex(bytes8);
    return hexlify(point.toRawBytes(compressed));
  }
  static recoverPublicKey(digest, signature2) {
    assertArgument(dataLength(digest) === 32, "invalid digest length", "digest", digest);
    const sig = Signature2.from(signature2);
    const der = Signature.fromCompact(getBytesCopy(concat([sig.r, sig.s]))).toDERRawBytes();
    const pubKey = recoverPublicKey(getBytesCopy(digest), der, sig.yParity);
    assertArgument(pubKey != null, "invalid signautre for digest", "signature", signature2);
    return hexlify(pubKey);
  }
  static addPoints(p0, p1, compressed) {
    const pub0 = Point2.fromHex(SigningKey.computePublicKey(p0).substring(2));
    const pub1 = Point2.fromHex(SigningKey.computePublicKey(p1).substring(2));
    return "0x" + pub0.add(pub1).toHex(!!compressed);
  }
}

// ../../node_modules/ethers/lib.esm/crypto/index.js
var lock = function() {
  computeHmac.lock();
  keccak2562.lock();
  pbkdf25.lock();
  randomBytes4.lock();
  ripemd1603.lock();
  scrypt6.lock();
  scryptSync2.lock();
  sha2567.lock();
  sha5123.lock();
  randomBytes4.lock();
};

// ../../node_modules/ethers/lib.esm/address/address.js
var getChecksumAddress = function(address7) {
  address7 = address7.toLowerCase();
  const chars = address7.substring(2).split("");
  const expanded = new Uint8Array(40);
  for (let i = 0;i < 40; i++) {
    expanded[i] = chars[i].charCodeAt(0);
  }
  const hashed = getBytes(keccak2562(expanded));
  for (let i = 0;i < 40; i += 2) {
    if (hashed[i >> 1] >> 4 >= 8) {
      chars[i] = chars[i].toUpperCase();
    }
    if ((hashed[i >> 1] & 15) >= 8) {
      chars[i + 1] = chars[i + 1].toUpperCase();
    }
  }
  return "0x" + chars.join("");
};
var ibanChecksum = function(address7) {
  address7 = address7.toUpperCase();
  address7 = address7.substring(4) + address7.substring(0, 2) + "00";
  let expanded = address7.split("").map((c) => {
    return ibanLookup[c];
  }).join("");
  while (expanded.length >= safeDigits) {
    let block4 = expanded.substring(0, safeDigits);
    expanded = parseInt(block4, 10) % 97 + expanded.substring(block4.length);
  }
  let checksum = String(98 - parseInt(expanded, 10) % 97);
  while (checksum.length < 2) {
    checksum = "0" + checksum;
  }
  return checksum;
};
var fromBase36 = function(value) {
  value = value.toLowerCase();
  let result = BN_05;
  for (let i = 0;i < value.length; i++) {
    result = result * BN_36 + Base36[value[i]];
  }
  return result;
};
function getAddress(address7) {
  assertArgument(typeof address7 === "string", "invalid address", "address", address7);
  if (address7.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
    if (!address7.startsWith("0x")) {
      address7 = "0x" + address7;
    }
    const result = getChecksumAddress(address7);
    assertArgument(!address7.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address7, "bad address checksum", "address", address7);
    return result;
  }
  if (address7.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
    assertArgument(address7.substring(2, 4) === ibanChecksum(address7), "bad icap checksum", "address", address7);
    let result = fromBase36(address7.substring(4)).toString(16);
    while (result.length < 40) {
      result = "0" + result;
    }
    return getChecksumAddress("0x" + result);
  }
  assertArgument(false, "invalid address", "address", address7);
}
function getIcapAddress(address7) {
  let base36 = BigInt(getAddress(address7)).toString(36).toUpperCase();
  while (base36.length < 30) {
    base36 = "0" + base36;
  }
  return "XE" + ibanChecksum("XE00" + base36) + base36;
}
var BN_05 = BigInt(0);
var BN_36 = BigInt(36);
var ibanLookup = {};
for (let i = 0;i < 10; i++) {
  ibanLookup[String(i)] = String(i);
}
for (let i = 0;i < 26; i++) {
  ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
var safeDigits = 15;
var Base36 = function() {
  const result = {};
  for (let i = 0;i < 36; i++) {
    const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i];
    result[key] = BigInt(i);
  }
  return result;
}();
// ../../node_modules/ethers/lib.esm/address/contract-address.js
function getCreateAddress(tx2) {
  const from = getAddress(tx2.from);
  const nonce = getBigInt(tx2.nonce, "tx.nonce");
  let nonceHex = nonce.toString(16);
  if (nonceHex === "0") {
    nonceHex = "0x";
  } else if (nonceHex.length % 2) {
    nonceHex = "0x0" + nonceHex;
  } else {
    nonceHex = "0x" + nonceHex;
  }
  return getAddress(dataSlice(keccak2562(encodeRlp([from, nonceHex])), 12));
}
function getCreate2Address(_from, _salt, _initCodeHash) {
  const from = getAddress(_from);
  const salt = getBytes(_salt, "salt");
  const initCodeHash = getBytes(_initCodeHash, "initCodeHash");
  assertArgument(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
  assertArgument(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
  return getAddress(dataSlice(keccak2562(concat(["0xff", from, salt, initCodeHash])), 12));
}
// ../../node_modules/ethers/lib.esm/address/checks.js
function isAddressable(value) {
  return value && typeof value.getAddress === "function";
}
function isAddress3(value) {
  try {
    getAddress(value);
    return true;
  } catch (error) {
  }
  return false;
}
async function checkAddress(target, promise) {
  const result = await promise;
  if (result == null || result === "0x0000000000000000000000000000000000000000") {
    assert2(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
    assertArgument(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
  }
  return getAddress(result);
}
function resolveAddress(target, resolver2) {
  if (typeof target === "string") {
    if (target.match(/^0x[0-9a-f]{40}$/i)) {
      return getAddress(target);
    }
    assert2(resolver2 != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
    return checkAddress(target, resolver2.resolveName(target));
  } else if (isAddressable(target)) {
    return checkAddress(target, target.getAddress());
  } else if (target && typeof target.then === "function") {
    return checkAddress(target, target);
  }
  assertArgument(false, "unsupported addressable value", "target", target);
}
// ../../node_modules/ethers/lib.esm/abi/typed.js
var n = function(value, width) {
  let signed2 = false;
  if (width < 0) {
    signed2 = true;
    width *= -1;
  }
  return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
};
var b = function(value, size) {
  return new Typed(_gaurd, `bytes${size ? size : ""}`, value, { size });
};
var _gaurd = {};
var _typedSymbol = Symbol.for("_ethers_typed");

class Typed {
  type;
  value;
  #options;
  _typedSymbol;
  constructor(gaurd, type, value, options) {
    if (options == null) {
      options = null;
    }
    assertPrivate(_gaurd, gaurd, "Typed");
    defineProperties(this, { _typedSymbol, type, value });
    this.#options = options;
    this.format();
  }
  format() {
    if (this.type === "array") {
      throw new Error("");
    } else if (this.type === "dynamicArray") {
      throw new Error("");
    } else if (this.type === "tuple") {
      return `tuple(${this.value.map((v) => v.format()).join(",")})`;
    }
    return this.type;
  }
  defaultValue() {
    return 0;
  }
  minValue() {
    return 0;
  }
  maxValue() {
    return 0;
  }
  isBigInt() {
    return !!this.type.match(/^u?int[0-9]+$/);
  }
  isData() {
    return this.type.startsWith("bytes");
  }
  isString() {
    return this.type === "string";
  }
  get tupleName() {
    if (this.type !== "tuple") {
      throw TypeError("not a tuple");
    }
    return this.#options;
  }
  get arrayLength() {
    if (this.type !== "array") {
      throw TypeError("not an array");
    }
    if (this.#options === true) {
      return -1;
    }
    if (this.#options === false) {
      return this.value.length;
    }
    return null;
  }
  static from(type, value) {
    return new Typed(_gaurd, type, value);
  }
  static uint8(v) {
    return n(v, 8);
  }
  static uint16(v) {
    return n(v, 16);
  }
  static uint24(v) {
    return n(v, 24);
  }
  static uint32(v) {
    return n(v, 32);
  }
  static uint40(v) {
    return n(v, 40);
  }
  static uint48(v) {
    return n(v, 48);
  }
  static uint56(v) {
    return n(v, 56);
  }
  static uint64(v) {
    return n(v, 64);
  }
  static uint72(v) {
    return n(v, 72);
  }
  static uint80(v) {
    return n(v, 80);
  }
  static uint88(v) {
    return n(v, 88);
  }
  static uint96(v) {
    return n(v, 96);
  }
  static uint104(v) {
    return n(v, 104);
  }
  static uint112(v) {
    return n(v, 112);
  }
  static uint120(v) {
    return n(v, 120);
  }
  static uint128(v) {
    return n(v, 128);
  }
  static uint136(v) {
    return n(v, 136);
  }
  static uint144(v) {
    return n(v, 144);
  }
  static uint152(v) {
    return n(v, 152);
  }
  static uint160(v) {
    return n(v, 160);
  }
  static uint168(v) {
    return n(v, 168);
  }
  static uint176(v) {
    return n(v, 176);
  }
  static uint184(v) {
    return n(v, 184);
  }
  static uint192(v) {
    return n(v, 192);
  }
  static uint200(v) {
    return n(v, 200);
  }
  static uint208(v) {
    return n(v, 208);
  }
  static uint216(v) {
    return n(v, 216);
  }
  static uint224(v) {
    return n(v, 224);
  }
  static uint232(v) {
    return n(v, 232);
  }
  static uint240(v) {
    return n(v, 240);
  }
  static uint248(v) {
    return n(v, 248);
  }
  static uint256(v) {
    return n(v, 256);
  }
  static uint(v) {
    return n(v, 256);
  }
  static int8(v) {
    return n(v, -8);
  }
  static int16(v) {
    return n(v, -16);
  }
  static int24(v) {
    return n(v, -24);
  }
  static int32(v) {
    return n(v, -32);
  }
  static int40(v) {
    return n(v, -40);
  }
  static int48(v) {
    return n(v, -48);
  }
  static int56(v) {
    return n(v, -56);
  }
  static int64(v) {
    return n(v, -64);
  }
  static int72(v) {
    return n(v, -72);
  }
  static int80(v) {
    return n(v, -80);
  }
  static int88(v) {
    return n(v, -88);
  }
  static int96(v) {
    return n(v, -96);
  }
  static int104(v) {
    return n(v, -104);
  }
  static int112(v) {
    return n(v, -112);
  }
  static int120(v) {
    return n(v, -120);
  }
  static int128(v) {
    return n(v, -128);
  }
  static int136(v) {
    return n(v, -136);
  }
  static int144(v) {
    return n(v, -144);
  }
  static int152(v) {
    return n(v, -152);
  }
  static int160(v) {
    return n(v, -160);
  }
  static int168(v) {
    return n(v, -168);
  }
  static int176(v) {
    return n(v, -176);
  }
  static int184(v) {
    return n(v, -184);
  }
  static int192(v) {
    return n(v, -192);
  }
  static int200(v) {
    return n(v, -200);
  }
  static int208(v) {
    return n(v, -208);
  }
  static int216(v) {
    return n(v, -216);
  }
  static int224(v) {
    return n(v, -224);
  }
  static int232(v) {
    return n(v, -232);
  }
  static int240(v) {
    return n(v, -240);
  }
  static int248(v) {
    return n(v, -248);
  }
  static int256(v) {
    return n(v, -256);
  }
  static int(v) {
    return n(v, -256);
  }
  static bytes1(v) {
    return b(v, 1);
  }
  static bytes2(v) {
    return b(v, 2);
  }
  static bytes3(v) {
    return b(v, 3);
  }
  static bytes4(v) {
    return b(v, 4);
  }
  static bytes5(v) {
    return b(v, 5);
  }
  static bytes6(v) {
    return b(v, 6);
  }
  static bytes7(v) {
    return b(v, 7);
  }
  static bytes8(v) {
    return b(v, 8);
  }
  static bytes9(v) {
    return b(v, 9);
  }
  static bytes10(v) {
    return b(v, 10);
  }
  static bytes11(v) {
    return b(v, 11);
  }
  static bytes12(v) {
    return b(v, 12);
  }
  static bytes13(v) {
    return b(v, 13);
  }
  static bytes14(v) {
    return b(v, 14);
  }
  static bytes15(v) {
    return b(v, 15);
  }
  static bytes16(v) {
    return b(v, 16);
  }
  static bytes17(v) {
    return b(v, 17);
  }
  static bytes18(v) {
    return b(v, 18);
  }
  static bytes19(v) {
    return b(v, 19);
  }
  static bytes20(v) {
    return b(v, 20);
  }
  static bytes21(v) {
    return b(v, 21);
  }
  static bytes22(v) {
    return b(v, 22);
  }
  static bytes23(v) {
    return b(v, 23);
  }
  static bytes24(v) {
    return b(v, 24);
  }
  static bytes25(v) {
    return b(v, 25);
  }
  static bytes26(v) {
    return b(v, 26);
  }
  static bytes27(v) {
    return b(v, 27);
  }
  static bytes28(v) {
    return b(v, 28);
  }
  static bytes29(v) {
    return b(v, 29);
  }
  static bytes30(v) {
    return b(v, 30);
  }
  static bytes31(v) {
    return b(v, 31);
  }
  static bytes32(v) {
    return b(v, 32);
  }
  static address(v) {
    return new Typed(_gaurd, "address", v);
  }
  static bool(v) {
    return new Typed(_gaurd, "bool", !!v);
  }
  static bytes(v) {
    return new Typed(_gaurd, "bytes", v);
  }
  static string(v) {
    return new Typed(_gaurd, "string", v);
  }
  static array(v, dynamic) {
    throw new Error("not implemented yet");
    return new Typed(_gaurd, "array", v, dynamic);
  }
  static tuple(v, name) {
    throw new Error("not implemented yet");
    return new Typed(_gaurd, "tuple", v, name);
  }
  static overrides(v) {
    return new Typed(_gaurd, "overrides", Object.assign({}, v));
  }
  static isTyped(value) {
    return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
  }
  static dereference(value, type) {
    if (Typed.isTyped(value)) {
      if (value.type !== type) {
        throw new Error(`invalid type: expecetd ${type}, got ${value.type}`);
      }
      return value.value;
    }
    return value;
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/address.js
class AddressCoder extends Coder {
  constructor(localName) {
    super("address", "address", localName, false);
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000";
  }
  encode(writer, _value) {
    let value = Typed.dereference(_value, "string");
    try {
      value = getAddress(value);
    } catch (error) {
      return this._throwError(error.message, _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    return getAddress(toBeHex(reader.readValue(), 20));
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/anonymous.js
class AnonymousCoder extends Coder {
  coder;
  constructor(coder) {
    super(coder.name, coder.type, "_", coder.dynamic);
    this.coder = coder;
  }
  defaultValue() {
    return this.coder.defaultValue();
  }
  encode(writer, value) {
    return this.coder.encode(writer, value);
  }
  decode(reader) {
    return this.coder.decode(reader);
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/array.js
function pack(writer, coders, values) {
  let arrayValues = [];
  if (Array.isArray(values)) {
    arrayValues = values;
  } else if (values && typeof values === "object") {
    let unique = {};
    arrayValues = coders.map((coder) => {
      const name = coder.localName;
      assert2(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      assert2(!unique[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
      unique[name] = true;
      return values[name];
    });
  } else {
    assertArgument(false, "invalid tuple value", "tuple", values);
  }
  assertArgument(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
  let staticWriter = new Writer;
  let dynamicWriter = new Writer;
  let updateFuncs = [];
  coders.forEach((coder, index) => {
    let value = arrayValues[index];
    if (coder.dynamic) {
      let dynamicOffset = dynamicWriter.length;
      coder.encode(dynamicWriter, value);
      let updateFunc = staticWriter.writeUpdatableValue();
      updateFuncs.push((baseOffset) => {
        updateFunc(baseOffset + dynamicOffset);
      });
    } else {
      coder.encode(staticWriter, value);
    }
  });
  updateFuncs.forEach((func) => {
    func(staticWriter.length);
  });
  let length = writer.appendWriter(staticWriter);
  length += writer.appendWriter(dynamicWriter);
  return length;
}
function unpack(reader, coders) {
  let values = [];
  let keys = [];
  let baseReader = reader.subReader(0);
  coders.forEach((coder) => {
    let value = null;
    if (coder.dynamic) {
      let offset = reader.readIndex();
      let offsetReader = baseReader.subReader(offset);
      try {
        value = coder.decode(offsetReader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    } else {
      try {
        value = coder.decode(reader);
      } catch (error) {
        if (isError(error, "BUFFER_OVERRUN")) {
          throw error;
        }
        value = error;
        value.baseType = coder.name;
        value.name = coder.localName;
        value.type = coder.type;
      }
    }
    if (value == undefined) {
      throw new Error("investigate");
    }
    values.push(value);
    keys.push(coder.localName || null);
  });
  return Result.fromItems(values, keys);
}

class ArrayCoder extends Coder {
  coder;
  length;
  constructor(coder, length, localName) {
    const type = coder.type + "[" + (length >= 0 ? length : "") + "]";
    const dynamic = length === -1 || coder.dynamic;
    super("array", type, localName, dynamic);
    defineProperties(this, { coder, length });
  }
  defaultValue() {
    const defaultChild = this.coder.defaultValue();
    const result = [];
    for (let i = 0;i < this.length; i++) {
      result.push(defaultChild);
    }
    return result;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "array");
    if (!Array.isArray(value)) {
      this._throwError("expected array value", value);
    }
    let count = this.length;
    if (count === -1) {
      count = value.length;
      writer.writeValue(value.length);
    }
    assertArgumentCount(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
    let coders = [];
    for (let i = 0;i < value.length; i++) {
      coders.push(this.coder);
    }
    return pack(writer, coders, value);
  }
  decode(reader) {
    let count = this.length;
    if (count === -1) {
      count = reader.readIndex();
      assert2(count * WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * WordSize, length: reader.dataLength });
    }
    let coders = [];
    for (let i = 0;i < count; i++) {
      coders.push(new AnonymousCoder(this.coder));
    }
    return unpack(reader, coders);
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/boolean.js
class BooleanCoder extends Coder {
  constructor(localName) {
    super("bool", "bool", localName, false);
  }
  defaultValue() {
    return false;
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "bool");
    return writer.writeValue(value ? 1 : 0);
  }
  decode(reader) {
    return !!reader.readValue();
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/bytes.js
class DynamicBytesCoder extends Coder {
  constructor(type, localName) {
    super(type, type, localName, true);
  }
  defaultValue() {
    return "0x";
  }
  encode(writer, value) {
    value = getBytesCopy(value);
    let length = writer.writeValue(value.length);
    length += writer.writeBytes(value);
    return length;
  }
  decode(reader) {
    return reader.readBytes(reader.readIndex(), true);
  }
}

class BytesCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("bytes", localName);
  }
  decode(reader) {
    return hexlify(super.decode(reader));
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/fixed-bytes.js
class FixedBytesCoder extends Coder {
  size;
  constructor(size, localName) {
    let name = "bytes" + String(size);
    super(name, name, localName, false);
    defineProperties(this, { size }, { size: "number" });
  }
  defaultValue() {
    return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
  }
  encode(writer, _value) {
    let data12 = getBytesCopy(Typed.dereference(_value, this.type));
    if (data12.length !== this.size) {
      this._throwError("incorrect data length", _value);
    }
    return writer.writeBytes(data12);
  }
  decode(reader) {
    return hexlify(reader.readBytes(this.size));
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/null.js
var Empty = new Uint8Array([]);

class NullCoder extends Coder {
  constructor(localName) {
    super("null", "", localName, false);
  }
  defaultValue() {
    return null;
  }
  encode(writer, value) {
    if (value != null) {
      this._throwError("not null", value);
    }
    return writer.writeBytes(Empty);
  }
  decode(reader) {
    reader.readBytes(0);
    return null;
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/number.js
var BN_06 = BigInt(0);
var BN_14 = BigInt(1);
var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

class NumberCoder extends Coder {
  size;
  signed;
  constructor(size, signed2, localName) {
    const name = (signed2 ? "int" : "uint") + size * 8;
    super(name, name, localName, false);
    defineProperties(this, { size, signed: signed2 }, { size: "number", signed: "boolean" });
  }
  defaultValue() {
    return 0;
  }
  encode(writer, _value) {
    let value = getBigInt(Typed.dereference(_value, this.type));
    let maxUintValue = mask2(BN_MAX_UINT256, WordSize * 8);
    if (this.signed) {
      let bounds = mask2(maxUintValue, this.size * 8 - 1);
      if (value > bounds || value < -(bounds + BN_14)) {
        this._throwError("value out-of-bounds", _value);
      }
      value = toTwos(value, 8 * WordSize);
    } else if (value < BN_06 || value > mask2(maxUintValue, this.size * 8)) {
      this._throwError("value out-of-bounds", _value);
    }
    return writer.writeValue(value);
  }
  decode(reader) {
    let value = mask2(reader.readValue(), this.size * 8);
    if (this.signed) {
      value = fromTwos(value, this.size * 8);
    }
    return value;
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/string.js
class StringCoder extends DynamicBytesCoder {
  constructor(localName) {
    super("string", localName);
  }
  defaultValue() {
    return "";
  }
  encode(writer, _value) {
    return super.encode(writer, toUtf8Bytes(Typed.dereference(_value, "string")));
  }
  decode(reader) {
    return toUtf8String(super.decode(reader));
  }
}

// ../../node_modules/ethers/lib.esm/abi/coders/tuple.js
class TupleCoder extends Coder {
  coders;
  constructor(coders, localName) {
    let dynamic = false;
    const types15 = [];
    coders.forEach((coder) => {
      if (coder.dynamic) {
        dynamic = true;
      }
      types15.push(coder.type);
    });
    const type = "tuple(" + types15.join(",") + ")";
    super("tuple", type, localName, dynamic);
    defineProperties(this, { coders: Object.freeze(coders.slice()) });
  }
  defaultValue() {
    const values = [];
    this.coders.forEach((coder) => {
      values.push(coder.defaultValue());
    });
    const uniqueNames = this.coders.reduce((accum, coder) => {
      const name = coder.localName;
      if (name) {
        if (!accum[name]) {
          accum[name] = 0;
        }
        accum[name]++;
      }
      return accum;
    }, {});
    this.coders.forEach((coder, index) => {
      let name = coder.localName;
      if (!name || uniqueNames[name] !== 1) {
        return;
      }
      if (name === "length") {
        name = "_length";
      }
      if (values[name] != null) {
        return;
      }
      values[name] = values[index];
    });
    return Object.freeze(values);
  }
  encode(writer, _value) {
    const value = Typed.dereference(_value, "tuple");
    return pack(writer, this.coders, value);
  }
  decode(reader) {
    return unpack(reader, this.coders);
  }
}

// ../../node_modules/ethers/lib.esm/hash/id.js
function id(value) {
  return keccak2562(toUtf8Bytes(value));
}
// ../../node_modules/@adraffy/ens-normalize/dist/index.mjs
var decode_arithmetic2 = function(bytes9) {
  let pos = 0;
  function u16() {
    return bytes9[pos++] << 8 | bytes9[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i = 1;i < symbol_count; i++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes9[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i = 0;i < N2; i++)
    register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0)
      break;
    symbols.push(start);
    let a = low + Math.floor(range * acc[start] / total);
    let b2 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a ^ b2) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a = a << 1 & MASK;
      b2 = b2 << 1 & MASK | 1;
    }
    while (a & ~b2 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a = a << 1 ^ HALF;
      b2 = (b2 ^ HALF) << 1 | HALF | 1;
    }
    low = a;
    range = 1 + b2 - a;
  }
  let offset = symbol_count - 4;
  return symbols.map((x) => {
    switch (x - offset) {
      case 3:
        return offset + 65792 + (bytes9[pos_payload++] << 16 | bytes9[pos_payload++] << 8 | bytes9[pos_payload++]);
      case 2:
        return offset + 256 + (bytes9[pos_payload++] << 8 | bytes9[pos_payload++]);
      case 1:
        return offset + bytes9[pos_payload++];
      default:
        return x - 1;
    }
  });
};
var read_payload2 = function(v) {
  let pos = 0;
  return () => v[pos++];
};
var read_compressed_payload2 = function(s) {
  return read_payload2(decode_arithmetic2(unsafe_atob2(s)));
};
var unsafe_atob2 = function(s) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c, i) => lookup[c.charCodeAt(0)] = i);
  let n2 = s.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i = 0, pos = 0, width = 0, carry = 0;i < n2; i++) {
    carry = carry << 6 | lookup[s.charCodeAt(i)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
};
var signed2 = function(i) {
  return i & 1 ? ~i >> 1 : i >> 1;
};
var read_deltas2 = function(n2, next) {
  let v = Array(n2);
  for (let i = 0, x = 0;i < n2; i++)
    v[i] = x += signed2(next());
  return v;
};
var read_sorted2 = function(next, prev = 0) {
  let ret = [];
  while (true) {
    let x = next();
    let n2 = next();
    if (!n2)
      break;
    prev += x;
    for (let i = 0;i < n2; i++) {
      ret.push(prev + i);
    }
    prev += n2 + 1;
  }
  return ret;
};
var read_sorted_arrays2 = function(next) {
  return read_array_while2(() => {
    let v = read_sorted2(next);
    if (v.length)
      return v;
  });
};
var read_mapped2 = function(next) {
  let ret = [];
  while (true) {
    let w = next();
    if (w == 0)
      break;
    ret.push(read_linear_table2(w, next));
  }
  while (true) {
    let w = next() - 1;
    if (w < 0)
      break;
    ret.push(read_replacement_table2(w, next));
  }
  return ret.flat();
};
var read_array_while2 = function(next) {
  let v = [];
  while (true) {
    let x = next(v.length);
    if (!x)
      break;
    v.push(x);
  }
  return v;
};
var read_transposed2 = function(n2, w, next) {
  let m = Array(n2).fill().map(() => []);
  for (let i = 0;i < w; i++) {
    read_deltas2(n2, next).forEach((x, j) => m[j].push(x));
  }
  return m;
};
var read_linear_table2 = function(w, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while2(next);
  let m = read_transposed2(vN.length, 1 + w, next);
  return m.flatMap((v, i) => {
    let [x, ...ys] = v;
    return Array(vN[i]).fill().map((_, j) => {
      let j_dy = j * dy;
      return [x + j * dx, ys.map((y) => y + j_dy)];
    });
  });
};
var read_replacement_table2 = function(w, next) {
  let n2 = 1 + next();
  let m = read_transposed2(n2, 1 + w, next);
  return m.map((v) => [v[0], v.slice(1)]);
};
var hex_cp2 = function(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
};
var quote_cp2 = function(cp) {
  return `{${hex_cp2(cp)}}`;
};
var explode_cp2 = function(s) {
  let cps = [];
  for (let pos = 0, len = s.length;pos < len; ) {
    let cp = s.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
};
var str_from_cps2 = function(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk)
    return String.fromCodePoint(...cps);
  let buf = [];
  for (let i = 0;i < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i, i += chunk)));
  }
  return buf.join("");
};
var unpack_cc2 = function(packed) {
  return packed >> 24 & 255;
};
var unpack_cp2 = function(packed) {
  return packed & 16777215;
};
var is_hangul2 = function(cp) {
  return cp >= S02 && cp < S12;
};
var compose_pair2 = function(a, b2) {
  if (a >= L02 && a < L12 && b2 >= V02 && b2 < V12) {
    return S02 + (a - L02) * N_COUNT2 + (b2 - V02) * T_COUNT2;
  } else if (is_hangul2(a) && b2 > T02 && b2 < T12 && (a - S02) % T_COUNT2 == 0) {
    return a + (b2 - T02);
  } else {
    let recomp = RECOMP2.get(a);
    if (recomp) {
      recomp = recomp.get(b2);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
};
var decomposed2 = function(cps) {
  let ret = [];
  let buf = [];
  let check_order = false;
  function add3(cp) {
    let cc = SHIFTED_RANK2.get(cp);
    if (cc) {
      check_order = true;
      cp |= cc;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul2(cp)) {
        let s_index = cp - S02;
        let l_index = s_index / N_COUNT2 | 0;
        let v_index = s_index % N_COUNT2 / T_COUNT2 | 0;
        let t_index = s_index % T_COUNT2;
        add3(L02 + l_index);
        add3(V02 + v_index);
        if (t_index > 0)
          add3(T02 + t_index);
      } else {
        let mapped = DECOMP2.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add3(cp);
        }
      }
      if (!buf.length)
        break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc2(ret[0]);
    for (let i = 1;i < ret.length; i++) {
      let cc = unpack_cc2(ret[i]);
      if (cc == 0 || prev_cc <= cc) {
        prev_cc = cc;
        continue;
      }
      let j = i - 1;
      while (true) {
        let tmp = ret[j + 1];
        ret[j + 1] = ret[j];
        ret[j] = tmp;
        if (!j)
          break;
        prev_cc = unpack_cc2(ret[--j]);
        if (prev_cc <= cc)
          break;
      }
      prev_cc = unpack_cc2(ret[i]);
    }
  }
  return ret;
};
var composed_from_decomposed2 = function(v) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v) {
    let cc = unpack_cc2(packed);
    let cp = unpack_cp2(packed);
    if (prev_cp == -1) {
      if (cc == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc) {
      if (cc == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc;
    } else {
      let composed = compose_pair2(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
};
var nfd2 = function(cps) {
  return decomposed2(cps).map(unpack_cp2);
};
var nfc2 = function(cps) {
  return composed_from_decomposed2(decomposed2(cps));
};
var read_set = function() {
  return new Set(read_sorted2(r$1));
};
var read_chunked = function() {
  return new Set([read_sorted2(r$1).map((i) => CHUNKS[i]), read_sorted2(r$1)].flat(2));
};
var read_emoji_trie = function(cps) {
  let B = read_array_while2(() => {
    let keys = read_sorted2(r$1).map((i) => EMOJI_SORTED[i]);
    if (keys.length)
      return read_emoji_trie(keys);
  }).sort((a, b2) => b2.Q.size - a.Q.size);
  let temp = r$1();
  let V = temp % 3;
  temp = temp / 3 | 0;
  let F = temp & 1;
  temp >>= 1;
  let S = temp & 1;
  let C = temp & 2;
  return { B, V, F, S, C, Q: new Set(cps) };
};
var safe_str_from_cps2 = function(cps, quoter = quote_cp2) {
  let buf = [];
  if (is_combining_mark2(cps[0]))
    buf.push("\u25CC");
  let prev = 0;
  let n2 = cps.length;
  for (let i = 0;i < n2; i++) {
    let cp = cps[i];
    if (should_escape2(cp)) {
      buf.push(str_from_cps2(cps.slice(prev, i)));
      buf.push(quoter(cp));
      prev = i + 1;
    }
  }
  buf.push(str_from_cps2(cps.slice(prev, n2)));
  return buf.join("");
};
var quoted_cp2 = function(cp) {
  return (should_escape2(cp) ? "" : `${bidi_qq2(safe_str_from_cps2([cp]))} `) + quote_cp2(cp);
};
var bidi_qq2 = function(s) {
  return `"${s}"\u200E`;
};
var check_label_extension2 = function(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN2 && cps[3] == HYPHEN2) {
    throw new Error("invalid label extension");
  }
};
var check_leading_underscore2 = function(cps) {
  const UNDERSCORE = 95;
  for (let i = cps.lastIndexOf(UNDERSCORE);i > 0; ) {
    if (cps[--i] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
};
var check_fenced2 = function(cps) {
  let cp = cps[0];
  let prev = FENCED2.get(cp);
  if (prev)
    throw error_placement2(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i = 1;i < n2; i++) {
    cp = cps[i];
    let match = FENCED2.get(cp);
    if (match) {
      if (last == i)
        throw error_placement2(`${prev} + ${match}`);
      last = i + 1;
      prev = match;
    }
  }
  if (last == n2)
    throw error_placement2(`trailing ${prev}`);
};
var is_combining_mark2 = function(cp) {
  return CM2.has(cp);
};
var should_escape2 = function(cp) {
  return ESCAPE2.has(cp);
};
var ens_normalize3 = function(name) {
  return flatten2(ens_split(name));
};
var ens_split = function(name, preserve_emoji) {
  let offset = 0;
  return name.split(STOP_CH2).map((label) => {
    let input = explode_cp2(label);
    let info = {
      input,
      offset
    };
    offset += input.length + 1;
    let norm;
    try {
      let tokens = info.tokens = process2(input, nfc2);
      let token_count = tokens.length;
      let type;
      if (!token_count) {
        throw new Error(`empty label`);
      } else {
        let chars = tokens[0];
        let emoji = token_count > 1 || chars.is_emoji;
        if (!emoji && chars.every((cp) => cp < 128)) {
          norm = chars;
          check_leading_underscore2(norm);
          check_label_extension2(norm);
          type = "ASCII";
        } else {
          if (emoji) {
            info.emoji = true;
            chars = tokens.flatMap((x) => x.is_emoji ? [] : x);
          }
          norm = tokens.flatMap((x) => !preserve_emoji && x.is_emoji ? filter_fe0f2(x) : x);
          check_leading_underscore2(norm);
          if (!chars.length) {
            type = "Emoji";
          } else {
            if (CM2.has(norm[0]))
              throw error_placement2("leading combining mark");
            for (let i = 1;i < token_count; i++) {
              let cps = tokens[i];
              if (!cps.is_emoji && CM2.has(cps[0])) {
                throw error_placement2(`emoji + combining mark: "${str_from_cps2(tokens[i - 1])} + ${safe_str_from_cps2([cps[0]])}"`);
              }
            }
            check_fenced2(norm);
            let unique = [...new Set(chars)];
            let [g] = determine_group2(unique);
            check_group2(g, chars);
            check_whole2(g, unique);
            type = g.N;
          }
        }
      }
      info.type = type;
    } catch (err) {
      info.error = err;
    }
    info.output = norm;
    return info;
  });
};
var check_whole2 = function(group, unique) {
  let maker;
  let shared = [];
  for (let cp of unique) {
    let whole = WHOLE_MAP2.get(cp);
    if (whole === UNIQUE_PH2)
      return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g) => set.has(g)) : [...set];
      if (!maker.length)
        return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g of maker) {
      if (shared.every((cp) => g.V.has(cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g.N}`);
      }
    }
  }
};
var determine_group2 = function(unique) {
  let groups = GROUPS2;
  for (let cp of unique) {
    let gs = groups.filter((g) => g.V.has(cp));
    if (!gs.length) {
      if (groups === GROUPS2) {
        throw error_disallowed2(cp);
      } else {
        throw error_group_member2(groups[0], cp);
      }
    }
    groups = gs;
    if (gs.length == 1)
      break;
  }
  return groups;
};
var flatten2 = function(split4) {
  return split4.map(({ input, error, output: output3 }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split4.length == 1 ? msg : `Invalid label ${bidi_qq2(safe_str_from_cps2(input))}: ${msg}`);
    }
    return str_from_cps2(output3);
  }).join(STOP_CH2);
};
var error_disallowed2 = function(cp) {
  return new Error(`disallowed character: ${quoted_cp2(cp)}`);
};
var error_group_member2 = function(g, cp) {
  let quoted = quoted_cp2(cp);
  let gg = GROUPS2.find((g2) => g2.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g.N} + ${quoted}`);
};
var error_placement2 = function(where) {
  return new Error(`illegal placement: ${where}`);
};
var check_group2 = function(g, cps) {
  let { V, M } = g;
  for (let cp of cps) {
    if (!V.has(cp)) {
      throw error_group_member2(g, cp);
    }
  }
  if (M) {
    let decomposed3 = nfd2(cps);
    for (let i = 1, e = decomposed3.length;i < e; i++) {
      if (NSM2.has(decomposed3[i])) {
        let j = i + 1;
        for (let cp;j < e && NSM2.has(cp = decomposed3[j]); j++) {
          for (let k = i;k < j; k++) {
            if (decomposed3[k] == cp) {
              throw new Error(`non-spacing marks: repeated ${quoted_cp2(cp)}`);
            }
          }
        }
        if (j - i > NSM_MAX2) {
          throw new Error(`non-spacing marks: too many ${bidi_qq2(safe_str_from_cps2(decomposed3.slice(i - 1, j)))} (${j - i}/${NSM_MAX2})`);
        }
        i = j;
      }
    }
  }
};
var process2 = function(input, nf) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed2(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(emoji);
    } else {
      let cp = input.pop();
      if (VALID2.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED2.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED2.has(cp)) {
          throw error_disallowed2(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
};
var filter_fe0f2 = function(cps) {
  return cps.filter((cp) => cp != FE0F2);
};
var consume_emoji_reversed2 = function(cps, eaten) {
  let node = EMOJI_ROOT2;
  let emoji;
  let saved;
  let stack = [];
  let pos = cps.length;
  if (eaten)
    eaten.length = 0;
  while (pos) {
    let cp = cps[--pos];
    node = node.B.find((x) => x.Q.has(cp));
    if (!node)
      break;
    if (node.S) {
      saved = cp;
    } else if (node.C) {
      if (cp === saved)
        break;
    }
    stack.push(cp);
    if (node.F) {
      stack.push(FE0F2);
      if (pos > 0 && cps[pos - 1] == FE0F2)
        pos--;
    }
    if (node.V) {
      emoji = conform_emoji_copy(stack, node);
      if (eaten)
        eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
};
var conform_emoji_copy = function(cps, node) {
  let copy = Emoji2.from(cps);
  if (node.V == 2)
    copy.splice(1, 1);
  return copy;
};
var r$1 = read_compressed_payload2("AEgSbwjEDVYByQKaAQsBOQDpATQAngDUAHsAoABoANQAagCNAEQAhABMAHIAOwA9ACsANgAmAGIAHgAvACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGAAeABMAFwAXAA0ADgAWAA8AFAAVBFsF1QEXE0o3xAXUALIArkABaACmAgPGAK6AMDAwMAE/qAYK7P4HQAblMgVYBVkAPSw5Afa3EgfJwgAPA8meNALGCjACjqIChtk/j2+KAsXMAoPzASDgCgDyrgFCAi6OCkCQAOQA4woWABjVuskNDD6eBBx4AP4COhi+D+wKBirqBgSCaA0cBy4ArABqku+mnIAAXAaUJAbqABwAPAyUFvyp/Mo8INAIvCoDshQ8APcubKQAon4ZABgEJtgXAR4AuhnOBPsKIE04CZgJiR8cVlpM5INDABQADQAWAA9sVQAiAA8ASO8W2T30OVnKluYvChEeX05ZPe0AFAANABYAD2wgXUCYAMPsABwAOgzGFryp/AHauQVcBeMC0KACxLEKTR2kZhR0Gm5M9gC8DmgC4gAMLjSKF8qSAoF8ARMcAL4OaALiAAwuAUlQJpJMCwMt/AUpCthqGK4B2EQAciwSeAIyFiIDKCi6OGwAOuIB9iYAyA7MtgEcZIIAsgYABgCK1EoFHNZsGACoKNIBogAAAAAAKy4DnABoAQoaPu43dQQZGACrAcgCIgDgLBJ0OvRQsTOiKDVJBfsoBVoFWbC5BWo7XkITO1hCmHuUZmCh+QwUA8YIJvJ4JASkTAJUVAJ2HKwoAZCkpjZcA0YYBIRiCgDSBqxAMCQHKgI6XgBsAWIgcgCEHhoAlgFKuAAoahgBsMYDOC4iRFQBcFoGZgJmAPJKGAMqAgYASkIArABeAHQALLYGCPTwGo6AAAAKIgAqALQcSAHSAdwIDDKXeYHpAAsAEgA1AD4AOTR3etTBEGAQXQJNCkxtOxUMAq0PpwvmERYM0irM09kANKoH7ANUB+wDVANUB+wH7ANUB+wDVANUA1QDVBwL8BvUwRBgD0kEbgWPBYwE1wiEJkoRggcpCNNUDnQfHEgDRgD9IyZJHTuUMwwlQ0wNTQQH/TZDbKh9OQNIMaxU9pCjA8wyUDltAh5yEqEAKw90HTW2Tn96SHGhCkxPr7WASWNOaAK/Oqk/+QoiCZRvvHdPBj4QGCeiEPQMMAGyATgN6kvVBO4GOATGH3oZFg/KlZkIoi3aDOom4C6egFcj8iqABepL8TzaC0pRZQ9WC2IJ4DpggUsDHgEKIogK2g02CGoQ8ArGaA3iEUIHNgPSSZcAogb+Cw4dMhWyJg1iqQsGOXQG+BrzC4wmrBMmevkF0BoeBkoBJhr8AMwu5IWtWi5cGU9cBgALIiPEFKVQHQ0iQLR4RRoYBxIlpgKOQ21KhFEzHpAh8zw6DWMuEFF5B/I8AhlMC348m0aoRQsRzz6KPUUiRkwpBDJ8LCwniAnMD4IMtnxvAVYJHgmuDG4TLhEUN8IINgcWKpchJxIIHkaSYJcE9JwD8BPOAwgFPAk+BxADshwqEysVJgUKgSHUAvA20i6wAoxWfQEUBcgPIh/cEE1H3Q7mCJgCYgOAJegAKhUeABQimAhAYABcj9VTAi7ICMRqaSNxA2QU5F4RcAeODlQHpBwwFbwc3nDFXgiGBSigrAlYAXIJlgFcBOAIBjVYjJ0gPmdQi1UYmCBeQTxd+QIuDGIVnES6h3UCiA9oEhgBMgFwBzYM/gJ0EeoRaBCSCOiGATWyM/U6IgRMIYAgDgokA0xsywskJvYM9WYBoBJfAwk0OnfrZ6hgsyEX+gcWMsJBXSHuC49PygyZGr4YP1QrGeEHvAPwGvAn50FUBfwDoAAQOkoz6wS6C2YIiAk8AEYOoBQH1BhnCm6MzQEuiAG0lgNUjoACbIwGNAcIAGQIhAV24gAaAqQIoAACAMwDVAA2AqoHmgAWAII+AToDJCwBHuICjAOQCC7IAZIsAfAmBBjADBIA9DRuRwLDrgKAZ2afBdpVAosCRjIBSiIEAktETgOsbt4A2ABIBhDcRAESqEfIF+BAAdxsKADEAPgAAjIHAj4BygHwagC0AVwLLgmfsLIBSuYmAIAAEmgB1AKGANoAMgB87gFQAEoFVvYF0AJMRgEOLhUoVF4BuAMcATABCgB2BsiKosYEHARqB9ACEBgV3gLvKweyAyLcE8pCwgK921IAMhMKNQqkCqNgWF0wAy5vPU0ACx+lPsQ/SwVOO1A7VTtQO1U7UDtVO1A7VTtQO1UDlLzfvN8KaV9CYegMow3RRMU6RhPYYE5gLxPFLbQUvhXLJVMZOhq5JwIl4VUGDwEt0GYtCCk0che5ADwpZYM+Y4MeLQpIHORTjlT1LRgArkufM6wNqRsSRD0FRHXqYicWCwofAmR+AmI/WEqsWDcdAqH0AmiVAmYGAp+BOBgIAmY4AmYjBGsEfAN/EAN+jzkDOXQUOX86ICACbBoCMjM4BwJtxAJtq+yHMGRCKAFkANsA3gBHAgeVDIoA+wi/AAqyAncsAnafPAJ5SEACeLcaWdhFq0bwAnw8AnrFAn0GAnztR/1IemAhACgSSVVKWBIUSskC0P4C0MlLJAOITAOH40TCkS8C8p5dAAMDq0vLTCoiAMxNSU2sAos8AorVvhgEGkBkArQCjjQCjlk9lH4CjtYCjll1UbFTMgdS0VSCApP4ApMJAOYAGVUbVaxVzQMsGCmSgzLeeGNFODYCl5wC769YHqUAViIClowClnmZAKZZqVoGfkoAOAKWsgKWS1xBXM4CmcgCmWFcx10EFgKcmDm/OpoCnBMCn5gCnrWHABoMLicMAp3uAp6PALI6YTFh7AKe0AKgawGmAp6cHAKeS6JjxWQkIigCJ6wCJnsCoPgCoEnUAqYsAqXLAqf8AHoCp+9oeWiuAABGahlqzgKs4AKsqwKtZAKs/wJXGgJV2QKx3tQDH0tslAKyugoCsuUUbN1tYG1FXAMlygK2WTg8bo0DKUICuFsCuUQSArkndHAzcN4CvRYDLa8DMg4CvoVx/wMzbgK+F3Mfc0wCw8gCwwFzf3RIMkJ03QM8pAM8lwM9vALFeQLGRALGDYYCyGZOAshBAslMAskrAmSaAt3PeHZeeKt5IkvNAxigZv8CYfEZ8JUhewhej164DgLPaALPaSxIUM/wEJwAw6oCz3ABJucDTg9+SAIC3CQC24cC0kwDUlkDU1wA/gNViYCGPMgT6l1CcoLLg4oC2sQC2duEDYRGpzkDhqIALANkC4ZuVvYAUgLfYgLetXB0AuIs7REB8y0kAfSYAfLPhALr8ALpbXYC6vYC6uEA9kQBtgLuhgLrmZanlwAC7jwDhd2YdnDdcZ4C8wAAZgOOE5mQAvcQA5FrA5KEAveVAvnWAvhjmhmaqLg0mxsDnYAC/vcBGAA2nxmfsAMFigOmZwOm1gDOwgMGZ6GFogIGAwxGAQwBHAdqBl62ZAIAuARovA6IHrAKABRyNgAgAzASSgOGfAFgJB4AjOwAHgDmoAScjgi0BhygwgCoBRK86h4+PxZ5BWk4P0EsQiJCtV9yEl+9AJbGBTMAkE0am7o7J2AzErrQDjAYxxiKyfcFWAVZBVgFWQVkBVkFWAVZBVgFWQVYBVkFWAVZRxYI2IZoAwMDCmVe6iwEygOyBjC8vAC8BKi8AOhBKhazBUc+aj5xQkBCt192OF/pAFgSM6wAjP/MbMv9puhGez4nJAUsFyg3Nn5u32vB8hnDLGoBbNdvMRgFYAVrycLJuQjQSlwBAQEKfV5+jL8AND+CAAQW0gbmriQGAIzEDAMCDgDlZh4+JSBLQrJCvUI5JF8oYDcoOSQJwj4KRT9EPnk+gj5xPnICikK9SkM8X8xPUGtOCy1sVTBrDG8gX+E0OxwJaJwKYyQsPR4nQqxCvSzMAsv9X8oPIC8KCQoAACN+nt9rOy5LGMmsya0JZsLMzQphQWAP5hCkEgCTjh5GQiYbqm06zjkKND9EPnFCQBwICx5NSG1cLS5a4rwTCn7uHixCQBxeCUsKDzRVREM4BTtEnC0KghwuQkAb9glUIyQZMTIBBo9i8F8KcmTKYAxgLiRvAERgGjoDHB9gtAcDbBFmT2BOEgIAZOhgFmCWYH5gtGBMYJJpFhgGtg/cVqq8WwtDF6wBvCzOwgMgFgEdBB8BegJtMDGWU4EBiwq5SBsA5SR0jwvLDqdN6wGcAoidUAVBYAD4AD4LATUXWHsMpg0lILuwSABQDTUAFhO4NVUC0wxLZhEcANlPBnYECx9bADIAtwKbKAsWcKwzOaAaAVwBhwn9A9ruEAarBksGugAey1aqWwq7YhOKCy1ADrwBvAEjA0hbKSkpIR8gIi0TJwciDY4AVQJvWJFKlgJvIA9ySAHUdRDPUiEaqrFN6wcSBU1gAPgAPgsBewAHJW0LiAymOTEuyLBXDgwAYL0MAGRKaFAiIhzAADIAtwKbKC08D88CkRh8ULxYyXRzjtilnA72mhU+G+0S2hIHDxwByAk7EJQGESwNNwwAPAC0zwEDAKUA4gCbizAAFQBcG8cvbXcrDsIRAzwlRNTiHR8MG34CfATCC6vxbQA4Oi4Opzkuz6IdB7wKABA7Ls8SGgB9rNsdD7wbSBzOoncfAT4qYB0C7KAJBE3z5R9mDL0M+wg9Cj8ABcELPgJMDbwIvQ09CT0KvS7PoisOvAaYAhwPjBriBBwLvBY8AKELPBC8BRihe90AO2wMPQACpwm9BRzR9QYFB2/LBnwAB7wSXBISvQECAOsCAAB1FVwHFswV/HAXvBg8AC68AuyovAAevAJWISuAAAG8AALkFT0VvCvso7zJqDwEAp8nTAACXADn3hm8CaVcD7/FAPUafAiiBQv/cQDfvKe8GNwavKOMeXMG/KmchAASvAcbDAADlABtvAcAC7ynPAIaPLsIopzLDvwHwak8AOF8L7dtvwNJAAPsABW8AAb8AAm8AGmMABq8AA68Axi8jmoV/AABXAAObAAuTB8ABrwAF7wIIgANSwC6vCcAA7wADpwq7ACyWwAcHAAbvAAB7AqiAAXHCxYV3AAHnABCvAEDAGm8AAt8AB28AAi8CaIABcsAbqAZ1gCSCCIABcsAATwAB9wAHZwIIgAGmwAJfAAbLABtHADmvIEACFwACDwAFLwAaPwJIgAGywDjjAAJPAuiDsX7YAAHPABunUBJAEgACrwFAAM8AAmuAzgABxwAGXwAAgym/AAKHAAKPAAJ/KfsBrwACRwAAwwAEDwBABQ8ABFsAA+MAA3sAA28ABkMBxYcABU8AG6cFrQBvAC7ABM8BABpLAsA4UwAAjwABFMAF3wFHAAG0QAYvB8BfClTADpGALAJBw4McwApK3EBpQYIXwJtJA0ACghwTG1gK4oggRVjLjcDogq1AALZABcC/ARvAXdzSFMVIgNQAhY/AS0GBHRHvnxTe0EAKgAyAvwAVAvcAHyRLQEsAHfmDhIzRwJLAFgGAAJRAQiLzQB5PAQhpgBbANcWAJZpOCCMAM5ssgDQ1RcJw3Z0HBlXHgrSAYmRrCNUVE5JEz3DivoAgB04QSos4RKYUABzASosMSlDGhADMVYE+MbvAExm3QBrAnICQBF7Osh4LzXWBhETIAUVCK6v/xPNACYAAQIbAIYAiQCONgDjALQA1QCdPQC7AKsApgChAOcAnwDTAJwA4AEBAPwAwAB6AFsAywDNAPwA1wDrAIkAogEqAOMA2ADVBAIIKzTT09PTtb/bzM/NQjEWAUsBVS5GAVMBYgFhAVQBRUpCRGcMAUwUBgkEMzcMBwAgDSQmKCs3OTk8PDw9Pg0/HVBQUFBSUlFSKFNUVlVVHFxgYF9hYCNlZ29ucXFxcXFxc3Nzc3Nzc3Nzc3N1dXZ1dFsAPesAQgCTAHEAKwBf8QCHAFAAUAAwAm/oAIT+8fEAXQCM6wCYAEgAWwBd+PipAH4AfgBiAE8AqgAdAK8AfAI5AjwA9QDgAPcA9wDhAPgA4gDiAOEA3wAoAnQBSgE5ATcBTQE3ATcBNwEyATEBMQExARUBURAAKgkBAEwYCxcEFhcPAIcAjwCfAEoAYxkCKgBvAGgAkAMOAyArAxpCP0gqAIoCSADAAlACnQC5Ao8CjwKPAo8CjwKPAoQCjwKPAo8CjwKPAo8CjgKOApECmQKQAo8CjwKNAo0CjQKNAosCjgJuAc0CkAKYAo8CjwKOF3oMAPcGA5gCWgIzGAFNETYC2xILLBQBRzgUTpIBdKU9AWJaAP4DOkgA/wCSKh4ZkGsAKmEAagAvAIoDlcyM8K+FWwa7LA/DEgKe1nUrCwQkWwGzAN5/gYB/gX+Cg4N/hIeFf4aJh4GIg4mDin+Lf4x/jYuOf49/kIORf5J/k3+Uf5WElomXg5h/AIMloQCEBDwEOQQ7BD4EPARCBD8EOgRABEIEQQQ9BD8EQgCkA4gAylIA0AINAPdbAPcBGgD3APUA9QD2APXVhSRmvwD3APUA9QD2APUdAIpbAPcAigEaAPcAigLtAPcAitWFJGa/HQD4WwEaAPcA9wD1APUA9gD1APgA9QD1APYA9dWFJGa/HQCKWwEaAPcAigD3AIoC7QD3AIrVhSRmvx0CRAE3AksBOgJMwgOfAu0Dn9WFJGa/HQCKWwEaA58AigOfAIoC7QOfAIrVhSRmvx0EMQCKBDIAigeOMm4hLQCKAT9vBCQA/gDHWwMAVVv/FDMDAIoDPtkASgMAigMAl2dBtv/TrfLzakaPh3aztmIuZQrR3ER2n5Yo+qNR2jK/aP/V04UK1njIJXLgkab9PjOxyJDVbIN3R/FZLoZVl2kYFQIZ7V6LpRqGDt9OdDohnJKp5yX/HLj0voPpLrneDaN11t5W3sSM4ALscgSw8fyWLVkKa/cNcQmjYOgTLZUgOLi2F05g4TR0RfgZ4PBdntxdV3qvdxQt8DeaMMgjJMgwUxYN3tUNpUNx21AvwADDAIa0+raTWaoBXmShAl5AThpMi282o+WzOKMlxjHj7a+DI6AM6VI9w+xyh3Eyg/1XvPmbqjeg2MGXugHt8wW03DQMRTd5iqqOhjLvyOCcKtViGwAHVLyl86KqvxVX7MxSW8HLq6KCrLpB8SspAOHO9IuOwCh9poLoMEha9CHCxlRAXJNDobducWjqhFHqCkzjTM2V9CHslwq4iU19IxqhIFZMve15lDTiMVZIPdADXGxTqzSTv0dDWyk1ht430yvaYCy9qY0MQ3cC5c1uw4mHcTGkMHTAGC99TkNXFAiLQgw9ZWhwKJjGCe+J5FIaMpYhhyUnEgfrF3zEtzn40DdgCIJUJfZ0mo3eXsDwneJ8AYCr7Vx2eHFnt2H6ZEyAHs9JoQ4Lzh5zBoGOGwAz37NOPuqSNmZf51hBEovtpm2T1wI79OBWDyvCFYkONqAKGVYgIL0F+uxTcMLSPtFbiNDbBPFgip8MGDmLLHbSyGXdCMO6f7teiW9EEmorZ+75KzanZwvUySgjoUQBTfHlOIerJs6Y9wLlgDw18AB1ne0tZRNgGjcrqHbtubSUooEpy4hWpDzTSrmvqw0H9AoXQLolMt9eOM+l9RitBB1OBnrdC1XL4yLFyXqZSgZhv7FnnDEXLUeffb4nVDqYTLY6X7gHVaK4ZZlepja2Oe6OhLDI/Ve5SQTCmJdH3HJeb14cw99XsBQAlDy5s5kil2sGezZA3tFok2IsNja7QuFgM30Hff3NGSsSVFYZLOcTBOvlPx8vLhjJrSI7xrNMA/BOzpBIJrdR1+v+zw4RZ7ry6aq4/tFfvPQxQCPDsXlcRvIZYl+E5g3kJ+zLMZon0yElBvEOQTh6SaAdIO6BwdqJqfvgU+e8Y65FQhdiHkZMVt9/39N2jGd26J6cNjq8cQIyp6RonRPgVn2fl89uRDcQ27GacaN0MPrcNyRlbUWelKfDfyrNVVGBG5sjd3jXzTx06ywyzuWn5jbvEfPPCTbpClkgEu9oPLKICxU5HuDe3jA1XnvU85IYYhaEtOU1YVWYhEFsa4/TQj3rHdsU2da2eVbF8YjSI0m619/8bLMZu3xildwqM7zf1cjn4Whx0PSYXcY5bR7wEQfGC7CTOXwZdmsdTO8q3uGm7Rh/RfCWwpzBHCAaVfjxgibL5vUeL0pH6bzDmI9yCXKC/okkmbc28OJvI87L/bjFzpq0DHepw4kT1Od+fL7cyuFaRgfaUWB2++TCFvz11J0leEtrGkpccfX9z2LY39sph4PBHCjNOOkd0ybUm+ZzS8GkFbqMpq8uiX2yHpa0jllTLfGTDBMYR6FT5FWLLDPMkYxt1Q0eyMvxJWztDjy0m6VvZPvamrFXjHmPpU6WxrZqH6WW//I37RwvqPQhPz8I3RPuXAk1C94ZprQWm9iGM/KgiGDO6SV9sjp+Jmk4TBajMNJ5zzWZ1k1jrteQQBp9C2dOvmbIeeEME8y573Q8TgGe+ZCzutM45gYLBzYm2LNvgq2kebAbMpHRDSyh6dQ27GbsAAdCqQVVXWC1C+zpwBM2Lr4eqtobmmu1vJEDlIQR1iN8CUWpztq50z7FFQBn3SKViX6wSqzVQCoYvAjByjeSa+h1PRnYWvBinTDB9cHt4eqDsPS4jcD3FwXJKT0RQsl8EvslI2SFaz2OtmYLFV8FwgvWroZ3fKmh7btewX9tfL2upXsrsqpLJzpzNGyNlnuZyetg7DIOxQTMBR7dqlrTlZ6FWi1g4j1NSjA2j1Yd7fzTH6k9LxCyUCneAKYCU581bnvKih6KJTeTeCX4Zhme/QIz7w2o+AdSgtLAkdrLS9nfweYEqrMLsrGGSWXtgWamAWp6+x6GM/Z8jNw3BqPNQ39hrzYLECn3tPvh/LqKbRSCiDGauDKBBj/kGbpnM1Bb/my8hv4NWStclkwjfl57y4oNDgw1JAG9VOti3QVVoSziMEsSdfEjaCPIDb7SgpLXykQsM+nbqbt97I0mIlzWv0uqFobLMAq8Rd9pszUBKxFhBPwOjf//gVOz2r7URJ2OnpviCXv9iz3a4X/YLBYbXoYwxBv/Kq0a5s4utQHzoTerJ7PmFW/no/ZAsid/hRIV82tD+Qabh5F1ssIM8Ri3chu0PuPD3sSJRMjDoxLAbwUbroiPAz/V52e8s3DIixxlO7OrvhMj3qfzA0kKxzwicr5wJmZwJxTXgrwYsqhRvpgC2Nfdyd+TYYxJSZgk+gk2g9KyHSlwQVAyPtWWgvVGyVBqsU2LpDlLNosSAtolC1uBKt5pQZLhAxTjeGCWIC/HVpagc5rRwkgpCHKEsjA8d+scp8aiMewwQBhp5dYTV5t/Nvl+HbDMu8F3S0psPyZb1bSnqlHPFUnMQeQqSqwDBT23fJO9gO3aVaa1icrXU0PKwlMM5K+iL3ATcVq2fFWKk0irCTF4LDVDG4gUpkyplq6efcZS+WDR1woApjD18x+2JQR9oOXzuA7uy4b+/91WsJd/tSd1QcAH8PVPXApieA37B7YXPhDPH1azP3PKR+HfHmOoDYLeuKsIi/ssSsdYs62qJo14Hw1P2N/6zpr8F3FTWmJ4ysAVcl84Iv/tl///Z8FaAWbBQbyMNDZjrZ2JwdRjtd1jOeNumSodFtr4/Zf45iRJf/8HSW+KIB/+GlKu8Rv1BPLr/4duoL+kFPRqrstEr41gfJupoJRf4hcYDWX93FOcfEBiIivxtjtV8g7mvOReiamYWKE7vfPbv3v2L9Kwq3cIDFGLyhyfOGuf/9vA5muH6Pjg7B4SUj2ydDXra9fSBI+DrsNHA6l51wfHssJb+11TfNk7B8OleUe3Y+ZmHboMFHdv7FFP2cfISFyeAQR0sk/Xv62HBTdW4HmnGSLFk/cqyWVVFJkdIIa+4hos3JRHcqLoRKM5h2Qtk1RZtzISMtlXTfTqIc77YsCCgQD0r61jtxskCctwJOtjE/pL8wC4LBD4AZFjh2wzzFCrT/PNqW0/DeBbkfMfzVm9yy06WiF+1mTdNNEAytVtohBKg3brWd2VQa+aF+cQ0mW5CvbwOlWCT07liX226PjiVLwFCRs/Ax2/u+ZNPjrNFIWIPf5GjHyUKp60OeXe9F01f7IaPf/SDTvyDAf7LSWWejtiZcsqtWZjrdn6A2MqBwnSeKhrZOlUMmgMionmiCIvXqKZfmhGZ1MwD3uMF4n9KJcfWLA3cL5pq48tm5NDYNh3SS/TKUtmFSlQR89MR4+kxcqJgpGbhm9gXneDELkyqAN5nitmIzTscKeJRXqd64RiaOALR2d295NWwbjHRNG2AU5oR9OS2oJg/5CY6BFPc1JvD2Mxdhp2/MZdI8dLePxiP4KRIp8VXmqfg+jqd/RNG7GNuq1U2SiI4735Bdc0MVFx6mH5UOWEa5HuhYykd6t4M1gYLVS8m1B+9bUqi5DziQq7qT8d94cxB6AB4WqMCOF/zPPtRSZUUaMSsvHOWxGASufywTX8ogy6HgUf9p+Z30wUEosl8qgmwm6o2AV6nO9HKQjRHpN6SUegI5pvR61RLnUJ1lqCtmfcsRQutEizVpAaPXN7xMp5UQ5OSZK6tniCK9CpyMd7LjR6+MxfoMEDPpWdf2p2m5N3KO4QMxf+V7vGdYjemQczQ+m2MGIkFNYDMf0Yop2eSx81sP36WHUczqEhKysp2iJSYAvfgJjinKwToPvRKb+HBi+7cJ96S5ngfLOXaHAFRLkulo4TnXTFO51gX0TCCo4ZUHdbpdgkMEwUZAPjh6M+hA8DzycbtxAgH3uD6i0nN1aTiIuQ4BYCE9dEHHwAmINU+4YEWx4EC3OZwFGfYZMPLScVlb+BAAJeARUh+gdWA3/gRqCrf1jecgqeFf1MdzrrP4SVlGm5mMihSP+zYYksAB7O+SBPwNQqSNMiLnkviY/klwgcRmvqtCqeWeA0gjuir4CMZqmw/ntP6M+l0pdN8/P9xI53aP7x/zavJbbKOz8VzO/nXxIr1tjparMnqd6iWdByHKw4lF4p/u57Yv07WeZPDnRl7wgmDVZZ44fQsjdYO/gmXQ+940PRGst8UMQApFC4OOV22e4N+lVOPyFLAOj4t8R3PFw/FjbSWy0ELuAFReNkee8ORcBOT2NPDcs7OfpUmzvn/F9Czk9o9naMyVYy/j8I5qVFmQDFcptBp65J/+sJA3w/j6y/eqUkKxTsf0CZjtNdRSBEmJ2tmfgmJbqpcsSagk+Ul9qdyV+NnqFBIJZFCB1XwPvWGDBOjVUmpWGHsWA5uDuMgLUNKZ4vlq5qfzY1LnRhCc/mh5/EX+hzuGdDy5aYYx4BAdwTTeZHcZpl3X0YyuxZFWNE6wFNppYs3LcFJePOyfKZ8KYb7dmRyvDOcORLPH0sytC6mH1US3JVj6paYM1GEr+CUmyHRnabHPqLlh6Kl0/BWd3ebziDfvpRQpPoR7N+LkUeYWtQ6Rn5v5+NtNeBPs2+DKDlzEVR5aYbTVPrZekJsZ9UC9qtVcP99thVIt1GREnN8zXP8mBfzS+wKYym8fcW6KqrE702Zco+hFQAEIR7qimo7dd7wO8B7R+QZPTuCWm1UAwblDTyURSbd85P4Pz+wBpQyGPeEpsEvxxIZkKsyfSOUcfE3UqzMFwZKYijb7sOkzpou+tC4bPXey5GI1GUAg9c3vLwIwAhcdPHRsYvpAfzkZHWY20vWxxJO0lvKfj6sG2g/pJ1vd/X2EBZkyEjLN4nUZOpOO7MewyHCrxQK8d5aF7rCeQlFX+XksK6l6z971BPuJqwdjj68ULOj9ZTDdOLopMdOLL0PFSS792SXE/EC9EDnIXZGYhr52aQb+9b2zEdBSnpkxAdBUkwJDqGCpZk/HkRidjdp0zKv/Cm52EenmfeKX6HkLUJgMbTTxxIZkIeL/6xuAaAAHbA7mONVduTHNX/UJj1nJEaI7f3HlUyiqKn7VfBE+bdb4HWln1HPJx001Ulq1tOxFf8WZEARvq5Da1+pE7fPVxLntGACz3nkoLsKcPdUqdCwwiyWkmXTd5+bv3j7HaReRt3ESn783Ew3SWsvkEjKtbocNksbrLmV+GVZn1+Uneo35MT1/4r8fngQX5/ptORfgmWfF6KSB/ssJmUSijXxQqUpzkANEkSkYgYj560OOjJr6uqckFuO15TRNgABEwNDjus1V3q2huLPYERMCLXUNmJJpbMrUQsSO7Qnxta55TvPWL6gWmMOvFknqETzqzFVO8SVkovEdYatypLGmDy9VWfgAc0KyIChiOhbd7UlbAeVLPZyEDp4POXKBwN/KP5pT6Cyqs6yaI00vXMn1ubk9OWT9Q/O2t/C25qlnO/zO0xcBzpMBCAB8vsdsh3U8fnPX1XlPEWfaYJxKVaTUgfCESWl4CCkIyjE6iQ5JFcwU6S4/IH0/Agacp8d5Gzq2+GzPnJ7+sqk40mfFQpKrDbAKwLlr3ONEati2k/ycLMSUu7V/7BBkDlNyXoN9tvqXCbbMc4SSQXgC/DBUY9QjtrCtQ+susEomCq8xcNJNNMWCH31GtlTw2BdCXkJBjT+/QNWlBWwQ5SWCh1LdQ99QVii/DyTxjSR6rmdap3l3L3aiplQpPYlrzNm9er88fXd2+ao+YdUNjtqmxiVxmyYPzJxl67OokDcTezEGqldkGgPbRdXA+fGcuZVkembZByo7J1dMnkGNjwwCny+FNcVcWvWYL9mg8oF7jACVWI3bA64EXpdM8bSIEVIAs5JJH+LHXgnCsgcMGPZyAAVBncvbLiexzg9YozcytjPXVlAbQAC7Tc4S0C8QN4LlAGjj4pQAVWrwkaDoUYGxxvkCWKRRHkdzJB5zpREleBDL1oDKEvAqmkDibVC4kTqF89YO6laUjgtJPebBfzr16tg4t10GmN1sJ5vezk2sUOq8blCn5mPZyT3ltaDcddKupQjqusNM9wtFVD0ABzv17fZDn7GPT1nkCtdcgYejcK1qOcTGtPxnCX1rErEjVWCnEJv5HaOAUjgpiKQjUKkQi64D5g2COgwas8FcgIl0Pw95H9dWxE3QG0VbMNffh6BPlAojLDf4es2/5Xfq7hw5NGcON2g8Qsy2UQm94KddKyy3kdJxWgpNaEc15xcylbLC3vnT26u8qS90qc2MU8LdOJc5VPF5KnSpXIhnj1eJJ/jszjZ01oR6JDFJRoeTPO/wh4IPFbdG9KljuSzeuI92p8JF/bpgDE8wG86/W2EBKgPrmzdLijxssQn8mM44ky/KLGOJcrSwXIpZa/Z3v7W6HCRk7ewds99LTsUW1LbeJytw8Q/BFZVZyfO9BUHOCe2suuEkO8DU4fLX0IQSQ2TdOkKXDtPf3sNV9tYhYFueuPRhfQlEEy+aYM/MCz7diDNmFSswYYlZZPmKr2Q5AxLsSVEqqBtn6hVl1BCFOFExnqnIsmyY/NA8jXnDaNzr7Zv3hu+I1Mf/PJjk0gALN2G8ABzdf9FNvWHvZHhv6xIoDCXf964MxG92vGZtx/LYU5PeZqgly8tT5tGeQGeJzMMsJc5p+a5Rn2PtEhiRzo/5Owjy1n0Lzx3ev8GHQmeWb8vagG6O5Qk5nrZuQTiKODI4UqL0LLAusS2Ve7j1Ivdxquu1BR9Rc4QkOiUPwQXJv6du2E8i5pDhVoQpUhyMWGUT2O2YODIhjAfI71gxep5r5zAY7GBUZpy51hAw0pcCCrhOmU8Wp6ujQTdZQsCjtq6SHX8QAMNiPCIIkoxhHEZPgsBcOlP4aErJZPhF7qvx6gHrn8hEwPwYbx8YmT/n7lbcmTip1v8kgsrIjFTAlvLY4Nuil0KDmgz3svYs0ZJ3O3Is/vSx4xpxF1e2VAtZE8dJxGYEIhCSuPvCjP54l/NSNDnwlKvAW8mG+AQkgp7a87Igh26uKMFGD0PoPHTSvoWxiHuk+su8XkQiHIjeYKl/RdcOHpxhQH3zHCNE3aARm83Bl6zGxU/vMltlVPQhubcqhW4RYkl6uXk5JdP/QpzaKFpw2M8zvysv2qj7xaQECuu2akM0Cssj/uB9+wDR7uA6XOnLNaoczalHoMj33eiiu+DRaFsUmlmUZuh9bjDY4INMNSSAivSh03uJvny4Gj+D+neudoa7iJi7c4VFlZ/J5gUR82308zSNAt/ZroBXDWw0fV3eVPAn3aX0mtJabF6RsUZmL+Ehn+wn51/4QipMjD+6y64t7bjL6bjENan2prQ4h7++hBJ9NXvX8CUocJqMC937IasLzm5K0qwXeFMAimMHkEIQIQI2LrQ9sLBfXuyp66zWvlsh74GPv7Xpabj993pRNNDuFud5oIcn/92isbADXdpRPbjmbCNOrwRbxGZx2XmYNGMiV5kjF4IKyxCBvKier9U4uVoheCdmk83rp5G0PihAm2fAtczI4b9BWqX+nrZTrJX5kSwQddi93NQrXG+Cl3eBGNkM77VBsMpEolhXex1MVvMkZN9fG59GGbciH11FEXaY1MxrArovaSjE/lUUqBg2cZBNmiWbvzCHCPJ4RVGFK2dTbObM1m+gJyEX53fa7u3+TZpm74mNEzWbkVL4vjNwfL9uzRCu1cgbrNx5Yv5dDruNrIOgwIk+UZWwJfdbu/WHul6PMmRflVCIzd7B37Pgm/Up/NuCiQW7RXyafevN3AL6ycciCc4ZPlTRzEu+aURGlUBOJbUEsheX7PPyrrhdUt5JAG12EEEZpY/N3Vhbl5uLAfT0CbC2XmpnryFkxZmBTs5prvEeuf0bn73i3O82WTiQtJWEPLsBXnQmdnKhB06NbbhLtlTZYJMxDMJpFeajSNRDB2v61BMUHqXggUwRJ19m6p5zl51v11q34T74lTXdJURuV6+bg2D6qpfGnLy7KGLuLZngobM4pIouz4+n0/UzFKxDgLM4h+fUwKZozQ9UGrHjcif51Ruonz7oIVZ56xWtZS8z7u5zay6J2LD4gCYh2RXoBRLDKsUlZ80R8kmoxlJiL8aZCy2wCAonnucFxCLT1HKoMhbPKt34D97EXPPh0joO93iJVF1Uruew61Qoy3ZUVNX9uIJDt9AQWKLLo+mSzmTibyLHq0D6hhzpvgUgI6ekyVEL3FD+Fi5R3A8MRHPXspN1VyKkfRlC+OGiNgPC4NREZpFETgVmdXrQ2TxChuS3aY+Ndc7CiYv5+CmzfiqeZrWIQJW/C4RvjbGUoJFf1K6ZdR2xL/bG4kVq1+I4jQWX+26YUijpp+lpN7o5c6ZodXJCF56UkFGsqz44sIg8jrdWvbjRCxi2Bk0iyM3a7ecAV93zB6h1Ei38c0s6+8nrbkopArccGP8vntQe1bFeEh2nJIFOHX/k3/UHb5PtKGpnzbkmnRETMX+9X/QduLZWw/feklW/kH/JnzToJe9Kgu9Hct1UGbH5BPCLo4OOtQnZonW0xnyCcdtKyPQ/sbLiSTYJdSx4sJqWLMnfn6fIqPB3WAgk00J+fCOkomPHqtS67pf0mFmKoItYZUlJu6BihSZ8qve8+/X+LX1MhQXF95AshfUleCtmdn6l6QFXzLg2sgLn1oyVFuZecv7fzsIHzoRlAGp0gwYDOn1S4qabWvB5xUaE+Svw4KmjWtxdnuQbI32dw87D4N95u8qQRJTSQg0wLxOLkxSrPMLEn1UIhNKjAa9VLs3WLaXGrtCIt8bKY2AQP/ZdyRU6zT/E8qP2ltyBE2CCZPgWgEYDoJJO4n92y61ylNaSFXKohJhLjkfvYWm592539sIpmBNLlDo1bExFBfmHJJ0lFEiC/fj8v42OoMC9Mo3whIoWvyHfq6Uacqq55mzFf/EGC+NP/gHjhd6urc6R0hES27VXux7UY8CGKPohplWIZtTrFSaPWslCWy78E22Pw8fvReSUZx/txqLtHrFqg1DY/Eus6Iq1heZdrdcqE0/c971Bz1HW/XNXHsXpUIbI4kHdOfCc6T5zHZzvzQJB0ggMFL6IGPAilU9bj/ASdPk6fNvNtZqPuwEDhMBtBnhCexo6D6VAGIOPvJPPV523Y8R8a9vCqZbswSZKzOT1291BsUbmUWehtbb1fdRX9hiJKXvwr1QX6GjnZMgyMvnwOo2Dr24amr7FqEAbVeJAjRNOceM2EQ1Mna9fInqPJ5mh5X8CzT1aDOv08An0blz0fF5Gq4mS2cwq5glwIOlY5nznE8X4j/UdZ3FJsVIXte1JH0A7iibuPfazStM5O/Vo3KXIpXBeGORV0M9XDXFvsYZUHGvFCUubWzTw248EHE0cpQM2zNg6rjavreq3NHCAWsoZ7wvVy7l5gvtKRmIj1MnvfWEm0yFnGcuOq192350a5WefpfKCcX3Sn+AgHU+qnpstNtddbdVebagJU390lq9ko4aI9rqdaWXYG8tv5O/ZQHSqDRYHC6zfH10l5z++opso7aOSaIczlQ13iAzXvLdEu0V7kwNUZ1c8Y8aq7SeIEe5p902FlNkW8DnwHyueHchbK8vVFJfmr9mz7P8nUSccl1ULaoWMRSI1ls32kvlK0h46h3J25Yd9AzfcJbp9qYF/SEt3H5j69mMdcsNxZcAzT/A89ov3tglTX54y/EwjMfuoDoxPwLJDm5I7q6F9Kp469yNy1zSxz0N4HbRRBj9xFFuogvBspv7DXUNIsGxTINEQfmctb42XImWAODgARNo7dfcTqFKq6aTfivmvunLmzP9f8yLsJvXD3JbcPcDGNriMAcjzeDTNr65t8YB5tsnFDFLa0Uwmd2OvUdkLMX9TsAUYUfooSv47sw5J88j7CpahRjjO3/UhOXjTS39W5YZAel2KTbQd1h7INOw9P23GW7GDAe4agIUFHP48MZr7ubq0efFmmtwYMyk7D0r1oeG/CGOODgb9Ur+JMHxkwzPbtCX2ZnENQuI0RN5SyTIZuoY4XS9Rd/tPe3vNAZGSHM/YYwqs9xkkENx0O+eC2YVW1cwOJ3ckE890nbQeHLKlW15L0P0W2VliyYrfNr0nrIYddoRyGaCtj4OYd2MT7ebApqZOAQIaSHJM4mphhfjNjtnjg6YRyx9qM2FT3xOiYIMqXPFWdzhSgFF8ItocqVV09CmIoO8k6U/oJB7++wSX/YksxfPXHyjSgAGZOj1aKEq9fSvXBqtp2wu8/FxEf5AxapAD06pPGuLVUYLdgEzHR8wqRGYEwiUO9MyYbgswstuLYhwYFpSVKOdzAihZ9LuHtD598EGhINU9xc9xhL+QgTLAstmPIvvm2xyRw/WTUPXkP3ZHu6GyPmj5xFH9/QGpkglKXRVUBgVmLOJx8uZO2AstxQYocZH2JhORlxawj66BAXUEs7K/gPxINIRAFyK3WLuyq9oBTF9wEbnmCot82WjIg7CPNwYK3KrZMrKAz5yFszg4wCVLJVnIL8+OYA0xRDH8cHQjQUiQ2i1mr/be32k/3Xej9sdf3iuGvZHyLFSJvPSqz/wltnxumTJYKZsrWXtx/Rmu39jjV9lFaJttfFn57/No2h/unsJmMHbrnZ8csxkp5HQ4xR1s0HH+t3Iz82a3iQWTUDGq/+l2W3TUYLE8zNdL8Y+5oXaIH/Y2UUcX67cXeN4WvENZjz4+8q7vjhowOI3rSjFhGZ6KzwmU7+5nFV+kGWAZ5z2UWvzq0TK0pk1hPwAN4jbw//1CApRvIaIjhSGhioY6TUmsToek9cF9XjJdHvLPcyyCV3lbR5Jiz/ts46ay2F820VjTXvllElwrGzKcNSyvQlWDXdwrUINXmHorAM3fE19ngLZmgeUaCJLsSITf2VcfAOuWwX7mTPdP8Zb/04KqRniufCpwnDUk7sP0RX6cud/sanFMagnzKInSRVey0YzlVSOtA/AjrofmSH6RYbJQ8b4NDeTkIGc6247+Mnbez/qhJ9GAv9fGNFercPnnrf285Qgs+UqThLRgflcAKFuqWhLzZaR4QqvSwa3xe0LPkqj9xJWub195r7NrrR0e78FR+0mRBNMPsraqZctAUVAJfYKehTDV1MGGQSeDsOK9J3sbUuKRIS/WilX/64CBms9jCZocBlsBSZaIAjWm/SUZ8daWL2a/cJFyUOFqE3Epc2RWbtjNyPwOGpWtzu32kUooUqsJud7IV4E8rstUBXM7tGEtBx99x60g1duhyvxeKJSl8s5E34HTMmADT0836aEdg5Dv9rVyCz8i2REOmiz6wtIVFN0HsjAoN37SrY0bV1Ms8CRUILhvZvvRaDzoVCaSI0u8EPuTe4b7OPowgRGODl22UBBmHSTUY8e4DyL+Bc7bngo+2T8HtNvzyATSL5iJZgFPKpmUyZv54vVL90+/RQGATUmNKnrIvcJMYON9fl83naW5sf6hRkbbTC9RUEE6XADwjgA46wWfUQ+QWZl0J4PVTWAln/YfAz/SV3q3J9+yCYDleruoN5uoc/wT2f4YONGTb6zTGq3V+3JqzmCOjwebKln+fExVLN7sqtqfMnsKVXWbb2Ai5m3D/fCTgX7oKYzTZvj+m28XnDqPbXuP4MyWdmPezcesdrh7rCzA7BWdObiuyDEKjjzBbQ0qnuwjliz+b+j7aPMKlkXyIznV3tGzAfYwIbzGGt098oh4eq3ruDjdgHtjxfFCjHrjjRbHajoz/YOY4raojPFQ910GIlBV7hq47UDgpyajBxQUmD8NctiLV1rTSLAEsQDLTeRKcmPBMVMFF0SPBBhZ5oXoxtD3lMhuAQXmA+57OcciczVW9e9zwSIAHS+FJmvfXMJGF1dMBsIUMaPjvgaVqUc3p32qVCMQYFEiRLzlVSOGMCmv/HJIxAHe3mL/XnoZ1IkWLeRZfgyByjnDbbeRK5KL7bYHSVJZ9UFq+yCiNKeRUaYjgbC3hVUvfJAhy/QNl/JqLKVvGMk9ZcfyGidNeo/VTxK9vUpodzfQI9Z2eAre4nmrkzgxKSnT5IJ1D69oHuUS5hp7pK9IAWuNrAOtOH0mAuwCrY8mXAtVXUeaNK3OXr6PRvmWg4VQqFSy+a1GZfFYgdsJELG8N0kvqmzvwZ02Plf5fH9QTy6br0oY/IDsEA+GBf9pEVWCIuBCjsup3LDSDqI+5+0IKSUFr7A96A2f0FbcU9fqljdqvsd8sG55KcKloHIFZem2Wb6pCLXybnVSB0sjCXzdS8IKvE");
var FENCED2 = new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX2 = 4;
var r = read_compressed_payload2("AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g");
var SHIFTED_RANK2 = new Map(read_sorted_arrays2(r).flatMap((v, i) => v.map((x) => [x, i + 1 << 24])));
var EXCLUSIONS2 = new Set(read_sorted2(r));
var DECOMP2 = new Map;
var RECOMP2 = new Map;
for (let [cp, cps] of read_mapped2(r)) {
  if (!EXCLUSIONS2.has(cp) && cps.length == 2) {
    let [a, b2] = cps;
    let bucket = RECOMP2.get(a);
    if (!bucket) {
      bucket = new Map;
      RECOMP2.set(a, bucket);
    }
    bucket.set(b2, cp);
  }
  DECOMP2.set(cp, cps.reverse());
}
var S02 = 44032;
var L02 = 4352;
var V02 = 4449;
var T02 = 4519;
var L_COUNT2 = 19;
var V_COUNT2 = 21;
var T_COUNT2 = 28;
var N_COUNT2 = V_COUNT2 * T_COUNT2;
var S_COUNT2 = L_COUNT2 * N_COUNT2;
var S12 = S02 + S_COUNT2;
var L12 = L02 + L_COUNT2;
var V12 = V02 + V_COUNT2;
var T12 = T02 + T_COUNT2;
var FE0F2 = 65039;
var STOP_CH2 = ".";
var UNIQUE_PH2 = 1;
var HYPHEN2 = 45;
var MAPPED2 = new Map(read_mapped2(r$1));
var IGNORED2 = read_set();
var CM2 = read_set();
var NSM2 = new Set(read_sorted2(r$1).map(function(i) {
  return this[i];
}, [...CM2]));
var ESCAPE2 = read_set();
var NFC_CHECK2 = read_set();
var CHUNKS = read_sorted_arrays2(r$1);
var UNRESTRICTED = r$1();
var GROUPS2 = read_array_while2((i) => {
  let N2 = read_array_while2(r$1).map((x) => x + 96);
  if (N2.length) {
    let R = i >= UNRESTRICTED;
    N2[0] -= 32;
    N2 = str_from_cps2(N2);
    if (R)
      N2 = `Restricted[${N2}]`;
    let P = read_chunked();
    let Q = read_chunked();
    let V = [...P, ...Q].sort((a, b2) => a - b2);
    let M = !r$1();
    return { N: N2, P, M, R, V: new Set(V) };
  }
});
var WHOLE_VALID2 = read_set();
var WHOLE_MAP2 = new Map;
[...WHOLE_VALID2, ...read_set()].sort((a, b2) => a - b2).map((cp, i, v) => {
  let d = r$1();
  let w = v[i] = d ? v[i - d] : { V: [], M: new Map };
  w.V.push(cp);
  if (!WHOLE_VALID2.has(cp)) {
    WHOLE_MAP2.set(cp, w);
  }
});
for (let { V, M } of new Set(WHOLE_MAP2.values())) {
  let recs = [];
  for (let cp of V) {
    let gs = GROUPS2.filter((g) => g.V.has(cp));
    let rec = recs.find(({ G }) => gs.some((g) => G.has(g)));
    if (!rec) {
      rec = { G: new Set, V: [] };
      recs.push(rec);
    }
    rec.V.push(cp);
    gs.forEach((g) => rec.G.add(g));
  }
  let union = recs.flatMap(({ G }) => [...G]);
  for (let { G, V: V2 } of recs) {
    let complement = new Set(union.filter((g) => !G.has(g)));
    for (let cp of V2) {
      M.set(cp, complement);
    }
  }
}
var union = new Set;
var multi = new Set;
for (let g of GROUPS2) {
  for (let cp of g.V) {
    (union.has(cp) ? multi : union).add(cp);
  }
}
for (let cp of union) {
  if (!WHOLE_MAP2.has(cp) && !multi.has(cp)) {
    WHOLE_MAP2.set(cp, UNIQUE_PH2);
  }
}
var VALID2 = new Set([...union, ...nfd2(union)]);
var EMOJI_SORTED = read_sorted2(r$1);
var EMOJI_ROOT2 = read_emoji_trie([]);

class Emoji2 extends Array {
  get is_emoji() {
    return true;
  }
}

// ../../node_modules/ethers/lib.esm/hash/namehash.js
var checkComponent = function(comp) {
  assertArgument(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
  return comp;
};
var ensNameSplit = function(name) {
  const bytes9 = toUtf8Bytes(ensNormalize(name));
  const comps = [];
  if (name.length === 0) {
    return comps;
  }
  let last = 0;
  for (let i = 0;i < bytes9.length; i++) {
    const d = bytes9[i];
    if (d === 46) {
      comps.push(checkComponent(bytes9.slice(last, i)));
      last = i + 1;
    }
  }
  assertArgument(last < bytes9.length, "invalid ENS name; empty component", "name", name);
  comps.push(checkComponent(bytes9.slice(last)));
  return comps;
};
function ensNormalize(name) {
  try {
    return ens_normalize3(name);
  } catch (error) {
    assertArgument(false, `invalid ENS name (${error.message})`, "name", name);
  }
}
function isValidName(name) {
  try {
    return ensNameSplit(name).length !== 0;
  } catch (error) {
  }
  return false;
}
function namehash2(name) {
  assertArgument(typeof name === "string", "invalid ENS name; not a string", "name", name);
  let result = Zeros2;
  const comps = ensNameSplit(name);
  while (comps.length) {
    result = keccak2562(concat([result, keccak2562(comps.pop())]));
  }
  return hexlify(result);
}
function dnsEncode(name) {
  return hexlify(concat(ensNameSplit(name).map((comp) => {
    if (comp.length > 63) {
      throw new Error("invalid DNS encoded entry; length exceeds 63 bytes");
    }
    const bytes9 = new Uint8Array(comp.length + 1);
    bytes9.set(comp, 1);
    bytes9[0] = bytes9.length - 1;
    return bytes9;
  }))) + "00";
}
var Zeros2 = new Uint8Array(32);
Zeros2.fill(0);
// ../../node_modules/ethers/lib.esm/transaction/accesslist.js
var accessSetify = function(addr, storageKeys) {
  return {
    address: getAddress(addr),
    storageKeys: storageKeys.map((storageKey, index) => {
      assertArgument(isHexString2(storageKey, 32), "invalid slot", `storageKeys[${index}]`, storageKey);
      return storageKey.toLowerCase();
    })
  };
};
function accessListify(value) {
  if (Array.isArray(value)) {
    return value.map((set, index) => {
      if (Array.isArray(set)) {
        assertArgument(set.length === 2, "invalid slot set", `value[${index}]`, set);
        return accessSetify(set[0], set[1]);
      }
      assertArgument(set != null && typeof set === "object", "invalid address-slot set", "value", value);
      return accessSetify(set.address, set.storageKeys);
    });
  }
  assertArgument(value != null && typeof value === "object", "invalid access list", "value", value);
  const result = Object.keys(value).map((addr) => {
    const storageKeys = value[addr].reduce((accum, storageKey) => {
      accum[storageKey] = true;
      return accum;
    }, {});
    return accessSetify(addr, Object.keys(storageKeys).sort());
  });
  result.sort((a, b2) => a.address.localeCompare(b2.address));
  return result;
}
// ../../node_modules/ethers/lib.esm/transaction/address.js
function computeAddress(key) {
  let pubkey;
  if (typeof key === "string") {
    pubkey = SigningKey.computePublicKey(key, false);
  } else {
    pubkey = key.publicKey;
  }
  return getAddress(keccak2562("0x" + pubkey.substring(4)).substring(26));
}
function recoverAddress(digest, signature2) {
  return computeAddress(SigningKey.recoverPublicKey(digest, signature2));
}
// ../../node_modules/ethers/lib.esm/transaction/transaction.js
var handleAddress = function(value) {
  if (value === "0x") {
    return null;
  }
  return getAddress(value);
};
var handleAccessList = function(value, param) {
  try {
    return accessListify(value);
  } catch (error) {
    assertArgument(false, error.message, param, value);
  }
};
var handleNumber = function(_value, param) {
  if (_value === "0x") {
    return 0;
  }
  return getNumber(_value, param);
};
var handleUint = function(_value, param) {
  if (_value === "0x") {
    return BN_07;
  }
  const value = getBigInt(_value, param);
  assertArgument(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
  return value;
};
var formatNumber = function(_value, name) {
  const value = getBigInt(_value, "value");
  const result = toBeArray(value);
  assertArgument(result.length <= 32, `value too large`, `tx.${name}`, value);
  return result;
};
var formatAccessList = function(value) {
  return accessListify(value).map((set) => [set.address, set.storageKeys]);
};
var _parseLegacy = function(data12) {
  const fields = decodeRlp(data12);
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data12);
  const tx2 = {
    type: 0,
    nonce: handleNumber(fields[0], "nonce"),
    gasPrice: handleUint(fields[1], "gasPrice"),
    gasLimit: handleUint(fields[2], "gasLimit"),
    to: handleAddress(fields[3]),
    value: handleUint(fields[4], "value"),
    data: hexlify(fields[5]),
    chainId: BN_07
  };
  if (fields.length === 6) {
    return tx2;
  }
  const v = handleUint(fields[6], "v");
  const r2 = handleUint(fields[7], "r");
  const s = handleUint(fields[8], "s");
  if (r2 === BN_07 && s === BN_07) {
    tx2.chainId = v;
  } else {
    let chainId = (v - BN_352) / BN_22;
    if (chainId < BN_07) {
      chainId = BN_07;
    }
    tx2.chainId = chainId;
    assertArgument(chainId !== BN_07 || (v === BN_272 || v === BN_282), "non-canonical legacy v", "v", fields[6]);
    tx2.signature = Signature2.from({
      r: zeroPadValue(fields[7], 32),
      s: zeroPadValue(fields[8], 32),
      v
    });
    tx2.hash = keccak2562(data12);
  }
  return tx2;
};
var _serializeLegacy = function(tx2, sig) {
  const fields = [
    formatNumber(tx2.nonce || 0, "nonce"),
    formatNumber(tx2.gasPrice || 0, "gasPrice"),
    formatNumber(tx2.gasLimit || 0, "gasLimit"),
    tx2.to != null ? getAddress(tx2.to) : "0x",
    formatNumber(tx2.value || 0, "value"),
    tx2.data || "0x"
  ];
  let chainId = BN_07;
  if (tx2.chainId != BN_07) {
    chainId = getBigInt(tx2.chainId, "tx.chainId");
    assertArgument(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
  } else if (tx2.signature) {
    const legacy = tx2.signature.legacyChainId;
    if (legacy != null) {
      chainId = legacy;
    }
  }
  if (!sig) {
    if (chainId !== BN_07) {
      fields.push(toBeArray(chainId));
      fields.push("0x");
      fields.push("0x");
    }
    return encodeRlp(fields);
  }
  let v = BigInt(27 + sig.yParity);
  if (chainId !== BN_07) {
    v = Signature2.getChainIdV(chainId, sig.v);
  } else if (BigInt(sig.v) !== v) {
    assertArgument(false, "tx.chainId/sig.v mismatch", "sig", sig);
  }
  fields.push(toBeArray(v));
  fields.push(toBeArray(sig.r));
  fields.push(toBeArray(sig.s));
  return encodeRlp(fields);
};
var _parseEipSignature = function(tx2, fields) {
  let yParity;
  try {
    yParity = handleNumber(fields[0], "yParity");
    if (yParity !== 0 && yParity !== 1) {
      throw new Error("bad yParity");
    }
  } catch (error) {
    assertArgument(false, "invalid yParity", "yParity", fields[0]);
  }
  const r2 = zeroPadValue(fields[1], 32);
  const s = zeroPadValue(fields[2], 32);
  const signature2 = Signature2.from({ r: r2, s, yParity });
  tx2.signature = signature2;
};
var _parseEip1559 = function(data12) {
  const fields = decodeRlp(getBytes(data12).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", hexlify(data12));
  const maxPriorityFeePerGas = handleUint(fields[2], "maxPriorityFeePerGas");
  const maxFeePerGas = handleUint(fields[3], "maxFeePerGas");
  const tx2 = {
    type: 2,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    maxPriorityFeePerGas,
    maxFeePerGas,
    gasPrice: null,
    gasLimit: handleUint(fields[4], "gasLimit"),
    to: handleAddress(fields[5]),
    value: handleUint(fields[6], "value"),
    data: hexlify(fields[7]),
    accessList: handleAccessList(fields[8], "accessList")
  };
  if (fields.length === 9) {
    return tx2;
  }
  tx2.hash = keccak2562(data12);
  _parseEipSignature(tx2, fields.slice(9));
  return tx2;
};
var _serializeEip1559 = function(tx2, sig) {
  const fields = [
    formatNumber(tx2.chainId || 0, "chainId"),
    formatNumber(tx2.nonce || 0, "nonce"),
    formatNumber(tx2.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
    formatNumber(tx2.maxFeePerGas || 0, "maxFeePerGas"),
    formatNumber(tx2.gasLimit || 0, "gasLimit"),
    tx2.to != null ? getAddress(tx2.to) : "0x",
    formatNumber(tx2.value || 0, "value"),
    tx2.data || "0x",
    formatAccessList(tx2.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "yParity"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x02", encodeRlp(fields)]);
};
var _parseEip2930 = function(data12) {
  const fields = decodeRlp(getBytes(data12).slice(1));
  assertArgument(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", hexlify(data12));
  const tx2 = {
    type: 1,
    chainId: handleUint(fields[0], "chainId"),
    nonce: handleNumber(fields[1], "nonce"),
    gasPrice: handleUint(fields[2], "gasPrice"),
    gasLimit: handleUint(fields[3], "gasLimit"),
    to: handleAddress(fields[4]),
    value: handleUint(fields[5], "value"),
    data: hexlify(fields[6]),
    accessList: handleAccessList(fields[7], "accessList")
  };
  if (fields.length === 8) {
    return tx2;
  }
  tx2.hash = keccak2562(data12);
  _parseEipSignature(tx2, fields.slice(8));
  return tx2;
};
var _serializeEip2930 = function(tx2, sig) {
  const fields = [
    formatNumber(tx2.chainId || 0, "chainId"),
    formatNumber(tx2.nonce || 0, "nonce"),
    formatNumber(tx2.gasPrice || 0, "gasPrice"),
    formatNumber(tx2.gasLimit || 0, "gasLimit"),
    tx2.to != null ? getAddress(tx2.to) : "0x",
    formatNumber(tx2.value || 0, "value"),
    tx2.data || "0x",
    formatAccessList(tx2.accessList || [])
  ];
  if (sig) {
    fields.push(formatNumber(sig.yParity, "recoveryParam"));
    fields.push(toBeArray(sig.r));
    fields.push(toBeArray(sig.s));
  }
  return concat(["0x01", encodeRlp(fields)]);
};
var BN_07 = BigInt(0);
var BN_22 = BigInt(2);
var BN_272 = BigInt(27);
var BN_282 = BigInt(28);
var BN_352 = BigInt(35);
var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");

class Transaction2 {
  #type;
  #to;
  #data;
  #nonce;
  #gasLimit;
  #gasPrice;
  #maxPriorityFeePerGas;
  #maxFeePerGas;
  #value;
  #chainId;
  #sig;
  #accessList;
  get type() {
    return this.#type;
  }
  set type(value) {
    switch (value) {
      case null:
        this.#type = null;
        break;
      case 0:
      case "legacy":
        this.#type = 0;
        break;
      case 1:
      case "berlin":
      case "eip-2930":
        this.#type = 1;
        break;
      case 2:
      case "london":
      case "eip-1559":
        this.#type = 2;
        break;
      default:
        assertArgument(false, "unsupported transaction type", "type", value);
    }
  }
  get typeName() {
    switch (this.type) {
      case 0:
        return "legacy";
      case 1:
        return "eip-2930";
      case 2:
        return "eip-1559";
    }
    return null;
  }
  get to() {
    return this.#to;
  }
  set to(value) {
    this.#to = value == null ? null : getAddress(value);
  }
  get nonce() {
    return this.#nonce;
  }
  set nonce(value) {
    this.#nonce = getNumber(value, "value");
  }
  get gasLimit() {
    return this.#gasLimit;
  }
  set gasLimit(value) {
    this.#gasLimit = getBigInt(value);
  }
  get gasPrice() {
    const value = this.#gasPrice;
    if (value == null && (this.type === 0 || this.type === 1)) {
      return BN_07;
    }
    return value;
  }
  set gasPrice(value) {
    this.#gasPrice = value == null ? null : getBigInt(value, "gasPrice");
  }
  get maxPriorityFeePerGas() {
    const value = this.#maxPriorityFeePerGas;
    if (value == null) {
      if (this.type === 2) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxPriorityFeePerGas(value) {
    this.#maxPriorityFeePerGas = value == null ? null : getBigInt(value, "maxPriorityFeePerGas");
  }
  get maxFeePerGas() {
    const value = this.#maxFeePerGas;
    if (value == null) {
      if (this.type === 2) {
        return BN_07;
      }
      return null;
    }
    return value;
  }
  set maxFeePerGas(value) {
    this.#maxFeePerGas = value == null ? null : getBigInt(value, "maxFeePerGas");
  }
  get data() {
    return this.#data;
  }
  set data(value) {
    this.#data = hexlify(value);
  }
  get value() {
    return this.#value;
  }
  set value(value) {
    this.#value = getBigInt(value, "value");
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value);
  }
  get signature() {
    return this.#sig || null;
  }
  set signature(value) {
    this.#sig = value == null ? null : Signature2.from(value);
  }
  get accessList() {
    const value = this.#accessList || null;
    if (value == null) {
      if (this.type === 1 || this.type === 2) {
        return [];
      }
      return null;
    }
    return value;
  }
  set accessList(value) {
    this.#accessList = value == null ? null : accessListify(value);
  }
  constructor() {
    this.#type = null;
    this.#to = null;
    this.#nonce = 0;
    this.#gasLimit = BigInt(0);
    this.#gasPrice = null;
    this.#maxPriorityFeePerGas = null;
    this.#maxFeePerGas = null;
    this.#data = "0x";
    this.#value = BigInt(0);
    this.#chainId = BigInt(0);
    this.#sig = null;
    this.#accessList = null;
  }
  get hash() {
    if (this.signature == null) {
      return null;
    }
    return keccak2562(this.serialized);
  }
  get unsignedHash() {
    return keccak2562(this.unsignedSerialized);
  }
  get from() {
    if (this.signature == null) {
      return null;
    }
    return recoverAddress(this.unsignedHash, this.signature);
  }
  get fromPublicKey() {
    if (this.signature == null) {
      return null;
    }
    return SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
  }
  isSigned() {
    return this.signature != null;
  }
  get serialized() {
    assert2(this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this, this.signature);
      case 1:
        return _serializeEip2930(this, this.signature);
      case 2:
        return _serializeEip1559(this, this.signature);
    }
    assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
  }
  get unsignedSerialized() {
    switch (this.inferType()) {
      case 0:
        return _serializeLegacy(this);
      case 1:
        return _serializeEip2930(this);
      case 2:
        return _serializeEip1559(this);
    }
    assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".unsignedSerialized" });
  }
  inferType() {
    return this.inferTypes().pop();
  }
  inferTypes() {
    const hasGasPrice = this.gasPrice != null;
    const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
    const hasAccessList = this.accessList != null;
    if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
      assert2(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
    }
    assert2(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
    assert2(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
    const types15 = [];
    if (this.type != null) {
      types15.push(this.type);
    } else {
      if (hasFee) {
        types15.push(2);
      } else if (hasGasPrice) {
        types15.push(1);
        if (!hasAccessList) {
          types15.push(0);
        }
      } else if (hasAccessList) {
        types15.push(1);
        types15.push(2);
      } else {
        types15.push(0);
        types15.push(1);
        types15.push(2);
      }
    }
    types15.sort();
    return types15;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  clone() {
    return Transaction2.from(this);
  }
  toJSON() {
    const s = (v) => {
      if (v == null) {
        return null;
      }
      return v.toString();
    };
    return {
      type: this.type,
      to: this.to,
      data: this.data,
      nonce: this.nonce,
      gasLimit: s(this.gasLimit),
      gasPrice: s(this.gasPrice),
      maxPriorityFeePerGas: s(this.maxPriorityFeePerGas),
      maxFeePerGas: s(this.maxFeePerGas),
      value: s(this.value),
      chainId: s(this.chainId),
      sig: this.signature ? this.signature.toJSON() : null,
      accessList: this.accessList
    };
  }
  static from(tx2) {
    if (tx2 == null) {
      return new Transaction2;
    }
    if (typeof tx2 === "string") {
      const payload = getBytes(tx2);
      if (payload[0] >= 127) {
        return Transaction2.from(_parseLegacy(payload));
      }
      switch (payload[0]) {
        case 1:
          return Transaction2.from(_parseEip2930(payload));
        case 2:
          return Transaction2.from(_parseEip1559(payload));
      }
      assert2(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
    }
    const result = new Transaction2;
    if (tx2.type != null) {
      result.type = tx2.type;
    }
    if (tx2.to != null) {
      result.to = tx2.to;
    }
    if (tx2.nonce != null) {
      result.nonce = tx2.nonce;
    }
    if (tx2.gasLimit != null) {
      result.gasLimit = tx2.gasLimit;
    }
    if (tx2.gasPrice != null) {
      result.gasPrice = tx2.gasPrice;
    }
    if (tx2.maxPriorityFeePerGas != null) {
      result.maxPriorityFeePerGas = tx2.maxPriorityFeePerGas;
    }
    if (tx2.maxFeePerGas != null) {
      result.maxFeePerGas = tx2.maxFeePerGas;
    }
    if (tx2.data != null) {
      result.data = tx2.data;
    }
    if (tx2.value != null) {
      result.value = tx2.value;
    }
    if (tx2.chainId != null) {
      result.chainId = tx2.chainId;
    }
    if (tx2.signature != null) {
      result.signature = Signature2.from(tx2.signature);
    }
    if (tx2.accessList != null) {
      result.accessList = tx2.accessList;
    }
    if (tx2.hash != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define hash", "tx", tx2);
      assertArgument(result.hash === tx2.hash, "hash mismatch", "tx", tx2);
    }
    if (tx2.from != null) {
      assertArgument(result.isSigned(), "unsigned transaction cannot define from", "tx", tx2);
      assertArgument(result.from.toLowerCase() === (tx2.from || "").toLowerCase(), "from mismatch", "tx", tx2);
    }
    return result;
  }
}
// ../../node_modules/ethers/lib.esm/hash/message.js
function hashMessage2(message) {
  if (typeof message === "string") {
    message = toUtf8Bytes(message);
  }
  return keccak2562(concat([
    toUtf8Bytes(MessagePrefix),
    toUtf8Bytes(String(message.length)),
    message
  ]));
}
function verifyMessage(message, sig) {
  const digest = hashMessage2(message);
  return recoverAddress(digest, sig);
}
// ../../node_modules/ethers/lib.esm/hash/solidity.js
var _pack = function(type, value, isArray) {
  switch (type) {
    case "address":
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(getAddress(value));
    case "string":
      return toUtf8Bytes(value);
    case "bytes":
      return getBytes(value);
    case "bool":
      value = value ? "0x01" : "0x00";
      if (isArray) {
        return getBytes(zeroPadValue(value, 32));
      }
      return getBytes(value);
  }
  let match = type.match(regexNumber);
  if (match) {
    let signed3 = match[1] === "int";
    let size = parseInt(match[2] || "256");
    assertArgument((!match[2] || match[2] === String(size)) && size % 8 === 0 && size !== 0 && size <= 256, "invalid number type", "type", type);
    if (isArray) {
      size = 256;
    }
    if (signed3) {
      value = toTwos(value, size);
    }
    return getBytes(zeroPadValue(toBeArray(value), size / 8));
  }
  match = type.match(regexBytes);
  if (match) {
    const size = parseInt(match[1]);
    assertArgument(String(size) === match[1] && size !== 0 && size <= 32, "invalid bytes type", "type", type);
    assertArgument(dataLength(value) === size, `invalid value for ${type}`, "value", value);
    if (isArray) {
      return getBytes(zeroPadBytes(value, 32));
    }
    return value;
  }
  match = type.match(regexArray);
  if (match && Array.isArray(value)) {
    const baseType = match[1];
    const count = parseInt(match[2] || String(value.length));
    assertArgument(count === value.length, `invalid array length for ${type}`, "value", value);
    const result = [];
    value.forEach(function(value2) {
      result.push(_pack(baseType, value2, true));
    });
    return getBytes(concat(result));
  }
  assertArgument(false, "invalid type", "type", type);
};
function solidityPacked(types15, values) {
  assertArgument(types15.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
  const tight = [];
  types15.forEach(function(type, index) {
    tight.push(_pack(type, values[index]));
  });
  return hexlify(concat(tight));
}
function solidityPackedKeccak256(types15, values) {
  return keccak2562(solidityPacked(types15, values));
}
function solidityPackedSha256(types15, values) {
  return sha2567(solidityPacked(types15, values));
}
var regexBytes = new RegExp("^bytes([0-9]+)$");
var regexNumber = new RegExp("^(u?int)([0-9]*)$");
var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
// ../../node_modules/ethers/lib.esm/hash/typed-data.js
var hexPadRight = function(value) {
  const bytes9 = getBytes(value);
  const padOffset = bytes9.length % 32;
  if (padOffset) {
    return concat([bytes9, padding.slice(padOffset)]);
  }
  return hexlify(bytes9);
};
var checkString = function(key) {
  return function(value) {
    assertArgument(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
    return value;
  };
};
var getBaseEncoder = function(type) {
  {
    const match = type.match(/^(u?)int(\d*)$/);
    if (match) {
      const signed3 = match[1] === "";
      const width = parseInt(match[2] || "256");
      assertArgument(width % 8 === 0 && width !== 0 && width <= 256 && (match[2] == null || match[2] === String(width)), "invalid numeric width", "type", type);
      const boundsUpper = mask2(BN_MAX_UINT2562, signed3 ? width - 1 : width);
      const boundsLower = signed3 ? (boundsUpper + BN_15) * BN__1 : BN_08;
      return function(_value) {
        const value = getBigInt(_value, "value");
        assertArgument(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type}`, "value", value);
        return toBeHex(signed3 ? toTwos(value, 256) : value, 32);
      };
    }
  }
  {
    const match = type.match(/^bytes(\d+)$/);
    if (match) {
      const width = parseInt(match[1]);
      assertArgument(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type);
      return function(value) {
        const bytes9 = getBytes(value);
        assertArgument(bytes9.length === width, `invalid length for ${type}`, "value", value);
        return hexPadRight(value);
      };
    }
  }
  switch (type) {
    case "address":
      return function(value) {
        return zeroPadValue(getAddress(value), 32);
      };
    case "bool":
      return function(value) {
        return !value ? hexFalse : hexTrue;
      };
    case "bytes":
      return function(value) {
        return keccak2562(value);
      };
    case "string":
      return function(value) {
        return id(value);
      };
  }
  return null;
};
var encodeType = function(name, fields) {
  return `${name}(${fields.map(({ name: name2, type }) => type + " " + name2).join(",")})`;
};
function verifyTypedData(domain, types15, value, signature2) {
  return recoverAddress(TypedDataEncoder.hash(domain, types15, value), signature2);
}
var padding = new Uint8Array(32);
padding.fill(0);
var BN__1 = BigInt(-1);
var BN_08 = BigInt(0);
var BN_15 = BigInt(1);
var BN_MAX_UINT2562 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
var hexTrue = toBeHex(BN_15, 32);
var hexFalse = toBeHex(BN_08, 32);
var domainFieldTypes = {
  name: "string",
  version: "string",
  chainId: "uint256",
  verifyingContract: "address",
  salt: "bytes32"
};
var domainFieldNames = [
  "name",
  "version",
  "chainId",
  "verifyingContract",
  "salt"
];
var domainChecks = {
  name: checkString("name"),
  version: checkString("version"),
  chainId: function(_value) {
    const value = getBigInt(_value, "domain.chainId");
    assertArgument(value >= 0, "invalid chain ID", "domain.chainId", _value);
    if (Number.isSafeInteger(value)) {
      return Number(value);
    }
    return toQuantity(value);
  },
  verifyingContract: function(value) {
    try {
      return getAddress(value).toLowerCase();
    } catch (error) {
    }
    assertArgument(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
  },
  salt: function(value) {
    const bytes9 = getBytes(value, "domain.salt");
    assertArgument(bytes9.length === 32, `invalid domain value "salt"`, "domain.salt", value);
    return hexlify(bytes9);
  }
};

class TypedDataEncoder {
  primaryType;
  #types;
  get types() {
    return JSON.parse(this.#types);
  }
  #fullTypes;
  #encoderCache;
  constructor(types15) {
    this.#types = JSON.stringify(types15);
    this.#fullTypes = new Map;
    this.#encoderCache = new Map;
    const links = new Map;
    const parents = new Map;
    const subtypes = new Map;
    Object.keys(types15).forEach((type) => {
      links.set(type, new Set);
      parents.set(type, []);
      subtypes.set(type, new Set);
    });
    for (const name in types15) {
      const uniqueNames = new Set;
      for (const field of types15[name]) {
        assertArgument(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types15);
        uniqueNames.add(field.name);
        const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1] || null;
        assertArgument(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", types15);
        const encoder = getBaseEncoder(baseType);
        if (encoder) {
          continue;
        }
        assertArgument(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", types15);
        parents.get(baseType).push(name);
        links.get(name).add(baseType);
      }
    }
    const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
    assertArgument(primaryTypes.length !== 0, "missing primary type", "types", types15);
    assertArgument(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t) => JSON.stringify(t)).join(", ")}`, "types", types15);
    defineProperties(this, { primaryType: primaryTypes[0] });
    function checkCircular(type, found) {
      assertArgument(!found.has(type), `circular type reference to ${JSON.stringify(type)}`, "types", types15);
      found.add(type);
      for (const child of links.get(type)) {
        if (!parents.has(child)) {
          continue;
        }
        checkCircular(child, found);
        for (const subtype of found) {
          subtypes.get(subtype).add(child);
        }
      }
      found.delete(type);
    }
    checkCircular(this.primaryType, new Set);
    for (const [name, set] of subtypes) {
      const st = Array.from(set);
      st.sort();
      this.#fullTypes.set(name, encodeType(name, types15[name]) + st.map((t) => encodeType(t, types15[t])).join(""));
    }
  }
  getEncoder(type) {
    let encoder = this.#encoderCache.get(type);
    if (!encoder) {
      encoder = this.#getEncoder(type);
      this.#encoderCache.set(type, encoder);
    }
    return encoder;
  }
  #getEncoder(type) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return encoder;
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      const subtype = match[1];
      const subEncoder = this.getEncoder(subtype);
      return (value) => {
        assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
        let result = value.map(subEncoder);
        if (this.#fullTypes.has(subtype)) {
          result = result.map(keccak2562);
        }
        return keccak2562(concat(result));
      };
    }
    const fields = this.types[type];
    if (fields) {
      const encodedType = id(this.#fullTypes.get(type));
      return (value) => {
        const values = fields.map(({ name, type: type2 }) => {
          const result = this.getEncoder(type2)(value[name]);
          if (this.#fullTypes.has(type2)) {
            return keccak2562(result);
          }
          return result;
        });
        values.unshift(encodedType);
        return concat(values);
      };
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  encodeType(name) {
    const result = this.#fullTypes.get(name);
    assertArgument(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
    return result;
  }
  encodeData(type, value) {
    return this.getEncoder(type)(value);
  }
  hashStruct(name, value) {
    return keccak2562(this.encodeData(name, value));
  }
  encode(value) {
    return this.encodeData(this.primaryType, value);
  }
  hash(value) {
    return this.hashStruct(this.primaryType, value);
  }
  _visit(type, value, callback) {
    {
      const encoder = getBaseEncoder(type);
      if (encoder) {
        return callback(type, value);
      }
    }
    const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
    if (match) {
      assertArgument(!match[3] || parseInt(match[3]) === value.length, `array length mismatch; expected length ${parseInt(match[3])}`, "value", value);
      return value.map((v) => this._visit(match[1], v, callback));
    }
    const fields = this.types[type];
    if (fields) {
      return fields.reduce((accum, { name, type: type2 }) => {
        accum[name] = this._visit(type2, value[name], callback);
        return accum;
      }, {});
    }
    assertArgument(false, `unknown type: ${type}`, "type", type);
  }
  visit(value, callback) {
    return this._visit(this.primaryType, value, callback);
  }
  static from(types15) {
    return new TypedDataEncoder(types15);
  }
  static getPrimaryType(types15) {
    return TypedDataEncoder.from(types15).primaryType;
  }
  static hashStruct(name, types15, value) {
    return TypedDataEncoder.from(types15).hashStruct(name, value);
  }
  static hashDomain(domain) {
    const domainFields = [];
    for (const name in domain) {
      if (domain[name] == null) {
        continue;
      }
      const type = domainFieldTypes[name];
      assertArgument(type, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
      domainFields.push({ name, type });
    }
    domainFields.sort((a, b2) => {
      return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b2.name);
    });
    return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
  }
  static encode(domain, types15, value) {
    return concat([
      "0x1901",
      TypedDataEncoder.hashDomain(domain),
      TypedDataEncoder.from(types15).hash(value)
    ]);
  }
  static hash(domain, types15, value) {
    return keccak2562(TypedDataEncoder.encode(domain, types15, value));
  }
  static async resolveNames(domain, types15, value, resolveName) {
    domain = Object.assign({}, domain);
    for (const key in domain) {
      if (domain[key] == null) {
        delete domain[key];
      }
    }
    const ensCache = {};
    if (domain.verifyingContract && !isHexString2(domain.verifyingContract, 20)) {
      ensCache[domain.verifyingContract] = "0x";
    }
    const encoder = TypedDataEncoder.from(types15);
    encoder.visit(value, (type, value2) => {
      if (type === "address" && !isHexString2(value2, 20)) {
        ensCache[value2] = "0x";
      }
      return value2;
    });
    for (const name in ensCache) {
      ensCache[name] = await resolveName(name);
    }
    if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
      domain.verifyingContract = ensCache[domain.verifyingContract];
    }
    value = encoder.visit(value, (type, value2) => {
      if (type === "address" && ensCache[value2]) {
        return ensCache[value2];
      }
      return value2;
    });
    return { domain, value };
  }
  static getPayload(domain, types15, value) {
    TypedDataEncoder.hashDomain(domain);
    const domainValues = {};
    const domainTypes = [];
    domainFieldNames.forEach((name) => {
      const value2 = domain[name];
      if (value2 == null) {
        return;
      }
      domainValues[name] = domainChecks[name](value2);
      domainTypes.push({ name, type: domainFieldTypes[name] });
    });
    const encoder = TypedDataEncoder.from(types15);
    const typesWithDomain = Object.assign({}, types15);
    assertArgument(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types15);
    typesWithDomain.EIP712Domain = domainTypes;
    encoder.encode(value);
    return {
      types: typesWithDomain,
      domain: domainValues,
      primaryType: encoder.primaryType,
      message: encoder.visit(value, (type, value2) => {
        if (type.match(/^bytes(\d*)/)) {
          return hexlify(getBytes(value2));
        }
        if (type.match(/^u?int/)) {
          return getBigInt(value2).toString();
        }
        switch (type) {
          case "address":
            return value2.toLowerCase();
          case "bool":
            return !!value2;
          case "string":
            assertArgument(typeof value2 === "string", "invalid string", "value", value2);
            return value2;
        }
        assertArgument(false, "unsupported type", "type", type);
      })
    };
  }
}
// ../../node_modules/ethers/lib.esm/abi/fragments.js
var setify = function(items) {
  const result = new Set;
  items.forEach((k) => result.add(k));
  return Object.freeze(result);
};
var lex = function(text) {
  const tokens = [];
  const throwError2 = (message) => {
    const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
    throw new Error(`invalid token ${token} at ${offset}: ${message}`);
  };
  let brackets = [];
  let commas = [];
  let offset = 0;
  while (offset < text.length) {
    let cur = text.substring(offset);
    let match = cur.match(regexWhitespacePrefix);
    if (match) {
      offset += match[1].length;
      cur = text.substring(offset);
    }
    const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
    tokens.push(token);
    let type = SimpleTokens[cur[0]] || "";
    if (type) {
      token.type = type;
      token.text = cur[0];
      offset++;
      if (type === "OPEN_PAREN") {
        brackets.push(tokens.length - 1);
        commas.push(tokens.length - 1);
      } else if (type == "CLOSE_PAREN") {
        if (brackets.length === 0) {
          throwError2("no matching open bracket");
        }
        token.match = brackets.pop();
        tokens[token.match].match = tokens.length - 1;
        token.depth--;
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
      } else if (type === "COMMA") {
        token.linkBack = commas.pop();
        tokens[token.linkBack].linkNext = tokens.length - 1;
        commas.push(tokens.length - 1);
      } else if (type === "OPEN_BRACKET") {
        token.type = "BRACKET";
      } else if (type === "CLOSE_BRACKET") {
        let suffix = tokens.pop().text;
        if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
          const value = tokens.pop().text;
          suffix = value + suffix;
          tokens[tokens.length - 1].value = getNumber(value);
        }
        if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
          throw new Error("missing opening bracket");
        }
        tokens[tokens.length - 1].text += suffix;
      }
      continue;
    }
    match = cur.match(regexIdPrefix);
    if (match) {
      token.text = match[1];
      offset += token.text.length;
      if (Keywords.has(token.text)) {
        token.type = "KEYWORD";
        continue;
      }
      if (token.text.match(regexType)) {
        token.type = "TYPE";
        continue;
      }
      token.type = "ID";
      continue;
    }
    match = cur.match(regexNumberPrefix);
    if (match) {
      token.text = match[1];
      token.type = "NUMBER";
      offset += token.text.length;
      continue;
    }
    throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
  }
  return new TokenString(tokens.map((t) => Object.freeze(t)));
};
var allowSingle = function(set, allowed) {
  let included = [];
  for (const key in allowed.keys()) {
    if (set.has(key)) {
      included.push(key);
    }
  }
  if (included.length > 1) {
    throw new Error(`conflicting types: ${included.join(", ")}`);
  }
};
var consumeName = function(type, tokens) {
  if (tokens.peekKeyword(KwTypes)) {
    const keyword = tokens.pop().text;
    if (keyword !== type) {
      throw new Error(`expected ${type}, got ${keyword}`);
    }
  }
  return tokens.popType("ID");
};
var consumeKeywords = function(tokens, allowed) {
  const keywords = new Set;
  while (true) {
    const keyword = tokens.peekType("KEYWORD");
    if (keyword == null || allowed && !allowed.has(keyword)) {
      break;
    }
    tokens.pop();
    if (keywords.has(keyword)) {
      throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
    }
    keywords.add(keyword);
  }
  return Object.freeze(keywords);
};
var consumeMutability = function(tokens) {
  let modifiers = consumeKeywords(tokens, KwVisib);
  allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
  allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
  if (modifiers.has("view")) {
    return "view";
  }
  if (modifiers.has("pure")) {
    return "pure";
  }
  if (modifiers.has("payable")) {
    return "payable";
  }
  if (modifiers.has("nonpayable")) {
    return "nonpayable";
  }
  if (modifiers.has("constant")) {
    return "view";
  }
  return "nonpayable";
};
var consumeParams = function(tokens, allowIndexed) {
  return tokens.popParams().map((t) => ParamType.from(t, allowIndexed));
};
var consumeGas = function(tokens) {
  if (tokens.peekType("AT")) {
    tokens.pop();
    if (tokens.peekType("NUMBER")) {
      return getBigInt(tokens.pop().text);
    }
    throw new Error("invalid gas");
  }
  return null;
};
var consumeEoi = function(tokens) {
  if (tokens.length) {
    throw new Error(`unexpected tokens: ${tokens.toString()}`);
  }
};
var verifyBasicType = function(type) {
  const match = type.match(regexType);
  assertArgument(match, "invalid type", "type", type);
  if (type === "uint") {
    return "uint256";
  }
  if (type === "int") {
    return "int256";
  }
  if (match[2]) {
    const length = parseInt(match[2]);
    assertArgument(length !== 0 && length <= 32, "invalid bytes length", "type", type);
  } else if (match[3]) {
    const size = parseInt(match[3]);
    assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid numeric width", "type", type);
  }
  return type;
};
var joinParams = function(format2, params) {
  return "(" + params.map((p) => p.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
};
var _kwVisibDeploy = "external public payable";
var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
var _kwVisib = "constant external internal payable private public pure view";
var KwVisib = setify(_kwVisib.split(" "));
var _kwTypes = "constructor error event fallback function receive struct";
var KwTypes = setify(_kwTypes.split(" "));
var _kwModifiers = "calldata memory storage payable indexed";
var KwModifiers = setify(_kwModifiers.split(" "));
var _kwOther = "tuple returns";
var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
var Keywords = setify(_keywords.split(" "));
var SimpleTokens = {
  "(": "OPEN_PAREN",
  ")": "CLOSE_PAREN",
  "[": "OPEN_BRACKET",
  "]": "CLOSE_BRACKET",
  ",": "COMMA",
  "@": "AT"
};
var regexWhitespacePrefix = new RegExp("^(\\s*)");
var regexNumberPrefix = new RegExp("^([0-9]+)");
var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");

class TokenString {
  #offset;
  #tokens;
  get offset() {
    return this.#offset;
  }
  get length() {
    return this.#tokens.length - this.#offset;
  }
  constructor(tokens) {
    this.#offset = 0;
    this.#tokens = tokens.slice();
  }
  clone() {
    return new TokenString(this.#tokens);
  }
  reset() {
    this.#offset = 0;
  }
  #subTokenString(from = 0, to = 0) {
    return new TokenString(this.#tokens.slice(from, to).map((t) => {
      return Object.freeze(Object.assign({}, t, {
        match: t.match - from,
        linkBack: t.linkBack - from,
        linkNext: t.linkNext - from
      }));
    }));
  }
  popKeyword(allowed) {
    const top = this.peek();
    if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
      throw new Error(`expected keyword ${top.text}`);
    }
    return this.pop().text;
  }
  popType(type) {
    if (this.peek().type !== type) {
      throw new Error(`expected ${type}; got ${JSON.stringify(this.peek())}`);
    }
    return this.pop().text;
  }
  popParen() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = this.#subTokenString(this.#offset + 1, top.match + 1);
    this.#offset = top.match + 1;
    return result;
  }
  popParams() {
    const top = this.peek();
    if (top.type !== "OPEN_PAREN") {
      throw new Error("bad start");
    }
    const result = [];
    while (this.#offset < top.match - 1) {
      const link = this.peek().linkNext;
      result.push(this.#subTokenString(this.#offset + 1, link));
      this.#offset = link;
    }
    this.#offset = top.match + 1;
    return result;
  }
  peek() {
    if (this.#offset >= this.#tokens.length) {
      throw new Error("out-of-bounds");
    }
    return this.#tokens[this.#offset];
  }
  peekKeyword(allowed) {
    const top = this.peekType("KEYWORD");
    return top != null && allowed.has(top) ? top : null;
  }
  peekType(type) {
    if (this.length === 0) {
      return null;
    }
    const top = this.peek();
    return top.type === type ? top.text : null;
  }
  pop() {
    const result = this.peek();
    this.#offset++;
    return result;
  }
  toString() {
    const tokens = [];
    for (let i = this.#offset;i < this.#tokens.length; i++) {
      const token = this.#tokens[i];
      tokens.push(`${token.type}:${token.text}`);
    }
    return `<TokenString ${tokens.join(" ")}>`;
  }
}
var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
var _guard4 = {};
var internal = Symbol.for("_ethers_internal");
var ParamTypeInternal = "_ParamTypeInternal";
var ErrorFragmentInternal = "_ErrorInternal";
var EventFragmentInternal = "_EventInternal";
var ConstructorFragmentInternal = "_ConstructorInternal";
var FallbackFragmentInternal = "_FallbackInternal";
var FunctionFragmentInternal = "_FunctionInternal";
var StructFragmentInternal = "_StructInternal";

class ParamType {
  name;
  type;
  baseType;
  indexed;
  components;
  arrayLength;
  arrayChildren;
  constructor(guard, name, type, baseType, indexed, components, arrayLength, arrayChildren) {
    assertPrivate(guard, _guard4, "ParamType");
    Object.defineProperty(this, internal, { value: ParamTypeInternal });
    if (components) {
      components = Object.freeze(components.slice());
    }
    if (baseType === "array") {
      if (arrayLength == null || arrayChildren == null) {
        throw new Error("");
      }
    } else if (arrayLength != null || arrayChildren != null) {
      throw new Error("");
    }
    if (baseType === "tuple") {
      if (components == null) {
        throw new Error("");
      }
    } else if (components != null) {
      throw new Error("");
    }
    defineProperties(this, {
      name,
      type,
      baseType,
      indexed,
      components,
      arrayLength,
      arrayChildren
    });
  }
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      const name = this.name || "";
      if (this.isArray()) {
        const result3 = JSON.parse(this.arrayChildren.format("json"));
        result3.name = name;
        result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        return JSON.stringify(result3);
      }
      const result2 = {
        type: this.baseType === "tuple" ? "tuple" : this.type,
        name
      };
      if (typeof this.indexed === "boolean") {
        result2.indexed = this.indexed;
      }
      if (this.isTuple()) {
        result2.components = this.components.map((c) => JSON.parse(c.format(format2)));
      }
      return JSON.stringify(result2);
    }
    let result = "";
    if (this.isArray()) {
      result += this.arrayChildren.format(format2);
      result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
    } else {
      if (this.isTuple()) {
        if (format2 !== "sighash") {
          result += this.type;
        }
        result += "(" + this.components.map((comp) => comp.format(format2)).join(format2 === "full" ? ", " : ",") + ")";
      } else {
        result += this.type;
      }
    }
    if (format2 !== "sighash") {
      if (this.indexed === true) {
        result += " indexed";
      }
      if (format2 === "full" && this.name) {
        result += " " + this.name;
      }
    }
    return result;
  }
  isArray() {
    return this.baseType === "array";
  }
  isTuple() {
    return this.baseType === "tuple";
  }
  isIndexable() {
    return this.indexed != null;
  }
  walk(value, process3) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v) => _this.arrayChildren.walk(v, process3));
    }
    if (this.isTuple()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid tuple value");
      }
      if (value.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      const _this = this;
      return value.map((v, i) => _this.components[i].walk(v, process3));
    }
    return process3(this.type, value);
  }
  #walkAsync(promises, value, process3, setValue) {
    if (this.isArray()) {
      if (!Array.isArray(value)) {
        throw new Error("invalid array value");
      }
      if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
        throw new Error("array is wrong length");
      }
      const childType = this.arrayChildren;
      const result2 = value.slice();
      result2.forEach((value2, index) => {
        childType.#walkAsync(promises, value2, process3, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    if (this.isTuple()) {
      const components = this.components;
      let result2;
      if (Array.isArray(value)) {
        result2 = value.slice();
      } else {
        if (value == null || typeof value !== "object") {
          throw new Error("invalid tuple value");
        }
        result2 = components.map((param) => {
          if (!param.name) {
            throw new Error("cannot use object value with unnamed components");
          }
          if (!(param.name in value)) {
            throw new Error(`missing value for component ${param.name}`);
          }
          return value[param.name];
        });
      }
      if (result2.length !== this.components.length) {
        throw new Error("array is wrong length");
      }
      result2.forEach((value2, index) => {
        components[index].#walkAsync(promises, value2, process3, (value3) => {
          result2[index] = value3;
        });
      });
      setValue(result2);
      return;
    }
    const result = process3(this.type, value);
    if (result.then) {
      promises.push(async function() {
        setValue(await result);
      }());
    } else {
      setValue(result);
    }
  }
  async walkAsync(value, process3) {
    const promises = [];
    const result = [value];
    this.#walkAsync(promises, value, process3, (value2) => {
      result[0] = value2;
    });
    if (promises.length) {
      await Promise.all(promises);
    }
    return result[0];
  }
  static from(obj, allowIndexed) {
    if (ParamType.isParamType(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ParamType.from(lex(obj), allowIndexed);
      } catch (error) {
        assertArgument(false, "invalid param type", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      let type2 = "", baseType = "";
      let comps = null;
      if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
        baseType = "tuple";
        comps = obj.popParams().map((t) => ParamType.from(t));
        type2 = `tuple(${comps.map((c) => c.format()).join(",")})`;
      } else {
        type2 = verifyBasicType(obj.popType("TYPE"));
        baseType = type2;
      }
      let arrayChildren = null;
      let arrayLength = null;
      while (obj.length && obj.peekType("BRACKET")) {
        const bracket = obj.pop();
        arrayChildren = new ParamType(_guard4, "", type2, baseType, null, comps, arrayLength, arrayChildren);
        arrayLength = bracket.value;
        type2 += bracket.text;
        baseType = "array";
        comps = null;
      }
      let indexed2 = null;
      const keywords = consumeKeywords(obj, KwModifiers);
      if (keywords.has("indexed")) {
        if (!allowIndexed) {
          throw new Error("");
        }
        indexed2 = true;
      }
      const name2 = obj.peekType("ID") ? obj.pop().text : "";
      if (obj.length) {
        throw new Error("leftover tokens");
      }
      return new ParamType(_guard4, name2, type2, baseType, indexed2, comps, arrayLength, arrayChildren);
    }
    const name = obj.name;
    assertArgument(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
    let indexed = obj.indexed;
    if (indexed != null) {
      assertArgument(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
      indexed = !!indexed;
    }
    let type = obj.type;
    let arrayMatch = type.match(regexArrayType);
    if (arrayMatch) {
      const arrayLength = parseInt(arrayMatch[2] || "-1");
      const arrayChildren = ParamType.from({
        type: arrayMatch[1],
        components: obj.components
      });
      return new ParamType(_guard4, name || "", type, "array", indexed, null, arrayLength, arrayChildren);
    }
    if (type === "tuple" || type.startsWith("tuple(") || type.startsWith("(")) {
      const comps = obj.components != null ? obj.components.map((c) => ParamType.from(c)) : null;
      const tuple3 = new ParamType(_guard4, name || "", type, "tuple", indexed, comps, null, null);
      return tuple3;
    }
    type = verifyBasicType(obj.type);
    return new ParamType(_guard4, name || "", type, type, indexed, null, null, null);
  }
  static isParamType(value) {
    return value && value[internal] === ParamTypeInternal;
  }
}

class Fragment {
  type;
  inputs;
  constructor(guard, type, inputs) {
    assertPrivate(guard, _guard4, "Fragment");
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { type, inputs });
  }
  static from(obj) {
    if (typeof obj === "string") {
      try {
        Fragment.from(JSON.parse(obj));
      } catch (e) {
      }
      return Fragment.from(lex(obj));
    }
    if (obj instanceof TokenString) {
      const type = obj.peekKeyword(KwTypes);
      switch (type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
    } else if (typeof obj === "object") {
      switch (obj.type) {
        case "constructor":
          return ConstructorFragment.from(obj);
        case "error":
          return ErrorFragment.from(obj);
        case "event":
          return EventFragment.from(obj);
        case "fallback":
        case "receive":
          return FallbackFragment.from(obj);
        case "function":
          return FunctionFragment.from(obj);
        case "struct":
          return StructFragment.from(obj);
      }
      assert2(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
        operation: "Fragment.from"
      });
    }
    assertArgument(false, "unsupported frgament object", "obj", obj);
  }
  static isConstructor(value) {
    return ConstructorFragment.isFragment(value);
  }
  static isError(value) {
    return ErrorFragment.isFragment(value);
  }
  static isEvent(value) {
    return EventFragment.isFragment(value);
  }
  static isFunction(value) {
    return FunctionFragment.isFragment(value);
  }
  static isStruct(value) {
    return StructFragment.isFragment(value);
  }
}

class NamedFragment extends Fragment {
  name;
  constructor(guard, type, name, inputs) {
    super(guard, type, inputs);
    assertArgument(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
    inputs = Object.freeze(inputs.slice());
    defineProperties(this, { name });
  }
}

class ErrorFragment extends NamedFragment {
  constructor(guard, name, inputs) {
    super(guard, "error", name, inputs);
    Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
  }
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "error",
        name: this.name,
        inputs: this.inputs.map((input) => JSON.parse(input.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("error");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    return result.join(" ");
  }
  static from(obj) {
    if (ErrorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      return ErrorFragment.from(lex(obj));
    } else if (obj instanceof TokenString) {
      const name = consumeName("error", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new ErrorFragment(_guard4, name, inputs);
    }
    return new ErrorFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  static isFragment(value) {
    return value && value[internal] === ErrorFragmentInternal;
  }
}

class EventFragment extends NamedFragment {
  anonymous;
  constructor(guard, name, inputs, anonymous2) {
    super(guard, "event", name, inputs);
    Object.defineProperty(this, internal, { value: EventFragmentInternal });
    defineProperties(this, { anonymous: anonymous2 });
  }
  get topicHash() {
    return id(this.format("sighash"));
  }
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "event",
        anonymous: this.anonymous,
        name: this.name,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("event");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash" && this.anonymous) {
      result.push("anonymous");
    }
    return result.join(" ");
  }
  static getTopicHash(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new EventFragment(_guard4, name, params, false);
    return fragment.topicHash;
  }
  static from(obj) {
    if (EventFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return EventFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid event fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("event", obj);
      const inputs = consumeParams(obj, true);
      const anonymous2 = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
      consumeEoi(obj);
      return new EventFragment(_guard4, name, inputs, anonymous2);
    }
    return new EventFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map((p) => ParamType.from(p, true)) : [], !!obj.anonymous);
  }
  static isFragment(value) {
    return value && value[internal] === EventFragmentInternal;
  }
}

class ConstructorFragment extends Fragment {
  payable;
  gas;
  constructor(guard, type, inputs, payable, gas) {
    super(guard, type, inputs);
    Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
    defineProperties(this, { payable, gas });
  }
  format(format2) {
    assert2(format2 != null && format2 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
    if (format2 === "json") {
      return JSON.stringify({
        type: "constructor",
        stateMutability: this.payable ? "payable" : "undefined",
        payable: this.payable,
        gas: this.gas != null ? this.gas : undefined,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2)))
      });
    }
    const result = [`constructor${joinParams(format2, this.inputs)}`];
    result.push(this.payable ? "payable" : "nonpayable");
    if (this.gas != null) {
      result.push(`@${this.gas.toString()}`);
    }
    return result.join(" ");
  }
  static from(obj) {
    if (ConstructorFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return ConstructorFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid constuctor fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      consumeKeywords(obj, setify(["constructor"]));
      const inputs = consumeParams(obj);
      const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new ConstructorFragment(_guard4, "constructor", inputs, payable, gas);
    }
    return new ConstructorFragment(_guard4, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
  }
  static isFragment(value) {
    return value && value[internal] === ConstructorFragmentInternal;
  }
}

class FallbackFragment extends Fragment {
  payable;
  constructor(guard, inputs, payable) {
    super(guard, "fallback", inputs);
    Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
    defineProperties(this, { payable });
  }
  format(format2) {
    const type = this.inputs.length === 0 ? "receive" : "fallback";
    if (format2 === "json") {
      const stateMutability = this.payable ? "payable" : "nonpayable";
      return JSON.stringify({ type, stateMutability });
    }
    return `${type}()${this.payable ? " payable" : ""}`;
  }
  static from(obj) {
    if (FallbackFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FallbackFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid fallback fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const errorObj = obj.toString();
      const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
      assertArgument(topIsValid, "type must be fallback or receive", "obj", errorObj);
      const type = obj.popKeyword(setify(["fallback", "receive"]));
      if (type === "receive") {
        const inputs2 = consumeParams(obj);
        assertArgument(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
        consumeKeywords(obj, setify(["payable"]));
        consumeEoi(obj);
        return new FallbackFragment(_guard4, [], true);
      }
      let inputs = consumeParams(obj);
      if (inputs.length) {
        assertArgument(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i) => i.format("minimal")).join(", "));
      } else {
        inputs = [ParamType.from("bytes")];
      }
      const mutability = consumeMutability(obj);
      assertArgument(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        const outputs = consumeParams(obj);
        assertArgument(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i) => i.format("minimal")).join(", "));
      }
      consumeEoi(obj);
      return new FallbackFragment(_guard4, inputs, mutability === "payable");
    }
    if (obj.type === "receive") {
      return new FallbackFragment(_guard4, [], true);
    }
    if (obj.type === "fallback") {
      const inputs = [ParamType.from("bytes")];
      const payable = obj.stateMutability === "payable";
      return new FallbackFragment(_guard4, inputs, payable);
    }
    assertArgument(false, "invalid fallback description", "obj", obj);
  }
  static isFragment(value) {
    return value && value[internal] === FallbackFragmentInternal;
  }
}

class FunctionFragment extends NamedFragment {
  constant;
  outputs;
  stateMutability;
  payable;
  gas;
  constructor(guard, name, stateMutability, inputs, outputs, gas) {
    super(guard, "function", name, inputs);
    Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
    outputs = Object.freeze(outputs.slice());
    const constant = stateMutability === "view" || stateMutability === "pure";
    const payable = stateMutability === "payable";
    defineProperties(this, { constant, gas, outputs, payable, stateMutability });
  }
  get selector() {
    return id(this.format("sighash")).substring(0, 10);
  }
  format(format2) {
    if (format2 == null) {
      format2 = "sighash";
    }
    if (format2 === "json") {
      return JSON.stringify({
        type: "function",
        name: this.name,
        constant: this.constant,
        stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : undefined,
        payable: this.payable,
        gas: this.gas != null ? this.gas : undefined,
        inputs: this.inputs.map((i) => JSON.parse(i.format(format2))),
        outputs: this.outputs.map((o) => JSON.parse(o.format(format2)))
      });
    }
    const result = [];
    if (format2 !== "sighash") {
      result.push("function");
    }
    result.push(this.name + joinParams(format2, this.inputs));
    if (format2 !== "sighash") {
      if (this.stateMutability !== "nonpayable") {
        result.push(this.stateMutability);
      }
      if (this.outputs && this.outputs.length) {
        result.push("returns");
        result.push(joinParams(format2, this.outputs));
      }
      if (this.gas != null) {
        result.push(`@${this.gas.toString()}`);
      }
    }
    return result.join(" ");
  }
  static getSelector(name, params) {
    params = (params || []).map((p) => ParamType.from(p));
    const fragment = new FunctionFragment(_guard4, name, "view", params, [], null);
    return fragment.selector;
  }
  static from(obj) {
    if (FunctionFragment.isFragment(obj)) {
      return obj;
    }
    if (typeof obj === "string") {
      try {
        return FunctionFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid function fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("function", obj);
      const inputs = consumeParams(obj);
      const mutability = consumeMutability(obj);
      let outputs = [];
      if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
        outputs = consumeParams(obj);
      }
      const gas = consumeGas(obj);
      consumeEoi(obj);
      return new FunctionFragment(_guard4, name, mutability, inputs, outputs, gas);
    }
    let stateMutability = obj.stateMutability;
    if (stateMutability == null) {
      stateMutability = "payable";
      if (typeof obj.constant === "boolean") {
        stateMutability = "view";
        if (!obj.constant) {
          stateMutability = "payable";
          if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
      } else if (typeof obj.payable === "boolean" && !obj.payable) {
        stateMutability = "nonpayable";
      }
    }
    return new FunctionFragment(_guard4, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
  }
  static isFragment(value) {
    return value && value[internal] === FunctionFragmentInternal;
  }
}

class StructFragment extends NamedFragment {
  constructor(guard, name, inputs) {
    super(guard, "struct", name, inputs);
    Object.defineProperty(this, internal, { value: StructFragmentInternal });
  }
  format() {
    throw new Error("@TODO");
  }
  static from(obj) {
    if (typeof obj === "string") {
      try {
        return StructFragment.from(lex(obj));
      } catch (error) {
        assertArgument(false, "invalid struct fragment", "obj", obj);
      }
    } else if (obj instanceof TokenString) {
      const name = consumeName("struct", obj);
      const inputs = consumeParams(obj);
      consumeEoi(obj);
      return new StructFragment(_guard4, name, inputs);
    }
    return new StructFragment(_guard4, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
  }
  static isFragment(value) {
    return value && value[internal] === StructFragmentInternal;
  }
}

// ../../node_modules/ethers/lib.esm/abi/abi-coder.js
var getBuiltinCallException = function(action, tx2, data12, abiCoder) {
  let message = "missing revert data";
  let reason = null;
  const invocation = null;
  let revert = null;
  if (data12) {
    message = "execution reverted";
    const bytes10 = getBytes(data12);
    data12 = hexlify(data12);
    if (bytes10.length === 0) {
      message += " (no data present; likely require(false) occurred";
      reason = "require(false)";
    } else if (bytes10.length % 32 !== 4) {
      message += " (could not decode reason; invalid data length)";
    } else if (hexlify(bytes10.slice(0, 4)) === "0x08c379a0") {
      try {
        reason = abiCoder.decode(["string"], bytes10.slice(4))[0];
        revert = {
          signature: "Error(string)",
          name: "Error",
          args: [reason]
        };
        message += `: ${JSON.stringify(reason)}`;
      } catch (error) {
        message += " (could not decode reason; invalid string data)";
      }
    } else if (hexlify(bytes10.slice(0, 4)) === "0x4e487b71") {
      try {
        const code = Number(abiCoder.decode(["uint256"], bytes10.slice(4))[0]);
        revert = {
          signature: "Panic(uint256)",
          name: "Panic",
          args: [code]
        };
        reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
        message += `: ${reason}`;
      } catch (error) {
        message += " (could not decode panic code)";
      }
    } else {
      message += " (unknown custom error)";
    }
  }
  const transaction3 = {
    to: tx2.to ? getAddress(tx2.to) : null,
    data: tx2.data || "0x"
  };
  if (tx2.from) {
    transaction3.from = getAddress(tx2.from);
  }
  return makeError(message, "CALL_EXCEPTION", {
    action,
    data: data12,
    reason,
    transaction: transaction3,
    invocation,
    revert
  });
};
var PanicReasons = new Map;
PanicReasons.set(0, "GENERIC_PANIC");
PanicReasons.set(1, "ASSERT_FALSE");
PanicReasons.set(17, "OVERFLOW");
PanicReasons.set(18, "DIVIDE_BY_ZERO");
PanicReasons.set(33, "ENUM_RANGE_ERROR");
PanicReasons.set(34, "BAD_STORAGE_DATA");
PanicReasons.set(49, "STACK_UNDERFLOW");
PanicReasons.set(50, "ARRAY_RANGE_ERROR");
PanicReasons.set(65, "OUT_OF_MEMORY");
PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
var defaultCoder = null;

class AbiCoder {
  #getCoder(param) {
    if (param.isArray()) {
      return new ArrayCoder(this.#getCoder(param.arrayChildren), param.arrayLength, param.name);
    }
    if (param.isTuple()) {
      return new TupleCoder(param.components.map((c) => this.#getCoder(c)), param.name);
    }
    switch (param.baseType) {
      case "address":
        return new AddressCoder(param.name);
      case "bool":
        return new BooleanCoder(param.name);
      case "string":
        return new StringCoder(param.name);
      case "bytes":
        return new BytesCoder(param.name);
      case "":
        return new NullCoder(param.name);
    }
    let match = param.type.match(paramTypeNumber);
    if (match) {
      let size = parseInt(match[2] || "256");
      assertArgument(size !== 0 && size <= 256 && size % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
      return new NumberCoder(size / 8, match[1] === "int", param.name);
    }
    match = param.type.match(paramTypeBytes);
    if (match) {
      let size = parseInt(match[1]);
      assertArgument(size !== 0 && size <= 32, "invalid bytes length", "param", param);
      return new FixedBytesCoder(size, param.name);
    }
    assertArgument(false, "invalid type", "type", param.type);
  }
  getDefaultValue(types15) {
    const coders = types15.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.defaultValue();
  }
  encode(types15, values) {
    assertArgumentCount(values.length, types15.length, "types/values length mismatch");
    const coders = types15.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    const writer = new Writer;
    coder.encode(writer, values);
    return writer.data;
  }
  decode(types15, data12, loose) {
    const coders = types15.map((type) => this.#getCoder(ParamType.from(type)));
    const coder = new TupleCoder(coders, "_");
    return coder.decode(new Reader(data12, loose));
  }
  static defaultAbiCoder() {
    if (defaultCoder == null) {
      defaultCoder = new AbiCoder;
    }
    return defaultCoder;
  }
  static getBuiltinCallException(action, tx2, data12) {
    return getBuiltinCallException(action, tx2, data12, AbiCoder.defaultAbiCoder());
  }
}
// ../../node_modules/ethers/lib.esm/abi/bytes32.js
function encodeBytes32String(text) {
  const bytes10 = toUtf8Bytes(text);
  if (bytes10.length > 31) {
    throw new Error("bytes32 string must be less than 32 bytes");
  }
  return zeroPadBytes(bytes10, 32);
}
function decodeBytes32String(_bytes) {
  const data12 = getBytes(_bytes, "bytes");
  if (data12.length !== 32) {
    throw new Error("invalid bytes32 - not 32 bytes long");
  }
  if (data12[31] !== 0) {
    throw new Error("invalid bytes32 string - no null terminator");
  }
  let length = 31;
  while (data12[length - 1] === 0) {
    length--;
  }
  return toUtf8String(data12.slice(0, length));
}
// ../../node_modules/ethers/lib.esm/abi/interface.js
class LogDescription {
  fragment;
  name;
  signature;
  topic;
  args;
  constructor(fragment, topic3, args) {
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      signature: signature2,
      topic: topic3,
      args
    });
  }
}

class TransactionDescription {
  fragment;
  name;
  args;
  signature;
  selector;
  value;
  constructor(fragment, selector, args, value) {
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector,
      value
    });
  }
}

class ErrorDescription {
  fragment;
  name;
  args;
  signature;
  selector;
  constructor(fragment, selector, args) {
    const name = fragment.name, signature2 = fragment.format();
    defineProperties(this, {
      fragment,
      name,
      args,
      signature: signature2,
      selector
    });
  }
}

class Indexed {
  hash;
  _isIndexed;
  static isIndexed(value) {
    return !!(value && value._isIndexed);
  }
  constructor(hash6) {
    defineProperties(this, { hash: hash6, _isIndexed: true });
  }
}
var PanicReasons2 = {
  "0": "generic panic",
  "1": "assert(false)",
  "17": "arithmetic overflow",
  "18": "division or modulo by zero",
  "33": "enum overflow",
  "34": "invalid encoded storage byte array accessed",
  "49": "out-of-bounds array access; popping on an empty array",
  "50": "out-of-bounds access of an array or bytesN",
  "65": "out of memory",
  "81": "uninitialized function"
};
var BuiltinErrors = {
  "0x08c379a0": {
    signature: "Error(string)",
    name: "Error",
    inputs: ["string"],
    reason: (message) => {
      return `reverted with reason string ${JSON.stringify(message)}`;
    }
  },
  "0x4e487b71": {
    signature: "Panic(uint256)",
    name: "Panic",
    inputs: ["uint256"],
    reason: (code) => {
      let reason = "unknown panic code";
      if (code >= 0 && code <= 255 && PanicReasons2[code.toString()]) {
        reason = PanicReasons2[code.toString()];
      }
      return `reverted with panic code 0x${code.toString(16)} (${reason})`;
    }
  }
};

class Interface {
  fragments;
  deploy;
  fallback;
  receive;
  #errors;
  #events;
  #functions;
  #abiCoder;
  constructor(fragments3) {
    let abi3 = [];
    if (typeof fragments3 === "string") {
      abi3 = JSON.parse(fragments3);
    } else {
      abi3 = fragments3;
    }
    this.#functions = new Map;
    this.#errors = new Map;
    this.#events = new Map;
    const frags = [];
    for (const a of abi3) {
      try {
        frags.push(Fragment.from(a));
      } catch (error) {
        console.log("EE", error);
      }
    }
    defineProperties(this, {
      fragments: Object.freeze(frags)
    });
    let fallback = null;
    let receive = false;
    this.#abiCoder = this.getAbiCoder();
    this.fragments.forEach((fragment, index) => {
      let bucket;
      switch (fragment.type) {
        case "constructor":
          if (this.deploy) {
            console.log("duplicate definition - constructor");
            return;
          }
          defineProperties(this, { deploy: fragment });
          return;
        case "fallback":
          if (fragment.inputs.length === 0) {
            receive = true;
          } else {
            assertArgument(!fallback || fragment.payable !== fallback.payable, "conflicting fallback fragments", `fragments[${index}]`, fragment);
            fallback = fragment;
            receive = fallback.payable;
          }
          return;
        case "function":
          bucket = this.#functions;
          break;
        case "event":
          bucket = this.#events;
          break;
        case "error":
          bucket = this.#errors;
          break;
        default:
          return;
      }
      const signature2 = fragment.format();
      if (bucket.has(signature2)) {
        return;
      }
      bucket.set(signature2, fragment);
    });
    if (!this.deploy) {
      defineProperties(this, {
        deploy: ConstructorFragment.from("constructor()")
      });
    }
    defineProperties(this, { fallback, receive });
  }
  format(minimal) {
    const format2 = minimal ? "minimal" : "full";
    const abi3 = this.fragments.map((f2) => f2.format(format2));
    return abi3;
  }
  formatJson() {
    const abi3 = this.fragments.map((f2) => f2.format("json"));
    return JSON.stringify(abi3.map((j) => JSON.parse(j)));
  }
  getAbiCoder() {
    return AbiCoder.defaultAbiCoder();
  }
  #getFunction(key, values, forceUnique) {
    if (isHexString2(key)) {
      const selector = key.toLowerCase();
      for (const fragment of this.#functions.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#functions) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        const lastValue = values.length > 0 ? values[values.length - 1] : null;
        let valueLength = values.length;
        let allowOptions = true;
        if (Typed.isTyped(lastValue) && lastValue.type === "overrides") {
          allowOptions = false;
          valueLength--;
        }
        for (let i = matching.length - 1;i >= 0; i--) {
          const inputs = matching[i].inputs.length;
          if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1;i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0;j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (j >= inputs.length) {
              if (values[j].type === "overrides") {
                continue;
              }
              matching.splice(i, 1);
              break;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
        const lastArg = values[values.length - 1];
        if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
          matching.splice(0, 1);
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#functions.get(FunctionFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  getFunctionName(key) {
    const fragment = this.#getFunction(key, null, false);
    assertArgument(fragment, "no matching function", "key", key);
    return fragment.name;
  }
  hasFunction(key) {
    return !!this.#getFunction(key, null, false);
  }
  getFunction(key, values) {
    return this.#getFunction(key, values || null, true);
  }
  forEachFunction(callback) {
    const names2 = Array.from(this.#functions.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0;i < names2.length; i++) {
      const name = names2[i];
      callback(this.#functions.get(name), i);
    }
  }
  #getEvent(key, values, forceUnique) {
    if (isHexString2(key)) {
      const eventTopic = key.toLowerCase();
      for (const fragment of this.#events.values()) {
        if (eventTopic === fragment.topicHash) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#events) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (values) {
        for (let i = matching.length - 1;i >= 0; i--) {
          if (matching[i].inputs.length < values.length) {
            matching.splice(i, 1);
          }
        }
        for (let i = matching.length - 1;i >= 0; i--) {
          const inputs = matching[i].inputs;
          for (let j = 0;j < values.length; j++) {
            if (!Typed.isTyped(values[j])) {
              continue;
            }
            if (values[j].type !== inputs[j].baseType) {
              matching.splice(i, 1);
              break;
            }
          }
        }
      }
      if (matching.length === 0) {
        return null;
      }
      if (matching.length > 1 && forceUnique) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
      }
      return matching[0];
    }
    const result = this.#events.get(EventFragment.from(key).format());
    if (result) {
      return result;
    }
    return null;
  }
  getEventName(key) {
    const fragment = this.#getEvent(key, null, false);
    assertArgument(fragment, "no matching event", "key", key);
    return fragment.name;
  }
  hasEvent(key) {
    return !!this.#getEvent(key, null, false);
  }
  getEvent(key, values) {
    return this.#getEvent(key, values || null, true);
  }
  forEachEvent(callback) {
    const names2 = Array.from(this.#events.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0;i < names2.length; i++) {
      const name = names2[i];
      callback(this.#events.get(name), i);
    }
  }
  getError(key, values) {
    if (isHexString2(key)) {
      const selector = key.toLowerCase();
      if (BuiltinErrors[selector]) {
        return ErrorFragment.from(BuiltinErrors[selector].signature);
      }
      for (const fragment of this.#errors.values()) {
        if (selector === fragment.selector) {
          return fragment;
        }
      }
      return null;
    }
    if (key.indexOf("(") === -1) {
      const matching = [];
      for (const [name, fragment] of this.#errors) {
        if (name.split("(")[0] === key) {
          matching.push(fragment);
        }
      }
      if (matching.length === 0) {
        if (key === "Error") {
          return ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic") {
          return ErrorFragment.from("error Panic(uint256)");
        }
        return null;
      } else if (matching.length > 1) {
        const matchStr = matching.map((m) => JSON.stringify(m.format())).join(", ");
        assertArgument(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
      }
      return matching[0];
    }
    key = ErrorFragment.from(key).format();
    if (key === "Error(string)") {
      return ErrorFragment.from("error Error(string)");
    }
    if (key === "Panic(uint256)") {
      return ErrorFragment.from("error Panic(uint256)");
    }
    const result = this.#errors.get(key);
    if (result) {
      return result;
    }
    return null;
  }
  forEachError(callback) {
    const names2 = Array.from(this.#errors.keys());
    names2.sort((a, b2) => a.localeCompare(b2));
    for (let i = 0;i < names2.length; i++) {
      const name = names2[i];
      callback(this.#errors.get(name), i);
    }
  }
  _decodeParams(params, data12) {
    return this.#abiCoder.decode(params, data12);
  }
  _encodeParams(params, values) {
    return this.#abiCoder.encode(params, values);
  }
  encodeDeploy(values) {
    return this._encodeParams(this.deploy.inputs, values || []);
  }
  decodeErrorResult(fragment, data12) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data12, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data12);
    return this._decodeParams(fragment.inputs, dataSlice(data12, 4));
  }
  encodeErrorResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getError(fragment);
      assertArgument(f2, "unknown error", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  decodeFunctionData(fragment, data12) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    assertArgument(dataSlice(data12, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data12);
    return this._decodeParams(fragment.inputs, dataSlice(data12, 4));
  }
  encodeFunctionData(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return concat([
      fragment.selector,
      this._encodeParams(fragment.inputs, values || [])
    ]);
  }
  decodeFunctionResult(fragment, data12) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    let message = "invalid length for result data";
    const bytes10 = getBytesCopy(data12);
    if (bytes10.length % 32 === 0) {
      try {
        return this.#abiCoder.decode(fragment.outputs, bytes10);
      } catch (error) {
        message = "could not decode result data";
      }
    }
    assert2(false, message, "BAD_DATA", {
      value: hexlify(bytes10),
      info: { method: fragment.name, signature: fragment.format() }
    });
  }
  makeError(_data, tx2) {
    const data12 = getBytes(_data, "data");
    const error = AbiCoder.getBuiltinCallException("call", tx2, data12);
    const customPrefix = "execution reverted (unknown custom error)";
    if (error.message.startsWith(customPrefix)) {
      const selector = hexlify(data12.slice(0, 4));
      const ef = this.getError(selector);
      if (ef) {
        try {
          const args = this.#abiCoder.decode(ef.inputs, data12.slice(4));
          error.revert = {
            name: ef.name,
            signature: ef.format(),
            args
          };
          error.reason = error.revert.signature;
          error.message = `execution reverted: ${error.reason}`;
        } catch (e) {
          error.message = `execution reverted (coult not decode custom error)`;
        }
      }
    }
    const parsed = this.parseTransaction(tx2);
    if (parsed) {
      error.invocation = {
        method: parsed.name,
        signature: parsed.signature,
        args: parsed.args
      };
    }
    return error;
  }
  encodeFunctionResult(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getFunction(fragment);
      assertArgument(f2, "unknown function", "fragment", fragment);
      fragment = f2;
    }
    return hexlify(this.#abiCoder.encode(fragment.outputs, values || []));
  }
  encodeFilterTopics(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    assert2(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
    const topics = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    const encodeTopic = (param, value) => {
      if (param.type === "string") {
        return id(value);
      } else if (param.type === "bytes") {
        return keccak2562(hexlify(value));
      }
      if (param.type === "bool" && typeof value === "boolean") {
        value = value ? "0x01" : "0x00";
      } else if (param.type.match(/^u?int/)) {
        value = toBeHex(value);
      } else if (param.type.match(/^bytes/)) {
        value = zeroPadBytes(value, 32);
      } else if (param.type === "address") {
        this.#abiCoder.encode(["address"], [value]);
      }
      return zeroPadValue(hexlify(value), 32);
    };
    values.forEach((value, index) => {
      const param = fragment.inputs[index];
      if (!param.indexed) {
        assertArgument(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
        return;
      }
      if (value == null) {
        topics.push(null);
      } else if (param.baseType === "array" || param.baseType === "tuple") {
        assertArgument(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
      } else if (Array.isArray(value)) {
        topics.push(value.map((value2) => encodeTopic(param, value2)));
      } else {
        topics.push(encodeTopic(param, value));
      }
    });
    while (topics.length && topics[topics.length - 1] === null) {
      topics.pop();
    }
    return topics;
  }
  encodeEventLog(fragment, values) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    const topics = [];
    const dataTypes = [];
    const dataValues = [];
    if (!fragment.anonymous) {
      topics.push(fragment.topicHash);
    }
    assertArgument(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
    fragment.inputs.forEach((param, index) => {
      const value = values[index];
      if (param.indexed) {
        if (param.type === "string") {
          topics.push(id(value));
        } else if (param.type === "bytes") {
          topics.push(keccak2562(value));
        } else if (param.baseType === "tuple" || param.baseType === "array") {
          throw new Error("not implemented");
        } else {
          topics.push(this.#abiCoder.encode([param.type], [value]));
        }
      } else {
        dataTypes.push(param);
        dataValues.push(value);
      }
    });
    return {
      data: this.#abiCoder.encode(dataTypes, dataValues),
      topics
    };
  }
  decodeEventLog(fragment, data12, topics) {
    if (typeof fragment === "string") {
      const f2 = this.getEvent(fragment);
      assertArgument(f2, "unknown event", "eventFragment", fragment);
      fragment = f2;
    }
    if (topics != null && !fragment.anonymous) {
      const eventTopic = fragment.topicHash;
      assertArgument(isHexString2(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
      topics = topics.slice(1);
    }
    const indexed = [];
    const nonIndexed = [];
    const dynamic = [];
    fragment.inputs.forEach((param, index) => {
      if (param.indexed) {
        if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
          indexed.push(ParamType.from({ type: "bytes32", name: param.name }));
          dynamic.push(true);
        } else {
          indexed.push(param);
          dynamic.push(false);
        }
      } else {
        nonIndexed.push(param);
        dynamic.push(false);
      }
    });
    const resultIndexed = topics != null ? this.#abiCoder.decode(indexed, concat(topics)) : null;
    const resultNonIndexed = this.#abiCoder.decode(nonIndexed, data12, true);
    const values = [];
    const keys = [];
    let nonIndexedIndex = 0, indexedIndex = 0;
    fragment.inputs.forEach((param, index) => {
      let value = null;
      if (param.indexed) {
        if (resultIndexed == null) {
          value = new Indexed(null);
        } else if (dynamic[index]) {
          value = new Indexed(resultIndexed[indexedIndex++]);
        } else {
          try {
            value = resultIndexed[indexedIndex++];
          } catch (error) {
            value = error;
          }
        }
      } else {
        try {
          value = resultNonIndexed[nonIndexedIndex++];
        } catch (error) {
          value = error;
        }
      }
      values.push(value);
      keys.push(param.name || null);
    });
    return Result.fromItems(values, keys);
  }
  parseTransaction(tx2) {
    const data12 = getBytes(tx2.data, "tx.data");
    const value = getBigInt(tx2.value != null ? tx2.value : 0, "tx.value");
    const fragment = this.getFunction(hexlify(data12.slice(0, 4)));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, data12.slice(4));
    return new TransactionDescription(fragment, fragment.selector, args, value);
  }
  parseCallResult(data12) {
    throw new Error("@TODO");
  }
  parseLog(log) {
    const fragment = this.getEvent(log.topics[0]);
    if (!fragment || fragment.anonymous) {
      return null;
    }
    return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
  }
  parseError(data12) {
    const hexData = hexlify(data12);
    const fragment = this.getError(dataSlice(hexData, 0, 4));
    if (!fragment) {
      return null;
    }
    const args = this.#abiCoder.decode(fragment.inputs, dataSlice(hexData, 4));
    return new ErrorDescription(fragment, fragment.selector, args);
  }
  static from(value) {
    if (value instanceof Interface) {
      return value;
    }
    if (typeof value === "string") {
      return new Interface(JSON.parse(value));
    }
    if (typeof value.format === "function") {
      return new Interface(value.format("json"));
    }
    return new Interface(value);
  }
}
// ../../node_modules/ethers/lib.esm/providers/provider.js
var getValue2 = function(value) {
  if (value == null) {
    return null;
  }
  return value;
};
var toJson = function(value) {
  if (value == null) {
    return null;
  }
  return value.toString();
};
function copyRequest(req) {
  const result = {};
  if (req.to) {
    result.to = req.to;
  }
  if (req.from) {
    result.from = req.from;
  }
  if (req.data) {
    result.data = hexlify(req.data);
  }
  const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
  for (const key of bigIntKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getBigInt(req[key], `request.${key}`);
  }
  const numberKeys = "type,nonce".split(/,/);
  for (const key of numberKeys) {
    if (!(key in req) || req[key] == null) {
      continue;
    }
    result[key] = getNumber(req[key], `request.${key}`);
  }
  if (req.accessList) {
    result.accessList = accessListify(req.accessList);
  }
  if ("blockTag" in req) {
    result.blockTag = req.blockTag;
  }
  if ("enableCcipRead" in req) {
    result.enableCcipRead = !!req.enableCcipRead;
  }
  if ("customData" in req) {
    result.customData = req.customData;
  }
  return result;
}
var createOrphanedBlockFilter = function(block4) {
  return { orphan: "drop-block", hash: block4.hash, number: block4.number };
};
var createReorderedTransactionFilter = function(tx2, other) {
  return { orphan: "reorder-transaction", tx: tx2, other };
};
var createRemovedTransactionFilter = function(tx2) {
  return { orphan: "drop-transaction", tx: tx2 };
};
var createRemovedLogFilter = function(log) {
  return { orphan: "drop-log", log: {
    transactionHash: log.transactionHash,
    blockHash: log.blockHash,
    blockNumber: log.blockNumber,
    address: log.address,
    data: log.data,
    topics: Object.freeze(log.topics.slice()),
    index: log.index
  } };
};
var BN_09 = BigInt(0);

class FeeData {
  gasPrice;
  maxFeePerGas;
  maxPriorityFeePerGas;
  constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
    defineProperties(this, {
      gasPrice: getValue2(gasPrice),
      maxFeePerGas: getValue2(maxFeePerGas),
      maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
    });
  }
  toJSON() {
    const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
    return {
      _type: "FeeData",
      gasPrice: toJson(gasPrice),
      maxFeePerGas: toJson(maxFeePerGas),
      maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
    };
  }
}

class Block {
  provider;
  number;
  hash;
  timestamp;
  parentHash;
  nonce;
  difficulty;
  gasLimit;
  gasUsed;
  miner;
  extraData;
  baseFeePerGas;
  #transactions;
  constructor(block4, provider) {
    this.#transactions = block4.transactions.map((tx2) => {
      if (typeof tx2 !== "string") {
        return new TransactionResponse(tx2, provider);
      }
      return tx2;
    });
    defineProperties(this, {
      provider,
      hash: getValue2(block4.hash),
      number: block4.number,
      timestamp: block4.timestamp,
      parentHash: block4.parentHash,
      nonce: block4.nonce,
      difficulty: block4.difficulty,
      gasLimit: block4.gasLimit,
      gasUsed: block4.gasUsed,
      miner: block4.miner,
      extraData: block4.extraData,
      baseFeePerGas: getValue2(block4.baseFeePerGas)
    });
  }
  get transactions() {
    return this.#transactions.map((tx2) => {
      if (typeof tx2 === "string") {
        return tx2;
      }
      return tx2.hash;
    });
  }
  get prefetchedTransactions() {
    const txs = this.#transactions.slice();
    if (txs.length === 0) {
      return [];
    }
    assert2(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
      operation: "transactionResponses()"
    });
    return txs;
  }
  toJSON() {
    const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash6, miner, nonce, number: number10, parentHash, timestamp, transactions } = this;
    return {
      _type: "Block",
      baseFeePerGas: toJson(baseFeePerGas),
      difficulty: toJson(difficulty),
      extraData,
      gasLimit: toJson(gasLimit),
      gasUsed: toJson(gasUsed),
      hash: hash6,
      miner,
      nonce,
      number: number10,
      parentHash,
      timestamp,
      transactions
    };
  }
  [Symbol.iterator]() {
    let index = 0;
    const txs = this.transactions;
    return {
      next: () => {
        if (index < this.length) {
          return {
            value: txs[index++],
            done: false
          };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get length() {
    return this.#transactions.length;
  }
  get date() {
    if (this.timestamp == null) {
      return null;
    }
    return new Date(this.timestamp * 1000);
  }
  async getTransaction(indexOrHash) {
    let tx2 = undefined;
    if (typeof indexOrHash === "number") {
      tx2 = this.#transactions[indexOrHash];
    } else {
      const hash6 = indexOrHash.toLowerCase();
      for (const v of this.#transactions) {
        if (typeof v === "string") {
          if (v !== hash6) {
            continue;
          }
          tx2 = v;
          break;
        } else {
          if (v.hash === hash6) {
            continue;
          }
          tx2 = v;
          break;
        }
      }
    }
    if (tx2 == null) {
      throw new Error("no such tx");
    }
    if (typeof tx2 === "string") {
      return await this.provider.getTransaction(tx2);
    } else {
      return tx2;
    }
  }
  getPrefetchedTransaction(indexOrHash) {
    const txs = this.prefetchedTransactions;
    if (typeof indexOrHash === "number") {
      return txs[indexOrHash];
    }
    indexOrHash = indexOrHash.toLowerCase();
    for (const tx2 of txs) {
      if (tx2.hash === indexOrHash) {
        return tx2;
      }
    }
    assertArgument(false, "no matching transaction", "indexOrHash", indexOrHash);
  }
  isMined() {
    return !!this.hash;
  }
  isLondon() {
    return !!this.baseFeePerGas;
  }
  orphanedEvent() {
    if (!this.isMined()) {
      throw new Error("");
    }
    return createOrphanedBlockFilter(this);
  }
}

class Log {
  provider;
  transactionHash;
  blockHash;
  blockNumber;
  removed;
  address;
  data;
  topics;
  index;
  transactionIndex;
  constructor(log, provider) {
    this.provider = provider;
    const topics = Object.freeze(log.topics.slice());
    defineProperties(this, {
      transactionHash: log.transactionHash,
      blockHash: log.blockHash,
      blockNumber: log.blockNumber,
      removed: log.removed,
      address: log.address,
      data: log.data,
      topics,
      index: log.index,
      transactionIndex: log.transactionIndex
    });
  }
  toJSON() {
    const { address: address18, blockHash, blockNumber, data: data12, index, removed, topics, transactionHash, transactionIndex } = this;
    return {
      _type: "log",
      address: address18,
      blockHash,
      blockNumber,
      data: data12,
      index,
      removed,
      topics,
      transactionHash,
      transactionIndex
    };
  }
  async getBlock() {
    const block4 = await this.provider.getBlock(this.blockHash);
    assert2(!!block4, "failed to find transaction", "UNKNOWN_ERROR", {});
    return block4;
  }
  async getTransaction() {
    const tx2 = await this.provider.getTransaction(this.transactionHash);
    assert2(!!tx2, "failed to find transaction", "UNKNOWN_ERROR", {});
    return tx2;
  }
  async getTransactionReceipt() {
    const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
    assert2(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
    return receipt;
  }
  removedEvent() {
    return createRemovedLogFilter(this);
  }
}

class TransactionReceipt {
  provider;
  to;
  from;
  contractAddress;
  hash;
  index;
  blockHash;
  blockNumber;
  logsBloom;
  gasUsed;
  cumulativeGasUsed;
  gasPrice;
  type;
  status;
  root;
  #logs;
  constructor(tx2, provider) {
    this.#logs = Object.freeze(tx2.logs.map((log) => {
      return new Log(log, provider);
    }));
    let gasPrice = BN_09;
    if (tx2.effectiveGasPrice != null) {
      gasPrice = tx2.effectiveGasPrice;
    } else if (tx2.gasPrice != null) {
      gasPrice = tx2.gasPrice;
    }
    defineProperties(this, {
      provider,
      to: tx2.to,
      from: tx2.from,
      contractAddress: tx2.contractAddress,
      hash: tx2.hash,
      index: tx2.index,
      blockHash: tx2.blockHash,
      blockNumber: tx2.blockNumber,
      logsBloom: tx2.logsBloom,
      gasUsed: tx2.gasUsed,
      cumulativeGasUsed: tx2.cumulativeGasUsed,
      gasPrice,
      type: tx2.type,
      status: tx2.status,
      root: tx2.root
    });
  }
  get logs() {
    return this.#logs;
  }
  toJSON() {
    const {
      to,
      from,
      contractAddress,
      hash: hash6,
      index,
      blockHash,
      blockNumber,
      logsBloom,
      logs,
      status,
      root
    } = this;
    return {
      _type: "TransactionReceipt",
      blockHash,
      blockNumber,
      contractAddress,
      cumulativeGasUsed: toJson(this.cumulativeGasUsed),
      from,
      gasPrice: toJson(this.gasPrice),
      gasUsed: toJson(this.gasUsed),
      hash: hash6,
      index,
      logs,
      logsBloom,
      root,
      status,
      to
    };
  }
  get length() {
    return this.logs.length;
  }
  [Symbol.iterator]() {
    let index = 0;
    return {
      next: () => {
        if (index < this.length) {
          return { value: this.logs[index++], done: false };
        }
        return { value: undefined, done: true };
      }
    };
  }
  get fee() {
    return this.gasUsed * this.gasPrice;
  }
  async getBlock() {
    const block4 = await this.provider.getBlock(this.blockHash);
    if (block4 == null) {
      throw new Error("TODO");
    }
    return block4;
  }
  async getTransaction() {
    const tx2 = await this.provider.getTransaction(this.hash);
    if (tx2 == null) {
      throw new Error("TODO");
    }
    return tx2;
  }
  async getResult() {
    return await this.provider.getTransactionResult(this.hash);
  }
  async confirmations() {
    return await this.provider.getBlockNumber() - this.blockNumber + 1;
  }
  removedEvent() {
    return createRemovedTransactionFilter(this);
  }
  reorderedEvent(other) {
    assert2(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
    return createReorderedTransactionFilter(this, other);
  }
}

class TransactionResponse {
  provider;
  blockNumber;
  blockHash;
  index;
  hash;
  type;
  to;
  from;
  nonce;
  gasLimit;
  gasPrice;
  maxPriorityFeePerGas;
  maxFeePerGas;
  data;
  value;
  chainId;
  signature;
  accessList;
  #startBlock;
  constructor(tx2, provider) {
    this.provider = provider;
    this.blockNumber = tx2.blockNumber != null ? tx2.blockNumber : null;
    this.blockHash = tx2.blockHash != null ? tx2.blockHash : null;
    this.hash = tx2.hash;
    this.index = tx2.index;
    this.type = tx2.type;
    this.from = tx2.from;
    this.to = tx2.to || null;
    this.gasLimit = tx2.gasLimit;
    this.nonce = tx2.nonce;
    this.data = tx2.data;
    this.value = tx2.value;
    this.gasPrice = tx2.gasPrice;
    this.maxPriorityFeePerGas = tx2.maxPriorityFeePerGas != null ? tx2.maxPriorityFeePerGas : null;
    this.maxFeePerGas = tx2.maxFeePerGas != null ? tx2.maxFeePerGas : null;
    this.chainId = tx2.chainId;
    this.signature = tx2.signature;
    this.accessList = tx2.accessList != null ? tx2.accessList : null;
    this.#startBlock = -1;
  }
  toJSON() {
    const { blockNumber, blockHash, index, hash: hash6, type, to, from, nonce, data: data12, signature: signature2, accessList } = this;
    return {
      _type: "TransactionReceipt",
      accessList,
      blockNumber,
      blockHash,
      chainId: toJson(this.chainId),
      data: data12,
      from,
      gasLimit: toJson(this.gasLimit),
      gasPrice: toJson(this.gasPrice),
      hash: hash6,
      maxFeePerGas: toJson(this.maxFeePerGas),
      maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
      nonce,
      signature: signature2,
      to,
      index,
      type,
      value: toJson(this.value)
    };
  }
  async getBlock() {
    let blockNumber = this.blockNumber;
    if (blockNumber == null) {
      const tx2 = await this.getTransaction();
      if (tx2) {
        blockNumber = tx2.blockNumber;
      }
    }
    if (blockNumber == null) {
      return null;
    }
    const block4 = this.provider.getBlock(blockNumber);
    if (block4 == null) {
      throw new Error("TODO");
    }
    return block4;
  }
  async getTransaction() {
    return this.provider.getTransaction(this.hash);
  }
  async confirmations() {
    if (this.blockNumber == null) {
      const { tx: tx2, blockNumber: blockNumber2 } = await resolveProperties({
        tx: this.getTransaction(),
        blockNumber: this.provider.getBlockNumber()
      });
      if (tx2 == null || tx2.blockNumber == null) {
        return 0;
      }
      return blockNumber2 - tx2.blockNumber + 1;
    }
    const blockNumber = await this.provider.getBlockNumber();
    return blockNumber - this.blockNumber + 1;
  }
  async wait(_confirms, _timeout) {
    const confirms = _confirms == null ? 1 : _confirms;
    const timeout = _timeout == null ? 0 : _timeout;
    let startBlock = this.#startBlock;
    let nextScan = -1;
    let stopScanning = startBlock === -1 ? true : false;
    const checkReplacement = async () => {
      if (stopScanning) {
        return null;
      }
      const { blockNumber, nonce } = await resolveProperties({
        blockNumber: this.provider.getBlockNumber(),
        nonce: this.provider.getTransactionCount(this.from)
      });
      if (nonce < this.nonce) {
        startBlock = blockNumber;
        return;
      }
      if (stopScanning) {
        return null;
      }
      const mined = await this.getTransaction();
      if (mined && mined.blockNumber != null) {
        return;
      }
      if (nextScan === -1) {
        nextScan = startBlock - 3;
        if (nextScan < this.#startBlock) {
          nextScan = this.#startBlock;
        }
      }
      while (nextScan <= blockNumber) {
        if (stopScanning) {
          return null;
        }
        const block4 = await this.provider.getBlock(nextScan, true);
        if (block4 == null) {
          return;
        }
        for (const hash6 of block4) {
          if (hash6 === this.hash) {
            return;
          }
        }
        for (let i = 0;i < block4.length; i++) {
          const tx2 = await block4.getTransaction(i);
          if (tx2.from === this.from && tx2.nonce === this.nonce) {
            if (stopScanning) {
              return null;
            }
            const receipt2 = await this.provider.getTransactionReceipt(tx2.hash);
            if (receipt2 == null) {
              return;
            }
            if (blockNumber - receipt2.blockNumber + 1 < confirms) {
              return;
            }
            let reason = "replaced";
            if (tx2.data === this.data && tx2.to === this.to && tx2.value === this.value) {
              reason = "repriced";
            } else if (tx2.data === "0x" && tx2.from === tx2.to && tx2.value === BN_09) {
              reason = "cancelled";
            }
            assert2(false, "transaction was replaced", "TRANSACTION_REPLACED", {
              cancelled: reason === "replaced" || reason === "cancelled",
              reason,
              replacement: tx2.replaceableTransaction(startBlock),
              hash: tx2.hash,
              receipt: receipt2
            });
          }
        }
        nextScan++;
      }
      return;
    };
    const checkReceipt = (receipt2) => {
      if (receipt2 == null || receipt2.status !== 0) {
        return receipt2;
      }
      assert2(false, "transaction execution reverted", "CALL_EXCEPTION", {
        action: "sendTransaction",
        data: null,
        reason: null,
        invocation: null,
        revert: null,
        transaction: {
          to: receipt2.to,
          from: receipt2.from,
          data: ""
        },
        receipt: receipt2
      });
    };
    const receipt = await this.provider.getTransactionReceipt(this.hash);
    if (confirms === 0) {
      return checkReceipt(receipt);
    }
    if (receipt) {
      if (await receipt.confirmations() >= confirms) {
        return checkReceipt(receipt);
      }
    } else {
      await checkReplacement();
      if (confirms === 0) {
        return null;
      }
    }
    const waiter = new Promise((resolve, reject) => {
      const cancellers = [];
      const cancel = () => {
        cancellers.forEach((c) => c());
      };
      cancellers.push(() => {
        stopScanning = true;
      });
      if (timeout > 0) {
        const timer = setTimeout(() => {
          cancel();
          reject(makeError("wait for transaction timeout", "TIMEOUT"));
        }, timeout);
        cancellers.push(() => {
          clearTimeout(timer);
        });
      }
      const txListener = async (receipt2) => {
        if (await receipt2.confirmations() >= confirms) {
          cancel();
          try {
            resolve(checkReceipt(receipt2));
          } catch (error) {
            reject(error);
          }
        }
      };
      cancellers.push(() => {
        this.provider.off(this.hash, txListener);
      });
      this.provider.on(this.hash, txListener);
      if (startBlock >= 0) {
        const replaceListener = async () => {
          try {
            await checkReplacement();
          } catch (error) {
            if (isError(error, "TRANSACTION_REPLACED")) {
              cancel();
              reject(error);
              return;
            }
          }
          if (!stopScanning) {
            this.provider.once("block", replaceListener);
          }
        };
        cancellers.push(() => {
          this.provider.off("block", replaceListener);
        });
        this.provider.once("block", replaceListener);
      }
    });
    return await waiter;
  }
  isMined() {
    return this.blockHash != null;
  }
  isLegacy() {
    return this.type === 0;
  }
  isBerlin() {
    return this.type === 1;
  }
  isLondon() {
    return this.type === 2;
  }
  removedEvent() {
    assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createRemovedTransactionFilter(this);
  }
  reorderedEvent(other) {
    assert2(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    assert2(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
    return createReorderedTransactionFilter(this, other);
  }
  replaceableTransaction(startBlock) {
    assertArgument(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
    const tx2 = new TransactionResponse(this, this.provider);
    tx2.#startBlock = startBlock;
    return tx2;
  }
}

// ../../node_modules/ethers/lib.esm/contract/wrappers.js
class EventLog extends Log {
  interface;
  fragment;
  args;
  constructor(log, iface, fragment) {
    super(log, log.provider);
    const args = iface.decodeEventLog(fragment, log.data, log.topics);
    defineProperties(this, { args, fragment, interface: iface });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}

class UndecodedEventLog extends Log {
  error;
  constructor(log, error) {
    super(log, log.provider);
    defineProperties(this, { error });
  }
}

class ContractTransactionReceipt extends TransactionReceipt {
  #iface;
  constructor(iface, provider2, tx2) {
    super(tx2, provider2);
    this.#iface = iface;
  }
  get logs() {
    return super.logs.map((log) => {
      const fragment = log.topics.length ? this.#iface.getEvent(log.topics[0]) : null;
      if (fragment) {
        try {
          return new EventLog(log, this.#iface, fragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return log;
    });
  }
}

class ContractTransactionResponse extends TransactionResponse {
  #iface;
  constructor(iface, provider2, tx2) {
    super(tx2, provider2);
    this.#iface = iface;
  }
  async wait(confirms) {
    const receipt = await super.wait(confirms);
    if (receipt == null) {
      return null;
    }
    return new ContractTransactionReceipt(this.#iface, this.provider, receipt);
  }
}

class ContractUnknownEventPayload extends EventPayload {
  log;
  constructor(contract3, listener, filter3, log) {
    super(contract3, listener, filter3);
    defineProperties(this, { log });
  }
  async getBlock() {
    return await this.log.getBlock();
  }
  async getTransaction() {
    return await this.log.getTransaction();
  }
  async getTransactionReceipt() {
    return await this.log.getTransactionReceipt();
  }
}

class ContractEventPayload extends ContractUnknownEventPayload {
  constructor(contract3, listener, filter3, fragment, _log) {
    super(contract3, listener, filter3, new EventLog(_log, contract3.interface, fragment));
    const args = contract3.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
    defineProperties(this, { args, fragment });
  }
  get eventName() {
    return this.fragment.name;
  }
  get eventSignature() {
    return this.fragment.format();
  }
}

// ../../node_modules/ethers/lib.esm/contract/contract.js
var canCall = function(value) {
  return value && typeof value.call === "function";
};
var canEstimate = function(value) {
  return value && typeof value.estimateGas === "function";
};
var canResolve = function(value) {
  return value && typeof value.resolveName === "function";
};
var canSend = function(value) {
  return value && typeof value.sendTransaction === "function";
};
var getRunner = function(value, feature) {
  if (value == null) {
    return null;
  }
  if (typeof value[feature] === "function") {
    return value;
  }
  if (value.provider && typeof value.provider[feature] === "function") {
    return value.provider;
  }
  return null;
};
var getProvider = function(value) {
  if (value == null) {
    return null;
  }
  return value.provider || null;
};
async function copyOverrides(arg, allowed) {
  const _overrides = Typed.dereference(arg, "overrides");
  assertArgument(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
  const overrides = copyRequest(_overrides);
  assertArgument(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
  assertArgument(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
  if (overrides.from) {
    overrides.from = await resolveAddress(overrides.from);
  }
  return overrides;
}
async function resolveArgs(_runner, inputs, args) {
  const runner = getRunner(_runner, "resolveName");
  const resolver2 = canResolve(runner) ? runner : null;
  return await Promise.all(inputs.map((param, index) => {
    return param.walkAsync(args[index], (type, value) => {
      value = Typed.dereference(value, type);
      if (type === "address") {
        return resolveAddress(value, resolver2);
      }
      return value;
    });
  }));
}
var buildWrappedFallback = function(contract3) {
  const populateTransaction = async function(overrides) {
    const tx2 = await copyOverrides(overrides, ["data"]);
    tx2.to = await contract3.getAddress();
    const iface = contract3.interface;
    const noValue = getBigInt(tx2.value || BN_010, "overrides.value") === BN_010;
    const noData = (tx2.data || "0x") === "0x";
    if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
      assertArgument(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
    }
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx2.data);
    const payable = iface.receive || iface.fallback && iface.fallback.payable;
    assertArgument(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx2.value);
    assertArgument(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx2.data);
    return tx2;
  };
  const staticCall = async function(overrides) {
    const runner = getRunner(contract3.runner, "call");
    assert2(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx2 = await populateTransaction(overrides);
    try {
      return await runner.call(tx2);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract3.interface.makeError(error.data, tx2);
      }
      throw error;
    }
  };
  const send = async function(overrides) {
    const runner = contract3.runner;
    assert2(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx2 = await runner.sendTransaction(await populateTransaction(overrides));
    const provider3 = getProvider(contract3.runner);
    return new ContractTransactionResponse(contract3.interface, provider3, tx2);
  };
  const estimateGas3 = async function(overrides) {
    const runner = getRunner(contract3.runner, "estimateGas");
    assert2(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(overrides));
  };
  const method = async (overrides) => {
    return await send(overrides);
  };
  defineProperties(method, {
    _contract: contract3,
    estimateGas: estimateGas3,
    populateTransaction,
    send,
    staticCall
  });
  return method;
};
var buildWrappedMethod = function(contract3, key) {
  const getFragment = function(...args) {
    const fragment = contract3.interface.getFunction(key, args);
    assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const populateTransaction = async function(...args) {
    const fragment = getFragment(...args);
    let overrides = {};
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
    }
    const resolvedArgs = await resolveArgs(contract3.runner, fragment.inputs, args);
    return Object.assign({}, overrides, await resolveProperties({
      to: contract3.getAddress(),
      data: contract3.interface.encodeFunctionData(fragment, resolvedArgs)
    }));
  };
  const staticCall = async function(...args) {
    const result = await staticCallResult(...args);
    if (result.length === 1) {
      return result[0];
    }
    return result;
  };
  const send = async function(...args) {
    const runner = contract3.runner;
    assert2(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
    const tx2 = await runner.sendTransaction(await populateTransaction(...args));
    const provider3 = getProvider(contract3.runner);
    return new ContractTransactionResponse(contract3.interface, provider3, tx2);
  };
  const estimateGas3 = async function(...args) {
    const runner = getRunner(contract3.runner, "estimateGas");
    assert2(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
    return await runner.estimateGas(await populateTransaction(...args));
  };
  const staticCallResult = async function(...args) {
    const runner = getRunner(contract3.runner, "call");
    assert2(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
    const tx2 = await populateTransaction(...args);
    let result = "0x";
    try {
      result = await runner.call(tx2);
    } catch (error) {
      if (isCallException(error) && error.data) {
        throw contract3.interface.makeError(error.data, tx2);
      }
      throw error;
    }
    const fragment = getFragment(...args);
    return contract3.interface.decodeFunctionResult(fragment, result);
  };
  const method = async (...args) => {
    const fragment = getFragment(...args);
    if (fragment.constant) {
      return await staticCall(...args);
    }
    return await send(...args);
  };
  defineProperties(method, {
    name: contract3.interface.getFunctionName(key),
    _contract: contract3,
    _key: key,
    getFragment,
    estimateGas: estimateGas3,
    populateTransaction,
    send,
    staticCall,
    staticCallResult
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract3.interface.getFunction(key);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
};
var buildWrappedEvent = function(contract3, key) {
  const getFragment = function(...args) {
    const fragment = contract3.interface.getEvent(key, args);
    assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
      operation: "fragment",
      info: { key, args }
    });
    return fragment;
  };
  const method = function(...args) {
    return new PreparedTopicFilter(contract3, getFragment(...args), args);
  };
  defineProperties(method, {
    name: contract3.interface.getEventName(key),
    _contract: contract3,
    _key: key,
    getFragment
  });
  Object.defineProperty(method, "fragment", {
    configurable: false,
    enumerable: true,
    get: () => {
      const fragment = contract3.interface.getEvent(key);
      assert2(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
        operation: "fragment",
        info: { key }
      });
      return fragment;
    }
  });
  return method;
};
var setInternal = function(contract3, values) {
  internalValues.set(contract3[internal2], values);
};
var getInternal = function(contract3) {
  return internalValues.get(contract3[internal2]);
};
var isDeferred = function(value) {
  return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
};
async function getSubInfo(contract3, event) {
  let topics;
  let fragment = null;
  if (Array.isArray(event)) {
    const topicHashify = function(name) {
      if (isHexString2(name, 32)) {
        return name;
      }
      const fragment2 = contract3.interface.getEvent(name);
      assertArgument(fragment2, "unknown fragment", "name", name);
      return fragment2.topicHash;
    };
    topics = event.map((e) => {
      if (e == null) {
        return null;
      }
      if (Array.isArray(e)) {
        return e.map(topicHashify);
      }
      return topicHashify(e);
    });
  } else if (event === "*") {
    topics = [null];
  } else if (typeof event === "string") {
    if (isHexString2(event, 32)) {
      topics = [event];
    } else {
      fragment = contract3.interface.getEvent(event);
      assertArgument(fragment, "unknown fragment", "event", event);
      topics = [fragment.topicHash];
    }
  } else if (isDeferred(event)) {
    topics = await event.getTopicFilter();
  } else if ("fragment" in event) {
    fragment = event.fragment;
    topics = [fragment.topicHash];
  } else {
    assertArgument(false, "unknown event name", "event", event);
  }
  topics = topics.map((t) => {
    if (t == null) {
      return null;
    }
    if (Array.isArray(t)) {
      const items = Array.from(new Set(t.map((t2) => t2.toLowerCase())).values());
      if (items.length === 1) {
        return items[0];
      }
      items.sort();
      return items;
    }
    return t.toLowerCase();
  });
  const tag = topics.map((t) => {
    if (t == null) {
      return "null";
    }
    if (Array.isArray(t)) {
      return t.join("|");
    }
    return t;
  }).join("&");
  return { fragment, tag, topics };
}
async function hasSub(contract3, event) {
  const { subs } = getInternal(contract3);
  return subs.get((await getSubInfo(contract3, event)).tag) || null;
}
async function getSub(contract3, operation, event) {
  const provider3 = getProvider(contract3.runner);
  assert2(provider3, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
  const { fragment, tag, topics } = await getSubInfo(contract3, event);
  const { addr, subs } = getInternal(contract3);
  let sub = subs.get(tag);
  if (!sub) {
    const address19 = addr ? addr : contract3;
    const filter3 = { address: address19, topics };
    const listener = (log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = contract3.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        const _foundFragment = foundFragment;
        const args = fragment ? contract3.interface.decodeEventLog(fragment, log.data, log.topics) : [];
        emit(contract3, event, args, (listener2) => {
          return new ContractEventPayload(contract3, listener2, event, _foundFragment, log);
        });
      } else {
        emit(contract3, event, [], (listener2) => {
          return new ContractUnknownEventPayload(contract3, listener2, event, log);
        });
      }
    };
    let starting = [];
    const start = () => {
      if (starting.length) {
        return;
      }
      starting.push(provider3.on(filter3, listener));
    };
    const stop = async () => {
      if (starting.length == 0) {
        return;
      }
      let started = starting;
      starting = [];
      await Promise.all(started);
      provider3.off(filter3, listener);
    };
    sub = { tag, listeners: [], start, stop };
    subs.set(tag, sub);
  }
  return sub;
}
async function _emit(contract3, event, args, payloadFunc) {
  await lastEmit;
  const sub = await hasSub(contract3, event);
  if (!sub) {
    return false;
  }
  const count = sub.listeners.length;
  sub.listeners = sub.listeners.filter(({ listener, once }) => {
    const passArgs = Array.from(args);
    if (payloadFunc) {
      passArgs.push(payloadFunc(once ? null : listener));
    }
    try {
      listener.call(contract3, ...passArgs);
    } catch (error) {
    }
    return !once;
  });
  if (sub.listeners.length === 0) {
    sub.stop();
    getInternal(contract3).subs.delete(sub.tag);
  }
  return count > 0;
}
async function emit(contract3, event, args, payloadFunc) {
  try {
    await lastEmit;
  } catch (error) {
  }
  const resultPromise = _emit(contract3, event, args, payloadFunc);
  lastEmit = resultPromise;
  return await resultPromise;
}
var _ContractBase = function() {
  return BaseContract;
};
var BN_010 = BigInt(0);

class PreparedTopicFilter {
  #filter;
  fragment;
  constructor(contract3, fragment, args) {
    defineProperties(this, { fragment });
    if (fragment.inputs.length < args.length) {
      throw new Error("too many arguments");
    }
    const runner = getRunner(contract3.runner, "resolveName");
    const resolver2 = canResolve(runner) ? runner : null;
    this.#filter = async function() {
      const resolvedArgs = await Promise.all(fragment.inputs.map((param, index) => {
        const arg = args[index];
        if (arg == null) {
          return null;
        }
        return param.walkAsync(args[index], (type, value) => {
          if (type === "address") {
            if (Array.isArray(value)) {
              return Promise.all(value.map((v) => resolveAddress(v, resolver2)));
            }
            return resolveAddress(value, resolver2);
          }
          return value;
        });
      }));
      return contract3.interface.encodeFilterTopics(fragment, resolvedArgs);
    }();
  }
  getTopicFilter() {
    return this.#filter;
  }
}
var internal2 = Symbol.for("_ethersInternal_contract");
var internalValues = new WeakMap;
var lastEmit = Promise.resolve();
var passProperties2 = ["then"];

class BaseContract {
  target;
  interface;
  runner;
  filters;
  [internal2];
  fallback;
  constructor(target, abi4, runner, _deployTx) {
    assertArgument(typeof target === "string" || isAddressable(target), "invalid value for Contract target", "target", target);
    if (runner == null) {
      runner = null;
    }
    const iface = Interface.from(abi4);
    defineProperties(this, { target, runner, interface: iface });
    Object.defineProperty(this, internal2, { value: {} });
    let addrPromise;
    let addr = null;
    let deployTx = null;
    if (_deployTx) {
      const provider3 = getProvider(runner);
      deployTx = new ContractTransactionResponse(this.interface, provider3, _deployTx);
    }
    let subs = new Map;
    if (typeof target === "string") {
      if (isHexString2(target)) {
        addr = target;
        addrPromise = Promise.resolve(target);
      } else {
        const resolver2 = getRunner(runner, "resolveName");
        if (!canResolve(resolver2)) {
          throw makeError("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
            operation: "resolveName"
          });
        }
        addrPromise = resolver2.resolveName(target).then((addr2) => {
          if (addr2 == null) {
            throw makeError("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
              value: target
            });
          }
          getInternal(this).addr = addr2;
          return addr2;
        });
      }
    } else {
      addrPromise = target.getAddress().then((addr2) => {
        if (addr2 == null) {
          throw new Error("TODO");
        }
        getInternal(this).addr = addr2;
        return addr2;
      });
    }
    setInternal(this, { addrPromise, addr, deployTx, subs });
    const filters = new Proxy({}, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return this.getEvent(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return;
      },
      has: (target2, prop) => {
        if (passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
      }
    });
    defineProperties(this, { filters });
    defineProperties(this, {
      fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
    });
    return new Proxy(this, {
      get: (target2, prop, receiver) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.get(target2, prop, receiver);
        }
        try {
          return target2.getFunction(prop);
        } catch (error) {
          if (!isError(error, "INVALID_ARGUMENT") || error.argument !== "key") {
            throw error;
          }
        }
        return;
      },
      has: (target2, prop) => {
        if (typeof prop === "symbol" || prop in target2 || passProperties2.indexOf(prop) >= 0) {
          return Reflect.has(target2, prop);
        }
        return target2.interface.hasFunction(prop);
      }
    });
  }
  connect(runner) {
    return new BaseContract(this.target, this.interface, runner);
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  async getAddress() {
    return await getInternal(this).addrPromise;
  }
  async getDeployedCode() {
    const provider3 = getProvider(this.runner);
    assert2(provider3, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
    const code = await provider3.getCode(await this.getAddress());
    if (code === "0x") {
      return null;
    }
    return code;
  }
  async waitForDeployment() {
    const deployTx = this.deploymentTransaction();
    if (deployTx) {
      await deployTx.wait();
      return this;
    }
    const code = await this.getDeployedCode();
    if (code != null) {
      return this;
    }
    const provider3 = getProvider(this.runner);
    assert2(provider3 != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
    return new Promise((resolve, reject) => {
      const checkCode = async () => {
        try {
          const code2 = await this.getDeployedCode();
          if (code2 != null) {
            return resolve(this);
          }
          provider3.once("block", checkCode);
        } catch (error) {
          reject(error);
        }
      };
      checkCode();
    });
  }
  deploymentTransaction() {
    return getInternal(this).deployTx;
  }
  getFunction(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    const func = buildWrappedMethod(this, key);
    return func;
  }
  getEvent(key) {
    if (typeof key !== "string") {
      key = key.format();
    }
    return buildWrappedEvent(this, key);
  }
  async queryTransaction(hash6) {
    throw new Error("@TODO");
  }
  async queryFilter(event, fromBlock, toBlock) {
    if (fromBlock == null) {
      fromBlock = 0;
    }
    if (toBlock == null) {
      toBlock = "latest";
    }
    const { addr, addrPromise } = getInternal(this);
    const address19 = addr ? addr : await addrPromise;
    const { fragment, topics } = await getSubInfo(this, event);
    const filter3 = { address: address19, topics, fromBlock, toBlock };
    const provider3 = getProvider(this.runner);
    assert2(provider3, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
    return (await provider3.getLogs(filter3)).map((log) => {
      let foundFragment = fragment;
      if (foundFragment == null) {
        try {
          foundFragment = this.interface.getEvent(log.topics[0]);
        } catch (error) {
        }
      }
      if (foundFragment) {
        try {
          return new EventLog(log, this.interface, foundFragment);
        } catch (error) {
          return new UndecodedEventLog(log, error);
        }
      }
      return new Log(log, provider3);
    });
  }
  async on(event, listener) {
    const sub = await getSub(this, "on", event);
    sub.listeners.push({ listener, once: false });
    sub.start();
    return this;
  }
  async once(event, listener) {
    const sub = await getSub(this, "once", event);
    sub.listeners.push({ listener, once: true });
    sub.start();
    return this;
  }
  async emit(event, ...args) {
    return await emit(this, event, args, null);
  }
  async listenerCount(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    const { subs } = getInternal(this);
    let total = 0;
    for (const { listeners } of subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    const { subs } = getInternal(this);
    let result = [];
    for (const { listeners } of subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await hasSub(this, event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (listener == null || sub.listeners.length === 0) {
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const sub = await hasSub(this, event);
      if (!sub) {
        return this;
      }
      sub.stop();
      getInternal(this).subs.delete(sub.tag);
    } else {
      const { subs } = getInternal(this);
      for (const { tag, stop } of subs.values()) {
        stop();
        subs.delete(tag);
      }
    }
    return this;
  }
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  async removeListener(event, listener) {
    return await this.off(event, listener);
  }
  static buildClass(abi4) {

    class CustomContract extends BaseContract {
      constructor(address19, runner = null) {
        super(address19, abi4, runner);
      }
    }
    return CustomContract;
  }
  static from(target, abi4, runner) {
    if (runner == null) {
      runner = null;
    }
    const contract3 = new this(target, abi4, runner);
    return contract3;
  }
}

class Contract2 extends _ContractBase() {
}
// ../../node_modules/ethers/lib.esm/contract/factory.js
class ContractFactory {
  interface;
  bytecode;
  runner;
  constructor(abi5, bytecode, runner) {
    const iface = Interface.from(abi5);
    if (bytecode instanceof Uint8Array) {
      bytecode = hexlify(getBytes(bytecode));
    } else {
      if (typeof bytecode === "object") {
        bytecode = bytecode.object;
      }
      if (!bytecode.startsWith("0x")) {
        bytecode = "0x" + bytecode;
      }
      bytecode = hexlify(getBytes(bytecode));
    }
    defineProperties(this, {
      bytecode,
      interface: iface,
      runner: runner || null
    });
  }
  attach(target) {
    return new BaseContract(target, this.interface, this.runner);
  }
  async getDeployTransaction(...args) {
    let overrides = {};
    const fragment = this.interface.deploy;
    if (fragment.inputs.length + 1 === args.length) {
      overrides = await copyOverrides(args.pop());
    }
    if (fragment.inputs.length !== args.length) {
      throw new Error("incorrect number of arguments to constructor");
    }
    const resolvedArgs = await resolveArgs(this.runner, fragment.inputs, args);
    const data12 = concat([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
    return Object.assign({}, overrides, { data: data12 });
  }
  async deploy(...args) {
    const tx2 = await this.getDeployTransaction(...args);
    assert2(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
      operation: "sendTransaction"
    });
    const sentTx = await this.runner.sendTransaction(tx2);
    const address20 = getCreateAddress(sentTx);
    return new BaseContract(address20, this.interface, this.runner, sentTx);
  }
  connect(runner) {
    return new ContractFactory(this.interface, this.bytecode, runner);
  }
  static fromSolidity(output3, runner) {
    assertArgument(output3 != null, "bad compiler output", "output", output3);
    if (typeof output3 === "string") {
      output3 = JSON.parse(output3);
    }
    const abi5 = output3.abi;
    let bytecode = "";
    if (output3.bytecode) {
      bytecode = output3.bytecode;
    } else if (output3.evm && output3.evm.bytecode) {
      bytecode = output3.evm.bytecode;
    }
    return new this(abi5, bytecode, runner);
  }
}
// ../../node_modules/ethers/lib.esm/providers/ens-resolver.js
var getIpfsLink = function(link) {
  if (link.match(/^ipfs:\/\/ipfs\//i)) {
    link = link.substring(12);
  } else if (link.match(/^ipfs:\/\//i)) {
    link = link.substring(7);
  } else {
    assertArgument(false, "unsupported IPFS format", "link", link);
  }
  return `https://gateway.ipfs.io/ipfs/${link}`;
};

class MulticoinProviderPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  connect(proivder) {
    return this;
  }
  supportsCoinType(coinType) {
    return false;
  }
  async encodeAddress(coinType, address21) {
    throw new Error("unsupported coin");
  }
  async decodeAddress(coinType, data12) {
    throw new Error("unsupported coin");
  }
}
var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
var matchers = [
  new RegExp("^(https)://(.*)$", "i"),
  new RegExp("^(data):(.*)$", "i"),
  matcherIpfs,
  new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
];

class EnsResolver {
  provider;
  address;
  name;
  #supports2544;
  #resolver;
  constructor(provider3, address21, name) {
    defineProperties(this, { provider: provider3, address: address21, name });
    this.#supports2544 = null;
    this.#resolver = new Contract2(address21, [
      "function supportsInterface(bytes4) view returns (bool)",
      "function resolve(bytes, bytes) view returns (bytes)",
      "function addr(bytes32) view returns (address)",
      "function addr(bytes32, uint) view returns (bytes)",
      "function text(bytes32, string) view returns (string)",
      "function contenthash(bytes32) view returns (bytes)"
    ], provider3);
  }
  async supportsWildcard() {
    if (this.#supports2544 == null) {
      this.#supports2544 = (async () => {
        try {
          return await this.#resolver.supportsInterface("0x9061b923");
        } catch (error) {
          if (isError(error, "CALL_EXCEPTION")) {
            return false;
          }
          this.#supports2544 = null;
          throw error;
        }
      })();
    }
    return await this.#supports2544;
  }
  async#fetch(funcName, params) {
    params = (params || []).slice();
    const iface = this.#resolver.interface;
    params.unshift(namehash2(this.name));
    let fragment = null;
    if (await this.supportsWildcard()) {
      fragment = iface.getFunction(funcName);
      assert2(fragment, "missing fragment", "UNKNOWN_ERROR", {
        info: { funcName }
      });
      params = [
        dnsEncode(this.name),
        iface.encodeFunctionData(fragment, params)
      ];
      funcName = "resolve(bytes,bytes)";
    }
    params.push({
      enableCcipRead: true
    });
    try {
      const result = await this.#resolver[funcName](...params);
      if (fragment) {
        return iface.decodeFunctionResult(fragment, result)[0];
      }
      return result;
    } catch (error) {
      if (!isError(error, "CALL_EXCEPTION")) {
        throw error;
      }
    }
    return null;
  }
  async getAddress(coinType) {
    if (coinType == null) {
      coinType = 60;
    }
    if (coinType === 60) {
      try {
        const result = await this.#fetch("addr(bytes32)");
        if (result == null || result === ZeroAddress) {
          return null;
        }
        return result;
      } catch (error) {
        if (isError(error, "CALL_EXCEPTION")) {
          return null;
        }
        throw error;
      }
    }
    if (coinType >= 0 && coinType < 2147483648) {
      let ethCoinType = coinType + 2147483648;
      const data13 = await this.#fetch("addr(bytes32,uint)", [ethCoinType]);
      if (isHexString2(data13, 20)) {
        return getAddress(data13);
      }
    }
    let coinPlugin = null;
    for (const plugin of this.provider.plugins) {
      if (!(plugin instanceof MulticoinProviderPlugin)) {
        continue;
      }
      if (plugin.supportsCoinType(coinType)) {
        coinPlugin = plugin;
        break;
      }
    }
    if (coinPlugin == null) {
      return null;
    }
    const data12 = await this.#fetch("addr(bytes32,uint)", [coinType]);
    if (data12 == null || data12 === "0x") {
      return null;
    }
    const address21 = await coinPlugin.decodeAddress(coinType, data12);
    if (address21 != null) {
      return address21;
    }
    assert2(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
      operation: `getAddress(${coinType})`,
      info: { coinType, data: data12 }
    });
  }
  async getText(key) {
    const data12 = await this.#fetch("text(bytes32,string)", [key]);
    if (data12 == null || data12 === "0x") {
      return null;
    }
    return data12;
  }
  async getContentHash() {
    const data12 = await this.#fetch("contenthash(bytes32)");
    if (data12 == null || data12 === "0x") {
      return null;
    }
    const ipfs = data12.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
    if (ipfs) {
      const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
      const length = parseInt(ipfs[4], 16);
      if (ipfs[5].length === length * 2) {
        return `${scheme}://${encodeBase58("0x" + ipfs[2])}`;
      }
    }
    const swarm = data12.match(/^0xe40101fa011b20([0-9a-f]*)$/);
    if (swarm && swarm[1].length === 64) {
      return `bzz://${swarm[1]}`;
    }
    assert2(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
      operation: "getContentHash()",
      info: { data: data12 }
    });
  }
  async getAvatar() {
    const avatar = await this._getAvatar();
    return avatar.url;
  }
  async _getAvatar() {
    const linkage = [{ type: "name", value: this.name }];
    try {
      const avatar = await this.getText("avatar");
      if (avatar == null) {
        linkage.push({ type: "!avatar", value: "" });
        return { url: null, linkage };
      }
      linkage.push({ type: "avatar", value: avatar });
      for (let i = 0;i < matchers.length; i++) {
        const match = avatar.match(matchers[i]);
        if (match == null) {
          continue;
        }
        const scheme = match[1].toLowerCase();
        switch (scheme) {
          case "https":
          case "data":
            linkage.push({ type: "url", value: avatar });
            return { linkage, url: avatar };
          case "ipfs": {
            const url = getIpfsLink(avatar);
            linkage.push({ type: "ipfs", value: avatar });
            linkage.push({ type: "url", value: url });
            return { linkage, url };
          }
          case "erc721":
          case "erc1155": {
            const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
            linkage.push({ type: scheme, value: avatar });
            const owner = await this.getAddress();
            if (owner == null) {
              linkage.push({ type: "!owner", value: "" });
              return { url: null, linkage };
            }
            const comps = (match[2] || "").split("/");
            if (comps.length !== 2) {
              linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
              return { url: null, linkage };
            }
            const tokenId = comps[1];
            const contract5 = new Contract2(comps[0], [
              "function tokenURI(uint) view returns (string)",
              "function ownerOf(uint) view returns (address)",
              "function uri(uint) view returns (string)",
              "function balanceOf(address, uint256) view returns (uint)"
            ], this.provider);
            if (scheme === "erc721") {
              const tokenOwner = await contract5.ownerOf(tokenId);
              if (owner !== tokenOwner) {
                linkage.push({ type: "!owner", value: tokenOwner });
                return { url: null, linkage };
              }
              linkage.push({ type: "owner", value: tokenOwner });
            } else if (scheme === "erc1155") {
              const balance = await contract5.balanceOf(owner, tokenId);
              if (!balance) {
                linkage.push({ type: "!balance", value: "0" });
                return { url: null, linkage };
              }
              linkage.push({ type: "balance", value: balance.toString() });
            }
            let metadataUrl = await contract5[selector](tokenId);
            if (metadataUrl == null || metadataUrl === "0x") {
              linkage.push({ type: "!metadata-url", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata-url-base", value: metadataUrl });
            if (scheme === "erc1155") {
              metadataUrl = metadataUrl.replace("{id}", toBeHex(tokenId, 32).substring(2));
              linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
            }
            if (metadataUrl.match(/^ipfs:/i)) {
              metadataUrl = getIpfsLink(metadataUrl);
            }
            linkage.push({ type: "metadata-url", value: metadataUrl });
            let metadata = {};
            const response = await new FetchRequest(metadataUrl).send();
            response.assertOk();
            try {
              metadata = response.bodyJson;
            } catch (error) {
              try {
                linkage.push({ type: "!metadata", value: response.bodyText });
              } catch (error2) {
                const bytes10 = response.body;
                if (bytes10) {
                  linkage.push({ type: "!metadata", value: hexlify(bytes10) });
                }
                return { url: null, linkage };
              }
              return { url: null, linkage };
            }
            if (!metadata) {
              linkage.push({ type: "!metadata", value: "" });
              return { url: null, linkage };
            }
            linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
            let imageUrl = metadata.image;
            if (typeof imageUrl !== "string") {
              linkage.push({ type: "!imageUrl", value: "" });
              return { url: null, linkage };
            }
            if (imageUrl.match(/^(https:\/\/|data:)/i)) {
            } else {
              const ipfs = imageUrl.match(matcherIpfs);
              if (ipfs == null) {
                linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                return { url: null, linkage };
              }
              linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
              imageUrl = getIpfsLink(imageUrl);
            }
            linkage.push({ type: "url", value: imageUrl });
            return { linkage, url: imageUrl };
          }
        }
      }
    } catch (error) {
    }
    return { linkage, url: null };
  }
  static async getEnsAddress(provider3) {
    const network = await provider3.getNetwork();
    const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
    assert2(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
      operation: "getEnsAddress",
      info: { network }
    });
    return ensPlugin.address;
  }
  static async#getResolver(provider3, name) {
    const ensAddr = await EnsResolver.getEnsAddress(provider3);
    try {
      const contract5 = new Contract2(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], provider3);
      const addr = await contract5.resolver(namehash2(name), {
        enableCcipRead: true
      });
      if (addr === ZeroAddress) {
        return null;
      }
      return addr;
    } catch (error) {
      throw error;
    }
    return null;
  }
  static async fromName(provider3, name) {
    let currentName = name;
    while (true) {
      if (currentName === "" || currentName === ".") {
        return null;
      }
      if (name !== "eth" && currentName === "eth") {
        return null;
      }
      const addr = await EnsResolver.#getResolver(provider3, currentName);
      if (addr != null) {
        const resolver2 = new EnsResolver(provider3, addr, name);
        if (currentName !== name && !await resolver2.supportsWildcard()) {
          return null;
        }
        return resolver2;
      }
      currentName = currentName.split(".").slice(1).join(".");
    }
  }
}

// ../../node_modules/ethers/lib.esm/providers/format.js
function allowNull(format2, nullValue) {
  return function(value) {
    if (value == null) {
      return nullValue;
    }
    return format2(value);
  };
}
function arrayOf(format2) {
  return (array4) => {
    if (!Array.isArray(array4)) {
      throw new Error("not an array");
    }
    return array4.map((i) => format2(i));
  };
}
function object3(format2, altNames) {
  return (value) => {
    const result = {};
    for (const key in format2) {
      let srcKey = key;
      if (altNames && key in altNames && !(srcKey in value)) {
        for (const altKey of altNames[key]) {
          if (altKey in value) {
            srcKey = altKey;
            break;
          }
        }
      }
      try {
        const nv = format2[key](value[srcKey]);
        if (nv !== undefined) {
          result[key] = nv;
        }
      } catch (error) {
        const message = error instanceof Error ? error.message : "not-an-error";
        assert2(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
      }
    }
    return result;
  };
}
function formatBoolean(value) {
  switch (value) {
    case true:
    case "true":
      return true;
    case false:
    case "false":
      return false;
  }
  assertArgument(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
}
function formatData(value) {
  assertArgument(isHexString2(value, true), "invalid data", "value", value);
  return value;
}
function formatHash(value) {
  assertArgument(isHexString2(value, 32), "invalid hash", "value", value);
  return value;
}
function formatLog(value) {
  return _formatLog(value);
}
function formatBlock(value) {
  const result = _formatBlock(value);
  result.transactions = value.transactions.map((tx2) => {
    if (typeof tx2 === "string") {
      return tx2;
    }
    return formatTransactionResponse(tx2);
  });
  return result;
}
function formatReceiptLog(value) {
  return _formatReceiptLog(value);
}
function formatTransactionReceipt(value) {
  return _formatTransactionReceipt(value);
}
function formatTransactionResponse(value) {
  if (value.to && getBigInt(value.to) === BN_011) {
    value.to = "0x0000000000000000000000000000000000000000";
  }
  const result = object3({
    hash: formatHash,
    type: (value2) => {
      if (value2 === "0x" || value2 == null) {
        return 0;
      }
      return getNumber(value2);
    },
    accessList: allowNull(accessListify, null),
    blockHash: allowNull(formatHash, null),
    blockNumber: allowNull(getNumber, null),
    transactionIndex: allowNull(getNumber, null),
    from: getAddress,
    gasPrice: allowNull(getBigInt),
    maxPriorityFeePerGas: allowNull(getBigInt),
    maxFeePerGas: allowNull(getBigInt),
    gasLimit: getBigInt,
    to: allowNull(getAddress, null),
    value: getBigInt,
    nonce: getNumber,
    data: formatData,
    creates: allowNull(getAddress, null),
    chainId: allowNull(getBigInt, null)
  }, {
    data: ["input"],
    gasLimit: ["gas"]
  })(value);
  if (result.to == null && result.creates == null) {
    result.creates = getCreateAddress(result);
  }
  if ((value.type === 1 || value.type === 2) && value.accessList == null) {
    result.accessList = [];
  }
  if (value.signature) {
    result.signature = Signature2.from(value.signature);
  } else {
    result.signature = Signature2.from(value);
  }
  if (result.chainId == null) {
    const chainId = result.signature.legacyChainId;
    if (chainId != null) {
      result.chainId = chainId;
    }
  }
  if (result.blockHash && getBigInt(result.blockHash) === BN_011) {
    result.blockHash = null;
  }
  return result;
}
var BN_011 = BigInt(0);
var _formatLog = object3({
  address: getAddress,
  blockHash: formatHash,
  blockNumber: getNumber,
  data: formatData,
  index: getNumber,
  removed: allowNull(formatBoolean, false),
  topics: arrayOf(formatHash),
  transactionHash: formatHash,
  transactionIndex: getNumber
}, {
  index: ["logIndex"]
});
var _formatBlock = object3({
  hash: allowNull(formatHash),
  parentHash: formatHash,
  number: getNumber,
  timestamp: getNumber,
  nonce: allowNull(formatData),
  difficulty: getBigInt,
  gasLimit: getBigInt,
  gasUsed: getBigInt,
  miner: allowNull(getAddress),
  extraData: formatData,
  baseFeePerGas: allowNull(getBigInt)
});
var _formatReceiptLog = object3({
  transactionIndex: getNumber,
  blockNumber: getNumber,
  transactionHash: formatHash,
  address: getAddress,
  topics: arrayOf(formatHash),
  data: formatData,
  index: getNumber,
  blockHash: formatHash
}, {
  index: ["logIndex"]
});
var _formatTransactionReceipt = object3({
  to: allowNull(getAddress, null),
  from: allowNull(getAddress, null),
  contractAddress: allowNull(getAddress, null),
  index: getNumber,
  root: allowNull(hexlify),
  gasUsed: getBigInt,
  logsBloom: allowNull(formatData),
  blockHash: formatHash,
  hash: formatHash,
  logs: arrayOf(formatReceiptLog),
  blockNumber: getNumber,
  cumulativeGasUsed: getBigInt,
  effectiveGasPrice: allowNull(getBigInt),
  status: allowNull(getNumber),
  type: allowNull(getNumber, 0)
}, {
  effectiveGasPrice: ["gasPrice"],
  hash: ["transactionHash"],
  index: ["transactionIndex"]
});

// ../../node_modules/ethers/lib.esm/providers/plugins-network.js
var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";

class NetworkPlugin {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  clone() {
    return new NetworkPlugin(this.name);
  }
}

class GasCostPlugin extends NetworkPlugin {
  effectiveBlock;
  txBase;
  txCreate;
  txDataZero;
  txDataNonzero;
  txAccessListStorageKey;
  txAccessListAddress;
  constructor(effectiveBlock, costs) {
    if (effectiveBlock == null) {
      effectiveBlock = 0;
    }
    super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
    const props = { effectiveBlock };
    function set(name, nullish) {
      let value = (costs || {})[name];
      if (value == null) {
        value = nullish;
      }
      assertArgument(typeof value === "number", `invalud value for ${name}`, "costs", costs);
      props[name] = value;
    }
    set("txBase", 21000);
    set("txCreate", 32000);
    set("txDataZero", 4);
    set("txDataNonzero", 16);
    set("txAccessListStorageKey", 1900);
    set("txAccessListAddress", 2400);
    defineProperties(this, props);
  }
  clone() {
    return new GasCostPlugin(this.effectiveBlock, this);
  }
}

class EnsPlugin extends NetworkPlugin {
  address;
  targetNetwork;
  constructor(address22, targetNetwork) {
    super("org.ethers.plugins.network.Ens");
    defineProperties(this, {
      address: address22 || EnsAddress,
      targetNetwork: targetNetwork == null ? 1 : targetNetwork
    });
  }
  clone() {
    return new EnsPlugin(this.address, this.targetNetwork);
  }
}

class FeeDataNetworkPlugin extends NetworkPlugin {
  #feeDataFunc;
  get feeDataFunc() {
    return this.#feeDataFunc;
  }
  constructor(feeDataFunc) {
    super("org.ethers.plugins.network.FeeData");
    this.#feeDataFunc = feeDataFunc;
  }
  async getFeeData(provider3) {
    return await this.#feeDataFunc(provider3);
  }
  clone() {
    return new FeeDataNetworkPlugin(this.#feeDataFunc);
  }
}

class FetchUrlFeeDataNetworkPlugin extends NetworkPlugin {
  #url;
  #processFunc;
  get url() {
    return this.#url;
  }
  get processFunc() {
    return this.#processFunc;
  }
  constructor(url, processFunc) {
    super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    this.#url = url;
    this.#processFunc = processFunc;
  }
  clone() {
    return this;
  }
}

// ../../node_modules/ethers/lib.esm/providers/network.js
var parseUnits2 = function(_value, decimals) {
  const value = String(_value);
  if (!value.match(/^[0-9.]+$/)) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  const comps = value.split(".");
  if (comps.length === 1) {
    comps.push("");
  }
  if (comps.length !== 2) {
    throw new Error(`invalid gwei value: ${_value}`);
  }
  while (comps[1].length < decimals) {
    comps[1] += "0";
  }
  if (comps[1].length > 9) {
    let frac = BigInt(comps[1].substring(0, 9));
    if (!comps[1].substring(9).match(/^0+$/)) {
      frac++;
    }
    comps[1] = frac.toString();
  }
  return BigInt(comps[0] + comps[1]);
};
var getGasStationPlugin = function(url) {
  return new FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider3, request) => {
    request.setHeader("User-Agent", "ethers");
    let response;
    try {
      response = await request.send();
      const payload = response.bodyJson.standard;
      const feeData = {
        maxFeePerGas: parseUnits2(payload.maxFee, 9),
        maxPriorityFeePerGas: parseUnits2(payload.maxPriorityFee, 9)
      };
      return feeData;
    } catch (error) {
      assert2(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
    }
  });
};
var getPriorityFeePlugin = function(maxPriorityFeePerGas) {
  return new FetchUrlFeeDataNetworkPlugin("data:", async (fetchFeeData, provider3, request) => {
    const feeData = await fetchFeeData();
    if (feeData.maxFeePerGas == null || feeData.maxPriorityFeePerGas == null) {
      return feeData;
    }
    const baseFee = feeData.maxFeePerGas - feeData.maxPriorityFeePerGas;
    return {
      gasPrice: feeData.gasPrice,
      maxFeePerGas: baseFee + maxPriorityFeePerGas,
      maxPriorityFeePerGas
    };
  });
};
var injectCommonNetworks = function() {
  if (injected) {
    return;
  }
  injected = true;
  function registerEth(name, chainId, options) {
    const func = function() {
      const network = new Network(name, chainId);
      if (options.ensNetwork != null) {
        network.attachPlugin(new EnsPlugin(null, options.ensNetwork));
      }
      network.attachPlugin(new GasCostPlugin);
      (options.plugins || []).forEach((plugin) => {
        network.attachPlugin(plugin);
      });
      return network;
    };
    Network.register(name, func);
    Network.register(chainId, func);
    if (options.altNames) {
      options.altNames.forEach((name2) => {
        Network.register(name2, func);
      });
    }
  }
  registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
  registerEth("ropsten", 3, { ensNetwork: 3 });
  registerEth("rinkeby", 4, { ensNetwork: 4 });
  registerEth("goerli", 5, { ensNetwork: 5 });
  registerEth("kovan", 42, { ensNetwork: 42 });
  registerEth("sepolia", 11155111, {});
  registerEth("classic", 61, {});
  registerEth("classicKotti", 6, {});
  registerEth("arbitrum", 42161, {
    ensNetwork: 1
  });
  registerEth("arbitrum-goerli", 421613, {});
  registerEth("bnb", 56, { ensNetwork: 1 });
  registerEth("bnbt", 97, {});
  registerEth("linea", 59144, { ensNetwork: 1 });
  registerEth("linea-goerli", 59140, {});
  registerEth("matic", 137, {
    ensNetwork: 1,
    plugins: [
      getGasStationPlugin("https://gasstation.polygon.technology/v2")
    ]
  });
  registerEth("matic-mumbai", 80001, {
    altNames: ["maticMumbai", "maticmum"],
    plugins: [
      getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
    ]
  });
  registerEth("optimism", 10, {
    ensNetwork: 1,
    plugins: [
      getPriorityFeePlugin(BigInt("1000000"))
    ]
  });
  registerEth("optimism-goerli", 420, {});
  registerEth("xdai", 100, { ensNetwork: 1 });
};
var Networks = new Map;

class Network {
  #name;
  #chainId;
  #plugins;
  constructor(name, chainId) {
    this.#name = name;
    this.#chainId = getBigInt(chainId);
    this.#plugins = new Map;
  }
  toJSON() {
    return { name: this.name, chainId: String(this.chainId) };
  }
  get name() {
    return this.#name;
  }
  set name(value) {
    this.#name = value;
  }
  get chainId() {
    return this.#chainId;
  }
  set chainId(value) {
    this.#chainId = getBigInt(value, "chainId");
  }
  matches(other) {
    if (other == null) {
      return false;
    }
    if (typeof other === "string") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return this.name === other;
    }
    if (typeof other === "number" || typeof other === "bigint") {
      try {
        return this.chainId === getBigInt(other);
      } catch (error) {
      }
      return false;
    }
    if (typeof other === "object") {
      if (other.chainId != null) {
        try {
          return this.chainId === getBigInt(other.chainId);
        } catch (error) {
        }
        return false;
      }
      if (other.name != null) {
        return this.name === other.name;
      }
      return false;
    }
    return false;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.clone());
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  getPlugins(basename) {
    return this.plugins.filter((p) => p.name.split("#")[0] === basename);
  }
  clone() {
    const clone = new Network(this.name, this.chainId);
    this.plugins.forEach((plugin) => {
      clone.attachPlugin(plugin.clone());
    });
    return clone;
  }
  computeIntrinsicGas(tx2) {
    const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new GasCostPlugin;
    let gas = costs.txBase;
    if (tx2.to == null) {
      gas += costs.txCreate;
    }
    if (tx2.data) {
      for (let i = 2;i < tx2.data.length; i += 2) {
        if (tx2.data.substring(i, i + 2) === "00") {
          gas += costs.txDataZero;
        } else {
          gas += costs.txDataNonzero;
        }
      }
    }
    if (tx2.accessList) {
      const accessList = accessListify(tx2.accessList);
      for (const addr in accessList) {
        gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
      }
    }
    return gas;
  }
  static from(network) {
    injectCommonNetworks();
    if (network == null) {
      return Network.from("mainnet");
    }
    if (typeof network === "number") {
      network = BigInt(network);
    }
    if (typeof network === "string" || typeof network === "bigint") {
      const networkFunc = Networks.get(network);
      if (networkFunc) {
        return networkFunc();
      }
      if (typeof network === "bigint") {
        return new Network("unknown", network);
      }
      assertArgument(false, "unknown network", "network", network);
    }
    if (typeof network.clone === "function") {
      const clone = network.clone();
      return clone;
    }
    if (typeof network === "object") {
      assertArgument(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
      const custom2 = new Network(network.name, network.chainId);
      if (network.ensAddress || network.ensNetwork != null) {
        custom2.attachPlugin(new EnsPlugin(network.ensAddress, network.ensNetwork));
      }
      return custom2;
    }
    assertArgument(false, "invalid network", "network", network);
  }
  static register(nameOrChainId, networkFunc) {
    if (typeof nameOrChainId === "number") {
      nameOrChainId = BigInt(nameOrChainId);
    }
    const existing = Networks.get(nameOrChainId);
    if (existing) {
      assertArgument(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
    }
    Networks.set(nameOrChainId, networkFunc);
  }
}
var injected = false;

// ../../node_modules/ethers/lib.esm/providers/subscriber-polling.js
var copy = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};
class PollingBlockSubscriber {
  #provider;
  #poller;
  #interval;
  #blockNumber;
  constructor(provider3) {
    this.#provider = provider3;
    this.#poller = null;
    this.#interval = 4000;
    this.#blockNumber = -2;
  }
  get pollingInterval() {
    return this.#interval;
  }
  set pollingInterval(value) {
    this.#interval = value;
  }
  async#poll() {
    try {
      const blockNumber = await this.#provider.getBlockNumber();
      if (this.#blockNumber === -2) {
        this.#blockNumber = blockNumber;
        return;
      }
      if (blockNumber !== this.#blockNumber) {
        for (let b2 = this.#blockNumber + 1;b2 <= blockNumber; b2++) {
          if (this.#poller == null) {
            return;
          }
          await this.#provider.emit("block", b2);
        }
        this.#blockNumber = blockNumber;
      }
    } catch (error) {
    }
    if (this.#poller == null) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
  }
  start() {
    if (this.#poller) {
      return;
    }
    this.#poller = this.#provider._setTimeout(this.#poll.bind(this), this.#interval);
    this.#poll();
  }
  stop() {
    if (!this.#poller) {
      return;
    }
    this.#provider._clearTimeout(this.#poller);
    this.#poller = null;
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}

class OnBlockSubscriber {
  #provider;
  #poll;
  #running;
  constructor(provider3) {
    this.#provider = provider3;
    this.#running = false;
    this.#poll = (blockNumber) => {
      this._poll(blockNumber, this.#provider);
    };
  }
  async _poll(blockNumber, provider3) {
    throw new Error("sub-classes must override this");
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
    this.#provider.on("block", this.#poll);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poll);
  }
  pause(dropWhilePaused) {
    this.stop();
  }
  resume() {
    this.start();
  }
}

class PollingOrphanSubscriber extends OnBlockSubscriber {
  #filter;
  constructor(provider3, filter3) {
    super(provider3);
    this.#filter = copy(filter3);
  }
  async _poll(blockNumber, provider3) {
    throw new Error("@TODO");
    console.log(this.#filter);
  }
}

class PollingTransactionSubscriber extends OnBlockSubscriber {
  #hash;
  constructor(provider3, hash7) {
    super(provider3);
    this.#hash = hash7;
  }
  async _poll(blockNumber, provider3) {
    const tx2 = await provider3.getTransactionReceipt(this.#hash);
    if (tx2) {
      provider3.emit(this.#hash, tx2);
    }
  }
}

class PollingEventSubscriber {
  #provider;
  #filter;
  #poller;
  #running;
  #blockNumber;
  constructor(provider3, filter3) {
    this.#provider = provider3;
    this.#filter = copy(filter3);
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#blockNumber = -2;
  }
  async#poll(blockNumber) {
    if (this.#blockNumber === -2) {
      return;
    }
    const filter3 = copy(this.#filter);
    filter3.fromBlock = this.#blockNumber + 1;
    filter3.toBlock = blockNumber;
    const logs = await this.#provider.getLogs(filter3);
    if (logs.length === 0) {
      if (this.#blockNumber < blockNumber - 60) {
        this.#blockNumber = blockNumber - 60;
      }
      return;
    }
    for (const log of logs) {
      this.#provider.emit(this.#filter, log);
      this.#blockNumber = log.blockNumber;
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    if (this.#blockNumber === -2) {
      this.#provider.getBlockNumber().then((blockNumber) => {
        this.#blockNumber = blockNumber;
      });
    }
    this.#provider.on("block", this.#poller);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    this.stop();
    if (dropWhilePaused) {
      this.#blockNumber = -2;
    }
  }
  resume() {
    this.start();
  }
}

// ../../node_modules/ethers/lib.esm/providers/abstract-provider.js
var isPromise2 = function(value) {
  return value && typeof value.then === "function";
};
var getTag = function(prefix, value) {
  return prefix + ":" + JSON.stringify(value, (k, v) => {
    if (v == null) {
      return "null";
    }
    if (typeof v === "bigint") {
      return `bigint:${v.toString()}`;
    }
    if (typeof v === "string") {
      return v.toLowerCase();
    }
    if (typeof v === "object" && !Array.isArray(v)) {
      const keys = Object.keys(v);
      keys.sort();
      return keys.reduce((accum, key) => {
        accum[key] = v[key];
        return accum;
      }, {});
    }
    return v;
  });
};
var copy2 = function(value) {
  return JSON.parse(JSON.stringify(value));
};
var concisify = function(items) {
  items = Array.from(new Set(items).values());
  items.sort();
  return items;
};
async function getSubscription(_event, provider4) {
  if (_event == null) {
    throw new Error("invalid event");
  }
  if (Array.isArray(_event)) {
    _event = { topics: _event };
  }
  if (typeof _event === "string") {
    switch (_event) {
      case "block":
      case "pending":
      case "debug":
      case "error":
      case "network": {
        return { type: _event, tag: _event };
      }
    }
  }
  if (isHexString2(_event, 32)) {
    const hash8 = _event.toLowerCase();
    return { type: "transaction", tag: getTag("tx", { hash: hash8 }), hash: hash8 };
  }
  if (_event.orphan) {
    const event = _event;
    return { type: "orphan", tag: getTag("orphan", event), filter: copy2(event) };
  }
  if (_event.address || _event.topics) {
    const event = _event;
    const filter3 = {
      topics: (event.topics || []).map((t) => {
        if (t == null) {
          return null;
        }
        if (Array.isArray(t)) {
          return concisify(t.map((t2) => t2.toLowerCase()));
        }
        return t.toLowerCase();
      })
    };
    if (event.address) {
      const addresses = [];
      const promises = [];
      const addAddress = (addr) => {
        if (isHexString2(addr)) {
          addresses.push(addr);
        } else {
          promises.push((async () => {
            addresses.push(await resolveAddress(addr, provider4));
          })());
        }
      };
      if (Array.isArray(event.address)) {
        event.address.forEach(addAddress);
      } else {
        addAddress(event.address);
      }
      if (promises.length) {
        await Promise.all(promises);
      }
      filter3.address = concisify(addresses.map((a) => a.toLowerCase()));
    }
    return { filter: filter3, tag: getTag("event", filter3), type: "event" };
  }
  assertArgument(false, "unknown ProviderEvent", "event", _event);
}
var getTime2 = function() {
  return new Date().getTime();
};
var _parseString = function(result, start) {
  try {
    const bytes10 = _parseBytes(result, start);
    if (bytes10) {
      return toUtf8String(bytes10);
    }
  } catch (error) {
  }
  return null;
};
var _parseBytes = function(result, start) {
  if (result === "0x") {
    return null;
  }
  try {
    const offset = getNumber(dataSlice(result, start, start + 32));
    const length = getNumber(dataSlice(result, offset, offset + 32));
    return dataSlice(result, offset + 32, offset + 32 + length);
  } catch (error) {
  }
  return null;
};
var numPad = function(value) {
  const result = toBeArray(value);
  if (result.length > 32) {
    throw new Error("internal; should not happen");
  }
  const padded = new Uint8Array(32);
  padded.set(result, 32 - result.length);
  return padded;
};
var bytesPad = function(value) {
  if (value.length % 32 === 0) {
    return value;
  }
  const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
  result.set(value);
  return result;
};
var encodeBytes2 = function(datas) {
  const result = [];
  let byteCount = 0;
  for (let i = 0;i < datas.length; i++) {
    result.push(empty);
    byteCount += 32;
  }
  for (let i = 0;i < datas.length; i++) {
    const data12 = getBytes(datas[i]);
    result[i] = numPad(byteCount);
    result.push(numPad(data12.length));
    result.push(bytesPad(data12));
    byteCount += 32 + Math.ceil(data12.length / 32) * 32;
  }
  return concat(result);
};
var parseOffchainLookup = function(data12) {
  const result = {
    sender: "",
    urls: [],
    calldata: "",
    selector: "",
    extraData: "",
    errorArgs: []
  };
  assert2(dataLength(data12) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
    reason: "insufficient OffchainLookup data"
  });
  const sender = dataSlice(data12, 0, 32);
  assert2(dataSlice(sender, 0, 12) === dataSlice(zeros2, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup sender"
  });
  result.sender = dataSlice(sender, 12);
  try {
    const urls = [];
    const urlsOffset = getNumber(dataSlice(data12, 32, 64));
    const urlsLength = getNumber(dataSlice(data12, urlsOffset, urlsOffset + 32));
    const urlsData = dataSlice(data12, urlsOffset + 32);
    for (let u = 0;u < urlsLength; u++) {
      const url = _parseString(urlsData, u * 32);
      if (url == null) {
        throw new Error("abort");
      }
      urls.push(url);
    }
    result.urls = urls;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup urls"
    });
  }
  try {
    const calldata = _parseBytes(data12, 64);
    if (calldata == null) {
      throw new Error("abort");
    }
    result.calldata = calldata;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup calldata"
    });
  }
  assert2(dataSlice(data12, 100, 128) === dataSlice(zeros2, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
    reason: "corrupt OffchainLookup callbaackSelector"
  });
  result.selector = dataSlice(data12, 96, 100);
  try {
    const extraData = _parseBytes(data12, 128);
    if (extraData == null) {
      throw new Error("abort");
    }
    result.extraData = extraData;
  } catch (error) {
    assert2(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
      reason: "corrupt OffchainLookup extraData"
    });
  }
  result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k) => result[k]);
  return result;
};
var BN_23 = BigInt(2);
var MAX_CCIP_REDIRECTS = 10;

class UnmanagedSubscriber {
  name;
  constructor(name) {
    defineProperties(this, { name });
  }
  start() {
  }
  stop() {
  }
  pause(dropWhilePaused) {
  }
  resume() {
  }
}
var defaultOptions = {
  cacheTimeout: 250,
  pollingInterval: 4000
};

class AbstractProvider {
  #subs;
  #plugins;
  #pausedState;
  #destroyed;
  #networkPromise;
  #anyNetwork;
  #performCache;
  #lastBlockNumber;
  #nextTimer;
  #timers;
  #disableCcipRead;
  #options;
  constructor(_network, options) {
    this.#options = Object.assign({}, defaultOptions, options || {});
    if (_network === "any") {
      this.#anyNetwork = true;
      this.#networkPromise = null;
    } else if (_network) {
      const network2 = Network.from(_network);
      this.#anyNetwork = false;
      this.#networkPromise = Promise.resolve(network2);
      setTimeout(() => {
        this.emit("network", network2, null);
      }, 0);
    } else {
      this.#anyNetwork = false;
      this.#networkPromise = null;
    }
    this.#lastBlockNumber = -1;
    this.#performCache = new Map;
    this.#subs = new Map;
    this.#plugins = new Map;
    this.#pausedState = null;
    this.#destroyed = false;
    this.#nextTimer = 1;
    this.#timers = new Map;
    this.#disableCcipRead = false;
  }
  get pollingInterval() {
    return this.#options.pollingInterval;
  }
  get provider() {
    return this;
  }
  get plugins() {
    return Array.from(this.#plugins.values());
  }
  attachPlugin(plugin) {
    if (this.#plugins.get(plugin.name)) {
      throw new Error(`cannot replace existing plugin: ${plugin.name} `);
    }
    this.#plugins.set(plugin.name, plugin.connect(this));
    return this;
  }
  getPlugin(name) {
    return this.#plugins.get(name) || null;
  }
  get disableCcipRead() {
    return this.#disableCcipRead;
  }
  set disableCcipRead(value) {
    this.#disableCcipRead = !!value;
  }
  async#perform(req) {
    const timeout = this.#options.cacheTimeout;
    if (timeout < 0) {
      return await this._perform(req);
    }
    const tag = getTag(req.method, req);
    let perform = this.#performCache.get(tag);
    if (!perform) {
      perform = this._perform(req);
      this.#performCache.set(tag, perform);
      setTimeout(() => {
        if (this.#performCache.get(tag) === perform) {
          this.#performCache.delete(tag);
        }
      }, timeout);
    }
    return await perform;
  }
  async ccipReadFetch(tx2, calldata, urls) {
    if (this.disableCcipRead || urls.length === 0 || tx2.to == null) {
      return null;
    }
    const sender = tx2.to.toLowerCase();
    const data12 = calldata.toLowerCase();
    const errorMessages = [];
    for (let i = 0;i < urls.length; i++) {
      const url = urls[i];
      const href = url.replace("{sender}", sender).replace("{data}", data12);
      const request = new FetchRequest(href);
      if (url.indexOf("{data}") === -1) {
        request.body = { data: data12, sender };
      }
      this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i, urls });
      let errorMessage = "unknown error";
      const resp = await request.send();
      try {
        const result = resp.bodyJson;
        if (result.data) {
          this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
          return result.data;
        }
        if (result.message) {
          errorMessage = result.message;
        }
        this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
      } catch (error) {
      }
      assert2(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx2, info: { url, errorMessage } });
      errorMessages.push(errorMessage);
    }
    assert2(false, `error encountered during CCIP fetch: ${errorMessages.map((m) => JSON.stringify(m)).join(", ")}`, "OFFCHAIN_FAULT", {
      reason: "500_SERVER_ERROR",
      transaction: tx2,
      info: { urls, errorMessages }
    });
  }
  _wrapBlock(value, network2) {
    return new Block(formatBlock(value), this);
  }
  _wrapLog(value, network2) {
    return new Log(formatLog(value), this);
  }
  _wrapTransactionReceipt(value, network2) {
    return new TransactionReceipt(formatTransactionReceipt(value), this);
  }
  _wrapTransactionResponse(tx2, network2) {
    return new TransactionResponse(formatTransactionResponse(tx2), this);
  }
  _detectNetwork() {
    assert2(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
      operation: "_detectNetwork"
    });
  }
  async _perform(req) {
    assert2(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
      operation: req.method,
      info: req
    });
  }
  async getBlockNumber() {
    const blockNumber = getNumber(await this.#perform({ method: "getBlockNumber" }), "%response");
    if (this.#lastBlockNumber >= 0) {
      this.#lastBlockNumber = blockNumber;
    }
    return blockNumber;
  }
  _getAddress(address23) {
    return resolveAddress(address23, this);
  }
  _getBlockTag(blockTag) {
    if (blockTag == null) {
      return "latest";
    }
    switch (blockTag) {
      case "earliest":
        return "0x0";
      case "latest":
      case "pending":
      case "safe":
      case "finalized":
        return blockTag;
    }
    if (isHexString2(blockTag)) {
      if (isHexString2(blockTag, 32)) {
        return blockTag;
      }
      return toQuantity(blockTag);
    }
    if (typeof blockTag === "bigint") {
      blockTag = getNumber(blockTag, "blockTag");
    }
    if (typeof blockTag === "number") {
      if (blockTag >= 0) {
        return toQuantity(blockTag);
      }
      if (this.#lastBlockNumber >= 0) {
        return toQuantity(this.#lastBlockNumber + blockTag);
      }
      return this.getBlockNumber().then((b2) => toQuantity(b2 + blockTag));
    }
    assertArgument(false, "invalid blockTag", "blockTag", blockTag);
  }
  _getFilter(filter3) {
    const topics = (filter3.topics || []).map((t) => {
      if (t == null) {
        return null;
      }
      if (Array.isArray(t)) {
        return concisify(t.map((t2) => t2.toLowerCase()));
      }
      return t.toLowerCase();
    });
    const blockHash = "blockHash" in filter3 ? filter3.blockHash : undefined;
    const resolve = (_address, fromBlock2, toBlock2) => {
      let address24 = undefined;
      switch (_address.length) {
        case 0:
          break;
        case 1:
          address24 = _address[0];
          break;
        default:
          _address.sort();
          address24 = _address;
      }
      if (blockHash) {
        if (fromBlock2 != null || toBlock2 != null) {
          throw new Error("invalid filter");
        }
      }
      const filter4 = {};
      if (address24) {
        filter4.address = address24;
      }
      if (topics.length) {
        filter4.topics = topics;
      }
      if (fromBlock2) {
        filter4.fromBlock = fromBlock2;
      }
      if (toBlock2) {
        filter4.toBlock = toBlock2;
      }
      if (blockHash) {
        filter4.blockHash = blockHash;
      }
      return filter4;
    };
    let address23 = [];
    if (filter3.address) {
      if (Array.isArray(filter3.address)) {
        for (const addr of filter3.address) {
          address23.push(this._getAddress(addr));
        }
      } else {
        address23.push(this._getAddress(filter3.address));
      }
    }
    let fromBlock = undefined;
    if ("fromBlock" in filter3) {
      fromBlock = this._getBlockTag(filter3.fromBlock);
    }
    let toBlock = undefined;
    if ("toBlock" in filter3) {
      toBlock = this._getBlockTag(filter3.toBlock);
    }
    if (address23.filter((a) => typeof a !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
      return Promise.all([Promise.all(address23), fromBlock, toBlock]).then((result) => {
        return resolve(result[0], result[1], result[2]);
      });
    }
    return resolve(address23, fromBlock, toBlock);
  }
  _getTransactionRequest(_request) {
    const request = copyRequest(_request);
    const promises = [];
    ["to", "from"].forEach((key) => {
      if (request[key] == null) {
        return;
      }
      const addr = resolveAddress(request[key]);
      if (isPromise2(addr)) {
        promises.push(async function() {
          request[key] = await addr;
        }());
      } else {
        request[key] = addr;
      }
    });
    if (request.blockTag != null) {
      const blockTag = this._getBlockTag(request.blockTag);
      if (isPromise2(blockTag)) {
        promises.push(async function() {
          request.blockTag = await blockTag;
        }());
      } else {
        request.blockTag = blockTag;
      }
    }
    if (promises.length) {
      return async function() {
        await Promise.all(promises);
        return request;
      }();
    }
    return request;
  }
  async getNetwork() {
    if (this.#networkPromise == null) {
      const detectNetwork = this._detectNetwork().then((network2) => {
        this.emit("network", network2, null);
        return network2;
      }, (error) => {
        if (this.#networkPromise === detectNetwork) {
          this.#networkPromise = null;
        }
        throw error;
      });
      this.#networkPromise = detectNetwork;
      return (await detectNetwork).clone();
    }
    const networkPromise = this.#networkPromise;
    const [expected, actual] = await Promise.all([
      networkPromise,
      this._detectNetwork()
    ]);
    if (expected.chainId !== actual.chainId) {
      if (this.#anyNetwork) {
        this.emit("network", actual, expected);
        if (this.#networkPromise === networkPromise) {
          this.#networkPromise = Promise.resolve(actual);
        }
      } else {
        assert2(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
          event: "changed"
        });
      }
    }
    return expected.clone();
  }
  async getFeeData() {
    const network2 = await this.getNetwork();
    const getFeeDataFunc = async () => {
      const { _block, gasPrice } = await resolveProperties({
        _block: this.#getBlock("latest", false),
        gasPrice: (async () => {
          try {
            const gasPrice2 = await this.#perform({ method: "getGasPrice" });
            return getBigInt(gasPrice2, "%response");
          } catch (error) {
          }
          return null;
        })()
      });
      let maxFeePerGas = null, maxPriorityFeePerGas = null;
      const block4 = this._wrapBlock(_block, network2);
      if (block4 && block4.baseFeePerGas) {
        maxPriorityFeePerGas = BigInt("1000000000");
        maxFeePerGas = block4.baseFeePerGas * BN_23 + maxPriorityFeePerGas;
      }
      return new FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
    };
    const plugin = network2.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
    if (plugin) {
      const req = new FetchRequest(plugin.url);
      const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
      return new FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
    }
    return await getFeeDataFunc();
  }
  async estimateGas(_tx) {
    let tx2 = this._getTransactionRequest(_tx);
    if (isPromise2(tx2)) {
      tx2 = await tx2;
    }
    return getBigInt(await this.#perform({
      method: "estimateGas",
      transaction: tx2
    }), "%response");
  }
  async#call(tx2, blockTag, attempt) {
    assert2(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
      reason: "TOO_MANY_REDIRECTS",
      transaction: Object.assign({}, tx2, { blockTag, enableCcipRead: true })
    });
    const transaction7 = copyRequest(tx2);
    try {
      return hexlify(await this._perform({ method: "call", transaction: transaction7, blockTag }));
    } catch (error) {
      if (!this.disableCcipRead && isCallException(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction7.to != null && dataSlice(error.data, 0, 4) === "0x556f1830") {
        const data12 = error.data;
        const txSender = await resolveAddress(transaction7.to, this);
        let ccipArgs;
        try {
          ccipArgs = parseOffchainLookup(dataSlice(error.data, 4));
        } catch (error2) {
          assert2(false, error2.message, "OFFCHAIN_FAULT", {
            reason: "BAD_DATA",
            transaction: transaction7,
            info: { data: data12 }
          });
        }
        assert2(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
          action: "call",
          data: data12,
          reason: "OffchainLookup",
          transaction: transaction7,
          invocation: null,
          revert: {
            signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
            name: "OffchainLookup",
            args: ccipArgs.errorArgs
          }
        });
        const ccipResult = await this.ccipReadFetch(transaction7, ccipArgs.calldata, ccipArgs.urls);
        assert2(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
          reason: "FETCH_FAILED",
          transaction: transaction7,
          info: { data: error.data, errorArgs: ccipArgs.errorArgs }
        });
        const tx3 = {
          to: txSender,
          data: concat([ccipArgs.selector, encodeBytes2([ccipResult, ccipArgs.extraData])])
        };
        this.emit("debug", { action: "sendCcipReadCall", transaction: tx3 });
        try {
          const result = await this.#call(tx3, blockTag, attempt + 1);
          this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx3), result });
          return result;
        } catch (error2) {
          this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx3), error: error2 });
          throw error2;
        }
      }
      throw error;
    }
  }
  async#checkNetwork(promise) {
    const { value } = await resolveProperties({
      network: this.getNetwork(),
      value: promise
    });
    return value;
  }
  async call(_tx) {
    const { tx: tx2, blockTag } = await resolveProperties({
      tx: this._getTransactionRequest(_tx),
      blockTag: this._getBlockTag(_tx.blockTag)
    });
    return await this.#checkNetwork(this.#call(tx2, blockTag, _tx.enableCcipRead ? 0 : -1));
  }
  async#getAccountValue(request, _address, _blockTag) {
    let address23 = this._getAddress(_address);
    let blockTag = this._getBlockTag(_blockTag);
    if (typeof address23 !== "string" || typeof blockTag !== "string") {
      [address23, blockTag] = await Promise.all([address23, blockTag]);
    }
    return await this.#checkNetwork(this.#perform(Object.assign(request, { address: address23, blockTag })));
  }
  async getBalance(address23, blockTag) {
    return getBigInt(await this.#getAccountValue({ method: "getBalance" }, address23, blockTag), "%response");
  }
  async getTransactionCount(address23, blockTag) {
    return getNumber(await this.#getAccountValue({ method: "getTransactionCount" }, address23, blockTag), "%response");
  }
  async getCode(address23, blockTag) {
    return hexlify(await this.#getAccountValue({ method: "getCode" }, address23, blockTag));
  }
  async getStorage(address23, _position, blockTag) {
    const position = getBigInt(_position, "position");
    return hexlify(await this.#getAccountValue({ method: "getStorage", position }, address23, blockTag));
  }
  async broadcastTransaction(signedTx) {
    const { blockNumber, hash: hash8, network: network2 } = await resolveProperties({
      blockNumber: this.getBlockNumber(),
      hash: this._perform({
        method: "broadcastTransaction",
        signedTransaction: signedTx
      }),
      network: this.getNetwork()
    });
    const tx2 = Transaction2.from(signedTx);
    if (tx2.hash !== hash8) {
      throw new Error("@TODO: the returned hash did not match");
    }
    return this._wrapTransactionResponse(tx2, network2).replaceableTransaction(blockNumber);
  }
  async#getBlock(block4, includeTransactions) {
    if (isHexString2(block4, 32)) {
      return await this.#perform({
        method: "getBlock",
        blockHash: block4,
        includeTransactions
      });
    }
    let blockTag = this._getBlockTag(block4);
    if (typeof blockTag !== "string") {
      blockTag = await blockTag;
    }
    return await this.#perform({
      method: "getBlock",
      blockTag,
      includeTransactions
    });
  }
  async getBlock(block4, prefetchTxs) {
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#getBlock(block4, !!prefetchTxs)
    });
    if (params == null) {
      return null;
    }
    return this._wrapBlock(params, network2);
  }
  async getTransaction(hash8) {
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransaction", hash: hash8 })
    });
    if (params == null) {
      return null;
    }
    return this._wrapTransactionResponse(params, network2);
  }
  async getTransactionReceipt(hash8) {
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getTransactionReceipt", hash: hash8 })
    });
    if (params == null) {
      return null;
    }
    if (params.gasPrice == null && params.effectiveGasPrice == null) {
      const tx2 = await this.#perform({ method: "getTransaction", hash: hash8 });
      if (tx2 == null) {
        throw new Error("report this; could not find tx or effectiveGasPrice");
      }
      params.effectiveGasPrice = tx2.gasPrice;
    }
    return this._wrapTransactionReceipt(params, network2);
  }
  async getTransactionResult(hash8) {
    const { result } = await resolveProperties({
      network: this.getNetwork(),
      result: this.#perform({ method: "getTransactionResult", hash: hash8 })
    });
    if (result == null) {
      return null;
    }
    return hexlify(result);
  }
  async getLogs(_filter) {
    let filter3 = this._getFilter(_filter);
    if (isPromise2(filter3)) {
      filter3 = await filter3;
    }
    const { network: network2, params } = await resolveProperties({
      network: this.getNetwork(),
      params: this.#perform({ method: "getLogs", filter: filter3 })
    });
    return params.map((p) => this._wrapLog(p, network2));
  }
  _getProvider(chainId) {
    assert2(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
      operation: "_getProvider()"
    });
  }
  async getResolver(name) {
    return await EnsResolver.fromName(this, name);
  }
  async getAvatar(name) {
    const resolver2 = await this.getResolver(name);
    if (resolver2) {
      return await resolver2.getAvatar();
    }
    return null;
  }
  async resolveName(name) {
    const resolver2 = await this.getResolver(name);
    if (resolver2) {
      return await resolver2.getAddress();
    }
    return null;
  }
  async lookupAddress(address23) {
    address23 = getAddress(address23);
    const node = namehash2(address23.substring(2).toLowerCase() + ".addr.reverse");
    try {
      const ensAddr = await EnsResolver.getEnsAddress(this);
      const ensContract = new Contract2(ensAddr, [
        "function resolver(bytes32) view returns (address)"
      ], this);
      const resolver2 = await ensContract.resolver(node);
      if (resolver2 == null || resolver2 === ZeroAddress) {
        return null;
      }
      const resolverContract = new Contract2(resolver2, [
        "function name(bytes32) view returns (string)"
      ], this);
      const name = await resolverContract.name(node);
      const check = await this.resolveName(name);
      if (check !== address23) {
        return null;
      }
      return name;
    } catch (error) {
      if (isError(error, "BAD_DATA") && error.value === "0x") {
        return null;
      }
      if (isError(error, "CALL_EXCEPTION")) {
        return null;
      }
      throw error;
    }
    return null;
  }
  async waitForTransaction(hash8, _confirms, timeout) {
    const confirms = _confirms != null ? _confirms : 1;
    if (confirms === 0) {
      return this.getTransactionReceipt(hash8);
    }
    return new Promise(async (resolve, reject) => {
      let timer = null;
      const listener = async (blockNumber) => {
        try {
          const receipt = await this.getTransactionReceipt(hash8);
          if (receipt != null) {
            if (blockNumber - receipt.blockNumber + 1 >= confirms) {
              resolve(receipt);
              if (timer) {
                clearTimeout(timer);
                timer = null;
              }
              return;
            }
          }
        } catch (error) {
          console.log("EEE", error);
        }
        this.once("block", listener);
      };
      if (timeout != null) {
        timer = setTimeout(() => {
          if (timer == null) {
            return;
          }
          timer = null;
          this.off("block", listener);
          reject(makeError("timeout", "TIMEOUT", { reason: "timeout" }));
        }, timeout);
      }
      listener(await this.getBlockNumber());
    });
  }
  async waitForBlock(blockTag) {
    assert2(false, "not implemented yet", "NOT_IMPLEMENTED", {
      operation: "waitForBlock"
    });
  }
  _clearTimeout(timerId) {
    const timer = this.#timers.get(timerId);
    if (!timer) {
      return;
    }
    if (timer.timer) {
      clearTimeout(timer.timer);
    }
    this.#timers.delete(timerId);
  }
  _setTimeout(_func, timeout) {
    if (timeout == null) {
      timeout = 0;
    }
    const timerId = this.#nextTimer++;
    const func = () => {
      this.#timers.delete(timerId);
      _func();
    };
    if (this.paused) {
      this.#timers.set(timerId, { timer: null, func, time: timeout });
    } else {
      const timer = setTimeout(func, timeout);
      this.#timers.set(timerId, { timer, func, time: getTime2() });
    }
    return timerId;
  }
  _forEachSubscriber(func) {
    for (const sub of this.#subs.values()) {
      func(sub.subscriber);
    }
  }
  _getSubscriber(sub) {
    switch (sub.type) {
      case "debug":
      case "error":
      case "network":
        return new UnmanagedSubscriber(sub.type);
      case "block": {
        const subscriber = new PollingBlockSubscriber(this);
        subscriber.pollingInterval = this.pollingInterval;
        return subscriber;
      }
      case "event":
        return new PollingEventSubscriber(this, sub.filter);
      case "transaction":
        return new PollingTransactionSubscriber(this, sub.hash);
      case "orphan":
        return new PollingOrphanSubscriber(this, sub.filter);
    }
    throw new Error(`unsupported event: ${sub.type}`);
  }
  _recoverSubscriber(oldSub, newSub) {
    for (const sub of this.#subs.values()) {
      if (sub.subscriber === oldSub) {
        if (sub.started) {
          sub.subscriber.stop();
        }
        sub.subscriber = newSub;
        if (sub.started) {
          newSub.start();
        }
        if (this.#pausedState != null) {
          newSub.pause(this.#pausedState);
        }
        break;
      }
    }
  }
  async#hasSub(event, emitArgs) {
    let sub = await getSubscription(event, this);
    if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
      sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
    }
    return this.#subs.get(sub.tag) || null;
  }
  async#getSub(event) {
    const subscription = await getSubscription(event, this);
    const tag = subscription.tag;
    let sub = this.#subs.get(tag);
    if (!sub) {
      const subscriber = this._getSubscriber(subscription);
      const addressableMap = new WeakMap;
      const nameMap = new Map;
      sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
      this.#subs.set(tag, sub);
    }
    return sub;
  }
  async on(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: false });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async once(event, listener) {
    const sub = await this.#getSub(event);
    sub.listeners.push({ listener, once: true });
    if (!sub.started) {
      sub.subscriber.start();
      sub.started = true;
      if (this.#pausedState != null) {
        sub.subscriber.pause(this.#pausedState);
      }
    }
    return this;
  }
  async emit(event, ...args) {
    const sub = await this.#hasSub(event, args);
    if (!sub || sub.listeners.length === 0) {
      return false;
    }
    const count = sub.listeners.length;
    sub.listeners = sub.listeners.filter(({ listener, once }) => {
      const payload = new EventPayload(this, once ? null : listener, event);
      try {
        listener.call(this, ...args, payload);
      } catch (error) {
      }
      return !once;
    });
    if (sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return count > 0;
  }
  async listenerCount(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return 0;
      }
      return sub.listeners.length;
    }
    let total = 0;
    for (const { listeners } of this.#subs.values()) {
      total += listeners.length;
    }
    return total;
  }
  async listeners(event) {
    if (event) {
      const sub = await this.#hasSub(event);
      if (!sub) {
        return [];
      }
      return sub.listeners.map(({ listener }) => listener);
    }
    let result = [];
    for (const { listeners } of this.#subs.values()) {
      result = result.concat(listeners.map(({ listener }) => listener));
    }
    return result;
  }
  async off(event, listener) {
    const sub = await this.#hasSub(event);
    if (!sub) {
      return this;
    }
    if (listener) {
      const index = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
      if (index >= 0) {
        sub.listeners.splice(index, 1);
      }
    }
    if (!listener || sub.listeners.length === 0) {
      if (sub.started) {
        sub.subscriber.stop();
      }
      this.#subs.delete(sub.tag);
    }
    return this;
  }
  async removeAllListeners(event) {
    if (event) {
      const { tag, started, subscriber } = await this.#getSub(event);
      if (started) {
        subscriber.stop();
      }
      this.#subs.delete(tag);
    } else {
      for (const [tag, { started, subscriber }] of this.#subs) {
        if (started) {
          subscriber.stop();
        }
        this.#subs.delete(tag);
      }
    }
    return this;
  }
  async addListener(event, listener) {
    return await this.on(event, listener);
  }
  async removeListener(event, listener) {
    return this.off(event, listener);
  }
  get destroyed() {
    return this.#destroyed;
  }
  destroy() {
    this.removeAllListeners();
    for (const timerId of this.#timers.keys()) {
      this._clearTimeout(timerId);
    }
    this.#destroyed = true;
  }
  get paused() {
    return this.#pausedState != null;
  }
  set paused(pause) {
    if (!!pause === this.paused) {
      return;
    }
    if (this.paused) {
      this.resume();
    } else {
      this.pause(false);
    }
  }
  pause(dropWhilePaused) {
    this.#lastBlockNumber = -1;
    if (this.#pausedState != null) {
      if (this.#pausedState == !!dropWhilePaused) {
        return;
      }
      assert2(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
        operation: "pause"
      });
    }
    this._forEachSubscriber((s) => s.pause(dropWhilePaused));
    this.#pausedState = !!dropWhilePaused;
    for (const timer of this.#timers.values()) {
      if (timer.timer) {
        clearTimeout(timer.timer);
      }
      timer.time = getTime2() - timer.time;
    }
  }
  resume() {
    if (this.#pausedState == null) {
      return;
    }
    this._forEachSubscriber((s) => s.resume());
    this.#pausedState = null;
    for (const timer of this.#timers.values()) {
      let timeout = timer.time;
      if (timeout < 0) {
        timeout = 0;
      }
      timer.time = getTime2();
      setTimeout(timer.func, timeout);
    }
  }
}
var empty = new Uint8Array([]);
var zeros2 = "0x0000000000000000000000000000000000000000000000000000000000000000";
// ../../node_modules/ethers/lib.esm/providers/abstract-signer.js
var checkProvider = function(signer, operation) {
  if (signer.provider) {
    return signer.provider;
  }
  assert2(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
};
async function populate(signer, tx2) {
  let pop = copyRequest(tx2);
  if (pop.to != null) {
    pop.to = resolveAddress(pop.to, signer);
  }
  if (pop.from != null) {
    const from = pop.from;
    pop.from = Promise.all([
      signer.getAddress(),
      resolveAddress(from, signer)
    ]).then(([address24, from2]) => {
      assertArgument(address24.toLowerCase() === from2.toLowerCase(), "transaction from mismatch", "tx.from", from2);
      return address24;
    });
  } else {
    pop.from = signer.getAddress();
  }
  return await resolveProperties(pop);
}

class AbstractSigner {
  provider;
  constructor(provider5) {
    defineProperties(this, { provider: provider5 || null });
  }
  async getNonce(blockTag) {
    return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
  }
  async populateCall(tx2) {
    const pop = await populate(this, tx2);
    return pop;
  }
  async populateTransaction(tx2) {
    const provider5 = checkProvider(this, "populateTransaction");
    const pop = await populate(this, tx2);
    if (pop.nonce == null) {
      pop.nonce = await this.getNonce("pending");
    }
    if (pop.gasLimit == null) {
      pop.gasLimit = await this.estimateGas(pop);
    }
    const network2 = await this.provider.getNetwork();
    if (pop.chainId != null) {
      const chainId = getBigInt(pop.chainId);
      assertArgument(chainId === network2.chainId, "transaction chainId mismatch", "tx.chainId", tx2.chainId);
    } else {
      pop.chainId = network2.chainId;
    }
    const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
    if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
      assertArgument(false, "eip-1559 transaction do not support gasPrice", "tx", tx2);
    } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
      assertArgument(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx2);
    }
    if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
      pop.type = 2;
    } else if (pop.type === 0 || pop.type === 1) {
      const feeData = await provider5.getFeeData();
      assert2(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
        operation: "getGasPrice"
      });
      if (pop.gasPrice == null) {
        pop.gasPrice = feeData.gasPrice;
      }
    } else {
      const feeData = await provider5.getFeeData();
      if (pop.type == null) {
        if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
          pop.type = 2;
          if (pop.gasPrice != null) {
            const gasPrice = pop.gasPrice;
            delete pop.gasPrice;
            pop.maxFeePerGas = gasPrice;
            pop.maxPriorityFeePerGas = gasPrice;
          } else {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        } else if (feeData.gasPrice != null) {
          assert2(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
            operation: "populateTransaction"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
          pop.type = 0;
        } else {
          assert2(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
            operation: "signer.getFeeData"
          });
        }
      } else if (pop.type === 2) {
        if (pop.maxFeePerGas == null) {
          pop.maxFeePerGas = feeData.maxFeePerGas;
        }
        if (pop.maxPriorityFeePerGas == null) {
          pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
        }
      }
    }
    return await resolveProperties(pop);
  }
  async estimateGas(tx2) {
    return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx2));
  }
  async call(tx2) {
    return checkProvider(this, "call").call(await this.populateCall(tx2));
  }
  async resolveName(name) {
    const provider5 = checkProvider(this, "resolveName");
    return await provider5.resolveName(name);
  }
  async sendTransaction(tx2) {
    const provider5 = checkProvider(this, "sendTransaction");
    const pop = await this.populateTransaction(tx2);
    delete pop.from;
    const txObj = Transaction2.from(pop);
    return await provider5.broadcastTransaction(await this.signTransaction(txObj));
  }
}

class VoidSigner extends AbstractSigner {
  address;
  constructor(address24, provider5) {
    super(provider5);
    defineProperties(this, { address: address24 });
  }
  async getAddress() {
    return this.address;
  }
  connect(provider5) {
    return new VoidSigner(this.address, provider5);
  }
  #throwUnsupported(suffix, operation) {
    assert2(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
  }
  async signTransaction(tx2) {
    this.#throwUnsupported("transactions", "signTransaction");
  }
  async signMessage(message) {
    this.#throwUnsupported("messages", "signMessage");
  }
  async signTypedData(domain, types15, value) {
    this.#throwUnsupported("typed-data", "signTypedData");
  }
}
// ../../node_modules/ethers/lib.esm/providers/community.js
function showThrottleMessage(service2) {
  if (shown.has(service2)) {
    return;
  }
  shown.add(service2);
  console.log("========= NOTICE =========");
  console.log(`Request-Rate Exceeded for ${service2} (this message will not be repeated)`);
  console.log("");
  console.log("The default API keys for each service are provided as a highly-throttled,");
  console.log("community resource for low-traffic projects and early prototyping.");
  console.log("");
  console.log("While your application will continue to function, we highly recommended");
  console.log("signing up for your own API keys to improve performance, increase your");
  console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
  console.log("");
  console.log("For more details: https://docs.ethers.org/api-keys/");
  console.log("==========================");
}
var shown = new Set;
// ../../node_modules/ethers/lib.esm/providers/subscriber-filterid.js
var copy3 = function(obj) {
  return JSON.parse(JSON.stringify(obj));
};

class FilterIdSubscriber {
  #provider;
  #filterIdPromise;
  #poller;
  #running;
  #network;
  #hault;
  constructor(provider5) {
    this.#provider = provider5;
    this.#filterIdPromise = null;
    this.#poller = this.#poll.bind(this);
    this.#running = false;
    this.#network = null;
    this.#hault = false;
  }
  _subscribe(provider5) {
    throw new Error("subclasses must override this");
  }
  _emitResults(provider5, result) {
    throw new Error("subclasses must override this");
  }
  _recover(provider5) {
    throw new Error("subclasses must override this");
  }
  async#poll(blockNumber) {
    try {
      if (this.#filterIdPromise == null) {
        this.#filterIdPromise = this._subscribe(this.#provider);
      }
      let filterId = null;
      try {
        filterId = await this.#filterIdPromise;
      } catch (error) {
        if (!isError(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
          throw error;
        }
      }
      if (filterId == null) {
        this.#filterIdPromise = null;
        this.#provider._recoverSubscriber(this, this._recover(this.#provider));
        return;
      }
      const network2 = await this.#provider.getNetwork();
      if (!this.#network) {
        this.#network = network2;
      }
      if (this.#network.chainId !== network2.chainId) {
        throw new Error("chaid changed");
      }
      if (this.#hault) {
        return;
      }
      const result = await this.#provider.send("eth_getFilterChanges", [filterId]);
      await this._emitResults(this.#provider, result);
    } catch (error) {
      console.log("@TODO", error);
    }
    this.#provider.once("block", this.#poller);
  }
  #teardown() {
    const filterIdPromise = this.#filterIdPromise;
    if (filterIdPromise) {
      this.#filterIdPromise = null;
      filterIdPromise.then((filterId) => {
        this.#provider.send("eth_uninstallFilter", [filterId]);
      });
    }
  }
  start() {
    if (this.#running) {
      return;
    }
    this.#running = true;
    this.#poll(-2);
  }
  stop() {
    if (!this.#running) {
      return;
    }
    this.#running = false;
    this.#hault = true;
    this.#teardown();
    this.#provider.off("block", this.#poller);
  }
  pause(dropWhilePaused) {
    if (dropWhilePaused) {
      this.#teardown();
    }
    this.#provider.off("block", this.#poller);
  }
  resume() {
    this.start();
  }
}

class FilterIdEventSubscriber extends FilterIdSubscriber {
  #event;
  constructor(provider5, filter3) {
    super(provider5);
    this.#event = copy3(filter3);
  }
  _recover(provider5) {
    return new PollingEventSubscriber(provider5, this.#event);
  }
  async _subscribe(provider5) {
    const filterId = await provider5.send("eth_newFilter", [this.#event]);
    return filterId;
  }
  async _emitResults(provider5, results) {
    for (const result of results) {
      provider5.emit(this.#event, provider5._wrapLog(result, provider5._network));
    }
  }
}

class FilterIdPendingSubscriber extends FilterIdSubscriber {
  async _subscribe(provider5) {
    return await provider5.send("eth_newPendingTransactionFilter", []);
  }
  async _emitResults(provider5, results) {
    for (const result of results) {
      provider5.emit("pending", result);
    }
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-jsonrpc.js
var deepCopy = function(value) {
  if (value == null || Primitive.indexOf(typeof value) >= 0) {
    return value;
  }
  if (typeof value.getAddress === "function") {
    return value;
  }
  if (Array.isArray(value)) {
    return value.map(deepCopy);
  }
  if (typeof value === "object") {
    return Object.keys(value).reduce((accum, key) => {
      accum[key] = value[key];
      return accum;
    }, {});
  }
  throw new Error(`should not happen: ${value} (${typeof value})`);
};
var stall = function(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
};
var getLowerCase = function(value) {
  if (value) {
    return value.toLowerCase();
  }
  return value;
};
var isPollable = function(value) {
  return value && typeof value.pollingInterval === "number";
};
var spelunkData = function(value) {
  if (value == null) {
    return null;
  }
  if (typeof value.message === "string" && value.message.match(/revert/i) && isHexString2(value.data)) {
    return { message: value.message, data: value.data };
  }
  if (typeof value === "object") {
    for (const key in value) {
      const result = spelunkData(value[key]);
      if (result) {
        return result;
      }
    }
    return null;
  }
  if (typeof value === "string") {
    try {
      return spelunkData(JSON.parse(value));
    } catch (error) {
    }
  }
  return null;
};
var _spelunkMessage = function(value, result) {
  if (value == null) {
    return;
  }
  if (typeof value.message === "string") {
    result.push(value.message);
  }
  if (typeof value === "object") {
    for (const key in value) {
      _spelunkMessage(value[key], result);
    }
  }
  if (typeof value === "string") {
    try {
      return _spelunkMessage(JSON.parse(value), result);
    } catch (error) {
    }
  }
};
var spelunkMessage = function(value) {
  const result = [];
  _spelunkMessage(value, result);
  return result;
};
var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
var defaultOptions2 = {
  polling: false,
  staticNetwork: null,
  batchStallTime: 10,
  batchMaxSize: 1 << 20,
  batchMaxCount: 100,
  cacheTimeout: 250,
  pollingInterval: 4000
};

class JsonRpcSigner extends AbstractSigner {
  address;
  constructor(provider5, address25) {
    super(provider5);
    address25 = getAddress(address25);
    defineProperties(this, { address: address25 });
  }
  connect(provider5) {
    assert2(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
      operation: "signer.connect"
    });
  }
  async getAddress() {
    return this.address;
  }
  async populateTransaction(tx2) {
    return await this.populateCall(tx2);
  }
  async sendUncheckedTransaction(_tx) {
    const tx2 = deepCopy(_tx);
    const promises = [];
    if (tx2.from) {
      const _from = tx2.from;
      promises.push((async () => {
        const from = await resolveAddress(_from, this.provider);
        assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
        tx2.from = from;
      })());
    } else {
      tx2.from = this.address;
    }
    if (tx2.gasLimit == null) {
      promises.push((async () => {
        tx2.gasLimit = await this.provider.estimateGas({ ...tx2, from: this.address });
      })());
    }
    if (tx2.to != null) {
      const _to = tx2.to;
      promises.push((async () => {
        tx2.to = await resolveAddress(_to, this.provider);
      })());
    }
    if (promises.length) {
      await Promise.all(promises);
    }
    const hexTx = this.provider.getRpcTransaction(tx2);
    return this.provider.send("eth_sendTransaction", [hexTx]);
  }
  async sendTransaction(tx2) {
    const blockNumber = await this.provider.getBlockNumber();
    const hash9 = await this.sendUncheckedTransaction(tx2);
    return await new Promise((resolve, reject) => {
      const timeouts = [1000, 100];
      const checkTx = async () => {
        const tx3 = await this.provider.getTransaction(hash9);
        if (tx3 != null) {
          resolve(tx3.replaceableTransaction(blockNumber));
          return;
        }
        this.provider._setTimeout(() => {
          checkTx();
        }, timeouts.pop() || 4000);
      };
      checkTx();
    });
  }
  async signTransaction(_tx) {
    const tx2 = deepCopy(_tx);
    if (tx2.from) {
      const from = await resolveAddress(tx2.from, this.provider);
      assertArgument(from != null && from.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
      tx2.from = from;
    } else {
      tx2.from = this.address;
    }
    const hexTx = this.provider.getRpcTransaction(tx2);
    return await this.provider.send("eth_signTransaction", [hexTx]);
  }
  async signMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("personal_sign", [
      hexlify(message),
      this.address.toLowerCase()
    ]);
  }
  async signTypedData(domain, types15, _value) {
    const value = deepCopy(_value);
    const populated = await TypedDataEncoder.resolveNames(domain, types15, value, async (value2) => {
      const address25 = await resolveAddress(value2);
      assertArgument(address25 != null, "TypedData does not support null address", "value", value2);
      return address25;
    });
    return await this.provider.send("eth_signTypedData_v4", [
      this.address.toLowerCase(),
      JSON.stringify(TypedDataEncoder.getPayload(populated.domain, types15, populated.value))
    ]);
  }
  async unlock(password) {
    return this.provider.send("personal_unlockAccount", [
      this.address.toLowerCase(),
      password,
      null
    ]);
  }
  async _legacySignMessage(_message) {
    const message = typeof _message === "string" ? toUtf8Bytes(_message) : _message;
    return await this.provider.send("eth_sign", [
      this.address.toLowerCase(),
      hexlify(message)
    ]);
  }
}

class JsonRpcApiProvider extends AbstractProvider {
  #options;
  #nextId;
  #payloads;
  #drainTimer;
  #notReady;
  #network;
  #scheduleDrain() {
    if (this.#drainTimer) {
      return;
    }
    const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
    this.#drainTimer = setTimeout(() => {
      this.#drainTimer = null;
      const payloads = this.#payloads;
      this.#payloads = [];
      while (payloads.length) {
        const batch = [payloads.shift()];
        while (payloads.length) {
          if (batch.length === this.#options.batchMaxCount) {
            break;
          }
          batch.push(payloads.shift());
          const bytes10 = JSON.stringify(batch.map((p) => p.payload));
          if (bytes10.length > this.#options.batchMaxSize) {
            payloads.unshift(batch.pop());
            break;
          }
        }
        (async () => {
          const payload = batch.length === 1 ? batch[0].payload : batch.map((p) => p.payload);
          this.emit("debug", { action: "sendRpcPayload", payload });
          try {
            const result = await this._send(payload);
            this.emit("debug", { action: "receiveRpcResult", result });
            for (const { resolve, reject, payload: payload2 } of batch) {
              if (this.destroyed) {
                reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                continue;
              }
              const resp = result.filter((r2) => r2.id === payload2.id)[0];
              if (resp == null) {
                const error = makeError("missing response for request", "BAD_DATA", {
                  value: result,
                  info: { payload: payload2 }
                });
                this.emit("error", error);
                reject(error);
                continue;
              }
              if ("error" in resp) {
                reject(this.getRpcError(payload2, resp));
                continue;
              }
              resolve(resp.result);
            }
          } catch (error) {
            this.emit("debug", { action: "receiveRpcError", error });
            for (const { reject } of batch) {
              reject(error);
            }
          }
        })();
      }
    }, stallTime);
  }
  constructor(network3, options) {
    super(network3, options);
    this.#nextId = 1;
    this.#options = Object.assign({}, defaultOptions2, options || {});
    this.#payloads = [];
    this.#drainTimer = null;
    this.#network = null;
    {
      let resolve = null;
      const promise = new Promise((_resolve) => {
        resolve = _resolve;
      });
      this.#notReady = { promise, resolve };
    }
    const staticNetwork = this._getOption("staticNetwork");
    if (staticNetwork) {
      assertArgument(network3 == null || staticNetwork.matches(network3), "staticNetwork MUST match network object", "options", options);
      this.#network = staticNetwork;
    }
  }
  _getOption(key) {
    return this.#options[key];
  }
  get _network() {
    assert2(this.#network, "network is not available yet", "NETWORK_ERROR");
    return this.#network;
  }
  async _perform(req) {
    if (req.method === "call" || req.method === "estimateGas") {
      let tx2 = req.transaction;
      if (tx2 && tx2.type != null && getBigInt(tx2.type)) {
        if (tx2.maxFeePerGas == null && tx2.maxPriorityFeePerGas == null) {
          const feeData = await this.getFeeData();
          if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
            req = Object.assign({}, req, {
              transaction: Object.assign({}, tx2, { type: undefined })
            });
          }
        }
      }
    }
    const request = this.getRpcRequest(req);
    if (request != null) {
      return await this.send(request.method, request.args);
    }
    return super._perform(req);
  }
  async _detectNetwork() {
    const network3 = this._getOption("staticNetwork");
    if (network3) {
      return network3;
    }
    if (this.ready) {
      return Network.from(getBigInt(await this.send("eth_chainId", [])));
    }
    const payload = {
      id: this.#nextId++,
      method: "eth_chainId",
      params: [],
      jsonrpc: "2.0"
    };
    this.emit("debug", { action: "sendRpcPayload", payload });
    let result;
    try {
      result = (await this._send(payload))[0];
    } catch (error) {
      this.emit("debug", { action: "receiveRpcError", error });
      throw error;
    }
    this.emit("debug", { action: "receiveRpcResult", result });
    if ("result" in result) {
      return Network.from(getBigInt(result.result));
    }
    throw this.getRpcError(payload, result);
  }
  _start() {
    if (this.#notReady == null || this.#notReady.resolve == null) {
      return;
    }
    this.#notReady.resolve();
    this.#notReady = null;
    (async () => {
      while (this.#network == null && !this.destroyed) {
        try {
          this.#network = await this._detectNetwork();
        } catch (error) {
          console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
          this.emit("error", makeError("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
          await stall(1000);
        }
      }
      this.#scheduleDrain();
    })();
  }
  async _waitUntilReady() {
    if (this.#notReady == null) {
      return;
    }
    return await this.#notReady.promise;
  }
  _getSubscriber(sub) {
    if (sub.type === "pending") {
      return new FilterIdPendingSubscriber(this);
    }
    if (sub.type === "event") {
      if (this._getOption("polling")) {
        return new PollingEventSubscriber(this, sub.filter);
      }
      return new FilterIdEventSubscriber(this, sub.filter);
    }
    if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
      return new UnmanagedSubscriber("orphan");
    }
    return super._getSubscriber(sub);
  }
  get ready() {
    return this.#notReady == null;
  }
  getRpcTransaction(tx2) {
    const result = {};
    ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
      if (tx2[key] == null) {
        return;
      }
      let dstKey = key;
      if (key === "gasLimit") {
        dstKey = "gas";
      }
      result[dstKey] = toQuantity(getBigInt(tx2[key], `tx.${key}`));
    });
    ["from", "to", "data"].forEach((key) => {
      if (tx2[key] == null) {
        return;
      }
      result[key] = hexlify(tx2[key]);
    });
    if (tx2.accessList) {
      result["accessList"] = accessListify(tx2.accessList);
    }
    return result;
  }
  getRpcRequest(req) {
    switch (req.method) {
      case "chainId":
        return { method: "eth_chainId", args: [] };
      case "getBlockNumber":
        return { method: "eth_blockNumber", args: [] };
      case "getGasPrice":
        return { method: "eth_gasPrice", args: [] };
      case "getBalance":
        return {
          method: "eth_getBalance",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getTransactionCount":
        return {
          method: "eth_getTransactionCount",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getCode":
        return {
          method: "eth_getCode",
          args: [getLowerCase(req.address), req.blockTag]
        };
      case "getStorage":
        return {
          method: "eth_getStorageAt",
          args: [
            getLowerCase(req.address),
            "0x" + req.position.toString(16),
            req.blockTag
          ]
        };
      case "broadcastTransaction":
        return {
          method: "eth_sendRawTransaction",
          args: [req.signedTransaction]
        };
      case "getBlock":
        if ("blockTag" in req) {
          return {
            method: "eth_getBlockByNumber",
            args: [req.blockTag, !!req.includeTransactions]
          };
        } else if ("blockHash" in req) {
          return {
            method: "eth_getBlockByHash",
            args: [req.blockHash, !!req.includeTransactions]
          };
        }
        break;
      case "getTransaction":
        return {
          method: "eth_getTransactionByHash",
          args: [req.hash]
        };
      case "getTransactionReceipt":
        return {
          method: "eth_getTransactionReceipt",
          args: [req.hash]
        };
      case "call":
        return {
          method: "eth_call",
          args: [this.getRpcTransaction(req.transaction), req.blockTag]
        };
      case "estimateGas": {
        return {
          method: "eth_estimateGas",
          args: [this.getRpcTransaction(req.transaction)]
        };
      }
      case "getLogs":
        if (req.filter && req.filter.address != null) {
          if (Array.isArray(req.filter.address)) {
            req.filter.address = req.filter.address.map(getLowerCase);
          } else {
            req.filter.address = getLowerCase(req.filter.address);
          }
        }
        return { method: "eth_getLogs", args: [req.filter] };
    }
    return null;
  }
  getRpcError(payload, _error) {
    const { method } = payload;
    const { error } = _error;
    if (method === "eth_estimateGas" && error.message) {
      const msg = error.message;
      if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
        return makeError("insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: payload.params[0],
          info: { payload, error }
        });
      }
    }
    if (method === "eth_call" || method === "eth_estimateGas") {
      const result = spelunkData(error);
      const e = AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
      e.info = { error, payload };
      return e;
    }
    const message = JSON.stringify(spelunkMessage(error));
    if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
      const actionMap = {
        eth_sign: "signMessage",
        personal_sign: "signMessage",
        eth_signTypedData_v4: "signTypedData",
        eth_signTransaction: "signTransaction",
        eth_sendTransaction: "sendTransaction",
        eth_requestAccounts: "requestAccess",
        wallet_requestAccounts: "requestAccess"
      };
      return makeError(`user rejected action`, "ACTION_REJECTED", {
        action: actionMap[method] || "unknown",
        reason: "rejected",
        info: { payload, error }
      });
    }
    if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
      const transaction9 = payload.params[0];
      if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
        return makeError("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
          transaction: transaction9,
          info: { error }
        });
      }
      if (message.match(/nonce/i) && message.match(/too low/i)) {
        return makeError("nonce has already been used", "NONCE_EXPIRED", { transaction: transaction9, info: { error } });
      }
      if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
        return makeError("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction: transaction9, info: { error } });
      }
      if (message.match(/only replay-protected/i)) {
        return makeError("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
          operation: method,
          info: { transaction: transaction9, info: { error } }
        });
      }
    }
    let unsupported = !!message.match(/the method .* does not exist/i);
    if (!unsupported) {
      if (error && error.details && error.details.startsWith("Unauthorized method:")) {
        unsupported = true;
      }
    }
    if (unsupported) {
      return makeError("unsupported operation", "UNSUPPORTED_OPERATION", {
        operation: payload.method,
        info: { error, payload }
      });
    }
    return makeError("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
  }
  send(method, params) {
    if (this.destroyed) {
      return Promise.reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
    }
    const id3 = this.#nextId++;
    const promise = new Promise((resolve, reject) => {
      this.#payloads.push({
        resolve,
        reject,
        payload: { method, params, id: id3, jsonrpc: "2.0" }
      });
    });
    this.#scheduleDrain();
    return promise;
  }
  async getSigner(address25) {
    if (address25 == null) {
      address25 = 0;
    }
    const accountsPromise = this.send("eth_accounts", []);
    if (typeof address25 === "number") {
      const accounts3 = await accountsPromise;
      if (address25 >= accounts3.length) {
        throw new Error("no such account");
      }
      return new JsonRpcSigner(this, accounts3[address25]);
    }
    const { accounts: accounts2 } = await resolveProperties({
      network: this.getNetwork(),
      accounts: accountsPromise
    });
    address25 = getAddress(address25);
    for (const account2 of accounts2) {
      if (getAddress(account2) === address25) {
        return new JsonRpcSigner(this, address25);
      }
    }
    throw new Error("invalid account");
  }
  async listAccounts() {
    const accounts2 = await this.send("eth_accounts", []);
    return accounts2.map((a) => new JsonRpcSigner(this, a));
  }
  destroy() {
    if (this.#drainTimer) {
      clearTimeout(this.#drainTimer);
      this.#drainTimer = null;
    }
    for (const { payload, reject } of this.#payloads) {
      reject(makeError("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
    }
    this.#payloads = [];
    super.destroy();
  }
}

class JsonRpcApiPollingProvider extends JsonRpcApiProvider {
  #pollingInterval;
  constructor(network3, options) {
    super(network3, options);
    this.#pollingInterval = 4000;
  }
  _getSubscriber(sub) {
    const subscriber = super._getSubscriber(sub);
    if (isPollable(subscriber)) {
      subscriber.pollingInterval = this.#pollingInterval;
    }
    return subscriber;
  }
  get pollingInterval() {
    return this.#pollingInterval;
  }
  set pollingInterval(value) {
    if (!Number.isInteger(value) || value < 0) {
      throw new Error("invalid interval");
    }
    this.#pollingInterval = value;
    this._forEachSubscriber((sub) => {
      if (isPollable(sub)) {
        sub.pollingInterval = this.#pollingInterval;
      }
    });
  }
}

class JsonRpcProvider extends JsonRpcApiPollingProvider {
  #connect;
  constructor(url, network3, options) {
    if (url == null) {
      url = "http://localhost:8545";
    }
    super(network3, options);
    if (typeof url === "string") {
      this.#connect = new FetchRequest(url);
    } else {
      this.#connect = url.clone();
    }
  }
  _getConnection() {
    return this.#connect.clone();
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    const request = this._getConnection();
    request.body = JSON.stringify(payload);
    request.setHeader("content-type", "application/json");
    const response = await request.send();
    response.assertOk();
    let resp = response.bodyJson;
    if (!Array.isArray(resp)) {
      resp = [resp];
    }
    return resp;
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-ankr.js
var getHost = function(name) {
  switch (name) {
    case "mainnet":
      return "rpc.ankr.com/eth";
    case "goerli":
      return "rpc.ankr.com/eth_goerli";
    case "matic":
      return "rpc.ankr.com/polygon";
    case "arbitrum":
      return "rpc.ankr.com/arbitrum";
  }
  assertArgument(false, "unsupported network", "network", name);
};
var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";

class AnkrProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network4 = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const options = { polling: true, staticNetwork: network4 };
    const request = AnkrProvider.getRequest(network4, apiKey);
    super(request, network4, options);
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AnkrProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  static getRequest(network4, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey;
    }
    const request = new FetchRequest(`https://${getHost(network4.name)}/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("AnkrProvider");
        return true;
      };
    }
    return request;
  }
  getRpcError(payload, error) {
    if (payload.method === "eth_sendRawTransaction") {
      if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
        error.error.message = "replacement transaction underpriced";
      }
    }
    return super.getRpcError(payload, error);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey;
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-alchemy.js
var getHost2 = function(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.alchemyapi.io";
    case "goerli":
      return "eth-goerli.g.alchemy.com";
    case "sepolia":
      return "eth-sepolia.g.alchemy.com";
    case "arbitrum":
      return "arb-mainnet.g.alchemy.com";
    case "arbitrum-goerli":
      return "arb-goerli.g.alchemy.com";
    case "matic":
      return "polygon-mainnet.g.alchemy.com";
    case "matic-mumbai":
      return "polygon-mumbai.g.alchemy.com";
    case "optimism":
      return "opt-mainnet.g.alchemy.com";
    case "optimism-goerli":
      return "opt-goerli.g.alchemy.com";
  }
  assertArgument(false, "unsupported network", "network", name);
};
var defaultApiKey2 = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";

class AlchemyProvider extends JsonRpcProvider {
  apiKey;
  constructor(_network, apiKey) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network5 = Network.from(_network);
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = AlchemyProvider.getRequest(network5, apiKey);
    super(request, network5, { staticNetwork: network5 });
    defineProperties(this, { apiKey });
  }
  _getProvider(chainId) {
    try {
      return new AlchemyProvider(chainId, this.apiKey);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  async _perform(req) {
    if (req.method === "getTransactionResult") {
      const { trace, tx: tx2 } = await resolveProperties({
        trace: this.send("trace_transaction", [req.hash]),
        tx: this.getTransaction(req.hash)
      });
      if (trace == null || tx2 == null) {
        return null;
      }
      let data12;
      let error = false;
      try {
        data12 = trace[0].result.output;
        error = trace[0].error === "Reverted";
      } catch (error2) {
      }
      if (data12) {
        assert2(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
          action: "getTransactionResult",
          data: data12,
          reason: null,
          transaction: tx2,
          invocation: null,
          revert: null
        });
        return data12;
      }
      assert2(false, "could not parse trace result", "BAD_DATA", { value: trace });
    }
    return await super._perform(req);
  }
  isCommunityResource() {
    return this.apiKey === defaultApiKey2;
  }
  static getRequest(network5, apiKey) {
    if (apiKey == null) {
      apiKey = defaultApiKey2;
    }
    const request = new FetchRequest(`https://${getHost2(network5.name)}/v2/${apiKey}`);
    request.allowGzip = true;
    if (apiKey === defaultApiKey2) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("alchemy");
        return true;
      };
    }
    return request;
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-cloudflare.js
class CloudflareProvider extends JsonRpcProvider {
  constructor(_network) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network6 = Network.from(_network);
    assertArgument(network6.name === "mainnet", "unsupported network", "network", _network);
    super("https://cloudflare-eth.com/", network6, { staticNetwork: network6 });
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-etherscan.js
var isPromise3 = function(value) {
  return value && typeof value.then === "function";
};
var THROTTLE = 2000;
var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";

class EtherscanPlugin extends NetworkPlugin {
  baseUrl;
  constructor(baseUrl) {
    super(EtherscanPluginId);
    defineProperties(this, { baseUrl });
  }
  clone() {
    return new EtherscanPlugin(this.baseUrl);
  }
}
var skipKeys = ["enableCcipRead"];
var nextId = 1;

class EtherscanProvider extends AbstractProvider {
  network;
  apiKey;
  #plugin;
  constructor(_network, _apiKey) {
    const apiKey = _apiKey != null ? _apiKey : null;
    super();
    const network7 = Network.from(_network);
    this.#plugin = network7.getPlugin(EtherscanPluginId);
    defineProperties(this, { apiKey, network: network7 });
    this.getBaseUrl();
  }
  getBaseUrl() {
    if (this.#plugin) {
      return this.#plugin.baseUrl;
    }
    switch (this.network.name) {
      case "mainnet":
        return "https://api.etherscan.io";
      case "goerli":
        return "https://api-goerli.etherscan.io";
      case "sepolia":
        return "https://api-sepolia.etherscan.io";
      case "arbitrum":
        return "https://api.arbiscan.io";
      case "arbitrum-goerli":
        return "https://api-goerli.arbiscan.io";
      case "matic":
        return "https://api.polygonscan.com";
      case "matic-mumbai":
        return "https://api-testnet.polygonscan.com";
      case "optimism":
        return "https://api-optimistic.etherscan.io";
      case "optimism-goerli":
        return "https://api-goerli-optimistic.etherscan.io";
      case "bnb":
        return "http://api.bscscan.com";
      case "bnbt":
        return "http://api-testnet.bscscan.com";
      default:
    }
    assertArgument(false, "unsupported network", "network", this.network);
  }
  getUrl(module, params) {
    const query = Object.keys(params).reduce((accum, key) => {
      const value = params[key];
      if (value != null) {
        accum += `&${key}=${value}`;
      }
      return accum;
    }, "");
    const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
    return `${this.getBaseUrl()}/api?module=${module}${query}${apiKey}`;
  }
  getPostUrl() {
    return `${this.getBaseUrl()}/api`;
  }
  getPostData(module, params) {
    params.module = module;
    params.apikey = this.apiKey;
    return params;
  }
  async detectNetwork() {
    return this.network;
  }
  async fetch(module, params, post) {
    const id3 = nextId++;
    const url = post ? this.getPostUrl() : this.getUrl(module, params);
    const payload = post ? this.getPostData(module, params) : null;
    this.emit("debug", { action: "sendRequest", id: id3, url, payload });
    const request = new FetchRequest(url);
    request.setThrottleParams({ slotInterval: 1000 });
    request.retryFunc = (req, resp, attempt) => {
      if (this.isCommunityResource()) {
        showThrottleMessage("Etherscan");
      }
      return Promise.resolve(true);
    };
    request.processFunc = async (request2, response2) => {
      const result2 = response2.hasBody() ? JSON.parse(toUtf8String(response2.body)) : {};
      const throttle = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
      if (module === "proxy") {
        if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result2 });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      } else {
        if (throttle) {
          this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result2.result });
          response2.throwThrottleError(result2.result, THROTTLE);
        }
      }
      return response2;
    };
    if (payload) {
      request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
      request.body = Object.keys(payload).map((k) => `${k}=${payload[k]}`).join("&");
    }
    const response = await request.send();
    try {
      response.assertOk();
    } catch (error) {
      this.emit("debug", { action: "receiveError", id: id3, error, reason: "assertOk" });
      assert2(false, "response error", "SERVER_ERROR", { request, response });
    }
    if (!response.hasBody()) {
      this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
      assert2(false, "missing response", "SERVER_ERROR", { request, response });
    }
    const result = JSON.parse(toUtf8String(response.body));
    if (module === "proxy") {
      if (result.jsonrpc != "2.0") {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "invalid JSON-RPC" });
        assert2(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
      }
      if (result.error) {
        this.emit("debug", { action: "receiveError", id: id3, result, reason: "JSON-RPC error" });
        assert2(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    } else {
      if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        this.emit("debug", { action: "receiveRequest", id: id3, result });
        return result.result;
      }
      if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
        this.emit("debug", { action: "receiveError", id: id3, result });
        assert2(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
      }
      this.emit("debug", { action: "receiveRequest", id: id3, result });
      return result.result;
    }
  }
  _getTransactionPostData(transaction10) {
    const result = {};
    for (let key in transaction10) {
      if (skipKeys.indexOf(key) >= 0) {
        continue;
      }
      if (transaction10[key] == null) {
        continue;
      }
      let value = transaction10[key];
      if (key === "type" && value === 0) {
        continue;
      }
      if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
        value = toQuantity(value);
      } else if (key === "accessList") {
        value = "[" + accessListify(value).map((set) => {
          return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
        }).join(",") + "]";
      } else {
        value = hexlify(value);
      }
      result[key] = value;
    }
    return result;
  }
  _checkError(req, error, transaction10) {
    let message = "";
    if (isError(error, "SERVER_ERROR")) {
      try {
        message = error.info.result.error.message;
      } catch (e) {
      }
      if (!message) {
        try {
          message = error.info.message;
        } catch (e) {
        }
      }
    }
    if (req.method === "estimateGas") {
      if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
        assert2(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
          transaction: req.transaction
        });
      }
    }
    if (req.method === "call" || req.method === "estimateGas") {
      if (message.match(/execution reverted/i)) {
        let data12 = "";
        try {
          data12 = error.info.result.error.data;
        } catch (error2) {
        }
        const e = AbiCoder.getBuiltinCallException(req.method, req.transaction, data12);
        e.info = { request: req, error };
        throw e;
      }
    }
    if (message) {
      if (req.method === "broadcastTransaction") {
        const transaction11 = Transaction2.from(req.signedTransaction);
        if (message.match(/replacement/i) && message.match(/underpriced/i)) {
          assert2(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
            transaction: transaction11
          });
        }
        if (message.match(/insufficient funds/)) {
          assert2(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
            transaction: transaction11
          });
        }
        if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
          assert2(false, "nonce has already been used", "NONCE_EXPIRED", {
            transaction: transaction11
          });
        }
      }
    }
    throw error;
  }
  async _detectNetwork() {
    return this.network;
  }
  async _perform(req) {
    switch (req.method) {
      case "chainId":
        return this.network.chainId;
      case "getBlockNumber":
        return this.fetch("proxy", { action: "eth_blockNumber" });
      case "getGasPrice":
        return this.fetch("proxy", { action: "eth_gasPrice" });
      case "getBalance":
        return this.fetch("account", {
          action: "balance",
          address: req.address,
          tag: req.blockTag
        });
      case "getTransactionCount":
        return this.fetch("proxy", {
          action: "eth_getTransactionCount",
          address: req.address,
          tag: req.blockTag
        });
      case "getCode":
        return this.fetch("proxy", {
          action: "eth_getCode",
          address: req.address,
          tag: req.blockTag
        });
      case "getStorage":
        return this.fetch("proxy", {
          action: "eth_getStorageAt",
          address: req.address,
          position: req.position,
          tag: req.blockTag
        });
      case "broadcastTransaction":
        return this.fetch("proxy", {
          action: "eth_sendRawTransaction",
          hex: req.signedTransaction
        }, true).catch((error) => {
          return this._checkError(req, error, req.signedTransaction);
        });
      case "getBlock":
        if ("blockTag" in req) {
          return this.fetch("proxy", {
            action: "eth_getBlockByNumber",
            tag: req.blockTag,
            boolean: req.includeTransactions ? "true" : "false"
          });
        }
        assert2(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
          operation: "getBlock(blockHash)"
        });
      case "getTransaction":
        return this.fetch("proxy", {
          action: "eth_getTransactionByHash",
          txhash: req.hash
        });
      case "getTransactionReceipt":
        return this.fetch("proxy", {
          action: "eth_getTransactionReceipt",
          txhash: req.hash
        });
      case "call": {
        if (req.blockTag !== "latest") {
          throw new Error("EtherscanProvider does not support blockTag for call");
        }
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_call";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      case "estimateGas": {
        const postData = this._getTransactionPostData(req.transaction);
        postData.module = "proxy";
        postData.action = "eth_estimateGas";
        try {
          return await this.fetch("proxy", postData, true);
        } catch (error) {
          return this._checkError(req, error, req.transaction);
        }
      }
      default:
        break;
    }
    return super._perform(req);
  }
  async getNetwork() {
    return this.network;
  }
  async getEtherPrice() {
    if (this.network.name !== "mainnet") {
      return 0;
    }
    return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
  }
  async getContract(_address) {
    let address25 = this._getAddress(_address);
    if (isPromise3(address25)) {
      address25 = await address25;
    }
    try {
      const resp = await this.fetch("contract", {
        action: "getabi",
        address: address25
      });
      const abi7 = JSON.parse(resp);
      return new Contract2(address25, abi7, this);
    } catch (error) {
      return null;
    }
  }
  isCommunityResource() {
    return this.apiKey == null;
  }
}

// ../../node_modules/ethers/lib.esm/providers/ws.js
import {WebSocket as WebSocket3} from "ws";

// ../../node_modules/ethers/lib.esm/providers/provider-socket.js
class SocketSubscriber {
  #provider;
  #filter;
  get filter() {
    return JSON.parse(this.#filter);
  }
  #filterId;
  #paused;
  #emitPromise;
  constructor(provider5, filter3) {
    this.#provider = provider5;
    this.#filter = JSON.stringify(filter3);
    this.#filterId = null;
    this.#paused = null;
    this.#emitPromise = null;
  }
  start() {
    this.#filterId = this.#provider.send("eth_subscribe", this.filter).then((filterId) => {
      this.#provider._register(filterId, this);
      return filterId;
    });
  }
  stop() {
    this.#filterId.then((filterId) => {
      this.#provider.send("eth_unsubscribe", [filterId]);
    });
    this.#filterId = null;
  }
  pause(dropWhilePaused) {
    assert2(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
    this.#paused = !!dropWhilePaused;
  }
  resume() {
    this.#paused = null;
  }
  _handleMessage(message) {
    if (this.#filterId == null) {
      return;
    }
    if (this.#paused === null) {
      let emitPromise = this.#emitPromise;
      if (emitPromise == null) {
        emitPromise = this._emit(this.#provider, message);
      } else {
        emitPromise = emitPromise.then(async () => {
          await this._emit(this.#provider, message);
        });
      }
      this.#emitPromise = emitPromise.then(() => {
        if (this.#emitPromise === emitPromise) {
          this.#emitPromise = null;
        }
      });
    }
  }
  async _emit(provider5, message) {
    throw new Error("sub-classes must implemente this; _emit");
  }
}

class SocketBlockSubscriber extends SocketSubscriber {
  constructor(provider5) {
    super(provider5, ["newHeads"]);
  }
  async _emit(provider5, message) {
    provider5.emit("block", parseInt(message.number));
  }
}

class SocketPendingSubscriber extends SocketSubscriber {
  constructor(provider5) {
    super(provider5, ["newPendingTransactions"]);
  }
  async _emit(provider5, message) {
    provider5.emit("pending", message);
  }
}

class SocketEventSubscriber extends SocketSubscriber {
  #logFilter;
  get logFilter() {
    return JSON.parse(this.#logFilter);
  }
  constructor(provider5, filter3) {
    super(provider5, ["logs", filter3]);
    this.#logFilter = JSON.stringify(filter3);
  }
  async _emit(provider5, message) {
    provider5.emit(this.logFilter, provider5._wrapLog(message, provider5._network));
  }
}

class SocketProvider2 extends JsonRpcApiProvider {
  #callbacks;
  #subs;
  #pending;
  constructor(network7) {
    super(network7, { batchMaxCount: 1 });
    this.#callbacks = new Map;
    this.#subs = new Map;
    this.#pending = new Map;
  }
  _getSubscriber(sub) {
    switch (sub.type) {
      case "close":
        return new UnmanagedSubscriber("close");
      case "block":
        return new SocketBlockSubscriber(this);
      case "pending":
        return new SocketPendingSubscriber(this);
      case "event":
        return new SocketEventSubscriber(this, sub.filter);
      case "orphan":
        if (sub.filter.orphan === "drop-log") {
          return new UnmanagedSubscriber("drop-log");
        }
    }
    return super._getSubscriber(sub);
  }
  _register(filterId, subscriber) {
    this.#subs.set(filterId, subscriber);
    const pending = this.#pending.get(filterId);
    if (pending) {
      for (const message of pending) {
        subscriber._handleMessage(message);
      }
      this.#pending.delete(filterId);
    }
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
    const promise = new Promise((resolve, reject) => {
      this.#callbacks.set(payload.id, { payload, resolve, reject });
    });
    await this._waitUntilReady();
    await this._write(JSON.stringify(payload));
    return [await promise];
  }
  async _processMessage(message) {
    const result = JSON.parse(message);
    if (result && typeof result === "object" && "id" in result) {
      const callback = this.#callbacks.get(result.id);
      if (callback == null) {
        this.emit("error", makeError("received result for unknown id", "UNKNOWN_ERROR", {
          reasonCode: "UNKNOWN_ID",
          result
        }));
        return;
      }
      this.#callbacks.delete(result.id);
      callback.resolve(result);
    } else if (result && result.method === "eth_subscription") {
      const filterId = result.params.subscription;
      const subscriber = this.#subs.get(filterId);
      if (subscriber) {
        subscriber._handleMessage(result.params.result);
      } else {
        let pending = this.#pending.get(filterId);
        if (pending == null) {
          pending = [];
          this.#pending.set(filterId, pending);
        }
        pending.push(result.params.result);
      }
    } else {
      this.emit("error", makeError("received unexpected message", "UNKNOWN_ERROR", {
        reasonCode: "UNEXPECTED_MESSAGE",
        result
      }));
      return;
    }
  }
  async _write(message) {
    throw new Error("sub-classes must override this");
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-websocket.js
class WebSocketProvider2 extends SocketProvider2 {
  #connect;
  #websocket;
  get websocket() {
    if (this.#websocket == null) {
      throw new Error("websocket closed");
    }
    return this.#websocket;
  }
  constructor(url, network7) {
    super(network7);
    if (typeof url === "string") {
      this.#connect = () => {
        return new WebSocket3(url);
      };
      this.#websocket = this.#connect();
    } else if (typeof url === "function") {
      this.#connect = url;
      this.#websocket = url();
    } else {
      this.#connect = null;
      this.#websocket = url;
    }
    this.websocket.onopen = async () => {
      try {
        await this._start();
        this.resume();
      } catch (error) {
        console.log("failed to start WebsocketProvider", error);
      }
    };
    this.websocket.onmessage = (message) => {
      this._processMessage(message.data);
    };
  }
  async _write(message) {
    this.websocket.send(message);
  }
  async destroy() {
    if (this.#websocket != null) {
      this.#websocket.close();
      this.#websocket = null;
    }
    super.destroy();
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-infura.js
var getHost3 = function(name) {
  switch (name) {
    case "mainnet":
      return "mainnet.infura.io";
    case "goerli":
      return "goerli.infura.io";
    case "sepolia":
      return "sepolia.infura.io";
    case "arbitrum":
      return "arbitrum-mainnet.infura.io";
    case "arbitrum-goerli":
      return "arbitrum-goerli.infura.io";
    case "linea":
      return "linea-mainnet.infura.io";
    case "linea-goerli":
      return "linea-goerli.infura.io";
    case "matic":
      return "polygon-mainnet.infura.io";
    case "matic-mumbai":
      return "polygon-mumbai.infura.io";
    case "optimism":
      return "optimism-mainnet.infura.io";
    case "optimism-goerli":
      return "optimism-goerli.infura.io";
  }
  assertArgument(false, "unsupported network", "network", name);
};
var defaultProjectId = "84842078b09946638c03157f83405213";

class InfuraWebSocketProvider extends WebSocketProvider2 {
  projectId;
  projectSecret;
  constructor(network8, projectId) {
    const provider5 = new InfuraProvider(network8, projectId);
    const req = provider5._getConnection();
    assert2(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
    const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
    super(url, network8);
    defineProperties(this, {
      projectId: provider5.projectId,
      projectSecret: provider5.projectSecret
    });
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
}

class InfuraProvider extends JsonRpcProvider {
  projectId;
  projectSecret;
  constructor(_network, projectId, projectSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network8 = Network.from(_network);
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = InfuraProvider.getRequest(network8, projectId, projectSecret);
    super(request, network8, { staticNetwork: network8 });
    defineProperties(this, { projectId, projectSecret });
  }
  _getProvider(chainId) {
    try {
      return new InfuraProvider(chainId, this.projectId, this.projectSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.projectId === defaultProjectId;
  }
  static getWebSocketProvider(network8, projectId) {
    return new InfuraWebSocketProvider(network8, projectId);
  }
  static getRequest(network8, projectId, projectSecret) {
    if (projectId == null) {
      projectId = defaultProjectId;
    }
    if (projectSecret == null) {
      projectSecret = null;
    }
    const request = new FetchRequest(`https://${getHost3(network8.name)}/v3/${projectId}`);
    request.allowGzip = true;
    if (projectSecret) {
      request.setCredentials("", projectSecret);
    }
    if (projectId === defaultProjectId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("InfuraProvider");
        return true;
      };
    }
    return request;
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-quicknode.js
var getHost4 = function(name) {
  switch (name) {
    case "mainnet":
      return "ethers.quiknode.pro";
    case "goerli":
      return "ethers.ethereum-goerli.quiknode.pro";
    case "arbitrum":
      return "ethers.arbitrum-mainnet.quiknode.pro";
    case "arbitrum-goerli":
      return "ethers.arbitrum-goerli.quiknode.pro";
    case "matic":
      return "ethers.matic.quiknode.pro";
    case "matic-mumbai":
      return "ethers.matic-testnet.quiknode.pro";
    case "optimism":
      return "ethers.optimism.quiknode.pro";
    case "optimism-goerli":
      return "ethers.optimism-goerli.quiknode.pro";
  }
  assertArgument(false, "unsupported network", "network", name);
};
var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";

class QuickNodeProvider extends JsonRpcProvider {
  token;
  constructor(_network, token) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network9 = Network.from(_network);
    if (token == null) {
      token = defaultToken;
    }
    const request = QuickNodeProvider.getRequest(network9, token);
    super(request, network9, { staticNetwork: network9 });
    defineProperties(this, { token });
  }
  _getProvider(chainId) {
    try {
      return new QuickNodeProvider(chainId, this.token);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  isCommunityResource() {
    return this.token === defaultToken;
  }
  static getRequest(network9, token) {
    if (token == null) {
      token = defaultToken;
    }
    const request = new FetchRequest(`https://${getHost4(network9.name)}/${token}`);
    request.allowGzip = true;
    if (token === defaultToken) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("QuickNodeProvider");
        return true;
      };
    }
    return request;
  }
}

// ../../node_modules/ethers/lib.esm/providers/provider-fallback.js
var shuffle = function(array4) {
  for (let i = array4.length - 1;i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    const tmp = array4[i];
    array4[i] = array4[j];
    array4[j] = tmp;
  }
};
var stall2 = function(duration) {
  return new Promise((resolve) => {
    setTimeout(resolve, duration);
  });
};
var getTime3 = function() {
  return new Date().getTime();
};
var stringify2 = function(value) {
  return JSON.stringify(value, (key, value2) => {
    if (typeof value2 === "bigint") {
      return { type: "bigint", value: value2.toString() };
    }
    return value2;
  });
};
async function waitForSync(config5, blockNumber) {
  while (config5.blockNumber < 0 || config5.blockNumber < blockNumber) {
    if (!config5._updateNumber) {
      config5._updateNumber = (async () => {
        try {
          const blockNumber2 = await config5.provider.getBlockNumber();
          if (blockNumber2 > config5.blockNumber) {
            config5.blockNumber = blockNumber2;
          }
        } catch (error) {
          config5.blockNumber = -2;
          config5._lastFatalError = error;
          config5._lastFatalErrorTimestamp = getTime3();
        }
        config5._updateNumber = null;
      })();
    }
    await config5._updateNumber;
    config5.outOfSync++;
    if (config5._lastFatalError) {
      break;
    }
  }
}
var _normalize = function(value) {
  if (value == null) {
    return "null";
  }
  if (Array.isArray(value)) {
    return "[" + value.map(_normalize).join(",") + "]";
  }
  if (typeof value === "object" && typeof value.toJSON === "function") {
    return _normalize(value.toJSON());
  }
  switch (typeof value) {
    case "boolean":
    case "symbol":
      return value.toString();
    case "bigint":
    case "number":
      return BigInt(value).toString();
    case "string":
      return JSON.stringify(value);
    case "object": {
      const keys = Object.keys(value);
      keys.sort();
      return "{" + keys.map((k) => `${JSON.stringify(k)}:${_normalize(value[k])}`).join(",") + "}";
    }
  }
  console.log("Could not serialize", value);
  throw new Error("Hmm...");
};
var normalizeResult = function(value) {
  if ("error" in value) {
    const error = value.error;
    return { tag: _normalize(error), value: error };
  }
  const result = value.result;
  return { tag: _normalize(result), value: result };
};
var checkQuorum = function(quorum, results) {
  const tally = new Map;
  for (const { value, tag, weight } of results) {
    const t = tally.get(tag) || { value, weight: 0 };
    t.weight += weight;
    tally.set(tag, t);
  }
  let best = null;
  for (const r2 of tally.values()) {
    if (r2.weight >= quorum && (!best || r2.weight > best.weight)) {
      best = r2;
    }
  }
  if (best) {
    return best.value;
  }
  return;
};
var getMedian = function(quorum, results) {
  let resultWeight = 0;
  const errorMap2 = new Map;
  let bestError = null;
  const values = [];
  for (const { value, tag, weight } of results) {
    if (value instanceof Error) {
      const e = errorMap2.get(tag) || { value, weight: 0 };
      e.weight += weight;
      errorMap2.set(tag, e);
      if (bestError == null || e.weight > bestError.weight) {
        bestError = e;
      }
    } else {
      values.push(BigInt(value));
      resultWeight += weight;
    }
  }
  if (resultWeight < quorum) {
    if (bestError && bestError.weight >= quorum) {
      return bestError.value;
    }
    return;
  }
  values.sort((a, b2) => a < b2 ? -1 : b2 > a ? 1 : 0);
  const mid = Math.floor(values.length / 2);
  if (values.length % 2) {
    return values[mid];
  }
  return (values[mid - 1] + values[mid] + BN_16) / BN_24;
};
var getAnyResult = function(quorum, results) {
  const result = checkQuorum(quorum, results);
  if (result !== undefined) {
    return result;
  }
  for (const r2 of results) {
    if (r2.value) {
      return r2.value;
    }
  }
  return;
};
var getFuzzyMode = function(quorum, results) {
  if (quorum === 1) {
    return getNumber(getMedian(quorum, results), "%internal");
  }
  const tally = new Map;
  const add3 = (result, weight) => {
    const t = tally.get(result) || { result, weight: 0 };
    t.weight += weight;
    tally.set(result, t);
  };
  for (const { weight, value } of results) {
    const r2 = getNumber(value);
    add3(r2 - 1, weight);
    add3(r2, weight);
    add3(r2 + 1, weight);
  }
  let bestWeight = 0;
  let bestResult = undefined;
  for (const { weight, result } of tally.values()) {
    if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
      bestWeight = weight;
      bestResult = result;
    }
  }
  return bestResult;
};
var BN_16 = BigInt("1");
var BN_24 = BigInt("2");
var defaultConfig = { stallTimeout: 400, priority: 1, weight: 1 };
var defaultState = {
  blockNumber: -2,
  requests: 0,
  lateResponses: 0,
  errorResponses: 0,
  outOfSync: -1,
  unsupportedEvents: 0,
  rollingDuration: 0,
  score: 0,
  _network: null,
  _updateNumber: null,
  _totalTime: 0,
  _lastFatalError: null,
  _lastFatalErrorTimestamp: 0
};

class FallbackProvider extends AbstractProvider {
  quorum;
  eventQuorum;
  eventWorkers;
  #configs;
  #height;
  #initialSyncPromise;
  constructor(providers, network10, options) {
    super(network10, options);
    this.#configs = providers.map((p) => {
      if (p instanceof AbstractProvider) {
        return Object.assign({ provider: p }, defaultConfig, defaultState);
      } else {
        return Object.assign({}, defaultConfig, p, defaultState);
      }
    });
    this.#height = -2;
    this.#initialSyncPromise = null;
    if (options && options.quorum != null) {
      this.quorum = options.quorum;
    } else {
      this.quorum = Math.ceil(this.#configs.reduce((accum, config5) => {
        accum += config5.weight;
        return accum;
      }, 0) / 2);
    }
    this.eventQuorum = 1;
    this.eventWorkers = 1;
    assertArgument(this.quorum <= this.#configs.reduce((a, c) => a + c.weight, 0), "quorum exceed provider wieght", "quorum", this.quorum);
  }
  get providerConfigs() {
    return this.#configs.map((c) => {
      const result = Object.assign({}, c);
      for (const key in result) {
        if (key[0] === "_") {
          delete result[key];
        }
      }
      return result;
    });
  }
  async _detectNetwork() {
    return Network.from(getBigInt(await this._perform({ method: "chainId" })));
  }
  async _translatePerform(provider5, req) {
    switch (req.method) {
      case "broadcastTransaction":
        return await provider5.broadcastTransaction(req.signedTransaction);
      case "call":
        return await provider5.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
      case "chainId":
        return (await provider5.getNetwork()).chainId;
      case "estimateGas":
        return await provider5.estimateGas(req.transaction);
      case "getBalance":
        return await provider5.getBalance(req.address, req.blockTag);
      case "getBlock": {
        const block4 = "blockHash" in req ? req.blockHash : req.blockTag;
        return await provider5.getBlock(block4, req.includeTransactions);
      }
      case "getBlockNumber":
        return await provider5.getBlockNumber();
      case "getCode":
        return await provider5.getCode(req.address, req.blockTag);
      case "getGasPrice":
        return (await provider5.getFeeData()).gasPrice;
      case "getLogs":
        return await provider5.getLogs(req.filter);
      case "getStorage":
        return await provider5.getStorage(req.address, req.position, req.blockTag);
      case "getTransaction":
        return await provider5.getTransaction(req.hash);
      case "getTransactionCount":
        return await provider5.getTransactionCount(req.address, req.blockTag);
      case "getTransactionReceipt":
        return await provider5.getTransactionReceipt(req.hash);
      case "getTransactionResult":
        return await provider5.getTransactionResult(req.hash);
    }
  }
  #getNextConfig(running) {
    const configs = Array.from(running).map((r2) => r2.config);
    const allConfigs = this.#configs.slice();
    shuffle(allConfigs);
    allConfigs.sort((a, b2) => a.priority - b2.priority);
    for (const config5 of allConfigs) {
      if (config5._lastFatalError) {
        continue;
      }
      if (configs.indexOf(config5) === -1) {
        return config5;
      }
    }
    return null;
  }
  #addRunner(running, req) {
    const config5 = this.#getNextConfig(running);
    if (config5 == null) {
      return null;
    }
    const runner = {
      config: config5,
      result: null,
      didBump: false,
      perform: null,
      staller: null
    };
    const now = getTime3();
    runner.perform = (async () => {
      try {
        config5.requests++;
        const result = await this._translatePerform(config5.provider, req);
        runner.result = { result };
      } catch (error) {
        config5.errorResponses++;
        runner.result = { error };
      }
      const dt = getTime3() - now;
      config5._totalTime += dt;
      config5.rollingDuration = 0.95 * config5.rollingDuration + 0.05 * dt;
      runner.perform = null;
    })();
    runner.staller = (async () => {
      await stall2(config5.stallTimeout);
      runner.staller = null;
    })();
    running.add(runner);
    return runner;
  }
  async#initialSync() {
    let initialSync = this.#initialSyncPromise;
    if (!initialSync) {
      const promises = [];
      this.#configs.forEach((config5) => {
        promises.push((async () => {
          await waitForSync(config5, 0);
          if (!config5._lastFatalError) {
            config5._network = await config5.provider.getNetwork();
          }
        })());
      });
      this.#initialSyncPromise = initialSync = (async () => {
        await Promise.all(promises);
        let chainId = null;
        for (const config5 of this.#configs) {
          if (config5._lastFatalError) {
            continue;
          }
          const network10 = config5._network;
          if (chainId == null) {
            chainId = network10.chainId;
          } else if (network10.chainId !== chainId) {
            assert2(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
              operation: "new FallbackProvider"
            });
          }
        }
      })();
    }
    await initialSync;
  }
  async#checkQuorum(running, req) {
    const results = [];
    for (const runner of running) {
      if (runner.result != null) {
        const { tag, value } = normalizeResult(runner.result);
        results.push({ tag, value, weight: runner.config.weight });
      }
    }
    if (results.reduce((a, r2) => a + r2.weight, 0) < this.quorum) {
      return;
    }
    switch (req.method) {
      case "getBlockNumber": {
        if (this.#height === -2) {
          this.#height = Math.ceil(getNumber(getMedian(this.quorum, this.#configs.filter((c) => !c._lastFatalError).map((c) => ({
            value: c.blockNumber,
            tag: getNumber(c.blockNumber).toString(),
            weight: c.weight
          })))));
        }
        const mode = getFuzzyMode(this.quorum, results);
        if (mode === undefined) {
          return;
        }
        if (mode > this.#height) {
          this.#height = mode;
        }
        return this.#height;
      }
      case "getGasPrice":
      case "estimateGas":
        return getMedian(this.quorum, results);
      case "getBlock":
        if ("blockTag" in req && req.blockTag === "pending") {
          return getAnyResult(this.quorum, results);
        }
        return checkQuorum(this.quorum, results);
      case "call":
      case "chainId":
      case "getBalance":
      case "getTransactionCount":
      case "getCode":
      case "getStorage":
      case "getTransaction":
      case "getTransactionReceipt":
      case "getLogs":
        return checkQuorum(this.quorum, results);
      case "broadcastTransaction":
        return getAnyResult(this.quorum, results);
    }
    assert2(false, "unsupported method", "UNSUPPORTED_OPERATION", {
      operation: `_perform(${stringify2(req.method)})`
    });
  }
  async#waitForQuorum(running, req) {
    if (running.size === 0) {
      throw new Error("no runners?!");
    }
    const interesting = [];
    let newRunners = 0;
    for (const runner of running) {
      if (runner.perform) {
        interesting.push(runner.perform);
      }
      if (runner.staller) {
        interesting.push(runner.staller);
        continue;
      }
      if (runner.didBump) {
        continue;
      }
      runner.didBump = true;
      newRunners++;
    }
    const value = await this.#checkQuorum(running, req);
    if (value !== undefined) {
      if (value instanceof Error) {
        throw value;
      }
      return value;
    }
    for (let i = 0;i < newRunners; i++) {
      this.#addRunner(running, req);
    }
    assert2(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
      request: "%sub-requests",
      info: { request: req, results: Array.from(running).map((r2) => stringify2(r2.result)) }
    });
    await Promise.race(interesting);
    return await this.#waitForQuorum(running, req);
  }
  async _perform(req) {
    if (req.method === "broadcastTransaction") {
      const results = await Promise.all(this.#configs.map(async ({ provider: provider5, weight }) => {
        try {
          const result3 = await provider5._perform(req);
          return Object.assign(normalizeResult({ result: result3 }), { weight });
        } catch (error) {
          return Object.assign(normalizeResult({ error }), { weight });
        }
      }));
      const result2 = getAnyResult(this.quorum, results);
      assert2(result2 !== undefined, "problem multi-broadcasting", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: results.map(stringify2) }
      });
      if (result2 instanceof Error) {
        throw result2;
      }
      return result2;
    }
    await this.#initialSync();
    const running = new Set;
    for (let i = 0;i < this.quorum; i++) {
      this.#addRunner(running, req);
    }
    const result = await this.#waitForQuorum(running, req);
    for (const runner of running) {
      if (runner.perform && runner.result == null) {
        runner.config.lateResponses++;
      }
    }
    return result;
  }
  async destroy() {
    for (const { provider: provider5 } of this.#configs) {
      provider5.destroy();
    }
    super.destroy();
  }
}

// ../../node_modules/ethers/lib.esm/providers/default-provider.js
var isWebSocketLike = function(value) {
  return value && typeof value.send === "function" && typeof value.close === "function";
};
function getDefaultProvider(network11, options) {
  if (options == null) {
    options = {};
  }
  const allowService = (name) => {
    if (options[name] === "-") {
      return false;
    }
    if (typeof options.exclusive === "string") {
      return name === options.exclusive;
    }
    if (Array.isArray(options.exclusive)) {
      return options.exclusive.indexOf(name) !== -1;
    }
    return true;
  };
  if (typeof network11 === "string" && network11.match(/^https?:/)) {
    return new JsonRpcProvider(network11);
  }
  if (typeof network11 === "string" && network11.match(/^wss?:/) || isWebSocketLike(network11)) {
    return new WebSocketProvider2(network11);
  }
  let staticNetwork = null;
  try {
    staticNetwork = Network.from(network11);
  } catch (error) {
  }
  const providers = [];
  if (allowService("publicPolygon") && staticNetwork) {
    if (staticNetwork.name === "matic") {
      providers.push(new JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
    }
  }
  if (allowService("alchemy")) {
    try {
      providers.push(new AlchemyProvider(network11, options.alchemy));
    } catch (error) {
    }
  }
  if (allowService("ankr") && options.ankr != null) {
    try {
      providers.push(new AnkrProvider(network11, options.ankr));
    } catch (error) {
    }
  }
  if (allowService("cloudflare")) {
    try {
      providers.push(new CloudflareProvider(network11));
    } catch (error) {
    }
  }
  if (allowService("etherscan")) {
    try {
      providers.push(new EtherscanProvider(network11, options.etherscan));
    } catch (error) {
    }
  }
  if (allowService("infura")) {
    try {
      let projectId = options.infura;
      let projectSecret = undefined;
      if (typeof projectId === "object") {
        projectSecret = projectId.projectSecret;
        projectId = projectId.projectId;
      }
      providers.push(new InfuraProvider(network11, projectId, projectSecret));
    } catch (error) {
    }
  }
  if (allowService("quicknode")) {
    try {
      let token = options.quicknode;
      providers.push(new QuickNodeProvider(network11, token));
    } catch (error) {
    }
  }
  assert2(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
    operation: "getDefaultProvider"
  });
  if (providers.length === 1) {
    return providers[0];
  }
  let quorum = Math.floor(providers.length / 2);
  if (quorum > 2) {
    quorum = 2;
  }
  if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
    quorum = 1;
  }
  if (options && options.quorum) {
    quorum = options.quorum;
  }
  return new FallbackProvider(providers, undefined, { quorum });
}
var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
// ../../node_modules/ethers/lib.esm/providers/signer-noncemanager.js
class NonceManager extends AbstractSigner {
  signer;
  #noncePromise;
  #delta;
  constructor(signer) {
    super(signer.provider);
    defineProperties(this, { signer });
    this.#noncePromise = null;
    this.#delta = 0;
  }
  async getAddress() {
    return this.signer.getAddress();
  }
  connect(provider5) {
    return new NonceManager(this.signer.connect(provider5));
  }
  async getNonce(blockTag) {
    if (blockTag === "pending") {
      if (this.#noncePromise == null) {
        this.#noncePromise = super.getNonce("pending");
      }
      const delta = this.#delta;
      return await this.#noncePromise + delta;
    }
    return super.getNonce(blockTag);
  }
  increment() {
    this.#delta++;
  }
  reset() {
    this.#delta = 0;
    this.#noncePromise = null;
  }
  async sendTransaction(tx2) {
    const noncePromise = this.getNonce("pending");
    this.increment();
    tx2 = await this.signer.populateTransaction(tx2);
    tx2.nonce = await noncePromise;
    return await this.signer.sendTransaction(tx2);
  }
  signTransaction(tx2) {
    return this.signer.signTransaction(tx2);
  }
  signMessage(message) {
    return this.signer.signMessage(message);
  }
  signTypedData(domain, types15, value) {
    return this.signer.signTypedData(domain, types15, value);
  }
}
// ../../node_modules/ethers/lib.esm/providers/provider-browser.js
class BrowserProvider extends JsonRpcApiPollingProvider {
  #request;
  constructor(ethereum, network11) {
    super(network11, { batchMaxCount: 1 });
    this.#request = async (method, params) => {
      const payload = { method, params };
      this.emit("debug", { action: "sendEip1193Request", payload });
      try {
        const result = await ethereum.request(payload);
        this.emit("debug", { action: "receiveEip1193Result", result });
        return result;
      } catch (e) {
        const error = new Error(e.message);
        error.code = e.code;
        error.data = e.data;
        error.payload = payload;
        this.emit("debug", { action: "receiveEip1193Error", error });
        throw error;
      }
    };
  }
  async send(method, params) {
    await this._start();
    return await super.send(method, params);
  }
  async _send(payload) {
    assertArgument(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
    try {
      const result = await this.#request(payload.method, payload.params || []);
      return [{ id: payload.id, result }];
    } catch (e) {
      return [{
        id: payload.id,
        error: { code: e.code, data: e.data, message: e.message }
      }];
    }
  }
  getRpcError(payload, error) {
    error = JSON.parse(JSON.stringify(error));
    switch (error.error.code || -1) {
      case 4001:
        error.error.message = `ethers-user-denied: ${error.error.message}`;
        break;
      case 4200:
        error.error.message = `ethers-unsupported: ${error.error.message}`;
        break;
    }
    return super.getRpcError(payload, error);
  }
  async hasSigner(address25) {
    if (address25 == null) {
      address25 = 0;
    }
    const accounts2 = await this.send("eth_accounts", []);
    if (typeof address25 === "number") {
      return accounts2.length > address25;
    }
    address25 = address25.toLowerCase();
    return accounts2.filter((a) => a.toLowerCase() === address25).length !== 0;
  }
  async getSigner(address25) {
    if (address25 == null) {
      address25 = 0;
    }
    if (!await this.hasSigner(address25)) {
      try {
        await this.#request("eth_requestAccounts", []);
      } catch (error) {
        const payload = error.payload;
        throw this.getRpcError(payload, { id: payload.id, error });
      }
    }
    return await super.getSigner(address25);
  }
}
// ../../node_modules/ethers/lib.esm/providers/provider-pocket.js
var getHost5 = function(name) {
  switch (name) {
    case "mainnet":
      return "eth-mainnet.gateway.pokt.network";
    case "goerli":
      return "eth-goerli.gateway.pokt.network";
    case "matic":
      return "poly-mainnet.gateway.pokt.network";
    case "matic-mumbai":
      return "polygon-mumbai-rpc.gateway.pokt.network";
  }
  assertArgument(false, "unsupported network", "network", name);
};
var defaultApplicationId = "62e1ad51b37b8e00394bda3b";

class PocketProvider extends JsonRpcProvider {
  applicationId;
  applicationSecret;
  constructor(_network, applicationId, applicationSecret) {
    if (_network == null) {
      _network = "mainnet";
    }
    const network12 = Network.from(_network);
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    if (applicationSecret == null) {
      applicationSecret = null;
    }
    const options = { staticNetwork: network12 };
    const request = PocketProvider.getRequest(network12, applicationId, applicationSecret);
    super(request, network12, options);
    defineProperties(this, { applicationId, applicationSecret });
  }
  _getProvider(chainId) {
    try {
      return new PocketProvider(chainId, this.applicationId, this.applicationSecret);
    } catch (error) {
    }
    return super._getProvider(chainId);
  }
  static getRequest(network12, applicationId, applicationSecret) {
    if (applicationId == null) {
      applicationId = defaultApplicationId;
    }
    const request = new FetchRequest(`https://${getHost5(network12.name)}/v1/lb/${applicationId}`);
    request.allowGzip = true;
    if (applicationSecret) {
      request.setCredentials("", applicationSecret);
    }
    if (applicationId === defaultApplicationId) {
      request.retryFunc = async (request2, response, attempt) => {
        showThrottleMessage("PocketProvider");
        return true;
      };
    }
    return request;
  }
  isCommunityResource() {
    return this.applicationId === defaultApplicationId;
  }
}
// ../../node_modules/ethers/lib.esm/providers/provider-ipcsocket.js
import {connect} from "net";
var splitBuffer = function(data12) {
  const messages = [];
  let lastStart = 0;
  while (true) {
    const nl = data12.indexOf(10, lastStart);
    if (nl === -1) {
      break;
    }
    messages.push(data12.subarray(lastStart, nl).toString().trim());
    lastStart = nl + 1;
  }
  return { messages, remaining: data12.subarray(lastStart) };
};

class IpcSocketProvider extends SocketProvider2 {
  #socket;
  get socket() {
    return this.#socket;
  }
  constructor(path, network12) {
    super(network12);
    this.#socket = connect(path);
    this.socket.on("ready", async () => {
      try {
        await this._start();
      } catch (error) {
        console.log("failed to start IpcSocketProvider", error);
      }
    });
    let response = Buffer.alloc(0);
    this.socket.on("data", (data12) => {
      response = Buffer.concat([response, data12]);
      const { messages, remaining } = splitBuffer(response);
      messages.forEach((message) => {
        this._processMessage(message);
      });
      response = remaining;
    });
    this.socket.on("end", () => {
      this.emit("close");
      this.socket.destroy();
      this.socket.end();
    });
  }
  destroy() {
    this.socket.destroy();
    this.socket.end();
    super.destroy();
  }
  async _write(message) {
    this.socket.write(message);
  }
}
// ../../node_modules/ethers/lib.esm/wallet/base-wallet.js
class BaseWallet extends AbstractSigner {
  address;
  #signingKey;
  constructor(privateKey, provider5) {
    super(provider5);
    assertArgument(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
    this.#signingKey = privateKey;
    const address26 = computeAddress(this.signingKey.publicKey);
    defineProperties(this, { address: address26 });
  }
  get signingKey() {
    return this.#signingKey;
  }
  get privateKey() {
    return this.signingKey.privateKey;
  }
  async getAddress() {
    return this.address;
  }
  connect(provider5) {
    return new BaseWallet(this.#signingKey, provider5);
  }
  async signTransaction(tx2) {
    const { to, from } = await resolveProperties({
      to: tx2.to ? resolveAddress(tx2.to, this.provider) : undefined,
      from: tx2.from ? resolveAddress(tx2.from, this.provider) : undefined
    });
    if (to != null) {
      tx2.to = to;
    }
    if (from != null) {
      tx2.from = from;
    }
    if (tx2.from != null) {
      assertArgument(getAddress(tx2.from) === this.address, "transaction from address mismatch", "tx.from", tx2.from);
      delete tx2.from;
    }
    const btx = Transaction2.from(tx2);
    btx.signature = this.signingKey.sign(btx.unsignedHash);
    return btx.serialized;
  }
  async signMessage(message) {
    return this.signMessageSync(message);
  }
  signMessageSync(message) {
    return this.signingKey.sign(hashMessage2(message)).serialized;
  }
  async signTypedData(domain, types15, value) {
    const populated = await TypedDataEncoder.resolveNames(domain, types15, value, async (name) => {
      assert2(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
        operation: "resolveName",
        info: { name }
      });
      const address26 = await this.provider.resolveName(name);
      assert2(address26 != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
        value: name
      });
      return address26;
    });
    return this.signingKey.sign(TypedDataEncoder.hash(populated.domain, types15, populated.value)).serialized;
  }
}
// ../../node_modules/ethers/lib.esm/wordlists/decode-owl.js
var unfold = function(words, sep) {
  let initial = 97;
  return words.reduce((accum, word) => {
    if (word === sep) {
      initial++;
    } else if (word.match(Word)) {
      accum.push(String.fromCharCode(initial) + word);
    } else {
      initial = 97;
      accum.push(word);
    }
    return accum;
  }, []);
};
function decode2(data12, subs) {
  for (let i = subsChrs.length - 1;i >= 0; i--) {
    data12 = data12.split(subsChrs[i]).join(subs.substring(2 * i, 2 * i + 2));
  }
  const clumps = [];
  const leftover = data12.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all, item, semi, word) => {
    if (semi) {
      for (let i = parseInt(semi);i >= 0; i--) {
        clumps.push(";");
      }
    } else {
      clumps.push(item.toLowerCase());
    }
    return "";
  });
  if (leftover) {
    throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
  }
  return unfold(unfold(clumps, ";"), ":");
}
function decodeOwl(data12) {
  assertArgument(data12[0] === "0", "unsupported auwl data", "data", data12);
  return decode2(data12.substring(1 + 2 * subsChrs.length), data12.substring(1, 1 + 2 * subsChrs.length));
}
var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
var Word = /^[a-z]*$/i;

// ../../node_modules/ethers/lib.esm/wordlists/wordlist.js
class Wordlist {
  locale;
  constructor(locale) {
    defineProperties(this, { locale });
  }
  split(phrase) {
    return phrase.toLowerCase().split(/\s+/g);
  }
  join(words) {
    return words.join(" ");
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/wordlist-owl.js
class WordlistOwl extends Wordlist {
  #data;
  #checksum;
  constructor(locale, data12, checksum) {
    super(locale);
    this.#data = data12;
    this.#checksum = checksum;
    this.#words = null;
  }
  get _data() {
    return this.#data;
  }
  _decodeWords() {
    return decodeOwl(this.#data);
  }
  #words;
  #loadWords() {
    if (this.#words == null) {
      const words = this._decodeWords();
      const checksum = id(words.join("\n") + "\n");
      if (checksum !== this.#checksum) {
        throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
      }
      this.#words = words;
    }
    return this.#words;
  }
  getWord(index) {
    const words = this.#loadWords();
    assertArgument(index >= 0 && index < words.length, `invalid word index: ${index}`, "index", index);
    return words[index];
  }
  getWordIndex(word) {
    return this.#loadWords().indexOf(word);
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-en.js
var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
var checksum = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
var wordlist2 = null;

class LangEn extends WordlistOwl {
  constructor() {
    super("en", words, checksum);
  }
  static wordlist() {
    if (wordlist2 == null) {
      wordlist2 = new LangEn;
    }
    return wordlist2;
  }
}

// ../../node_modules/ethers/lib.esm/wallet/mnemonic.js
var getUpperMask = function(bits) {
  return (1 << bits) - 1 << 8 - bits & 255;
};
var getLowerMask = function(bits) {
  return (1 << bits) - 1 & 255;
};
var mnemonicToEntropy = function(mnemonic, wordlist3) {
  assertNormalize("NFKD");
  if (wordlist3 == null) {
    wordlist3 = LangEn.wordlist();
  }
  const words2 = wordlist3.split(mnemonic);
  assertArgument(words2.length % 3 === 0 && words2.length >= 12 && words2.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
  const entropy = new Uint8Array(Math.ceil(11 * words2.length / 8));
  let offset = 0;
  for (let i = 0;i < words2.length; i++) {
    let index = wordlist3.getWordIndex(words2[i].normalize("NFKD"));
    assertArgument(index >= 0, `invalid mnemonic word at index ${i}`, "mnemonic", "[ REDACTED ]");
    for (let bit = 0;bit < 11; bit++) {
      if (index & 1 << 10 - bit) {
        entropy[offset >> 3] |= 1 << 7 - offset % 8;
      }
      offset++;
    }
  }
  const entropyBits = 32 * words2.length / 3;
  const checksumBits = words2.length / 3;
  const checksumMask = getUpperMask(checksumBits);
  const checksum2 = getBytes(sha2567(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
  assertArgument(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
  return hexlify(entropy.slice(0, entropyBits / 8));
};
var entropyToMnemonic = function(entropy, wordlist3) {
  assertArgument(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
  if (wordlist3 == null) {
    wordlist3 = LangEn.wordlist();
  }
  const indices = [0];
  let remainingBits = 11;
  for (let i = 0;i < entropy.length; i++) {
    if (remainingBits > 8) {
      indices[indices.length - 1] <<= 8;
      indices[indices.length - 1] |= entropy[i];
      remainingBits -= 8;
    } else {
      indices[indices.length - 1] <<= remainingBits;
      indices[indices.length - 1] |= entropy[i] >> 8 - remainingBits;
      indices.push(entropy[i] & getLowerMask(8 - remainingBits));
      remainingBits += 3;
    }
  }
  const checksumBits = entropy.length / 4;
  const checksum2 = parseInt(sha2567(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
  indices[indices.length - 1] <<= checksumBits;
  indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
  return wordlist3.join(indices.map((index) => wordlist3.getWord(index)));
};
var _guard5 = {};

class Mnemonic {
  phrase;
  password;
  wordlist;
  entropy;
  constructor(guard, entropy, phrase, password, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    assertPrivate(guard, _guard5, "Mnemonic");
    defineProperties(this, { phrase, password, wordlist: wordlist3, entropy });
  }
  computeSeed() {
    const salt = toUtf8Bytes("mnemonic" + this.password, "NFKD");
    return pbkdf25(toUtf8Bytes(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
  }
  static fromPhrase(phrase, password, wordlist3) {
    const entropy = mnemonicToEntropy(phrase, wordlist3);
    phrase = entropyToMnemonic(getBytes(entropy), wordlist3);
    return new Mnemonic(_guard5, entropy, phrase, password, wordlist3);
  }
  static fromEntropy(_entropy, password, wordlist3) {
    const entropy = getBytes(_entropy, "entropy");
    const phrase = entropyToMnemonic(entropy, wordlist3);
    return new Mnemonic(_guard5, hexlify(entropy), phrase, password, wordlist3);
  }
  static entropyToPhrase(_entropy, wordlist3) {
    const entropy = getBytes(_entropy, "entropy");
    return entropyToMnemonic(entropy, wordlist3);
  }
  static phraseToEntropy(phrase, wordlist3) {
    return mnemonicToEntropy(phrase, wordlist3);
  }
  static isValidMnemonic(phrase, wordlist3) {
    try {
      mnemonicToEntropy(phrase, wordlist3);
      return true;
    } catch (error) {
    }
    return false;
  }
}

// ../../node_modules/aes-js/lib.esm/aes.js
var convertToInt32 = function(bytes10) {
  const result = [];
  for (let i = 0;i < bytes10.length; i += 4) {
    result.push(bytes10[i] << 24 | bytes10[i + 1] << 16 | bytes10[i + 2] << 8 | bytes10[i + 3]);
  }
  return result;
};
/*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. */
var __classPrivateFieldGet = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var __classPrivateFieldSet = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var _AES_key;
var _AES_Kd;
var _AES_Ke;
var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
var S = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
var Si = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
var T13 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
var T2 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
var T3 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239000, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998000, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239000, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998000, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];

class AES {
  get key() {
    return __classPrivateFieldGet(this, _AES_key, "f").slice();
  }
  constructor(key) {
    _AES_key.set(this, undefined);
    _AES_Kd.set(this, undefined);
    _AES_Ke.set(this, undefined);
    if (!(this instanceof AES)) {
      throw Error("AES must be instanitated with `new`");
    }
    __classPrivateFieldSet(this, _AES_key, new Uint8Array(key), "f");
    const rounds = numberOfRounds[this.key.length];
    if (rounds == null) {
      throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
    }
    __classPrivateFieldSet(this, _AES_Ke, [], "f");
    __classPrivateFieldSet(this, _AES_Kd, [], "f");
    for (let i = 0;i <= rounds; i++) {
      __classPrivateFieldGet(this, _AES_Ke, "f").push([0, 0, 0, 0]);
      __classPrivateFieldGet(this, _AES_Kd, "f").push([0, 0, 0, 0]);
    }
    const roundKeyCount = (rounds + 1) * 4;
    const KC = this.key.length / 4;
    const tk = convertToInt32(this.key);
    let index;
    for (let i = 0;i < KC; i++) {
      index = i >> 2;
      __classPrivateFieldGet(this, _AES_Ke, "f")[index][i % 4] = tk[i];
      __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - index][i % 4] = tk[i];
    }
    let rconpointer = 0;
    let t = KC, tt;
    while (t < roundKeyCount) {
      tt = tk[KC - 1];
      tk[0] ^= S[tt >> 16 & 255] << 24 ^ S[tt >> 8 & 255] << 16 ^ S[tt & 255] << 8 ^ S[tt >> 24 & 255] ^ rcon[rconpointer] << 24;
      rconpointer += 1;
      if (KC != 8) {
        for (let i2 = 1;i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      } else {
        for (let i2 = 1;i2 < KC / 2; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
        tt = tk[KC / 2 - 1];
        tk[KC / 2] ^= S[tt & 255] ^ S[tt >> 8 & 255] << 8 ^ S[tt >> 16 & 255] << 16 ^ S[tt >> 24 & 255] << 24;
        for (let i2 = KC / 2 + 1;i2 < KC; i2++) {
          tk[i2] ^= tk[i2 - 1];
        }
      }
      let i = 0, r2, c;
      while (i < KC && t < roundKeyCount) {
        r2 = t >> 2;
        c = t % 4;
        __classPrivateFieldGet(this, _AES_Ke, "f")[r2][c] = tk[i];
        __classPrivateFieldGet(this, _AES_Kd, "f")[rounds - r2][c] = tk[i++];
        t++;
      }
    }
    for (let r2 = 1;r2 < rounds; r2++) {
      for (let c = 0;c < 4; c++) {
        tt = __classPrivateFieldGet(this, _AES_Kd, "f")[r2][c];
        __classPrivateFieldGet(this, _AES_Kd, "f")[r2][c] = U1[tt >> 24 & 255] ^ U2[tt >> 16 & 255] ^ U3[tt >> 8 & 255] ^ U4[tt & 255];
      }
    }
  }
  encrypt(plaintext) {
    if (plaintext.length != 16) {
      throw new TypeError("invalid plaintext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Ke, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(plaintext);
    for (let i = 0;i < 4; i++) {
      t[i] ^= __classPrivateFieldGet(this, _AES_Ke, "f")[0][i];
    }
    for (let r2 = 1;r2 < rounds; r2++) {
      for (let i = 0;i < 4; i++) {
        a[i] = T13[t[i] >> 24 & 255] ^ T2[t[(i + 1) % 4] >> 16 & 255] ^ T3[t[(i + 2) % 4] >> 8 & 255] ^ T4[t[(i + 3) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Ke, "f")[r2][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0;i < 4; i++) {
      tt = __classPrivateFieldGet(this, _AES_Ke, "f")[rounds][i];
      result[4 * i] = (S[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (S[t[(i + 1) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (S[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (S[t[(i + 3) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
  decrypt(ciphertext) {
    if (ciphertext.length != 16) {
      throw new TypeError("invalid ciphertext size (must be 16 bytes)");
    }
    const rounds = __classPrivateFieldGet(this, _AES_Kd, "f").length - 1;
    const a = [0, 0, 0, 0];
    let t = convertToInt32(ciphertext);
    for (let i = 0;i < 4; i++) {
      t[i] ^= __classPrivateFieldGet(this, _AES_Kd, "f")[0][i];
    }
    for (let r2 = 1;r2 < rounds; r2++) {
      for (let i = 0;i < 4; i++) {
        a[i] = T5[t[i] >> 24 & 255] ^ T6[t[(i + 3) % 4] >> 16 & 255] ^ T7[t[(i + 2) % 4] >> 8 & 255] ^ T8[t[(i + 1) % 4] & 255] ^ __classPrivateFieldGet(this, _AES_Kd, "f")[r2][i];
      }
      t = a.slice();
    }
    const result = new Uint8Array(16);
    let tt = 0;
    for (let i = 0;i < 4; i++) {
      tt = __classPrivateFieldGet(this, _AES_Kd, "f")[rounds][i];
      result[4 * i] = (Si[t[i] >> 24 & 255] ^ tt >> 24) & 255;
      result[4 * i + 1] = (Si[t[(i + 3) % 4] >> 16 & 255] ^ tt >> 16) & 255;
      result[4 * i + 2] = (Si[t[(i + 2) % 4] >> 8 & 255] ^ tt >> 8) & 255;
      result[4 * i + 3] = (Si[t[(i + 1) % 4] & 255] ^ tt) & 255;
    }
    return result;
  }
}
_AES_key = new WeakMap, _AES_Kd = new WeakMap, _AES_Ke = new WeakMap;

// ../../node_modules/aes-js/lib.esm/mode.js
class ModeOfOperation {
  constructor(name, key, cls) {
    if (cls && !(this instanceof cls)) {
      throw new Error(`${name} must be instantiated with "new"`);
    }
    Object.defineProperties(this, {
      aes: { enumerable: true, value: new AES(key) },
      name: { enumerable: true, value: name }
    });
  }
}

// ../../node_modules/aes-js/lib.esm/mode-cbc.js
var __classPrivateFieldSet2 = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet2 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CBC_iv;
var _CBC_lastBlock;

class CBC extends ModeOfOperation {
  constructor(key, iv) {
    super("ECC", key, CBC);
    _CBC_iv.set(this, undefined);
    _CBC_lastBlock.set(this, undefined);
    if (iv) {
      if (iv.length % 16) {
        throw new TypeError("invalid iv size (must be 16 bytes)");
      }
      __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(iv), "f");
    } else {
      __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(16), "f");
    }
    __classPrivateFieldSet2(this, _CBC_lastBlock, this.iv, "f");
  }
  get iv() {
    return new Uint8Array(__classPrivateFieldGet2(this, _CBC_iv, "f"));
  }
  encrypt(plaintext) {
    if (plaintext.length % 16) {
      throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
    }
    const ciphertext = new Uint8Array(plaintext.length);
    for (let i = 0;i < plaintext.length; i += 16) {
      for (let j = 0;j < 16; j++) {
        __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] ^= plaintext[i + j];
      }
      __classPrivateFieldSet2(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet2(this, _CBC_lastBlock, "f")), "f");
      ciphertext.set(__classPrivateFieldGet2(this, _CBC_lastBlock, "f"), i);
    }
    return ciphertext;
  }
  decrypt(ciphertext) {
    if (ciphertext.length % 16) {
      throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
    }
    const plaintext = new Uint8Array(ciphertext.length);
    for (let i = 0;i < ciphertext.length; i += 16) {
      const block4 = this.aes.decrypt(ciphertext.subarray(i, i + 16));
      for (let j = 0;j < 16; j++) {
        plaintext[i + j] = block4[j] ^ __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j];
        __classPrivateFieldGet2(this, _CBC_lastBlock, "f")[j] = ciphertext[i + j];
      }
    }
    return plaintext;
  }
}
_CBC_iv = new WeakMap, _CBC_lastBlock = new WeakMap;
// ../../node_modules/aes-js/lib.esm/mode-ctr.js
var __classPrivateFieldSet3 = function(receiver, state, value, kind, f2) {
  if (kind === "m")
    throw new TypeError("Private method is not writable");
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f2.call(receiver, value) : f2 ? f2.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet3 = function(receiver, state, kind, f2) {
  if (kind === "a" && !f2)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f2 : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f2 : kind === "a" ? f2.call(receiver) : f2 ? f2.value : state.get(receiver);
};
var _CTR_remaining;
var _CTR_remainingIndex;
var _CTR_counter;

class CTR extends ModeOfOperation {
  constructor(key, initialValue) {
    super("CTR", key, CTR);
    _CTR_remaining.set(this, undefined);
    _CTR_remainingIndex.set(this, undefined);
    _CTR_counter.set(this, undefined);
    __classPrivateFieldSet3(this, _CTR_counter, new Uint8Array(16), "f");
    __classPrivateFieldGet3(this, _CTR_counter, "f").fill(0);
    __classPrivateFieldSet3(this, _CTR_remaining, __classPrivateFieldGet3(this, _CTR_counter, "f"), "f");
    __classPrivateFieldSet3(this, _CTR_remainingIndex, 16, "f");
    if (initialValue == null) {
      initialValue = 1;
    }
    if (typeof initialValue === "number") {
      this.setCounterValue(initialValue);
    } else {
      this.setCounterBytes(initialValue);
    }
  }
  get counter() {
    return new Uint8Array(__classPrivateFieldGet3(this, _CTR_counter, "f"));
  }
  setCounterValue(value) {
    if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
      throw new TypeError("invalid counter initial integer value");
    }
    for (let index = 15;index >= 0; --index) {
      __classPrivateFieldGet3(this, _CTR_counter, "f")[index] = value % 256;
      value = Math.floor(value / 256);
    }
  }
  setCounterBytes(value) {
    if (value.length !== 16) {
      throw new TypeError("invalid counter initial Uint8Array value length");
    }
    __classPrivateFieldGet3(this, _CTR_counter, "f").set(value);
  }
  increment() {
    for (let i = 15;i >= 0; i--) {
      if (__classPrivateFieldGet3(this, _CTR_counter, "f")[i] === 255) {
        __classPrivateFieldGet3(this, _CTR_counter, "f")[i] = 0;
      } else {
        __classPrivateFieldGet3(this, _CTR_counter, "f")[i]++;
        break;
      }
    }
  }
  encrypt(plaintext) {
    var _a4, _b;
    const crypttext = new Uint8Array(plaintext);
    for (let i = 0;i < crypttext.length; i++) {
      if (__classPrivateFieldGet3(this, _CTR_remainingIndex, "f") === 16) {
        __classPrivateFieldSet3(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet3(this, _CTR_counter, "f")), "f");
        __classPrivateFieldSet3(this, _CTR_remainingIndex, 0, "f");
        this.increment();
      }
      crypttext[i] ^= __classPrivateFieldGet3(this, _CTR_remaining, "f")[__classPrivateFieldSet3(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet3(this, _CTR_remainingIndex, "f"), _a4 = _b++, _b), "f"), _a4];
    }
    return crypttext;
  }
  decrypt(ciphertext) {
    return this.encrypt(ciphertext);
  }
}
_CTR_remaining = new WeakMap, _CTR_remainingIndex = new WeakMap, _CTR_counter = new WeakMap;
// ../../node_modules/aes-js/lib.esm/padding.js
function pkcs7Strip(data12) {
  if (data12.length < 16) {
    throw new TypeError("PKCS#7 invalid length");
  }
  const padder = data12[data12.length - 1];
  if (padder > 16) {
    throw new TypeError("PKCS#7 padding byte out of range");
  }
  const length = data12.length - padder;
  for (let i = 0;i < padder; i++) {
    if (data12[length + i] !== padder) {
      throw new TypeError("PKCS#7 invalid padding byte");
    }
  }
  return new Uint8Array(data12.subarray(0, length));
}
// ../../node_modules/ethers/lib.esm/wallet/utils.js
function looseArrayify(hexString) {
  if (typeof hexString === "string" && !hexString.startsWith("0x")) {
    hexString = "0x" + hexString;
  }
  return getBytesCopy(hexString);
}
function zpad(value, length) {
  value = String(value);
  while (value.length < length) {
    value = "0" + value;
  }
  return value;
}
function getPassword(password) {
  if (typeof password === "string") {
    return toUtf8Bytes(password, "NFKC");
  }
  return getBytesCopy(password);
}
function spelunk(object4, _path) {
  const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
  assertArgument(match != null, "invalid path", "path", _path);
  const path = match[1];
  const type = match[3];
  const reqd = match[4] === "!";
  let cur = object4;
  for (const comp of path.toLowerCase().split(".")) {
    if (Array.isArray(cur)) {
      if (!comp.match(/^[0-9]+$/)) {
        break;
      }
      cur = cur[parseInt(comp)];
    } else if (typeof cur === "object") {
      let found = null;
      for (const key in cur) {
        if (key.toLowerCase() === comp) {
          found = cur[key];
          break;
        }
      }
      cur = found;
    } else {
      cur = null;
    }
    if (cur == null) {
      break;
    }
  }
  assertArgument(!reqd || cur != null, "missing required value", "path", path);
  if (type && cur != null) {
    if (type === "int") {
      if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
        return parseInt(cur);
      } else if (Number.isSafeInteger(cur)) {
        return cur;
      }
    }
    if (type === "number") {
      if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
        return parseFloat(cur);
      }
    }
    if (type === "data") {
      if (typeof cur === "string") {
        return looseArrayify(cur);
      }
    }
    if (type === "array" && Array.isArray(cur)) {
      return cur;
    }
    if (type === typeof cur) {
      return cur;
    }
    assertArgument(false, `wrong type found for ${type} `, "path", path);
  }
  return cur;
}

// ../../node_modules/ethers/lib.esm/wallet/json-keystore.js
function isKeystoreJson(json) {
  try {
    const data12 = JSON.parse(json);
    const version3 = data12.version != null ? parseInt(data12.version) : 0;
    if (version3 === 3) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
var decrypt3 = function(data12, key, ciphertext) {
  const cipher = spelunk(data12, "crypto.cipher:string");
  if (cipher === "aes-128-ctr") {
    const iv = spelunk(data12, "crypto.cipherparams.iv:data!");
    const aesCtr = new CTR(key, iv);
    return hexlify(aesCtr.decrypt(ciphertext));
  }
  assert2(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
    operation: "decrypt"
  });
};
var getAccount = function(data12, _key) {
  const key = getBytes(_key);
  const ciphertext = spelunk(data12, "crypto.ciphertext:data!");
  const computedMAC = hexlify(keccak2562(concat([key.slice(16, 32), ciphertext]))).substring(2);
  assertArgument(computedMAC === spelunk(data12, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
  const privateKey = decrypt3(data12, key.slice(0, 16), ciphertext);
  const address27 = computeAddress(privateKey);
  if (data12.address) {
    let check = data12.address.toLowerCase();
    if (!check.startsWith("0x")) {
      check = "0x" + check;
    }
    assertArgument(getAddress(check) === address27, "keystore address/privateKey mismatch", "address", data12.address);
  }
  const account2 = { address: address27, privateKey };
  const version3 = spelunk(data12, "x-ethers.version:string");
  if (version3 === "0.1") {
    const mnemonicKey = key.slice(32, 64);
    const mnemonicCiphertext = spelunk(data12, "x-ethers.mnemonicCiphertext:data!");
    const mnemonicIv = spelunk(data12, "x-ethers.mnemonicCounter:data!");
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    account2.mnemonic = {
      path: spelunk(data12, "x-ethers.path:string") || defaultPath,
      locale: spelunk(data12, "x-ethers.locale:string") || "en",
      entropy: hexlify(getBytes(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
    };
  }
  return account2;
};
var getDecryptKdfParams = function(data12) {
  const kdf = spelunk(data12, "crypto.kdf:string");
  if (kdf && typeof kdf === "string") {
    if (kdf.toLowerCase() === "scrypt") {
      const salt = spelunk(data12, "crypto.kdfparams.salt:data!");
      const N2 = spelunk(data12, "crypto.kdfparams.n:int!");
      const r2 = spelunk(data12, "crypto.kdfparams.r:int!");
      const p = spelunk(data12, "crypto.kdfparams.p:int!");
      assertArgument(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
      assertArgument(r2 > 0 && p > 0, "invalid kdf", "kdf", kdf);
      const dkLen = spelunk(data12, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
      return { name: "scrypt", salt, N: N2, r: r2, p, dkLen: 64 };
    } else if (kdf.toLowerCase() === "pbkdf2") {
      const salt = spelunk(data12, "crypto.kdfparams.salt:data!");
      const prf = spelunk(data12, "crypto.kdfparams.prf:string!");
      const algorithm = prf.split("-").pop();
      assertArgument(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
      const count = spelunk(data12, "crypto.kdfparams.c:int!");
      const dkLen = spelunk(data12, "crypto.kdfparams.dklen:int!");
      assertArgument(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
      return { name: "pbkdf2", salt, count, dkLen, algorithm };
    }
  }
  assertArgument(false, "unsupported key-derivation function", "kdf", kdf);
};
function decryptKeystoreJsonSync(json, _password) {
  const data12 = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data12);
  if (params.name === "pbkdf2") {
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf25(password, salt2, count, dkLen2, algorithm);
    return getAccount(data12, key2);
  }
  assert2(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r: r2, p, dkLen } = params;
  const key = scryptSync2(password, salt, N2, r2, p, dkLen);
  return getAccount(data12, key);
}
var stall3 = function(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
};
async function decryptKeystoreJson(json, _password, progress) {
  const data12 = JSON.parse(json);
  const password = getPassword(_password);
  const params = getDecryptKdfParams(data12);
  if (params.name === "pbkdf2") {
    if (progress) {
      progress(0);
      await stall3(0);
    }
    const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
    const key2 = pbkdf25(password, salt2, count, dkLen2, algorithm);
    if (progress) {
      progress(1);
      await stall3(0);
    }
    return getAccount(data12, key2);
  }
  assert2(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
  const { salt, N: N2, r: r2, p, dkLen } = params;
  const key = await scrypt6(password, salt, N2, r2, p, dkLen, progress);
  return getAccount(data12, key);
}
var getEncryptKdfParams = function(options) {
  const salt = options.salt != null ? getBytes(options.salt, "options.salt") : randomBytes4(32);
  let N2 = 1 << 17, r2 = 8, p = 1;
  if (options.scrypt) {
    if (options.scrypt.N) {
      N2 = options.scrypt.N;
    }
    if (options.scrypt.r) {
      r2 = options.scrypt.r;
    }
    if (options.scrypt.p) {
      p = options.scrypt.p;
    }
  }
  assertArgument(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
  assertArgument(typeof r2 === "number" && r2 > 0 && Number.isSafeInteger(r2), "invalid scrypt r parameter", "options.r", r2);
  assertArgument(typeof p === "number" && p > 0 && Number.isSafeInteger(p), "invalid scrypt p parameter", "options.p", p);
  return { name: "scrypt", dkLen: 32, salt, N: N2, r: r2, p };
};
var _encryptKeystore = function(key, kdf, account2, options) {
  const privateKey = getBytes(account2.privateKey, "privateKey");
  const iv = options.iv != null ? getBytes(options.iv, "options.iv") : randomBytes4(16);
  assertArgument(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
  const uuidRandom = options.uuid != null ? getBytes(options.uuid, "options.uuid") : randomBytes4(16);
  assertArgument(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
  const derivedKey = key.slice(0, 16);
  const macPrefix = key.slice(16, 32);
  const aesCtr = new CTR(derivedKey, iv);
  const ciphertext = getBytes(aesCtr.encrypt(privateKey));
  const mac = keccak2562(concat([macPrefix, ciphertext]));
  const data12 = {
    address: account2.address.substring(2).toLowerCase(),
    id: uuidV42(uuidRandom),
    version: 3,
    Crypto: {
      cipher: "aes-128-ctr",
      cipherparams: {
        iv: hexlify(iv).substring(2)
      },
      ciphertext: hexlify(ciphertext).substring(2),
      kdf: "scrypt",
      kdfparams: {
        salt: hexlify(kdf.salt).substring(2),
        n: kdf.N,
        dklen: 32,
        p: kdf.p,
        r: kdf.r
      },
      mac: mac.substring(2)
    }
  };
  if (account2.mnemonic) {
    const client = options.client != null ? options.client : `ethers/${version2}`;
    const path = account2.mnemonic.path || defaultPath;
    const locale = account2.mnemonic.locale || "en";
    const mnemonicKey = key.slice(32, 64);
    const entropy = getBytes(account2.mnemonic.entropy, "account.mnemonic.entropy");
    const mnemonicIv = randomBytes4(16);
    const mnemonicAesCtr = new CTR(mnemonicKey, mnemonicIv);
    const mnemonicCiphertext = getBytes(mnemonicAesCtr.encrypt(entropy));
    const now = new Date;
    const timestamp = now.getUTCFullYear() + "-" + zpad(now.getUTCMonth() + 1, 2) + "-" + zpad(now.getUTCDate(), 2) + "T" + zpad(now.getUTCHours(), 2) + "-" + zpad(now.getUTCMinutes(), 2) + "-" + zpad(now.getUTCSeconds(), 2) + ".0Z";
    const gethFilename = "UTC--" + timestamp + "--" + data12.address;
    data12["x-ethers"] = {
      client,
      gethFilename,
      path,
      locale,
      mnemonicCounter: hexlify(mnemonicIv).substring(2),
      mnemonicCiphertext: hexlify(mnemonicCiphertext).substring(2),
      version: "0.1"
    };
  }
  return JSON.stringify(data12);
};
function encryptKeystoreJsonSync(account2, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = scryptSync2(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
  return _encryptKeystore(getBytes(key), kdf, account2, options);
}
async function encryptKeystoreJson(account2, password, options) {
  if (options == null) {
    options = {};
  }
  const passwordBytes = getPassword(password);
  const kdf = getEncryptKdfParams(options);
  const key = await scrypt6(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
  return _encryptKeystore(getBytes(key), kdf, account2, options);
}
var defaultPath = "m/44'/60'/0'/0/0";

// ../../node_modules/ethers/lib.esm/wallet/hdwallet.js
var zpad2 = function(value, length) {
  let result = "";
  while (value) {
    result = Nibbles2[value % 16] + result;
    value = Math.trunc(value / 16);
  }
  while (result.length < length * 2) {
    result = "0" + result;
  }
  return "0x" + result;
};
var encodeBase58Check = function(_value) {
  const value = getBytes(_value);
  const check = dataSlice(sha2567(sha2567(value)), 0, 4);
  const bytes10 = concat([value, check]);
  return encodeBase58(bytes10);
};
var ser_I = function(index, chainCode, publicKey, privateKey) {
  const data12 = new Uint8Array(37);
  if (index & HardenedBit) {
    assert2(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
      operation: "deriveChild"
    });
    data12.set(getBytes(privateKey), 1);
  } else {
    data12.set(getBytes(publicKey));
  }
  for (let i = 24;i >= 0; i -= 8) {
    data12[33 + (i >> 3)] = index >> 24 - i & 255;
  }
  const I = getBytes(computeHmac("sha512", chainCode, data12));
  return { IL: I.slice(0, 32), IR: I.slice(32) };
};
var derivePath = function(node, path) {
  const components = path.split("/");
  assertArgument(components.length > 0 && (components[0] === "m" || node.depth > 0), "invalid path", "path", path);
  if (components[0] === "m") {
    components.shift();
  }
  let result = node;
  for (let i = 0;i < components.length; i++) {
    const component = components[i];
    if (component.match(/^[0-9]+'$/)) {
      const index = parseInt(component.substring(0, component.length - 1));
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(HardenedBit + index);
    } else if (component.match(/^[0-9]+$/)) {
      const index = parseInt(component);
      assertArgument(index < HardenedBit, "invalid path index", `path[${i}]`, component);
      result = result.deriveChild(index);
    } else {
      assertArgument(false, "invalid path component", `path[${i}]`, component);
    }
  }
  return result;
};
function getAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/${index}'/0/0`;
}
function getIndexedAccountPath(_index) {
  const index = getNumber(_index, "index");
  assertArgument(index >= 0 && index < HardenedBit, "invalid account index", "index", index);
  return `m/44'/60'/0'/0/${index}`;
}
var defaultPath2 = "m/44'/60'/0'/0/0";
var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
var HardenedBit = 2147483648;
var N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
var Nibbles2 = "0123456789abcdef";
var _guard6 = {};

class HDNodeWallet extends BaseWallet {
  publicKey;
  fingerprint;
  parentFingerprint;
  mnemonic;
  chainCode;
  path;
  index;
  depth;
  constructor(guard, signingKey, parentFingerprint, chainCode, path, index, depth, mnemonic2, provider5) {
    super(signingKey, provider5);
    assertPrivate(guard, _guard6, "HDNodeWallet");
    defineProperties(this, { publicKey: signingKey.compressedPublicKey });
    const fingerprint = dataSlice(ripemd1603(sha2567(this.publicKey)), 0, 4);
    defineProperties(this, {
      parentFingerprint,
      fingerprint,
      chainCode,
      path,
      index,
      depth
    });
    defineProperties(this, { mnemonic: mnemonic2 });
  }
  connect(provider5) {
    return new HDNodeWallet(_guard6, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider5);
  }
  #account() {
    const account2 = { address: this.address, privateKey: this.privateKey };
    const m = this.mnemonic;
    if (this.path && m && m.wordlist.locale === "en" && m.password === "") {
      account2.mnemonic = {
        path: this.path,
        locale: "en",
        entropy: m.entropy
      };
    }
    return account2;
  }
  async encrypt(password, progressCallback) {
    return await encryptKeystoreJson(this.#account(), password, { progressCallback });
  }
  encryptSync(password) {
    return encryptKeystoreJsonSync(this.#account(), password);
  }
  get extendedKey() {
    assert2(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488ADE4",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      concat(["0x00", this.privateKey])
    ]));
  }
  hasPath() {
    return this.path != null;
  }
  neuter() {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
  }
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, this.privateKey);
    const ki = new SigningKey(toBeHex((toBigInt2(IL) + BigInt(this.privateKey)) % N2, 32));
    return new HDNodeWallet(_guard6, ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.mnemonic, this.provider);
  }
  derivePath(path) {
    return derivePath(this, path);
  }
  static #fromSeed(_seed, mnemonic2) {
    assertArgument(isBytesLike(_seed), "invalid seed", "seed", "[REDACTED]");
    const seed = getBytes(_seed, "seed");
    assertArgument(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
    const I = getBytes(computeHmac("sha512", MasterSecret, seed));
    const signingKey = new SigningKey(hexlify(I.slice(0, 32)));
    return new HDNodeWallet(_guard6, signingKey, "0x00000000", hexlify(I.slice(32)), "m", 0, 0, mnemonic2, null);
  }
  static fromExtendedKey(extendedKey) {
    const bytes10 = toBeArray(decodeBase58(extendedKey));
    assertArgument(bytes10.length === 82 || encodeBase58Check(bytes10.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
    const depth = bytes10[4];
    const parentFingerprint = hexlify(bytes10.slice(5, 9));
    const index = parseInt(hexlify(bytes10.slice(9, 13)).substring(2), 16);
    const chainCode = hexlify(bytes10.slice(13, 45));
    const key = bytes10.slice(45, 78);
    switch (hexlify(bytes10.slice(0, 4))) {
      case "0x0488b21e":
      case "0x043587cf": {
        const publicKey = hexlify(key);
        return new HDNodeVoidWallet(_guard6, computeAddress(publicKey), publicKey, parentFingerprint, chainCode, null, index, depth, null);
      }
      case "0x0488ade4":
      case "0x04358394 ":
        if (key[0] !== 0) {
          break;
        }
        return new HDNodeWallet(_guard6, new SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index, depth, null, null);
    }
    assertArgument(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
  }
  static createRandom(password, path, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    const mnemonic2 = Mnemonic.fromEntropy(randomBytes4(16), password, wordlist3);
    return HDNodeWallet.#fromSeed(mnemonic2.computeSeed(), mnemonic2).derivePath(path);
  }
  static fromMnemonic(mnemonic2, path) {
    if (!path) {
      path = defaultPath2;
    }
    return HDNodeWallet.#fromSeed(mnemonic2.computeSeed(), mnemonic2).derivePath(path);
  }
  static fromPhrase(phrase, password, path, wordlist3) {
    if (password == null) {
      password = "";
    }
    if (path == null) {
      path = defaultPath2;
    }
    if (wordlist3 == null) {
      wordlist3 = LangEn.wordlist();
    }
    const mnemonic2 = Mnemonic.fromPhrase(phrase, password, wordlist3);
    return HDNodeWallet.#fromSeed(mnemonic2.computeSeed(), mnemonic2).derivePath(path);
  }
  static fromSeed(seed) {
    return HDNodeWallet.#fromSeed(seed, null);
  }
}

class HDNodeVoidWallet extends VoidSigner {
  publicKey;
  fingerprint;
  parentFingerprint;
  chainCode;
  path;
  index;
  depth;
  constructor(guard, address27, publicKey, parentFingerprint, chainCode, path, index, depth, provider5) {
    super(address27, provider5);
    assertPrivate(guard, _guard6, "HDNodeVoidWallet");
    defineProperties(this, { publicKey });
    const fingerprint = dataSlice(ripemd1603(sha2567(publicKey)), 0, 4);
    defineProperties(this, {
      publicKey,
      fingerprint,
      parentFingerprint,
      chainCode,
      path,
      index,
      depth
    });
  }
  connect(provider5) {
    return new HDNodeVoidWallet(_guard6, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider5);
  }
  get extendedKey() {
    assert2(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
    return encodeBase58Check(concat([
      "0x0488B21E",
      zpad2(this.depth, 1),
      this.parentFingerprint,
      zpad2(this.index, 4),
      this.chainCode,
      this.publicKey
    ]));
  }
  hasPath() {
    return this.path != null;
  }
  deriveChild(_index) {
    const index = getNumber(_index, "index");
    assertArgument(index <= 4294967295, "invalid index", "index", index);
    let path = this.path;
    if (path) {
      path += "/" + (index & ~HardenedBit);
      if (index & HardenedBit) {
        path += "'";
      }
    }
    const { IR, IL } = ser_I(index, this.chainCode, this.publicKey, null);
    const Ki = SigningKey.addPoints(IL, this.publicKey, true);
    const address27 = computeAddress(Ki);
    return new HDNodeVoidWallet(_guard6, address27, Ki, this.fingerprint, hexlify(IR), path, index, this.depth + 1, this.provider);
  }
  derivePath(path) {
    return derivePath(this, path);
  }
}
// ../../node_modules/ethers/lib.esm/wallet/json-crowdsale.js
function isCrowdsaleJson(json) {
  try {
    const data12 = JSON.parse(json);
    if (data12.encseed) {
      return true;
    }
  } catch (error) {
  }
  return false;
}
function decryptCrowdsaleJson(json, _password) {
  const data12 = JSON.parse(json);
  const password = getPassword(_password);
  const address28 = getAddress(spelunk(data12, "ethaddr:string!"));
  const encseed = looseArrayify(spelunk(data12, "encseed:string!"));
  assertArgument(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
  const key = getBytes(pbkdf25(password, password, 2000, 32, "sha256")).slice(0, 16);
  const iv = encseed.slice(0, 16);
  const encryptedSeed = encseed.slice(16);
  const aesCbc = new CBC(key, iv);
  const seed = pkcs7Strip(getBytes(aesCbc.decrypt(encryptedSeed)));
  let seedHex = "";
  for (let i = 0;i < seed.length; i++) {
    seedHex += String.fromCharCode(seed[i]);
  }
  return { address: address28, privateKey: id(seedHex) };
}
// ../../node_modules/ethers/lib.esm/wallet/wallet.js
var stall4 = function(duration) {
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve();
    }, duration);
  });
};

class Wallet2 extends BaseWallet {
  constructor(key, provider5) {
    if (typeof key === "string" && !key.startsWith("0x")) {
      key = "0x" + key;
    }
    let signingKey = typeof key === "string" ? new SigningKey(key) : key;
    super(signingKey, provider5);
  }
  connect(provider5) {
    return new Wallet2(this.signingKey, provider5);
  }
  async encrypt(password, progressCallback) {
    const account2 = { address: this.address, privateKey: this.privateKey };
    return await encryptKeystoreJson(account2, password, { progressCallback });
  }
  encryptSync(password) {
    const account2 = { address: this.address, privateKey: this.privateKey };
    return encryptKeystoreJsonSync(account2, password);
  }
  static #fromAccount(account2) {
    assertArgument(account2, "invalid JSON wallet", "json", "[ REDACTED ]");
    if ("mnemonic" in account2 && account2.mnemonic && account2.mnemonic.locale === "en") {
      const mnemonic3 = Mnemonic.fromEntropy(account2.mnemonic.entropy);
      const wallet3 = HDNodeWallet.fromMnemonic(mnemonic3, account2.mnemonic.path);
      if (wallet3.address === account2.address && wallet3.privateKey === account2.privateKey) {
        return wallet3;
      }
      console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
    }
    const wallet2 = new Wallet2(account2.privateKey);
    assertArgument(wallet2.address === account2.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
    return wallet2;
  }
  static async fromEncryptedJson(json, password, progress) {
    let account2 = null;
    if (isKeystoreJson(json)) {
      account2 = await decryptKeystoreJson(json, password, progress);
    } else if (isCrowdsaleJson(json)) {
      if (progress) {
        progress(0);
        await stall4(0);
      }
      account2 = decryptCrowdsaleJson(json, password);
      if (progress) {
        progress(1);
        await stall4(0);
      }
    }
    return Wallet2.#fromAccount(account2);
  }
  static fromEncryptedJsonSync(json, password) {
    let account2 = null;
    if (isKeystoreJson(json)) {
      account2 = decryptKeystoreJsonSync(json, password);
    } else if (isCrowdsaleJson(json)) {
      account2 = decryptCrowdsaleJson(json, password);
    } else {
      assertArgument(false, "invalid JSON wallet", "json", "[ REDACTED ]");
    }
    return Wallet2.#fromAccount(account2);
  }
  static createRandom(provider5) {
    const wallet2 = HDNodeWallet.createRandom();
    if (provider5) {
      return wallet2.connect(provider5);
    }
    return wallet2;
  }
  static fromPhrase(phrase, provider5) {
    const wallet2 = HDNodeWallet.fromPhrase(phrase);
    if (provider5) {
      return wallet2.connect(provider5);
    }
    return wallet2;
  }
}
// ../../node_modules/ethers/lib.esm/wordlists/bit-reader.js
function decodeBits(width, data12) {
  const maxValue2 = (1 << width) - 1;
  const result = [];
  let accum = 0, bits = 0, flood = 0;
  for (let i = 0;i < data12.length; i++) {
    accum = accum << 6 | Base64.indexOf(data12[i]);
    bits += 6;
    while (bits >= width) {
      const value = accum >> bits - width;
      accum &= (1 << bits - width) - 1;
      bits -= width;
      if (value === 0) {
        flood += maxValue2;
      } else {
        result.push(value + flood);
        flood = 0;
      }
    }
  }
  return result;
}
var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";

// ../../node_modules/ethers/lib.esm/wordlists/decode-owla.js
function decodeOwlA(data12, accents) {
  let words2 = decodeOwl(data12).join(",");
  accents.split(/,/g).forEach((accent) => {
    const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
    assertArgument(match !== null, "internal error parsing accents", "accents", accents);
    let posOffset = 0;
    const positions = decodeBits(parseInt(match[3]), match[4]);
    const charCode = parseInt(match[2]);
    const regex = new RegExp(`([${match[1]}])`, "g");
    words2 = words2.replace(regex, (all, letter) => {
      const rem = --positions[posOffset];
      if (rem === 0) {
        letter = String.fromCharCode(letter.charCodeAt(0), charCode);
        posOffset++;
      }
      return letter;
    });
  });
  return words2.split(",");
}

// ../../node_modules/ethers/lib.esm/wordlists/wordlist-owla.js
class WordlistOwlA extends WordlistOwl {
  #accent;
  constructor(locale, data12, accent, checksum2) {
    super(locale, data12, checksum2);
    this.#accent = accent;
  }
  get _accent() {
    return this.#accent;
  }
  _decodeWords() {
    return decodeOwlA(this._data, this._accent);
  }
}
// ../../node_modules/ethers/lib.esm/wordlists/lang-cz.js
var words2 = "0itatkastcenaovo$taouleraeki&chor*teci%enbalodaeladet'!Chn=0Di#%E%^1Resa2Rese3CeT'#0EjKohol0Pu)%0A&sDul#Ekdo)Ke)Ti#Ul|3}aOgan%0FaltI$@tPi,%TmaTronom0LasL{i#Ol0Tobus4Yl:B#}<CilCul#D!_Ge)GrHnoKterieLa^L{#LkonLon-LvanLzaMbusNkom!R[rR{RmanRokoRvaTer#TohVl&Zal#Zili#Zu#3D&RanSe^StieTonZin#ZmocZ)k3CyklD]Ft-KinyLan%Og,fO]gTvaZon2AhobytAt*/E/aEdu+EskIk!Iz&Ok|Oud Ud2B-BrDl.D~H!(JkotJ|K<ysLe$R>R'?TaUb_U/!U^U+Ur!Xer2A^v#Ambo,An#AtrEp)Ike)KoLohOnzOskevUn{#Usin#Z^Zy2Bl.Bn|})D _D#D'aF{Jar(Kv?LdokLvaN^NkrRzaTikVolZola3D+tL.T'#0Ukot:PartRev&3DrDu+J/JnLaLerLkemLn?N.Nn(N'#NtrumNz<StopisT#2AlupaAp`]Ar aA)E/t!EmieI/otIrurgL`Le[Lub M_Mu,ObotO/olOd[O+,Om=Op Oro[OvRapotRl RtRupTiv(Ud.Utn!V!Vil#V(Y[Y$!Yt 0Bu+Gare)H_&HlaNkotRkusSter&Ta%TrusZin>Z(2O&2KolivUv!4It_N(0Dn(Ke)KrPot0Ak~AlIkRkot2Kli$a:L-oRe[T_Tum1E,1B!a}'#Cib_Fic Fla%KlKr{Mokr!PreseRbyS#T-tiv3Kob,zKt|O^P]mSkSp+jV`]Vo/2AhaOuhoUhopis1Es0BroByt-C@t}ut DnesH+dHo^H,JemJn?Kl`KolaKt<Kum@tLarLevaL.MaM.ntMluv M'Nut P`PisPln PosudPr'odPu$ Raz R(RtSahSl'St!-SudSy)TazT-Tk~Uf!Utn!Voz%Z`uZn!Z<%2Aho)AkAm!ikAv>AzeDolObn(OgerieOzdSn(T Z(2B@}'noD-HaH'#S SnoT(0Oj?Or>2Nam :9O]gOnomie0EktronIpsa0AilIseO%P!ie2Izo^O/aOpejOs2EjEn%K<)Kymo0Ike)0F<ie0Olu%1Eku%KurzePed?P]zeP<tT,kt:C#Jf#Kul)N!ikN)zieRmacieV< Zo+3De,%J{onN#3Al#Gu,ntLozofLtrNan%N)Xa%0Ord1An_IrtOtila2NdSf<T[lT#Ton2Ak%Es#On)2KarNk%3Zi#:LejeRant3N{i#O]g3Lot.2Azu,Ejt2LemLfi$aTi#2AfAmofonAnu+EpIlOgOtes#2Ma:D?DrLaL@#N[NopisRfaRpu&V,n3Bk(J#lJnoJtmanK)rLmaM!omR>R&S]Zky3St<ik2Ad'#AsivkyAvaEd!EnO^v>OhOup(T!Ub.U/o)0AtO)Yz0IsOjivoOut0Bl.Boj}DinyDl!Dno)D|Jn(KejLin#L#LubMo+N [No,%RalR^RizontRkoRliv>RmonRn.RoskopR$voSpo^St.T'(U[UfUp!Us#V<2Ad[An?Av(Az^Bo+kD.D]D(N-Ob#Oma^OtOu^Oz@St#Ub(Yz!2B@(B~D[KotMrS aSto)0Ozd2Bn(D,ntGie&M&Sterik:2Yl#3Ned2O&0Uze0Un a0F-%Fla%KasoOva%Sp-%Tern{Vali^Ve$<Zer%3Onie:Blko})Ho^Kmi+K(L'>N)rRmarkRoSanSnoT#V<Zyk3Din>D+Dn!_HlanKotL@L oMn(NomP?S{erV Zd>Zero3NakNdyNo/Sk,Sto)Trn?Zva3En|1Gurt5R):Bar{B_Bin{}&D{Did]HanJakJu)KaoKtusLam aLhotyLibrLn(Me,MkolivM&Ni[lNoeNt<Pal.P_aP olaP#P+Po)PrPu$aPy[,Ram_Rot#RtonSaTa]gTed,U%UzaVa+cZaj#Ze)Ziv(2EkolivEsi0Dlub@MpRami#3No2A%kAdivoAmApotAsi#AunEcEn[Ep!Es~IdImaIs&Ob*kO#nOpaOubUb'&Us!Uzk(0EnIt!Otr0IhaOt0Al?Ber>B#BlihaBylaC*rH=J@>KosKtejlLapsLe^LizeLoMandoMe)MikMn!aMo,MpasMun aN!N%ptNd?N>NfeseNgresN.NkursN)ktNzervaPan>PieP~Pr'#Rb_R-t<Rmid]RoptevRpusRu&RytoRz{S!>St#T_T+)T*lUk!Up_&Us-Uz]VbojZaZ<oh2Ab?A/Aj.Al|AsopisAv!aEd EjcarEs[Eve)Ik{ItikIzeKav>Me+cMivoOcanOkOni#Op OupaOv#T-Uh`]Up?Ut(Vin#Y/+Yp)Y$alYt2Dlan#FrJn(KlaLaj^Li/L#Lom{Ltu,NaPodivuRtRz<Til0Al aAsin#E$<2No]gS_.Ta,T?T#T'>V`]:B,d<})nDn(IkKom>M_aMpaN'#S?SoStu,Tin#V.3B#CkdyD@Dn?D'#Dv.G@^GieG,%H%Hk(H~KtvarNo/odNtil#P@#Pid]T`]T>TmoTokruhVhartV a%Vobok3B,}ot#DojedDsk(H'.Jav>L-M{#NieN#No+umStop`T.T|5Bi$aDivodGi#GopedKal aK{Mc|P!aPu/RdSosTrU^lUhU#Usk!V>3Tiv(1Cer&CiferMpSkSt,%0I%2RaRi#S.:DamD]Gi$rHagonJ{-J _J< aKakK'?Kr_aL[L.L|Lv?Min#Nd+NkoRn(SakrSkotSopu$T?Tri#Tur aZan>ZivoZl Zur#2Lo[0}anikD a%D'.LasaL*nNtol#TlaTo^TrZe,3G,%H~Hu+K.KrofonL@>Lim{rL(Mi#Nc'&Ni[rNom{Nul(S#StrX|2Ad(HaH'.OkS!Uv 1I/Ohem0BilCn(D_#Dl [HylaKroL-ulaM@t#Nar/aNoklN$rumNt|NzunSazSkytStTiva%T<#Ty#U/aUdr(Zai#Z-Zol2Am<Av@>KevTvolaZ{Zut(0T _1DrcF]nL!MieN?S{Ta%ZeumZi#nt3Sliv>0Da:B*r!}yt!Da%Dbyt-DhozDobroDpisHlasHn!Hodi+H,d Iv aJedn*Ji$oJm=K]n Kon>Krm LevoMaz!Mluv Nom{rOkoOpakO$roP`!PevnoPln P~Pos+dPr(oRod RubyRy/]S` S-!S+poSt!TolikV@-Vr/Vzd<yZv!3Be}!CkyDa+koDb!DuhGa%H{Ho^J@JprveKlidLib(Mil(MocO/o)On#PokojR(RvSmyslS*l`Tv<UronV.Zvyk+3Co)JakKamKdyKlKte,kTro5C+hHav?M.%RaR-S _Sn(UzeVinyVo)Zd,5DaD+G{T Tn(Trie3Mfa:0AlArv AvaDivEcEhn!Ejm=Ez aHajo[Iln?Jasn J-tK]p La$L-Li[LohaLu^NosOh! Oj-OutRaz>R&Ru[RysSahSluhaS)r!UvVazVin VodVyk+Yv!_Z<0AsElEn Hl` Ho)H,&It~0BojByt}odCiz Ebr!Esl!Evzd!EzvaH`%Hod J{JinudKazK*p LivLu#Ml#Oln(P`PisPl=P<Pu$ Pyk!Raz#S*d StupSunTokTudVahaVe)Vol!V,%tZ&k1I&Sajd1LasNiskoRa^Roz Ryz-2ApEn?Li#NoOuzl OvyRasaResRs-RuhUpantUr#Us 0Ejn.Iz|0AkE+)Ez L`.L*v!LuvaYl0Ehdy1Ak|As-E,%I%Il(Is|O,Oz?RavduRoti1B al}e$rGieL?LojT_0A^}~I#IvoLavaLep Ln L' N'aO[Ol Pa+cT@T,haTu^Ty/Voj 0Epl IskOpRh!Rl(RokRubyV<1A~ArEsLivn O%1Id1Do[:}!_Ci@tD*/H<-KtLan^L>LivoLu[Mf+tMls-N@#Ni#N&N|N$voNtof+Pri#Rke)RodieR)Ru#Ry[Se#Siv aSt_#T@tTro&V*kZnehtZ*r-3C#DagogJs-K]LotonNal)Ndr-NzeRiskopRoStr(Tar^T?Tro+jVn.Xeso3Ani$aHaJav?K+KnikL.Ln(Lul#Nze)Pe)S!_Sto+Tev&Vn?V'ar2A%n)Ak!Am@Ane)A$i#At Avid]AzE/Em@oEn)EsEtivoEv_Iv!N NoO/aOd.Om[OutUkYn2Bav Byt}odC Ctiv>D!D%n Deps!Dh+dDiv Dkl`Dman DnikDo[Dpo,D,zD$!aDvodDzimEzieHan#Hnut#H'<HromaHybIn)Ji$#Jm=Kaz K+sKojKrokKu)KynLedneLib-Lk~LohaLynomMaluMi~Ml#MocM$aMys+tNe/!N<#Nur(P`!P_Pis-Pla/Pros Ps!PudR`%R%RodRu/aRyvS` SedSilaSkokSlan>S*d SpoluS)vaSud-SypTahT#nT+skTom-T,vaTupaTvo,U#zUtoUzdroVahaVidlaVlakVozVr/V$!VykVzde/Zd,vZem-Zn!-Z<Zv!2Ac|Ah<yAkti#A+sAot>Ap<-AseAv^IncipKnoObud O%ntoOdejOfeseOh,Oj-tO]m Omi+Onik!Op`OrokOs[OtonOut-OvazS#v#St@Udk(UtV-Voh<y0An>OvodTruh0Actvo0Ber)}DlKav>Kl.Kr+LtMpaNcP@SaSin#St.T|Ty#3Rami^SkT_::C-}otDia%Dn?DonFtGbyKe)K'.M@oMp*/NdeRa/R aS'&StrTo+$Zan%Zid]3Ag|Ak%CeptDakt<Fer@tF+xJnokKlamaK<dKrutKt<Pu)%VizeVmaVolverZerva3Sk|Ziko5Boti#Dokm@H'#K+KokoMan{oP'odPu/aRejsSolStl.Tmi$rTopedTun^Ub@#U/oUpU,V.Vn?Zb<Z/odZd!Zezn!Zhod%Zin#ZjezdZ#zZ]haZmarZp`Zru/ZsahZtokZumZvod5Bri#}`]Kav?Kopis3BaBol'}l(D]P`]T.Z(:Di$aH!KoM>Mizd!Mo)N #Rdin#San#T_ Z[Z@?0Or0H|1B,n#CeseD`]Dim@tD]Hn!Jm=Ke,K)Kun^KvojeM@oNoRvisS` Sho,SkokSl!St,SuvSyp!T[T.Tk!T~Trv!VerZ&m2O^R~0FonLn?R#Rot-RupTua%1AfandrAliskoAnz@AutEptikIcaL`[L@?LoLuzO[O#nOroRip)RzUp.V(Vr&0Abi#Adid]An.A$Avn(Ed|Ep>EvaEz.IbI&Izn?OnOup-OvoU/UhaUn%Up#Za0A,gdE)&Il$voL*vaOgR`RkRt#Ut-Ysl0AdAhaOb0Bo)}aD'#KolP#TvaUbojUc Ud%UhlasUl`Um,kUp,vaUsedUtokUvis{0Al'&As _IsLavOd-Oj@>OluOnz<Orn(Ou$aR/aU$ 1An^AzD%NaN>Ovn!P@StUb1An?Ar(aAti#Av[EhnoEz#OdolaO+kOpaOrnoOup!Ra/ResRh~RomRu&Ud&Upn?VolYk0Bj-tBtropy}arD(KnoNd!N=Rik!aR'.0AhAl$voEtrAt[Az-Is+It-Obo^Odid]Or#Rab2Kav#KotN-N'>P!Pk(R'(S_T(:B+t#Bu+H*nJemnoJfunJgaJ Jn(Kti#Mh+MponNc|N>NkerPe)V@.Z!_3}ni#HdyKut.LefonMno)Nd@%Ni$aN<P])P&PrveRapieRmos#Xtil3}oSkopisTu+k1Ad+cAn.0Ap#Esk!UkotUpa0El1A+)Pin#PolRzoUhaU+c2Ad?Akt<AmpAsaAverzaEf E$Ez<Hav.Hl.O/uOj?Os#Ou[P%P _Pk(Ub>U/l Uhl?UsV!2DyH~H(Nd,Ri$aR&jZemsko0ArohOr[Rd(Rz2GrKev:0Oh(OzeR!R*s-RusYt'&0HoTiv(0Iv 3R` 1Edn!I$ M=0Az!_Lidn Lon Otv Roj 0I%I)Ov 0Yv`]0Av If<maIk~1Ad~L!n Ly~Out!Rav 1AnAz 0Ed~Il|Mrt N`n N=Oud Tl!Tr~0Ah|K!Lum O~Op@>R*s 1Al Oln Oz'#3D,v ElEn.L.N!:GonL/aL*nNaN^lNil#RanRhanyR|1ElkuHod0Ova0DroGe)%J%Lbl*dL{rhL _LmocLry[Nk'Ran^RzeS_#SkrzeSn?SpoduS)Ter.Ver#3B,%}rDeoh,D.D+LaN?S{Tal aZeZ #0Ezd0L`Us0Aj#AkAs>EvoHk(IvN'#Oup!1Uc|Uk0DaDiv(Doz&kD$voJ@skyJ&JskoLantL[L LnoSk'#Zid]Z'&0Ravo1Ab>A%tAhA)Ba}o+kH!StvaTu+0Ad T*p Tup0Ip4Bav Br!}|D!D,Fot H+d!H~Hod H,d Hub Jasn J{Jm=K]p Kon!L-!Maz!Mez Miz{Mys+tNe/!Nik!Nut P`!Pl! P,v Pu$ Raz R'n!Rv!Sl' SokoS)v Su~Syp!Tas Tes!Tr! Vi~Vol!Vrh_Zdob Zn!0AduBud }op D<Du/Dy/!E$upH+demKazLyk!NikOr-P*,TahT-::993Lofon::Br!Byd+t}|DarmoDus F*k!Hlt Hod H,^Hy~J!>J{Ji$ K+p!K*p Lep Mez Mot!Mys+tNe/!Nik!Pl! Poj Ps!Raz S)v Su~Taj Temn Tk~Ujm=Val Ve+tVin Vol!Vrt!Zvon 0Av RusuUd|Yt-1A+#ArmaAtn(IvoOb RojVihYm`]0L@.ManM.Pt!Z`uZdola2At Lt~Lubo#Ot' Ru[0MaMn?0Emn 0Lam!Oum!R!#Umav#0AtoEh#O[OmO$Ozvyk0Ap|ArAt-IjeIz{Ocn Odr!Rzl.Ut|0AkAl(Am@!Ovu0B,z Tav Ub-Ufa+0Lod Omal RavaR( Rud#Rvu1A^An C`]N (NoOv&Y/l Zav(1I/aR! 0B'.Br0Ed~EnkuEs_aOnR!Uk'odYk";
var checksum2 = "0x25f44555f4af25b51a711136e1c7d6e50ce9f8917d39d6b1f076b2bb4d2fac1a";
var wordlist3 = null;

class LangCz extends WordlistOwl {
  constructor() {
    super("cz", words2, checksum2);
  }
  static wordlist() {
    if (wordlist3 == null) {
      wordlist3 = new LangCz;
    }
    return wordlist3;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-es.js
var words3 = "0arertoiotadonoaRteirroenaNonaLsolocoiliaralaorrenadaChoN$n0A>Dom,EjaI!#Oga&O'Or#RazoR*Ue=U<0Ab Adem@Ce<C~Ei)ElgaEn#Ept I&L  NeOg!O<TivoToTrizTu Ud*U!&Us 0Ic#Mit*Opt Or'Ua`Ul#0Reo0Ect Ic~In Irm 0IlIt On@Os#Ot Reg R$UaU&U?aUja0OgoOr+0ReSl 0Ed_zE'Us)1Ac[nAmb_ArmaBaBumCaldeDeaEg_Ej Er%E%F?!GaGo&nIa&I,#Iv$MaMejaMib T TezaTivoToTu[Um'Z 0AbleAn)Apo]ArgoAs B Bi#E'IgoIs%dOrP oPl$0|oC@'C]D D,Em@Gu=Il=ImoIsOt T,aTiguoTojoUalUl Unc$Ad*EjoO1Ag A[#Eti#IoLic O&Or)OyoR,d!Rob Ues%U+1A&A`ArBit+BolBus#|ivoCoD!D?]DuoEaI&IesM.i-esOmaPaP.Reg=RozRugaTeTis%0AA&Al#C,<Egur EoE<rI,#I=Ist*NoOmb+P!oT?]T+Tu#Um*Un#0AjoAqueArEn#EoI>Le%OmoRa!RozUn0DazD$GeLaM,#S,)T^0AlAnceA+EEl]`E`EstruzI.I<2ErU{U'0Af[nArO)Uc Uf_Ul:BaB^|eH@IleJ Lanz/c.LdeMbuN>Nd-oRb(>RnizR+Scu]S#nSu[Tal]T!@T*Tu%UlZ 3BeBid/=S SoSt@3|oEnNgo2An>OqueUsa2ABi`BoCaCi`DaDegaIn//!oLsaMb-{dNi#N}saiRdeRr SqueTeTinVe{Zal2AvoAzoEchaEveIl=In>IsaOcaOmaOnceO)UjaUs>U#2CeoCleE'EyFan{F.HoIt_L#Rbuj(l(+Sc TacaZ.:Bal=BezaBi`B[CaoDav!D,aErFeI{ImanJaJ.LLam Lc$L&Li{dLleLm/^LvoMaMb$Mel=Mi'Mp}c!Nd?Nel-gu+Nic-#N-.ObaOsPazPi%nPo)Pt Puch((b.RcelRe%Rg(i'RneRpe%R+R%SaS>S!oSpaS#rT^ceT_U{lUsaZo3Bol]D!D+Ld/eb_Lo<Lu]M,#Niz-t+Rc(&Rez(oRr R)zaSpedT+2AcalAle>AmpuAnc]ApaAr]I>Is)IvoOqueOzaUle%Up 0Cl.EgoE=EnEr#F[G +M->NeN%P_sR>Rue]SneTaU{d2Am^AnA+AseAveI,)ImaInica2B_Cc~|i'Ci`CoDigoDoF_G!He)JinJoL/ch/eg$Lg Lin/l LmoLum`Mba)M!Mi{Mo&Mpr-deNej}g-oc!Nsej}t PaPi(az.Rba%RchoR&nR.(r!S!SmosS%2AneoAt!E Ec!Ei&EmaIaIm,Ip%IsisOmoOnicaOque%U&Uz2Ad+Ar#At+BoBr*| aEl=En#Er{Es%EvaId Lebr/p/#Mb_Mpl*N-e%O%P.Pul( R$<R<RvaTis:M-z(R&T?3B!B?Ca{C*DoF,saFin*J LfinLga&Li#M^-<N%lP^)RechoR+%Sayu'SeoSf?eSnu&Sti'Sv$TalleT,!U{3AAb=AdemaAman)A`Ar$BujoCt En)E%EzFic?G'Lem/u*N!oRec#Rig*S>Se'Sf[zVaVi'5BleCeL^Ming}N Ra&Rm*R<SSis2Ag.Oga2|aDaE=E'LceOQueR Rez(o:0A'R$0H OUa&r0AdIc~Ific$I#rUc 1Ec#Icaz3EEmp=1Efan)Eg*Em,#Ev IpseI)Ix*Og$Ud*0Bu&It*Oc~Pa)Pe'PleoP_sa0A'C go|ufeC@EmigoE+Fa&F!moGa'Igm/aceOrmeRe&SayoS, T!oTr VaseV$1Oca0Uipo0Izo0Ca]C,aCol Crib*Cu&Enc@F!aFu!zoPa{PejoP@PosaPumaQuiT TeTi=Tufa0ApaEr'Ic-@1Ad*Alu En#It 1Ac#Am,Ce<CusaEn#Ig*Il$Ist*I#P!#Plic P.!T_mo:BricaBu]|a{C?C#rE`J/d/=L<Lt MaM?@Mo<Ra.Rmaci(olRsaSeTigaU`V^X3Br!o|/izORi(ozRt?Rv^Stin3AbleAnzaArB[Cc~|aDeoEb_ElE[Es%Gu[J JoL/e)L@lLt+NNc-g*Ni#Rma2A>Au%EchaOrO%U*UjoU^2B@CaGa%G.L$Lle#N&Rm(+Rtun(z SaTo2Aca<Ag?AnjaAseAudeE*E'EsaIoI#U%2EgoEn)ErzaGaM Nc~Nd(g.R@S?TbolTu+:Ce]FasI%JoL/!i/=Mb- Nch}g-<RajeRzaSoli`St ToV?an3Me=M*NN!}$N)Ran$R,)Rm,S#3Gan)M`s$R Ro2Aci OboOr@2LLfoLo<LpeM(&R?([TaTeoZ 2A{Afi>A'AsaAtisAveIe%Il=IpeIsI#O<rUaUe<UmoUpo2An)ApoArd@Er[IaI'I.I<It [Sa'St :B!B?Bl C!|aD/l Mac(i`ZZa`3B?]B[|oLa&L$Mbr(*Rma'RoeRv*3E=Er+Ga&Gi,eJoM'S#r@5Ci>G Gu!aJaMb_Ng}^Nr((mig('St?Yo5E>ElgaEr%E<EvoI{IrMa'Me&M?deM}d*RacanR#:1O'0EalIomaO=2Lesi/uUal4EgalUs~0Ag,AnIt P P!$P.!Pul<0CapazDiceEr)FielF^meG,$Ic$M,<MuneNa#Sec#S%n)T!esTimoTu*Ut?Vi!'3AIsOn@0L/o):BaliB.M.RabeRdinR[U]Zmin3FeRinga3Ne)5R`d(obaV,Ya5ErgaEvesEzGa&rGoGue)Ic$N>Ngl-$Nt Pit!R S#V,?Zg :7Lo5A]:B$C$C[DoD+nG #GrimaGu`I>M!Mi`Mp --ch-gos%NzaPizRgoRvaStimaTaTexT*U_lV Zo3AlCc~|eC#rErG~Gumb_Ja'Ngu-#NaOnOp &S~TalT[VeY,{3B!%dB+C^D!Di EnzoGaG!oMaMi)M.Mp$NceN&Ne-go)N}t!`Qui&SoS%T!aT$T+2AgaAmaAn#AveEg En Ev Or Ov!Uv@2BoC~CoCu[GicaG+MbrizM}jaTe5|aC*G J}-esPaSt+ToZ:Ce%|oD!aD_Du+Est+F@G@GoIzL{dLe%Ll/oMaMboMutN>N&Nej Ng-iquiNj N}<N%Na`PaQuin(R>Re(f?Rg,Ri&RmolR+nR)sRzoSaSc aSivoT T!@TizTrizXimoY^Z^ca3|aDal]D$Du]J?]J^L,/.M^i-^NsajeN)NuRca&R,gueRi#SS.TaT!To&T+Zc]3E&ElEmb+G/Lag+Lit Ll.M}-!}im}u#OpeR SaS!@S?SmoTadTo5|?aC~DaDe=HoJ LdeL!Li'M,#Mi- c-ed-j-#NoRad(d!Re'R*R+Rs(%lScaStr TivoV!V?Zo5|oD EbleE]Er)Est[G_J!L/e%L%N&Nec(alRoScu=SeoSgoSicaS=:C C~D IpeRanj(izRr SalTalTivoTu[lUseaValVeVi{d3C$Ct G Goc$G+OnRv$ToUt+V V!a3|oDoEb]E#NezNoTi&Vel5Bleza|eMin(i(m()TaTic@Va#Ve]V$5BeCaCleoD?=DoE[EveEzLoM!oTr@:Sis0E<IspoJe#R(!oS!v T,!V$0AA<Ea'H,%HoIoReTavoTub_Ul#Up Urr*0I IoIsea0S)0EnsaEr%Ic$Rec!0Ro1DoR0O1AEa{Fa#IvoLaMoOrVi&0Bligo0DaZa1A>C~E[In On!T TicaUes#1Ac~A&rAlBi%CaD,EjaGa'G@Gul=I,)Ig,Il]OQues%Uga0Ad@Cu+Ez'OT[0O'Ro1EjaU=1I&Ige'0En)0O':C#D_El]Gi`GoIsJ oLabr/>Le%Li&Lm/om/p NNalNi>Nt!-ue=PaPelP?]Que)R Rcel(edR*RoRpa&RqueR[foR)S SeoS~SoS%TaT$Tr@UsaU%VoYa<3A#nCa&C!a|oDalD*G IneL L{'Le/ig+LlejoLoLuc--s N.OnOrPi'Que'R(ch(d!Rez(f?Ri>Rl(mi<R+Rs.aSaScaSimoS%`Ta=T+leoZZu`3C |.EEd[Er`EzaJam/ Lo#Mi,%N}#rNz-aOjoP(a%S Sci`SoS%T.Zca2AcaAnA%AyaAzaEi#E'OmoUmaU[l2B_CoD!D$EmaEs@E%L,Lici/=LvoMa{Me=MoMp-!Rc~R%lSa{Se!SibleS)T,c@T+Zo2A&E>zEgun%Em$EnsaE<Ev$ImoIncipeIs~Iv OaOb Oce<Oduc#OezaOfe<rOg[maOleOmesaOn#Op$OximoUeba2Bli>|!oD^Eb=Er%Es#Lg/*Lm.LpoL<M-#NalNoPaP?(e:99Ed EjaEm Er!E<Ie#ImicaInceIt :Ba'B@BoC~DicalIzMaMp-ch}goPazPi&P#SgoSpaToYoZaZ.3Acc~Ali{dBa'Bo)Ca!Ce%|azoCog!C_oC#Cur<DD.&Duc*FlejoF^maF[nFug$Ga=G*G]G_<H,I'IrJ/a#LevoLieveLle'LojM Med$M}>rNd*N%P #Pet*Po<Pt?SSca)Si`Spe#S#Sum,T*oT^'T[#Un*VesVis%YZ 3CoEgoEn{EsgoFaGi&G^Nc.N.OQuezaSaTmoToZo5BleCeCi D DeoD?]ErJizoJoM!oMp!NN>N{PaP!oSaScaSt+T 5BiB^DoE{G*I&In/e%LoMboM^Ptu[TaTi`:Ba&B!B$BleC GazG[&L/&L!oL*Lm.L.Ls/#LudLv Mb-c~Ndi-e Ng_Ni{dN}#PoQueRdin()nSt_TanU`Xof.3Cc~CoC_#C%DGu*IsL=LvaMa`M?l-d-<rNalN^P  P@Qui(RieRm.Rv*S,%S~TaT,%V!oXoX#3D[Es%E)G=G'Lab/b L,c$L]Mbo=M$R,aS)maT$Tu 5B_C$D$LLap/{&Le{dLi&Lt Luc~Mbr-de}i&No+NrisaPaPl P^)R&Rp_s()oS)nTa'5AveB*Ce<D^Eg[E=E'Er)Fr*Je#L%nM P! Pl*P.!P_moRR>Re'Rg*S#T?:Ba>BiqueB]BuCoC#JoL L>L,#Ll/.Ma'Mb^Ng}quePaPe)P@P.Qu?l(deRe(if(je%RotR+R%TuajeU+ZaZ.3At+|oC]CnicaJa&J!Ji&L/efo'MaM^Mp=NazNd!N!NisN<Ori(api(>Rmi'Rnur(+rSisSo+StigoT!aX#Z3B$Bu+nEmpoEn{Er[E<G_J!/deMb_Mi&M}%OPi>PoR(.TanT!eTu=Za5Al]B?=C Ci'DoG/&M N}#P PeQueRaxR!oRm,%RneoRoRpe&R_R<RtugaSS>S!Xi>2AbajoAc#rA!Afi>AgoAjeAmoAnceA#AumaAz EbolEguaEin%EnEp EsIbuIgoIpaIs)IunfoOfeoOmpaOn>OpaO)OzoU>Ue'Ufa2B!@BoEr#MbaM^NelNic(bin(ismoR'T^:0Ic 9C!a0B[l0I{dIrIv!<OT A3Ba'BeG,)Na0ArU $0IlOp@1A:CaC$Cu`G GoI`J?l/eLi&LleL^Lvu]Mp*oR(i R.So3Ci'C#rHicu=In)JezL/!oLozN-c!Nd-e'Ng N*N%NusRRa'RboRdeRed(j(<Rt!3AAjeBr C$CtimaDaDeoDr$EjoErnesG^LLl-ag_N}e&OlinRalRgoRtudS^Sp!aS%Tami`U&VazV!oV*Vo5LcanLum,Lv!RazT ToZ5E=Lg :::C!Te3GuaM('So9DoGaGur:F*}jaPa#Rza93N(+5MoR&";
var accents = "aeiou7695@@BZWWavwUJkO@Y-Kn))YEGq#E@O)cI@#ZkMHv$e*))M!!)D**$GW!oKm*Acoh^k&It-pi^SYW)$^n!G)bO!Wkzam(jS#X)Og*^l^RW!bQ#QygBKXfzE))hti!Qm)Cng%%c)mJiI*HJWbmYniCLwNdYyY%WKO^bnT$PuGOr!IvHu&G(GKbtBuhiW&!eO@XMeoYQeCa#!MrTJCq!OW&CHG(WCcW%%)$rfrIegu$)w!G)JGmWWw)MnD%SXXWIT^LWAZuVWB^W)eTL^x&$WGHW(nKWEMA)#$F$x$Waekqs,n7715)W*HM-$WAcCiu(a))VCZ)GG%(*CWWdW%$D!UCO$M";
var checksum3 = "0xf74fb7092aeacdfbf8959557de22098da512207fb9f109cb526994938cf40300";
var wordlist4 = null;

class LangEs extends WordlistOwlA {
  constructor() {
    super("es", words3, accents, checksum3);
  }
  static wordlist() {
    if (wordlist4 == null) {
      wordlist4 = new LangEs;
    }
    return wordlist4;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-fr.js
var words4 = "0erreleontiteurinueiriet cegeanseali medenel q)eniluxaus ch0Ais}And$Diqu E`#Ol*Ord Ou%rOy RasifReuv Ri,Rog RuptS_-SoluS'@UsifYss=0A@m+AjouAr+nCab]Cep,Clam Cola@Cro~eCu}ErbeHatHe,Idu]I Omp&Qu *R$y?Te'TifT)l0Ep&EquatHesifJec%fJug Mett!M* Op,Or Ouc*Res<RoitUl&V be0R R$ef0Fai!Fec,Fi~eF!{Fub]0Ac Enc I#I,Raf Reab#Ru?1D Gu`#L>Mab#S/-0Ou,Us,1Arm Chim+Er&Geb!G)I_ I?ntLeg Lia.Lou Lum O'd*PagaTes<Veo#0A&'BiguB!Enag Ertu?Id$Ir=Orc O'Ovib#Phib+P#'Us/t0Aly<Apho!Ar~+Atom+C+nE/%rG#Gois<Gu#{Im=Nex N$-N)lOd(Om=+Ony?Orm=T_[Tido&X+{1Ai}Eri%fL/*Olog+Pa!`Pe]Por,Puy 0UariumUeduc0Bit!Bus&De'Doi<G_tLequ(Matu!Me?ntMoi!Mu!P_,Ra~ Riv Ro}S_icT +lTic#0PectPh=&P* S|tS v*S+t&Soc>S' TicotT!Tu-0El>O?RiumRo-Ta^T_%fT* Trap 0Ba(eB .Da-Dib#G' Ro!Tom[Tru~e0A]Anc Ari-En*Er<Eug#Ia&'I@I$I}O(eOu R`1I=Io?:D.Fou Ga.G)t&Igna@L/c Lc$Le(eLisa.Mb(Ncai!Nda.Nl+)Nn>eNqu>Rb>R`R$R^Rra.Ss(S%$Ta`#Te|T,+Udr>Vard 3Let&L>Lo&Nefi-R-|Rg Rl(eRmudaSa-Sog[Ta`Ur!3B $Cyc#Du#JouL/L(g)LlardNai!Olog+Ops+OtypeScuitS$Sto'iTu?Zar!2AfardAg)An~*Ess/tInd OndOqu Ous$2BardB(eI!I}Li@Nb$Nd*Nhe'Nif>NusRdu!R[T&Uc#Ue{Ug+Ul$Uqu(Ur<Usso#U%^Xe'2An~eAs>AveEbisE~eEuva.Ico]Iga@Ill/tIo~eI^O~u!Od Onz Ous<Oye'U?Us^Ut=Uy/t2Ff#Iss$L#%nRe|R(S% T( To*Vab#Vet&:B/$B(eChet&De|D!Fe(eIllouIss$Lcu]Lep(Lib!Lm Lomn+Lvai!Mara@M aMi$Mpag[N=Net$N$N%[NularPab#Por=Pri-Psu#P,Pu~eRab(eRb$eRes}RibouRna.Rot&R!|Rt$Sca@S>S^Ssu!U}U%$V=>V [Viar3D`#Intu!Les&Llu#Ndr>Ns' Ntr=Rc#Rebr=Ri<Rn Rve|S}2Agr(Ai<A#'Amb!An-Apit!Arb$As<'At$Auss$Av* Emi<En`#Equ>Er~ Ev=I_Iff!Ign$Im eIotLoru!OcolatOis*O<O)t&Ro?U&0Ga!Gog[M_,NemaNtr Rcu]R R^T [Toy_Tr$V`2A*$A?'Aqu As<Av>I_tIgn ImatIva.O~eOna.Opor&2B=tBraCas<Co% D Dif>Ff!Gn Hesi$Iff Inc L eLibriLl(eLma,L$elMbatMed+Mm/@MpactNc tNdui!Nf>N.]Nno,Ns$[NtactNvexePa(P+Ra`Rbe|Rda.Rni~eRpusR!ctR&.Smi^Stu?T$U@Upu!Ura.U&|Uvr*Yo&2AbeA(&Ava&Ay$Eatu!Edi,E?{Eu}Evet&Ib]I Ist=I,eOi!Oqu Ota#Uci=UelYp,2Bi^E`l*Il]eIs(eIv!Lm( L%v Mu]Pi@Ra%fR<'3Anu!C#L(d!Ni^:Ign M>Ng N<'Uph(3Batt!Bi,Bord Brid But/tC= Cemb!Ch* Cid Clar Cor Cri!Cup]Da#Duc%fEs<F_sifFi]Fray Gag Givr Glu%rGraf Jeun Li-Log M/d Me' Mol*Ni~ Nou N&l#Nud PartP_}Pha}Plac Po}R/g Rob Sast!S-n&S tSign Sobe*Ss( Str>Ta~ Tes,To' T!s<V/c V_*V( Vo*3Ab#Alog)Am/tC,Ff  G  Git=G[Lu M/~eM(u Oxy@Rec%fRig Scu,Spo}Ssip St/-V %rVi}5Ci#C&'G?IgtMa(eMici#Mp,Na&'Nj$Nn Pam(eRto*Ru!Sa.Se'Ss>Ta%$U/>Ub#U-'U,Y_2Ag$Ap Es}Ibb]Oitu!2P +P#xeRab#Rc*3Nas%e:0Lou*0Ar,HarpeHel#La* Lip<Lo!Lu<O#Onom+Or-Ou,Ra}Rem Riva(RouU?U!u`0If>Uqu 1Fac Fec%fFig+FortFray Fusi$0Ali}Ar 2Ec,1Abor Arg*Ectr$Eg/tEph/tEveIgib#I%s?O.Ucid Ud 0B=]Bell*Bry$Er|@Issi$M_ O%$Ouvo*P e'Ploy Por,Pri<Ulsi$0Cadr Ch eClaveCo~eDigu Dos}DroitDui!Erg+F/-F m Fou*Gag G(Glob Ig?Jamb JeuLev NemiNuye{Ri~*Roba.Seig[Tas}T_d!T>To' Trav Um  Vah*Viab#Voy Zy?0L+n0Aiss*Arg[At/tAu#Ic +I@m+I Ilog)I[Iso@ItapheO^ReuveRouv Uis/t0U !Uipe0Ig Osi$Re'Up%$0C=>Pad$Pe-P+g#Po*PritQuiv Say S_-S+uSor Ti?TomacTra@0Ag eA]An~eA%^E(d!Endo*Er[lH/olHi^Hn+Ir Off Oi#Onn/tO'd*R/.RoitU@0Phor+0Alu Asi$Enta`I@n-I,Olu%fOqu 1ActAg  Auc Cel]Cit/tClusifCu<Ecu,Emp#Erc H= Hor,I.n-I]Is,O%^Ped>Plor Po}Prim QuisT_sifTrai!Ul,:B#Bu#{Cet&Ci#Ctu!Ibl*Lai<Me{M`#R-'RfeluR(eRou~eSc( T=Tig)Uc$U%fVe'Vori3Bri#C$d D  L(M?M'Ndo*Od=Rm Ro-Rve'S%v=U`#Ut!Vr>3AscoCe]C%fDe#Gu!Latu!Leta.L>eL#ulLm LouLtr N/c N*O#R?Ssu!X 2A* Am?As^At&'E|E~eE'Exi$Oc$O!Uctu Ui@Uvi=2L+Nd +Ngib#Nta(eRc Rg $Rmu]Rtu[Ssi#Ud!Ug eU`]Ulu!Urmi2Agi#Ai<An~*App Aye'Ega&E( El$Em*E[s+E!Iab#Ic%$Iss$Ivo#OidOma.Ont=Ot,Uit2Gi%fI&Re'R+{R%fSi$T':Gn Lax+L +Mbad R/%rRd+nRn*Rrig)Zel#Z$3AntLa%[Lu#Ndar?N =N+NouN%lOlog+O?t!R/iumR?St)lY}3B>C]RafeV!2A-AiveIs}ObeOi!Or+{2Lfe'M?Nf]R.R`#Udr$Uff!UlotUp`#Urm/dUt&2Ad)lAffi%A(eAndApp(AtuitAv*EnatIffu!Il]Imp Ogn Ond Ot&OupeUg U% Uy e2EpardErr>I@Im|veIta!Sta%f3Mnas&Rostat:Bitu@Cho*L&Me|NgarN[t$RicotRm$+Rp$Sard3LiumMato?RbeRiss$Rm(eR$Si,U!{3B n BouLar/tStoi!V 5MardMma.Mo.[N['Nor N&{R@Riz$Rlo.Rm$eRrib#U#{Us<5BlotI#{Ma(Mb#Mi@Mo'R]3Dro?lG+[M[Pno<:2Yl#2Nor U/e4Lici&Lusi$0A.Bib I,M_<Mobi#Muab#PactP i=Plor Po}Prim Pu,0Carn C_d+Ci@ntCl( Colo!Dex Di-Duc%fEditEp%eExactF(iFlig Form Fusi$G  H= Hib Jec,Ju!No-ntOcu]Ond Scri!Sec&Sig[Soli&Sp* S%nctSul,TactT_<Ti?Trig)Tui%fU%#Vasi$V_,Vi,Voqu 3Oni^Rad>ReelRi,0O]2Oi!Res<:GuarIll*MbeNv>Rd(Ug U[Velot3Tab#T$UdiU[s<9Ind!N~ Ng]Ue'UissifUrn=Vi=Y|Ye{5Bi]Ge?ntNiorP$Ris&S%-Te{V_i#:Yak7M$oOs^:BelBi=Bo' C  Cto<Gu[I[Is}I% Mbe|Mel#MpeN-'Nga.N,[P(R.'R?Ur>VaboVo*3Ctu!G=G Gu?SsiveTt!V>Xi^Zard3As<B  B!C_-Cor[E.Ev!Gatu!Go,G)M Mi&M$a@Mpi@Neai!NgotOn-|Qui@S>eS,ThiumTi.Ttor=V!'5Gi^Inta(Is*MbricT +U UrdUt!UveY=5B+Ci@Cra%fE'Gub!Is/tM>eNai!NdiR$T,X){:Ch(eGas(G_taGi^Ig!Ill$In%_Ir+Is$Jor Lax Lefi-Lhe'Li-L#t&MmouthNda,Niab#Nqu/tN&|N)lRath$Rb!R~/dRdiRi%?R^'Rr$R&]Scot&SsifT +lT>eTra^Udi!Ussa@UveXim=3Ch/tC$nuDa`#Dec(Di,Du<Il#'L/.Lod+Mb!Moi!Nac N Nh*Ns$.NtorRc!diRi&R#Ssag Su!T=Teo!Tho@T>Ub#3Au]CrobeEt&Gn$Gr L+uLli$Mi^N-N =Nim=Nor Nu&Rac#Roi,Ssi#X&5Bi#D [El#{Ndi=Ni&'Nna+Not$eNst!Ntag[Nu?ntQ)'R-|Rsu!R% Te'TifU~eUf#Ul(Uss$Ut$Uv/t5L%p#Ni%$Ra`#Re[Rmu!Sc#SeumSic+nTa%$T T)l3Ria@R%l#S,eThi^:Ge'PpeRquoisRr Ta%$Ti$Tu!Ufra.U%^Vi!3Bu#{CtarFas&Ga%$Glig Goc>I.Rve{Ttoy Ur$eUtr$Veu3CheCkelTra&Ve|5B#CifCt'[Ir-'I<t&Ma@Mb!{Mm Rma%fTab#Tif>Toi!Urr*Uve|Va&'Vemb!Vi-5A.Anc I!Isib#M oP%=Q)Tri%f:0E*Jec%fLig Sc'S v Stac#T_*T' 0Casi$Cup E/Tob!Troy Tup]Ulai!0E'Or/t1F_}Fic>Fr*0Ive1Se|S`l$2Fac%fIv>0Bra.Ett!0Ct){Du]E!{Iri^1A#A^Er Ini$PortunPrim T Ti^1A.{An.Bi&D$n E`#G/eG)`Ifi-Ne?ntQ)T+0C`]Mo<Satu!0Ar+0Rag/Rs$T`Trag Vra.0A%$1Y@Y.[1O[:Isib#La-Lma!sLo'@Lp Na~eNdaNgol(Niqu N[|NoramaNt=$PayeP>Po,PyrusRadoxeR-l#Res<Rfum R]Ro#Rra(R<m Rtag Ru!Rv_*Ssi$S&^T [lT+n-Tr$V`l$Voi}Y Ysa.3Ig[Int!La.Lic/L#Lou<Lu~eNdu#Netr Nib#NsifN'+Pi&PlumRdrixRfor Rio@Rmu,Rp#xeRs`R&S Ta#TitTr*Up#2Ara$Ob+O^Ot$Ra<Ysi^0AnoCt'=E-Er!Euv!Lo&N-|Pet&Qu Rog)Sc(eSt$Vo,XelZza2AcardAf$dAis*An A^Astr$A&|E' ExusIa.OmbOng U+Uma.2Chet&Es+E&In&Ir>Iss$Iv!Lai!Lic>L#nLyg$eMma@Mp>Nct)lNd  NeyR%^Si%$S<d Stu!Tag Te|Ti$U-Ula(Um$Urp!Uss(Uvo*2A*+A%^Ec+{Edi!EfixeElu@EnomE<n-E&x&Evo*Imi%fIn-Is$Iv Ob#?O-d Odi.Of$dOg!sO+Oje,Olog)O?n Op!Osp eO&g O)s<Ov beU@n-U[|0Y~o<1BlicC $I}LpeLsarNai<Ni%fPit!Rif>Zz#3Rami@:99AsarE!l#Es%$Ietu@It,O%_t:C(eC$,D+{G$d(I@'Is(L_%rLl$.Mas}Pi@Sa.Tis}Vag V(Y$n 3Ac%fAg*Ali}Anim Cevo*Ci,Clam Col,Cru,Cu]Cyc]Dig Dou,Fai!F#xeForm Fra(Fu.G=+nGi$Gla.Gul>I, Je,Jou La%fLev L+fMar^Me@Mi<M$,Mpl*Mu NardNfortNif]N$c Ntr NvoiPl>Por,Pri<P%#Qu(S veS(e{Soud!SpectS,SultatTabl*T_*Ticu#Tomb Trac Uni$Uss*V/~eViv!Vol&Vulsif3Ches<De|E'Gi@Go]Nc Pos,Sib#S^T)lV=V>e5Che{M/-Mp!N-Nd(Se|S>Ta%fTorTu#U.U`#U#|U%[Y|?5B/BisCheEl#G){In Is<|S S%^3Th?:B]Bo,B!Co~eFariGes<Is*La@LiveL$Lu MediNc%$Ngl>Rcas?Rd(eT' Ug!nuUm$U,Uva.V/tV$n 1AlpelAnda#E]atEnarioEpt!HemaI_-Ind O!Ru%nUlp,1An-Cab#Ch Cou C!,Da%fDui!Ig['Jo'Lec%fMa(eMb]M_-M(=Na&'Nsib#N&n-Par Q)n-Re(R.ntR+{Rru!RumRvi-Sa?V*Vra.Xtup#3D =Ec#Eg Ff]G#Gn=L_-LiciumMp#Nc eNist!Ph$RopSmi^Tu 1I 3Ci=C#DiumIg[{LdatLe`Litu@Lub#Mb!M?`Mno]N@N.'N[t&No!Rc>R%rS+T%<Uc+{Udu!Uff#U#v UpapeUr-U%r Uv_*0Ac+{A%=Eci=H eIr=3Ab#A%$ErnumImulusIpu]RictUd+{Upe'Ylis&0Bli?BstratB%lBv_*C-sC!FfixeGg  Ive'Lfa&P bePpl>Rfa-Rica&R?n Rpri<Rs|tRv+Spect3LlabeMbo#Metr+Nap<NtaxeS&?:BacBl>C%#Il]L_tLism/L$n Mbo'Mi}Ngib#PisQu( Rd RifR%[S<TamiToua.UpeU!|X 3Mo(Mpo!lNa`#Nd!Ne'N*Nsi$Rm( R[Rrib#T(eX&2E?Eor+Erap+Orax0BiaE@Mi@Reli!Ro*SsuT/eT!Tub 5Bogg/L /tMa&Ni^N[|P$y?R~eRd!Rna@Rp`#R!ntR<Rt)TemU~ Urna.Us}X(e2Ac%$AficAgi^Ah*A(An~ Ava`Ef#Emp EsorEu`Ia.Ibun=Ico,Ilog+IompheIp]It' Ivi=Omb$eOncOpic=Oupe|2I#LipeMul&N[lRb(eTe'Toy Y|3Mp/Ph$Pi^R/:0Ues^9Ti?Tras$1Ani?If>I$I^Itai!Iv s3AniumBa(Tic/t0A.I[UelU!0I#Op+:Car?Cc(Gab$dG)Ill/tInc!Is<|Lab#Li<Ll$LveMpi!N`#Pe'R>Se{Ss=S&3C&'Det&Get=Hicu#InardLo-Nd!diN  Ng Ni?{Ntou<Rdu!R(Rn*RrouR}RtuSt$T /Tus&X/tX 3AducAn@Ctoi!D/.DeoG[t&G)'La(Lla.Naig!Ol$P eRe?ntRtuo<RusSa.Se'Si$S^{S)lT=Tes<Tico#Tr(eVa-Vipa!5Ca%$Gu I#Is(Itu!La`#Lc/L%g Lu?Ra-R&xT Ulo*Ya.Yel#:G$:3N$:Cht:3B!NithS&9Olog+";
var accents2 = "e7693&)U*o&)Ry^)*)W))))#X^))))@@)#Wf)m%)#!))AG)&IIAQIIIBIIHJNAgBIILIDJGo)))HIQIIIIA(IGgJHH(BIIxX#)Ou)@*IAAPIIIJHQJ)&QIQPYI(HYAQC%)!))QHJJ@)#)^f*^AXCJ))$%CP))%&m)u)@e^A#G#))W@!(IKK%!(I%))O@QA))@GG#e))))WHJIWh))my@IIBT^)!)HAYGETHI*))!QnUDG)))nBoKAC*HwyQh))$&)G&)UGO)G)))(BX#v**)%O,e7686)I))@)&)gdMP()))ud)p#L))I^FIHYdWG))D@DFV)QA)o%MyTh%*)Z)%)n(XANc^R)YS";
var checksum4 = "0x51deb7ae009149dc61a6bd18a918eb7ac78d2775726c68e598b92d002519b045";
var wordlist5 = null;

class LangFr extends WordlistOwlA {
  constructor() {
    super("fr", words4, accents2, checksum4);
  }
  static wordlist() {
    if (wordlist5 == null) {
      wordlist5 = new LangFr;
    }
    return wordlist5;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-ja.js
var hex = function(word) {
  return hexlify(toUtf8Bytes(word));
};
var toString2 = function(data12) {
  return toUtf8String(new Uint8Array(data12));
};
var loadWords = function() {
  if (_wordlist !== null) {
    return _wordlist;
  }
  const wordlist7 = [];
  const transform = {};
  transform[toString2([227, 130, 154])] = false;
  transform[toString2([227, 130, 153])] = false;
  transform[toString2([227, 130, 133])] = toString2([227, 130, 134]);
  transform[toString2([227, 129, 163])] = toString2([227, 129, 164]);
  transform[toString2([227, 130, 131])] = toString2([227, 130, 132]);
  transform[toString2([227, 130, 135])] = toString2([227, 130, 136]);
  function normalize2(word) {
    let result = "";
    for (let i = 0;i < word.length; i++) {
      let kana = word[i];
      const target = transform[kana];
      if (target === false) {
        continue;
      }
      if (target) {
        kana = target;
      }
      result += kana;
    }
    return result;
  }
  function sortJapanese(a, b2) {
    a = normalize2(a);
    b2 = normalize2(b2);
    if (a < b2) {
      return -1;
    }
    if (a > b2) {
      return 1;
    }
    return 0;
  }
  for (let length = 3;length <= 9; length++) {
    const d = data12[length - 3];
    for (let offset = 0;offset < d.length; offset += length) {
      const word = [];
      for (let i = 0;i < length; i++) {
        const k = mapping.indexOf(d[offset + i]);
        word.push(227);
        word.push(k & 64 ? 130 : 129);
        word.push((k & 63) + 128);
      }
      wordlist7.push(toString2(word));
    }
  }
  wordlist7.sort(sortJapanese);
  if (hex(wordlist7[442]) === KiYoKu && hex(wordlist7[443]) === KyoKu) {
    const tmp = wordlist7[442];
    wordlist7[442] = wordlist7[443];
    wordlist7[443] = tmp;
  }
  const checksum5 = id(wordlist7.join("\n") + "\n");
  if (checksum5 !== "0xcb36b09e6baa935787fd762ce65e80b0c6a8dabdfbc3a7f86ac0e2c4fd111600") {
    throw new Error("BIP39 Wordlist for ja (Japanese) FAILED");
  }
  _wordlist = wordlist7;
  return wordlist7;
};
var data12 = [
  "AQRASRAGBAGUAIRAHBAghAURAdBAdcAnoAMEAFBAFCBKFBQRBSFBCXBCDBCHBGFBEQBpBBpQBIkBHNBeOBgFBVCBhBBhNBmOBmRBiHBiFBUFBZDBvFBsXBkFBlcBjYBwDBMBBTBBTRBWBBWXXaQXaRXQWXSRXCFXYBXpHXOQXHRXhRXuRXmXXbRXlXXwDXTRXrCXWQXWGaBWaKcaYgasFadQalmaMBacAKaRKKBKKXKKjKQRKDRKCYKCRKIDKeVKHcKlXKjHKrYNAHNBWNaRNKcNIBNIONmXNsXNdXNnBNMBNRBNrXNWDNWMNFOQABQAHQBrQXBQXFQaRQKXQKDQKOQKFQNBQNDQQgQCXQCDQGBQGDQGdQYXQpBQpQQpHQLXQHuQgBQhBQhCQuFQmXQiDQUFQZDQsFQdRQkHQbRQlOQlmQPDQjDQwXQMBQMDQcFQTBQTHQrDDXQDNFDGBDGQDGRDpFDhFDmXDZXDbRDMYDRdDTRDrXSAhSBCSBrSGQSEQSHBSVRShYShkSyQSuFSiBSdcSoESocSlmSMBSFBSFKSFNSFdSFcCByCaRCKcCSBCSRCCrCGbCEHCYXCpBCpQCIBCIHCeNCgBCgFCVECVcCmkCmwCZXCZFCdRClOClmClFCjDCjdCnXCwBCwXCcRCFQCFjGXhGNhGDEGDMGCDGCHGIFGgBGVXGVEGVRGmXGsXGdYGoSGbRGnXGwXGwDGWRGFNGFLGFOGFdGFkEABEBDEBFEXOEaBEKSENBENDEYXEIgEIkEgBEgQEgHEhFEudEuFEiBEiHEiFEZDEvBEsXEsFEdXEdREkFEbBEbRElFEPCEfkEFNYAEYAhYBNYQdYDXYSRYCEYYoYgQYgRYuRYmCYZTYdBYbEYlXYjQYRbYWRpKXpQopQnpSFpCXpIBpISphNpdBpdRpbRpcZpFBpFNpFDpFopFrLADLBuLXQLXcLaFLCXLEhLpBLpFLHXLeVLhILdHLdRLoDLbRLrXIABIBQIBCIBsIBoIBMIBRIXaIaRIKYIKRINBINuICDIGBIIDIIkIgRIxFIyQIiHIdRIbYIbRIlHIwRIMYIcRIRVITRIFBIFNIFQOABOAFOBQOaFONBONMOQFOSFOCDOGBOEQOpBOLXOIBOIFOgQOgFOyQOycOmXOsXOdIOkHOMEOMkOWWHBNHXNHXWHNXHDuHDRHSuHSRHHoHhkHmRHdRHkQHlcHlRHwBHWcgAEgAggAkgBNgBQgBEgXOgYcgLXgHjgyQgiBgsFgdagMYgWSgFQgFEVBTVXEVKBVKNVKDVKYVKRVNBVNYVDBVDxVSBVSRVCjVGNVLXVIFVhBVhcVsXVdRVbRVlRhBYhKYhDYhGShxWhmNhdahdkhbRhjohMXhTRxAXxXSxKBxNBxEQxeNxeQxhXxsFxdbxlHxjcxFBxFNxFQxFOxFoyNYyYoybcyMYuBQuBRuBruDMuCouHBudQukkuoBulVuMXuFEmCYmCRmpRmeDmiMmjdmTFmFQiADiBOiaRiKRiNBiNRiSFiGkiGFiERipRiLFiIFihYibHijBijEiMXiWBiFBiFCUBQUXFUaRUNDUNcUNRUNFUDBUSHUCDUGBUGFUEqULNULoUIRUeEUeYUgBUhFUuRUiFUsXUdFUkHUbBUjSUjYUwXUMDUcHURdUTBUrBUrXUrQZAFZXZZaRZKFZNBZQFZCXZGBZYdZpBZLDZIFZHXZHNZeQZVRZVFZmXZiBZvFZdFZkFZbHZbFZwXZcCZcRZRBvBQvBGvBLvBWvCovMYsAFsBDsaRsKFsNFsDrsSHsSFsCXsCRsEBsEHsEfspBsLBsLDsIgsIRseGsbRsFBsFQsFSdNBdSRdCVdGHdYDdHcdVbdySduDdsXdlRdwXdWYdWcdWRkBMkXOkaRkNIkNFkSFkCFkYBkpRkeNkgBkhVkmXksFklVkMBkWDkFNoBNoaQoaFoNBoNXoNaoNEoSRoEroYXoYCoYbopRopFomXojkowXorFbBEbEIbdBbjYlaRlDElMXlFDjKjjSRjGBjYBjYkjpRjLXjIBjOFjeVjbRjwBnXQnSHnpFnLXnINnMBnTRwXBwXNwXYwNFwQFwSBwGFwLXwLDweNwgBwuHwjDwnXMBXMpFMIBMeNMTHcaQcNBcDHcSFcCXcpBcLXcLDcgFcuFcnXcwXccDcTQcrFTQErXNrCHrpFrgFrbFrTHrFcWNYWNbWEHWMXWTR",
  "ABGHABIJAEAVAYJQALZJAIaRAHNXAHdcAHbRAZJMAZJRAZTRAdVJAklmAbcNAjdRAMnRAMWYAWpRAWgRAFgBAFhBAFdcBNJBBNJDBQKBBQhcBQlmBDEJBYJkBYJTBpNBBpJFBIJBBIJDBIcABOKXBOEJBOVJBOiJBOZJBepBBeLXBeIFBegBBgGJBVJXBuocBiJRBUJQBlXVBlITBwNFBMYVBcqXBTlmBWNFBWiJBWnRBFGHBFwXXKGJXNJBXNZJXDTTXSHSXSVRXSlHXCJDXGQJXEhXXYQJXYbRXOfXXeNcXVJFXhQJXhEJXdTRXjdXXMhBXcQTXRGBXTEBXTnQXFCXXFOFXFgFaBaFaBNJaBCJaBpBaBwXaNJKaNJDaQIBaDpRaEPDaHMFamDJalEJaMZJaFaFaFNBaFQJaFLDaFVHKBCYKBEBKBHDKXaFKXGdKXEJKXpHKXIBKXZDKXwXKKwLKNacKNYJKNJoKNWcKDGdKDTRKChXKGaRKGhBKGbRKEBTKEaRKEPTKLMDKLWRKOHDKVJcKdBcKlIBKlOPKFSBKFEPKFpFNBNJNJBQNBGHNBEPNBHXNBgFNBVXNBZDNBsXNBwXNNaRNNJDNNJENNJkNDCJNDVDNGJRNJiDNZJNNsCJNJFNNFSBNFCXNFEPNFLXNFIFQJBFQCaRQJEQQLJDQLJFQIaRQOqXQHaFQHHQQVJXQVJDQhNJQmEIQZJFQsJXQJrFQWbRDJABDBYJDXNFDXCXDXLXDXZDDXsJDQqXDSJFDJCXDEPkDEqXDYmQDpSJDOCkDOGQDHEIDVJDDuDuDWEBDJFgSBNDSBSFSBGHSBIBSBTQSKVYSJQNSJQiSJCXSEqXSJYVSIiJSOMYSHAHSHaQSeCFSepQSegBSHdHSHrFShSJSJuHSJUFSkNRSrSrSWEBSFaHSJFQSFCXSFGDSFYXSFODSFgBSFVXSFhBSFxFSFkFSFbBSFMFCADdCJXBCXaFCXKFCXNFCXCXCXGBCXEJCXYBCXLDCXIBCXOPCXHXCXgBCXhBCXiBCXlDCXcHCJNBCJNFCDCJCDGBCDVXCDhBCDiDCDJdCCmNCpJFCIaRCOqXCHCHCHZJCViJCuCuCmddCJiFCdNBCdHhClEJCnUJCreSCWlgCWTRCFBFCFNBCFYBCFVFCFhFCFdSCFTBCFWDGBNBGBQFGJBCGBEqGBpBGBgQGNBEGNJYGNkOGNJRGDUFGJpQGHaBGJeNGJeEGVBlGVKjGiJDGvJHGsVJGkEBGMIJGWjNGFBFGFCXGFGBGFYXGFpBGFMFEASJEAWpEJNFECJVEIXSEIQJEOqXEOcFEeNcEHEJEHlFEJgFEhlmEmDJEmZJEiMBEUqXEoSREPBFEPXFEPKFEPSFEPEFEPpFEPLXEPIBEJPdEPcFEPTBEJnXEqlHEMpREFCXEFODEFcFYASJYJAFYBaBYBVXYXpFYDhBYCJBYJGFYYbRYeNcYJeVYiIJYZJcYvJgYvJRYJsXYsJFYMYMYreVpBNHpBEJpBwXpQxFpYEJpeNDpJeDpeSFpeCHpHUJpHbBpHcHpmUJpiiJpUJrpsJuplITpFaBpFQqpFGBpFEfpFYBpFpBpFLJpFIDpFgBpFVXpFyQpFuFpFlFpFjDpFnXpFwXpJFMpFTBLXCJLXEFLXhFLXUJLXbFLalmLNJBLSJQLCLCLGJBLLDJLHaFLeNFLeSHLeCXLepFLhaRLZsJLsJDLsJrLocaLlLlLMdbLFNBLFSBLFEHLFkFIBBFIBXFIBaQIBKXIBSFIBpHIBLXIBgBIBhBIBuHIBmXIBiFIBZXIBvFIBbFIBjQIBwXIBWFIKTRIQUJIDGFICjQIYSRIINXIJeCIVaRImEkIZJFIvJRIsJXIdCJIJoRIbBQIjYBIcqXITFVIreVIFKFIFSFIFCJIFGFIFLDIFIBIJFOIFgBIFVXIJFhIFxFIFmXIFdHIFbBIJFrIJFWOBGBOQfXOOKjOUqXOfXBOqXEOcqXORVJOFIBOFlDHBIOHXiFHNTRHCJXHIaRHHJDHHEJHVbRHZJYHbIBHRsJHRkDHWlmgBKFgBSBgBCDgBGHgBpBgBIBgBVJgBuBgBvFgKDTgQVXgDUJgGSJgOqXgmUMgZIJgTUJgWIEgFBFgFNBgFDJgFSFgFGBgFYXgJFOgFgQgFVXgFhBgFbHgJFWVJABVQKcVDgFVOfXVeDFVhaRVmGdViJYVMaRVFNHhBNDhBCXhBEqhBpFhBLXhNJBhSJRheVXhhKEhxlmhZIJhdBQhkIJhbMNhMUJhMZJxNJgxQUJxDEkxDdFxSJRxplmxeSBxeCXxeGFxeYXxepQxegBxWVcxFEQxFLXxFIBxFgBxFxDxFZtxFdcxFbBxFwXyDJXyDlcuASJuDJpuDIBuCpJuGSJuIJFueEFuZIJusJXudWEuoIBuWGJuFBcuFKEuFNFuFQFuFDJuFGJuFVJuFUtuFdHuFTBmBYJmNJYmQhkmLJDmLJomIdXmiJYmvJRmsJRmklmmMBymMuCmclmmcnQiJABiJBNiJBDiBSFiBCJiBEFiBYBiBpFiBLXiBTHiJNciDEfiCZJiECJiJEqiOkHiHKFieNDiHJQieQcieDHieSFieCXieGFieEFieIHiegFihUJixNoioNXiFaBiFKFiFNDiFEPiFYXitFOitFHiFgBiFVEiFmXiFitiFbBiFMFiFrFUCXQUIoQUIJcUHQJUeCEUHwXUUJDUUqXUdWcUcqXUrnQUFNDUFSHUFCFUFEfUFLXUtFOZBXOZXSBZXpFZXVXZEQJZEJkZpDJZOqXZeNHZeCDZUqXZFBQZFEHZFLXvBAFvBKFvBCXvBEPvBpHvBIDvBgFvBuHvQNJvFNFvFGBvFIBvJFcsXCDsXLXsXsXsXlFsXcHsQqXsJQFsEqXseIFsFEHsFjDdBxOdNpRdNJRdEJbdpJRdhZJdnSJdrjNdFNJdFQHdFhNkNJDkYaRkHNRkHSRkVbRkuMRkjSJkcqDoSJFoEiJoYZJoOfXohEBoMGQocqXbBAFbBXFbBaFbBNDbBGBbBLXbBTBbBWDbGJYbIJHbFQqbFpQlDgQlOrFlVJRjGEBjZJRnXvJnXbBnEfHnOPDngJRnxfXnUJWwXEJwNpJwDpBwEfXwrEBMDCJMDGHMDIJMLJDcQGDcQpHcqXccqNFcqCXcFCJRBSBRBGBRBEJRBpQTBNFTBQJTBpBTBVXTFABTFSBTFCFTFGBTFMDrXCJrXLDrDNJrEfHrFQJrFitWNjdWNTR",
  "AKLJMANOPFASNJIAEJWXAYJNRAIIbRAIcdaAeEfDAgidRAdjNYAMYEJAMIbRAFNJBAFpJFBBIJYBDZJFBSiJhBGdEBBEJfXBEJqXBEJWRBpaUJBLXrXBIYJMBOcfXBeEfFBestXBjNJRBcDJOBFEqXXNvJRXDMBhXCJNYXOAWpXONJWXHDEBXeIaRXhYJDXZJSJXMDJOXcASJXFVJXaBQqXaBZJFasXdQaFSJQaFEfXaFpJHaFOqXKBNSRKXvJBKQJhXKEJQJKEJGFKINJBKIJjNKgJNSKVElmKVhEBKiJGFKlBgJKjnUJKwsJYKMFIJKFNJDKFIJFKFOfXNJBSFNJBCXNBpJFNJBvQNJBMBNJLJXNJOqXNJeCXNJeGFNdsJCNbTKFNwXUJQNFEPQDiJcQDMSJQSFpBQGMQJQJeOcQyCJEQUJEBQJFBrQFEJqDXDJFDJXpBDJXIMDGiJhDIJGRDJeYcDHrDJDVXgFDkAWpDkIgRDjDEqDMvJRDJFNFDJFIBSKclmSJQOFSJQVHSJQjDSJGJBSJGJFSECJoSHEJqSJHTBSJVJDSViJYSZJNBSJsJDSFSJFSFEfXSJFLXCBUJVCJXSBCJXpBCXVJXCJXsXCJXdFCJNJHCLIJgCHiJFCVNJMChCJhCUHEJCsJTRCJdYcCoQJCCFEfXCFIJgCFUJxCFstFGJBaQGJBIDGQJqXGYJNRGJHKFGeQqDGHEJFGJeLXGHIiJGHdBlGUJEBGkIJTGFQPDGJFEqEAGegEJIJBEJVJXEhQJTEiJNcEJZJFEJoEqEjDEqEPDsXEPGJBEPOqXEPeQFEfDiDEJfEFEfepQEfMiJEqXNBEqDIDEqeSFEqVJXEMvJRYXNJDYXEJHYKVJcYYJEBYJeEcYJUqXYFpJFYFstXpAZJMpBSJFpNBNFpeQPDpHLJDpHIJFpHgJFpeitFpHZJFpJFADpFSJFpJFCJpFOqXpFitBpJFZJLXIJFLIJgRLVNJWLVHJMLwNpJLFGJBLFLJDLFOqXLJFUJIBDJXIBGJBIJBYQIJBIBIBOqXIBcqDIEGJFILNJTIIJEBIOiJhIJeNBIJeIBIhiJIIWoTRIJFAHIJFpBIJFuHIFUtFIJFTHOSBYJOEcqXOHEJqOvBpFOkVJrObBVJOncqDOcNJkHhNJRHuHJuHdMhBgBUqXgBsJXgONJBgHNJDgHHJQgJeitgHsJXgJyNagyDJBgZJDrgsVJQgkEJNgkjSJgJFAHgFCJDgFZtMVJXNFVXQfXVJXDJVXoQJVQVJQVDEfXVDvJHVEqNFVeQfXVHpJFVHxfXVVJSRVVmaRVlIJOhCXVJhHjYkhxCJVhWVUJhWiJcxBNJIxeEqDxfXBFxcFEPxFSJFxFYJXyBDQJydaUJyFOPDuYCJYuLvJRuHLJXuZJLDuFOPDuFZJHuFcqXmKHJdmCQJcmOsVJiJAGFitLCFieOfXiestXiZJMEikNJQirXzFiFQqXiFIJFiFZJFiFvtFUHpJFUteIcUteOcUVCJkUhdHcUbEJEUJqXQUMNJhURjYkUFitFZDGJHZJIxDZJVJXZJFDJZJFpQvBNJBvBSJFvJxBrseQqDsVFVJdFLJDkEJNBkmNJYkFLJDoQJOPoGsJRoEAHBoEJfFbBQqDbBZJHbFVJXlFIJBjYIrXjeitcjjCEBjWMNBwXQfXwXOaFwDsJXwCJTRwrCZJMDNJQcDDJFcqDOPRYiJFTBsJXTQIJBTFEfXTFLJDrXEJFrEJXMrFZJFWEJdEWYTlm",
  "ABCDEFACNJTRAMBDJdAcNJVXBLNJEBXSIdWRXErNJkXYDJMBXZJCJaXMNJaYKKVJKcKDEJqXKDcNJhKVJrNYKbgJVXKFVJSBNBYBwDNJeQfXNJeEqXNhGJWENJFiJRQlIJbEQJfXxDQqXcfXQFNDEJQFwXUJDYcnUJDJIBgQDIUJTRDJFEqDSJQSJFSJQIJFSOPeZtSJFZJHCJXQfXCTDEqFGJBSJFGJBOfXGJBcqXGJHNJDGJRLiJEJfXEqEJFEJPEFpBEJYJBZJFYBwXUJYiJMEBYJZJyTYTONJXpQMFXFpeGIDdpJFstXpJFcPDLBVSJRLHQJqXLJFZJFIJBNJDIJBUqXIBkFDJIJEJPTIYJGWRIJeQPDIJeEfHIJFsJXOqGDSFHXEJqXgJCsJCgGQJqXgdQYJEgFMFNBgJFcqDVJwXUJVJFZJchIgJCCxOEJqXxOwXUJyDJBVRuscisciJBiJBieUtqXiJFDJkiFsJXQUGEZJcUJFsJXZtXIrXZDZJDrZJFNJDZJFstXvJFQqXvJFCJEsJXQJqkhkNGBbDJdTRbYJMEBlDwXUJMEFiJFcfXNJDRcNJWMTBLJXC",
  "BraFUtHBFSJFdbNBLJXVJQoYJNEBSJBEJfHSJHwXUJCJdAZJMGjaFVJXEJPNJBlEJfFiJFpFbFEJqIJBVJCrIBdHiJhOPFChvJVJZJNJWxGFNIFLueIBQJqUHEJfUFstOZJDrlXEASJRlXVJXSFwVJNJWD",
  "QJEJNNJDQJEJIBSFQJEJxegBQJEJfHEPSJBmXEJFSJCDEJqXLXNJFQqXIcQsFNJFIFEJqXUJgFsJXIJBUJEJfHNFvJxEqXNJnXUJFQqD",
  "IJBEJqXZJ"
];
var mapping = "~~AzB~X~a~KN~Q~D~S~C~G~E~Y~p~L~I~O~eH~g~V~hxyumi~~U~~Z~~v~~s~~dkoblPjfnqwMcRTr~W~~~F~~~~~Jt";
var _wordlist = null;
var KiYoKu = "0xe3818de38284e3818f";
var KyoKu = "0xe3818de38283e3818f";
var wordlist7 = null;

class LangJa extends Wordlist {
  constructor() {
    super("ja");
  }
  getWord(index) {
    const words5 = loadWords();
    assertArgument(index >= 0 && index < words5.length, `invalid word index: ${index}`, "index", index);
    return words5[index];
  }
  getWordIndex(word) {
    return loadWords().indexOf(word);
  }
  split(phrase) {
    return phrase.split(/(?:\u3000| )+/g);
  }
  join(words5) {
    return words5.join("\u3000");
  }
  static wordlist() {
    if (wordlist7 == null) {
      wordlist7 = new LangJa;
    }
    return wordlist7;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-ko.js
var getHangul = function(code) {
  if (code >= 40) {
    code = code + 168 - 40;
  } else if (code >= 19) {
    code = code + 97 - 19;
  }
  return toUtf8String(new Uint8Array([225, (code >> 6) + 132, (code & 63) + 128]));
};
var loadWords2 = function() {
  if (_wordlist2 != null) {
    return _wordlist2;
  }
  const wordlist9 = [];
  data13.forEach((data13, length) => {
    length += 4;
    for (let i = 0;i < data13.length; i += length) {
      let word = "";
      for (let j = 0;j < length; j++) {
        word += getHangul(codes.indexOf(data13[i + j]));
      }
      wordlist9.push(word);
    }
  });
  wordlist9.sort();
  const checksum5 = id(wordlist9.join("\n") + "\n");
  if (checksum5 !== "0xf9eddeace9c5d3da9c93cf7d3cd38f6a13ed3affb933259ae865714e8a3ae71a") {
    throw new Error("BIP39 Wordlist for ko (Korean) FAILED");
  }
  _wordlist2 = wordlist9;
  return wordlist9;
};
var data13 = [
  "OYAa",
  "ATAZoATBl3ATCTrATCl8ATDloATGg3ATHT8ATJT8ATJl3ATLlvATLn4ATMT8ATMX8ATMboATMgoAToLbAToMTATrHgATvHnAT3AnAT3JbAT3MTAT8DbAT8JTAT8LmAT8MYAT8MbAT#LnAUHT8AUHZvAUJXrAUJX8AULnrAXJnvAXLUoAXLgvAXMn6AXRg3AXrMbAX3JTAX3QbAYLn3AZLgvAZrSUAZvAcAZ8AaAZ8AbAZ8AnAZ8HnAZ8LgAZ8MYAZ8MgAZ8OnAaAboAaDTrAaFTrAaJTrAaJboAaLVoAaMXvAaOl8AaSeoAbAUoAbAg8AbAl4AbGnrAbMT8AbMXrAbMn4AbQb8AbSV8AbvRlAb8AUAb8AnAb8HgAb8JTAb8NTAb8RbAcGboAcLnvAcMT8AcMX8AcSToAcrAaAcrFnAc8AbAc8MgAfGgrAfHboAfJnvAfLV8AfLkoAfMT8AfMnoAfQb8AfScrAfSgrAgAZ8AgFl3AgGX8AgHZvAgHgrAgJXoAgJX8AgJboAgLZoAgLn4AgOX8AgoATAgoAnAgoCUAgoJgAgoLXAgoMYAgoSeAgrDUAgrJTAhrFnAhrLjAhrQgAjAgoAjJnrAkMX8AkOnoAlCTvAlCV8AlClvAlFg4AlFl6AlFn3AloSnAlrAXAlrAfAlrFUAlrFbAlrGgAlrOXAlvKnAlvMTAl3AbAl3MnAnATrAnAcrAnCZ3AnCl8AnDg8AnFboAnFl3AnHX4AnHbrAnHgrAnIl3AnJgvAnLXoAnLX4AnLbrAnLgrAnLhrAnMXoAnMgrAnOn3AnSbrAnSeoAnvLnAn3OnCTGgvCTSlvCTvAUCTvKnCTvNTCT3CZCT3GUCT3MTCT8HnCUCZrCULf8CULnvCU3HnCU3JUCY6NUCbDb8CbFZoCbLnrCboOTCboScCbrFnCbvLnCb8AgCb8HgCb$LnCkLfoClBn3CloDUDTHT8DTLl3DTSU8DTrAaDTrLXDTrLjDTrOYDTrOgDTvFXDTvFnDT3HUDT3LfDUCT9DUDT4DUFVoDUFV8DUFkoDUGgrDUJnrDULl8DUMT8DUMXrDUMX4DUMg8DUOUoDUOgvDUOg8DUSToDUSZ8DbDXoDbDgoDbGT8DbJn3DbLg3DbLn4DbMXrDbMg8DbOToDboJXGTClvGTDT8GTFZrGTLVoGTLlvGTLl3GTMg8GTOTvGTSlrGToCUGTrDgGTrJYGTrScGTtLnGTvAnGTvQgGUCZrGUDTvGUFZoGUHXrGULnvGUMT8GUoMgGXoLnGXrMXGXrMnGXvFnGYLnvGZOnvGZvOnGZ8LaGZ8LmGbAl3GbDYvGbDlrGbHX3GbJl4GbLV8GbLn3GbMn4GboJTGboRfGbvFUGb3GUGb4JnGgDX3GgFl$GgJlrGgLX6GgLZoGgLf8GgOXoGgrAgGgrJXGgrMYGgrScGgvATGgvOYGnAgoGnJgvGnLZoGnLg3GnLnrGnQn8GnSbrGnrMgHTClvHTDToHTFT3HTQT8HToJTHToJgHTrDUHTrMnHTvFYHTvRfHT8MnHT8SUHUAZ8HUBb4HUDTvHUoMYHXFl6HXJX6HXQlrHXrAUHXrMnHXrSbHXvFYHXvKXHX3LjHX3MeHYvQlHZrScHZvDbHbAcrHbFT3HbFl3HbJT8HbLTrHbMT8HbMXrHbMbrHbQb8HbSX3HboDbHboJTHbrFUHbrHgHbrJTHb8JTHb8MnHb8QgHgAlrHgDT3HgGgrHgHgrHgJTrHgJT8HgLX@HgLnrHgMT8HgMX8HgMboHgOnrHgQToHgRg3HgoHgHgrCbHgrFnHgrLVHgvAcHgvAfHnAloHnCTrHnCnvHnGTrHnGZ8HnGnvHnJT8HnLf8HnLkvHnMg8HnRTrITvFUITvFnJTAXrJTCV8JTFT3JTFT8JTFn4JTGgvJTHT8JTJT8JTJXvJTJl3JTJnvJTLX4JTLf8JTLhvJTMT8JTMXrJTMnrJTObrJTQT8JTSlvJT8DUJT8FkJT8MTJT8OXJT8OgJT8QUJT8RfJUHZoJXFT4JXFlrJXGZ8JXGnrJXLV8JXLgvJXMXoJXMX3JXNboJXPlvJXoJTJXoLkJXrAXJXrHUJXrJgJXvJTJXvOnJX4KnJYAl3JYJT8JYLhvJYQToJYrQXJY6NUJbAl3JbCZrJbDloJbGT8JbGgrJbJXvJbJboJbLf8JbLhrJbLl3JbMnvJbRg8JbSZ8JboDbJbrCZJbrSUJb3KnJb8LnJfRn8JgAXrJgCZrJgDTrJgGZrJgGZ8JgHToJgJT8JgJXoJgJgvJgLX4JgLZ3JgLZ8JgLn4JgMgrJgMn4JgOgvJgPX6JgRnvJgSToJgoCZJgoJbJgoMYJgrJXJgrJgJgrLjJg6MTJlCn3JlGgvJlJl8Jl4AnJl8FnJl8HgJnAToJnATrJnAbvJnDUoJnGnrJnJXrJnJXvJnLhvJnLnrJnLnvJnMToJnMT8JnMXvJnMX3JnMg8JnMlrJnMn4JnOX8JnST4JnSX3JnoAgJnoAnJnoJTJnoObJnrAbJnrAkJnrHnJnrJTJnrJYJnrOYJnrScJnvCUJnvFaJnvJgJnvJnJnvOYJnvQUJnvRUJn3FnJn3JTKnFl3KnLT6LTDlvLTMnoLTOn3LTRl3LTSb4LTSlrLToAnLToJgLTrAULTrAcLTrCULTrHgLTrMgLT3JnLULnrLUMX8LUoJgLVATrLVDTrLVLb8LVoJgLV8MgLV8RTLXDg3LXFlrLXrCnLXrLXLX3GTLX4GgLX4OYLZAXrLZAcrLZAgrLZAhrLZDXyLZDlrLZFbrLZFl3LZJX6LZJX8LZLc8LZLnrLZSU8LZoJTLZoJnLZrAgLZrAnLZrJYLZrLULZrMgLZrSkLZvAnLZvGULZvJeLZvOTLZ3FZLZ4JXLZ8STLZ8ScLaAT3LaAl3LaHT8LaJTrLaJT8LaJXrLaJgvLaJl4LaLVoLaMXrLaMXvLaMX8LbClvLbFToLbHlrLbJn4LbLZ3LbLhvLbMXrLbMnoLbvSULcLnrLc8HnLc8MTLdrMnLeAgoLeOgvLeOn3LfAl3LfLnvLfMl3LfOX8Lf8AnLf8JXLf8LXLgJTrLgJXrLgJl8LgMX8LgRZrLhCToLhrAbLhrFULhrJXLhvJYLjHTrLjHX4LjJX8LjLhrLjSX3LjSZ4LkFX4LkGZ8LkGgvLkJTrLkMXoLkSToLkSU8LkSZ8LkoOYLl3FfLl3MgLmAZrLmCbrLmGgrLmHboLmJnoLmJn3LmLfoLmLhrLmSToLnAX6LnAb6LnCZ3LnCb3LnDTvLnDb8LnFl3LnGnrLnHZvLnHgvLnITvLnJT8LnJX8LnJlvLnLf8LnLg6LnLhvLnLnoLnMXrLnMg8LnQlvLnSbrLnrAgLnrAnLnrDbLnrFkLnrJdLnrMULnrOYLnrSTLnvAnLnvDULnvHgLnvOYLnvOnLn3GgLn4DULn4JTLn4JnMTAZoMTAloMTDb8MTFT8MTJnoMTJnrMTLZrMTLhrMTLkvMTMX8MTRTrMToATMTrDnMTrOnMT3JnMT4MnMT8FUMT8FaMT8FlMT8GTMT8GbMT8GnMT8HnMT8JTMT8JbMT8OTMUCl8MUJTrMUJU8MUMX8MURTrMUSToMXAX6MXAb6MXCZoMXFXrMXHXrMXLgvMXOgoMXrAUMXrAnMXrHgMXrJYMXrJnMXrMTMXrMgMXrOYMXrSZMXrSgMXvDUMXvOTMX3JgMX3OTMX4JnMX8DbMX8FnMX8HbMX8HgMX8HnMX8LbMX8MnMX8OnMYAb8MYGboMYHTvMYHX4MYLTrMYLnvMYMToMYOgvMYRg3MYSTrMbAToMbAXrMbAl3MbAn8MbGZ8MbJT8MbJXrMbMXvMbMX8MbMnoMbrMUMb8AfMb8FbMb8FkMcJXoMeLnrMgFl3MgGTvMgGXoMgGgrMgGnrMgHT8MgHZrMgJnoMgLnrMgLnvMgMT8MgQUoMgrHnMgvAnMg8HgMg8JYMg8LfMloJnMl8ATMl8AXMl8JYMnAToMnAT4MnAZ8MnAl3MnAl4MnCl8MnHT8MnHg8MnJnoMnLZoMnLhrMnMXoMnMX3MnMnrMnOgvMnrFbMnrFfMnrFnMnrNTMnvJXNTMl8OTCT3OTFV8OTFn3OTHZvOTJXrOTOl3OT3ATOT3JUOT3LZOT3LeOT3MbOT8ATOT8AbOT8AgOT8MbOUCXvOUMX3OXHXvOXLl3OXrMUOXvDbOX6NUOX8JbOYFZoOYLbrOYLkoOYMg8OYSX3ObHTrObHT4ObJgrObLhrObMX3ObOX8Ob8FnOeAlrOeJT8OeJXrOeJnrOeLToOeMb8OgJXoOgLXoOgMnrOgOXrOgOloOgoAgOgoJbOgoMYOgoSTOg8AbOjLX4OjMnoOjSV8OnLVoOnrAgOn3DUPXQlrPXvFXPbvFTPdAT3PlFn3PnvFbQTLn4QToAgQToMTQULV8QURg8QUoJnQXCXvQbFbrQb8AaQb8AcQb8FbQb8MYQb8ScQeAlrQeLhrQjAn3QlFXoQloJgQloSnRTLnvRTrGURTrJTRUJZrRUoJlRUrQnRZrLmRZrMnRZrSnRZ8ATRZ8JbRZ8ScRbMT8RbST3RfGZrRfMX8RfMgrRfSZrRnAbrRnGT8RnvJgRnvLfRnvMTRn8AaSTClvSTJgrSTOXrSTRg3STRnvSToAcSToAfSToAnSToHnSToLjSToMTSTrAaSTrEUST3BYST8AgST8LmSUAZvSUAgrSUDT4SUDT8SUGgvSUJXoSUJXvSULTrSU8JTSU8LjSV8AnSV8JgSXFToSXLf8SYvAnSZrDUSZrMUSZrMnSZ8HgSZ8JTSZ8JgSZ8MYSZ8QUSaQUoSbCT3SbHToSbQYvSbSl4SboJnSbvFbSb8HbSb8JgSb8OTScGZrScHgrScJTvScMT8ScSToScoHbScrMTScvAnSeAZrSeAcrSeHboSeJUoSeLhrSeMT8SeMXrSe6JgSgHTrSkJnoSkLnvSk8CUSlFl3SlrSnSl8GnSmAboSmGT8SmJU8",
  "ATLnDlATrAZoATrJX4ATrMT8ATrMX4ATrRTrATvDl8ATvJUoATvMl8AT3AToAT3MX8AT8CT3AT8DT8AT8HZrAT8HgoAUAgFnAUCTFnAXoMX8AXrAT8AXrGgvAXrJXvAXrOgoAXvLl3AZvAgoAZvFbrAZvJXoAZvJl8AZvJn3AZvMX8AZvSbrAZ8FZoAZ8LZ8AZ8MU8AZ8OTvAZ8SV8AZ8SX3AbAgFZAboJnoAbvGboAb8ATrAb8AZoAb8AgrAb8Al4Ab8Db8Ab8JnoAb8LX4Ab8LZrAb8LhrAb8MT8Ab8OUoAb8Qb8Ab8ST8AcrAUoAcrAc8AcrCZ3AcrFT3AcrFZrAcrJl4AcrJn3AcrMX3AcrOTvAc8AZ8Ac8MT8AfAcJXAgoFn4AgoGgvAgoGnrAgoLc8AgoMXoAgrLnrAkrSZ8AlFXCTAloHboAlrHbrAlrLhrAlrLkoAl3CZrAl3LUoAl3LZrAnrAl4AnrMT8An3HT4BT3IToBX4MnvBb!Ln$CTGXMnCToLZ4CTrHT8CT3JTrCT3RZrCT#GTvCU6GgvCU8Db8CU8GZrCU8HT8CboLl3CbrGgrCbrMU8Cb8DT3Cb8GnrCb8LX4Cb8MT8Cb8ObrCgrGgvCgrKX4Cl8FZoDTrAbvDTrDboDTrGT6DTrJgrDTrMX3DTrRZrDTrRg8DTvAVvDTvFZoDT3DT8DT3Ln3DT4HZrDT4MT8DT8AlrDT8MT8DUAkGbDUDbJnDYLnQlDbDUOYDbMTAnDbMXSnDboAT3DboFn4DboLnvDj6JTrGTCgFTGTGgFnGTJTMnGTLnPlGToJT8GTrCT3GTrLVoGTrLnvGTrMX3GTrMboGTvKl3GZClFnGZrDT3GZ8DTrGZ8FZ8GZ8MXvGZ8On8GZ8ST3GbCnQXGbMbFnGboFboGboJg3GboMXoGb3JTvGb3JboGb3Mn6Gb3Qb8GgDXLjGgMnAUGgrDloGgrHX4GgrSToGgvAXrGgvAZvGgvFbrGgvLl3GgvMnvGnDnLXGnrATrGnrMboGnuLl3HTATMnHTAgCnHTCTCTHTrGTvHTrHTvHTrJX8HTrLl8HTrMT8HTrMgoHTrOTrHTuOn3HTvAZrHTvDTvHTvGboHTvJU8HTvLl3HTvMXrHTvQb4HT4GT6HT4JT8HT4Jb#HT8Al3HT8GZrHT8GgrHT8HX4HT8Jb8HT8JnoHT8LTrHT8LgvHT8SToHT8SV8HUoJUoHUoJX8HUoLnrHXrLZoHXvAl3HX3LnrHX4FkvHX4LhrHX4MXoHX4OnoHZrAZ8HZrDb8HZrGZ8HZrJnrHZvGZ8HZvLnvHZ8JnvHZ8LhrHbCXJlHbMTAnHboJl4HbpLl3HbrJX8HbrLnrHbrMnvHbvRYrHgoSTrHgrFV8HgrGZ8HgrJXoHgrRnvHgvBb!HgvGTrHgvHX4HgvHn!HgvLTrHgvSU8HnDnLbHnFbJbHnvDn8Hn6GgvHn!BTvJTCTLnJTQgFnJTrAnvJTrLX4JTrOUoJTvFn3JTvLnrJTvNToJT3AgoJT3Jn4JT3LhvJT3ObrJT8AcrJT8Al3JT8JT8JT8JnoJT8LX4JT8LnrJT8MX3JT8Rg3JT8Sc8JUoBTvJU8AToJU8GZ8JU8GgvJU8JTrJU8JXrJU8JnrJU8LnvJU8ScvJXHnJlJXrGgvJXrJU8JXrLhrJXrMT8JXrMXrJXrQUoJXvCTvJXvGZ8JXvGgrJXvQT8JX8Ab8JX8DT8JX8GZ8JX8HZvJX8LnrJX8MT8JX8MXoJX8MnvJX8ST3JYGnCTJbAkGbJbCTAnJbLTAcJboDT3JboLb6JbrAnvJbrCn3JbrDl8JbrGboJbrIZoJbrJnvJbrMnvJbrQb4Jb8RZrJeAbAnJgJnFbJgScAnJgrATrJgvHZ8JgvMn4JlJlFbJlLiQXJlLjOnJlRbOlJlvNXoJlvRl3Jl4AcrJl8AUoJl8MnrJnFnMlJnHgGbJnoDT8JnoFV8JnoGgvJnoIT8JnoQToJnoRg3JnrCZ3JnrGgrJnrHTvJnrLf8JnrOX8JnvAT3JnvFZoJnvGT8JnvJl4JnvMT8JnvMX8JnvOXrJnvPX6JnvSX3JnvSZrJn3MT8Jn3MX8Jn3RTrLTATKnLTJnLTLTMXKnLTRTQlLToGb8LTrAZ8LTrCZ8LTrDb8LTrHT8LT3PX6LT4FZoLT$CTvLT$GgrLUvHX3LVoATrLVoAgoLVoJboLVoMX3LVoRg3LV8CZ3LV8FZoLV8GTvLXrDXoLXrFbrLXvAgvLXvFlrLXvLl3LXvRn6LX4Mb8LX8GT8LYCXMnLYrMnrLZoSTvLZrAZvLZrAloLZrFToLZrJXvLZrJboLZrJl4LZrLnrLZrMT8LZrOgvLZrRnvLZrST4LZvMX8LZvSlvLZ8AgoLZ8CT3LZ8JT8LZ8LV8LZ8LZoLZ8Lg8LZ8SV8LZ8SbrLZ$HT8LZ$Mn4La6CTvLbFbMnLbRYFTLbSnFZLboJT8LbrAT9LbrGb3LbrQb8LcrJX8LcrMXrLerHTvLerJbrLerNboLgrDb8LgrGZ8LgrHTrLgrMXrLgrSU8LgvJTrLgvLl3Lg6Ll3LhrLnrLhrMT8LhvAl4LiLnQXLkoAgrLkoJT8LkoJn4LlrSU8Ll3FZoLl3HTrLl3JX8Ll3JnoLl3LToLmLeFbLnDUFbLnLVAnLnrATrLnrAZoLnrAb8LnrAlrLnrGgvLnrJU8LnrLZrLnrLhrLnrMb8LnrOXrLnrSZ8LnvAb4LnvDTrLnvDl8LnvHTrLnvHbrLnvJT8LnvJU8LnvJbrLnvLhvLnvMX8LnvMb8LnvNnoLnvSU8Ln3Al3Ln4FZoLn4GT6Ln4JgvLn4LhrLn4MT8Ln4SToMToCZrMToJX8MToLX4MToLf8MToRg3MTrEloMTvGb6MT3BTrMT3Lb6MT8AcrMT8AgrMT8GZrMT8JnoMT8LnrMT8MX3MUOUAnMXAbFnMXoAloMXoJX8MXoLf8MXoLl8MXrAb8MXrDTvMXrGT8MXrGgrMXrHTrMXrLf8MXrMU8MXrOXvMXrQb8MXvGT8MXvHTrMXvLVoMX3AX3MX3Jn3MX3LhrMX3MX3MX4AlrMX4OboMX8GTvMX8GZrMX8GgrMX8JT8MX8JX8MX8LhrMX8MT8MYDUFbMYMgDbMbGnFfMbvLX4MbvLl3Mb8Mb8Mb8ST4MgGXCnMg8ATrMg8AgoMg8CZrMg8DTrMg8DboMg8HTrMg8JgrMg8LT8MloJXoMl8AhrMl8JT8MnLgAUMnoJXrMnoLX4MnoLhrMnoMT8MnrAl4MnrDb8MnrOTvMnrOgvMnrQb8MnrSU8MnvGgrMnvHZ8Mn3MToMn4DTrMn4LTrMn4Mg8NnBXAnOTFTFnOToAToOTrGgvOTrJX8OT3JXoOT6MTrOT8GgrOT8HTpOT8MToOUoHT8OUoJT8OUoLn3OXrAgoOXrDg8OXrMT8OXvSToOX6CTvOX8CZrOX8OgrOb6HgvOb8AToOb8MT8OcvLZ8OgvAlrOgvHTvOgvJTrOgvJnrOgvLZrOgvLn4OgvMT8OgvRTrOg8AZoOg8DbvOnrOXoOnvJn4OnvLhvOnvRTrOn3GgoOn3JnvOn6JbvOn8OTrPTGYFTPbBnFnPbGnDnPgDYQTPlrAnvPlrETvPlrLnvPlrMXvPlvFX4QTMTAnQTrJU8QYCnJlQYJlQlQbGTQbQb8JnrQb8LZoQb8LnvQb8MT8Qb8Ml8Qb8ST4QloAl4QloHZvQloJX8QloMn8QnJZOlRTrAZvRTrDTrRTvJn4RTvLhvRT4Jb8RZrAZrRZ8AkrRZ8JU8RZ8LV8RZ8LnvRbJlQXRg3GboRg3MnvRg8AZ8Rg8JboRg8Jl4RnLTCbRnvFl3RnvQb8SToAl4SToCZrSToFZoSToHXrSToJU8SToJgvSToJl4SToLhrSToMX3STrAlvSTrCT9STrCgrSTrGgrSTrHXrSTrHboSTrJnoSTrNboSTvLnrST4AZoST8Ab8ST8JT8SUoJn3SU6HZ#SU6JTvSU8Db8SU8HboSU8LgrSV8JT8SZrAcrSZrAl3SZrJT8SZrJnvSZrMT8SZvLUoSZ4FZoSZ8JnoSZ8RZrScoLnrScoMT8ScoMX8ScrAT4ScrAZ8ScrLZ8ScrLkvScvDb8ScvLf8ScvNToSgrFZrShvKnrSloHUoSloLnrSlrMXoSl8HgrSmrJUoSn3BX6",
  "ATFlOn3ATLgrDYAT4MTAnAT8LTMnAYJnRTrAbGgJnrAbLV8LnAbvNTAnAeFbLg3AgOYMXoAlQbFboAnDboAfAnJgoJTBToDgAnBUJbAl3BboDUAnCTDlvLnCTFTrSnCYoQTLnDTwAbAnDUDTrSnDUHgHgrDX8LXFnDbJXAcrETvLTLnGTFTQbrGTMnGToGT3DUFbGUJlPX3GbQg8LnGboJbFnGb3GgAYGgAg8ScGgMbAXrGgvAbAnGnJTLnvGnvATFgHTDT6ATHTrDlJnHYLnMn8HZrSbJTHZ8LTFnHbFTJUoHgSeMT8HgrLjAnHgvAbAnHlFUrDlHnDgvAnHnHTFT3HnQTGnrJTAaMXvJTGbCn3JTOgrAnJXvAXMnJbMg8SnJbMnRg3Jb8LTMnJnAl3OnJnGYrQlJnJlQY3LTDlCn3LTJjLg3LTLgvFXLTMg3GTLV8HUOgLXFZLg3LXNXrMnLX8QXFnLX9AlMYLYLXPXrLZAbJU8LZDUJU8LZMXrSnLZ$AgFnLaPXrDULbFYrMnLbMn8LXLboJgJgLeFbLg3LgLZrSnLgOYAgoLhrRnJlLkCTrSnLkOnLhrLnFX%AYLnFZoJXLnHTvJbLnLloAbMTATLf8MTHgJn3MTMXrAXMT3MTFnMUITvFnMXFX%AYMXMXvFbMXrFTDbMYAcMX3MbLf8SnMb8JbFnMgMXrMTMgvAXFnMgvGgCmMnAloSnMnFnJTrOXvMXSnOX8HTMnObJT8ScObLZFl3ObMXCZoPTLgrQXPUFnoQXPU3RXJlPX3RkQXPbrJXQlPlrJbFnQUAhrDbQXGnCXvQYLnHlvQbLfLnvRTOgvJbRXJYrQlRYLnrQlRbLnrQlRlFT8JlRlFnrQXSTClCn3STHTrAnSTLZQlrSTMnGTrSToHgGbSTrGTDnSTvGXCnST3HgFbSU3HXAXSbAnJn3SbFT8LnScLfLnv",
  "AT3JgJX8AT8FZoSnAT8JgFV8AT8LhrDbAZ8JT8DbAb8GgLhrAb8SkLnvAe8MT8SnAlMYJXLVAl3GYDTvAl3LfLnvBUDTvLl3CTOn3HTrCT3DUGgrCU8MT8AbCbFTrJUoCgrDb8MTDTLV8JX8DTLnLXQlDT8LZrSnDUQb8FZ8DUST4JnvDb8ScOUoDj6GbJl4GTLfCYMlGToAXvFnGboAXvLnGgAcrJn3GgvFnSToGnLf8JnvGn#HTDToHTLnFXJlHTvATFToHTvHTDToHTvMTAgoHT3STClvHT4AlFl6HT8HTDToHUoDgJTrHUoScMX3HbRZrMXoHboJg8LTHgDb8JTrHgMToLf8HgvLnLnoHnHn3HT4Hn6MgvAnJTJU8ScvJT3AaQT8JT8HTrAnJXrRg8AnJbAloMXoJbrATFToJbvMnoSnJgDb6GgvJgDb8MXoJgSX3JU8JguATFToJlPYLnQlJlQkDnLbJlQlFYJlJl8Lf8OTJnCTFnLbJnLTHXMnJnLXGXCnJnoFfRg3JnrMYRg3Jn3HgFl3KT8Dg8LnLTRlFnPTLTvPbLbvLVoSbrCZLXMY6HT3LXNU7DlrLXNXDTATLX8DX8LnLZDb8JU8LZMnoLhrLZSToJU8LZrLaLnrLZvJn3SnLZ8LhrSnLaJnoMT8LbFlrHTvLbrFTLnrLbvATLlvLb6OTFn3LcLnJZOlLeAT6Mn4LeJT3ObrLg6LXFlrLhrJg8LnLhvDlPX4LhvLfLnvLj6JTFT3LnFbrMXoLnQluCTvLnrQXCY6LnvLfLnvLnvMgLnvLnvSeLf8MTMbrJn3MT3JgST3MT8AnATrMT8LULnrMUMToCZrMUScvLf8MXoDT8SnMX6ATFToMX8AXMT8MX8FkMT8MX8HTrDUMX8ScoSnMYJT6CTvMgAcrMXoMg8SToAfMlvAXLg3MnFl3AnvOT3AnFl3OUoATHT8OU3RnLXrOXrOXrSnObPbvFn6Og8HgrSnOg8OX8DbPTvAgoJgPU3RYLnrPXrDnJZrPb8CTGgvPlrLTDlvPlvFUJnoQUvFXrQlQeMnoAl3QlrQlrSnRTFTrJUoSTDlLiLXSTFg6HT3STJgoMn4STrFTJTrSTrLZFl3ST4FnMXoSUrDlHUoScvHTvSnSfLkvMXo",
  "AUoAcrMXoAZ8HboAg8AbOg6ATFgAg8AloMXoAl3AT8JTrAl8MX8MXoCT3SToJU8Cl8Db8MXoDT8HgrATrDboOT8MXoGTOTrATMnGT8LhrAZ8GnvFnGnQXHToGgvAcrHTvAXvLl3HbrAZoMXoHgBlFXLg3HgMnFXrSnHgrSb8JUoHn6HT8LgvITvATrJUoJUoLZrRnvJU8HT8Jb8JXvFX8QT8JXvLToJTrJYrQnGnQXJgrJnoATrJnoJU8ScvJnvMnvMXoLTCTLgrJXLTJlRTvQlLbRnJlQYvLbrMb8LnvLbvFn3RnoLdCVSTGZrLeSTvGXCnLg3MnoLn3MToLlrETvMT8SToAl3MbrDU6GTvMb8LX4LhrPlrLXGXCnSToLf8Rg3STrDb8LTrSTvLTHXMnSb3RYLnMnSgOg6ATFg",
  "HUDlGnrQXrJTrHgLnrAcJYMb8DULc8LTvFgGnCk3Mg8JbAnLX4QYvFYHnMXrRUoJnGnvFnRlvFTJlQnoSTrBXHXrLYSUJgLfoMT8Se8DTrHbDb",
  "AbDl8SToJU8An3RbAb8ST8DUSTrGnrAgoLbFU6Db8LTrMg8AaHT8Jb8ObDl8SToJU8Pb3RlvFYoJl"
];
var codes = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789!@#$%^&*";
var _wordlist2 = null;
var wordlist9 = null;

class LangKo extends Wordlist {
  constructor() {
    super("ko");
  }
  getWord(index) {
    const words5 = loadWords2();
    assertArgument(index >= 0 && index < words5.length, `invalid word index: ${index}`, "index", index);
    return words5[index];
  }
  getWordIndex(word) {
    return loadWords2().indexOf(word);
  }
  static wordlist() {
    if (wordlist9 == null) {
      wordlist9 = new LangKo;
    }
    return wordlist9;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-it.js
var words5 = "0torea noica!iosorolotaleratelanena%oiadoencotivomai t ca%a0A]Bagl'Bin#E.Is(Oli!Rasi_Rog#0Cade!C[$Cus#E <Hil,I@QuaReRil>Roba+U 0Ag'Deb{DomeEgu#Eri!IpeOtt&Ul&1Fabi,Fe|Fis(F-n Oris`O(R~$0AveEn.E_,Ganc'I!It&OnismoR>*Rume Uzzo4AbardaA Bat)Ber#BoBumeCeCol>E|<FaGeb-Ian.IbiIm[ Lag#Leg)Lie_Lo@/Lusi_Me$Oge$Pa}Pest!Ta,=Ter$T%c'T)veUn$Veo*Z&0Alga`Ani+A!=B{Br#EbaEr~E^s+I]Mas(M[daMir&Mon{O!P'Pli&U, 0A}r@Ag-feAlis+Arch?At-CaCel/Co-D&D!aEl*Ge*Gol&Gus I`Neg&Nid#NoNunc'OnimoT%ipoZi1At>Ertu-OdePari!Pe^ Pogg'P)@Pun Ri,1Ab~AchideAgos+Ald~Anc'Atu-AzzoBit)Chiv'D{Eni,G[ Gi<Gu IaMon?NeseRed#RingaRos S[>SoTef%eZil*0Ciu|Col EpsiEtt>Fal I$O/Pir#P)Sagg'SeSolu Sur@TaT[u T%eT-|0Av>EismoOm>O$TesaTiv&Tor$Tr{Tua,0Sil'Str?Tis+To$moTun$0Anz#E!V[i!Vi(Volge!3Io<O ZimoZur):Be,C}$Ci$CoDessaDi/+Gn#I+L]<L@Le=L/+Lza$Mbi$Ndi!RaondaRba)R}R{$RlumeRoc]Sil>S(Tos+Ttu U,VaVosa3C]FfaLg'LvaNdaNe_,Nig$Nzi=ReRli=Ta3Bi+CiDo<Fi@GaLanc?MboNo]*O*goPedePol&Rban.R-S]|Ses S$n$Son.SturiZzar)2An@At+2Ll{Nif>R@S]Tan>T^$Zzo*2Acc'AdipoA`An}Avu-E.l/Eve|EzzaIgl?Il/n.Ind&Oc]*O@Onzi=Ul*U$2Bbo<CaDi$Ffo<IoLboO$R*<R-s}S(/S+:De|Du]La`)L]*LesseLib)LmoLor?MbusaMe-+M%?Mmi$Mo/Mpa,NapaNde/NeNi$No|N^=PacePel*P{*Pogi)Ppe)P-Psu/RapaceR}ssaR@Ris`Rova=R!|R li=Sacc'S}+Ser`SoS(<S.l*Sua,Tas+Te=T-meU Vil*3Dibi,D-+Fa*Leb!Llul&NaNo<N.simoRam~Rc&R RumeRvel*So?SpoTo2E/Ia)Ic}Iede!Ime-I=IrurgoI+r-0AoClismoFr&G$Lind)O|*R}R)siTr>T+di$UffoVet+Vi,2Ass>In~O)2C]Dar@D%eE!n.G$meLl&Lm#Lo!Lpo(L^v#LzaMaMe+M`n@Mo@Mpu.rMu<Nci(Ndur!Nfer`Ngel&NiugeN<s(Nosce!NsumoN^nuoNveg$Per P'<Pp?Pr~poRazzaRda+R%#Rn%eRol/RpoR!@Rs?R.seSm>S+n.Ttu-V#2A.!Avat+E#Ede!Emo(Esci+E+Ice I=,IsiIt>OceO=}Os++Uc?,Us}2Ci!Cu*Gi$Ll#Po/R#!R(!R_Sci$S de:DoI$L`+Meri$Nie/N$(Nz&T#Van^Vve)3Bu|C[n'Ci(Cli$Col*C! D%#Fin{FormeG$Leg&Lfi$Lir'L+M[zaNot#Nt)Pos{Rapa+Riv&RogaScri|Ser Sider'Sume!Tersi_Vo 3Amet)Cemb!Ed)Fe(Ffu(Geri!Gi+,Luv'Nam>N=nziPin P*`Po*Rad&ReRo|RupoSag'Sc! Sf&Sge*Spos S+nzaSu`$ToVa$Vel Vide!Vor#5B*<C[.Ga=,G`LceM#M[~Min&N@*NoRmi!TeT !Vu Zzi=2AgoUi@2Bb'Bit&Ca,NaOmoPl%eRatu):0A$0Ces(CoLissiO$m?0E-I]/I,I r?Uc&2Emon?LiOismoReg'4Abor#Argi!Egan.Enc#E|Ev&F>I}MoSaU(0An#B,`Es(I)O^_Oz'<Pir>U*0Dem>Du)Erg?FasiO.}Tr&Zi`1A^.I*goI(d'O},Pu!0U#!0Ar'BaBo(EdeEmi+Ige!Met>OeOsi_Ran.0Ago$AmeAnimeAudi!CaEmp'Erc{Ib{Ig[.Is.!I OfagoOrt#O(Pan(P!s(S[zaSoTe(Tim&Ton?T)(Ult&0Il>N>Rus]To0ClideoRopa0A(Id[zaIt#Olu Viva:Bbr~Cc[daChi)L]Migl?Na,Nfa-NgoN+s`ReRfal/Ri$(R`]Sc?S (Sul*T%&ToVo*(3Bb!Co/DeG#LpaLt)Mmi=Nde!Nome$Rm[ R)R^,Ssu-S^_T+U@3AbaDuc?FaGur#LoNanzaNest-Ni!O!S},S>Ume2A]<Am[]EboEm`Ori@U[.Uo)2B>Cacc?Co(Der#Gl'La+Lc*!Lgo!Nd[.Net>N?N+=Rb{Rchet+Res+Rm~R='RoR.zzaRz&Sf#S(2A}s(A=Assi$A.l*Eccet+E=+Es]IgoOlli$OndeUga,Ut+2Ci/+Cs?Gg[.Lmi<L_Man.Me|Mo(NeNz'<O]RboRgo<Ro!SoTi,:Bb?$FfeLa.oLli=LoppoMbe)M`Ranz?RboRofa$Rzo<S@|Sol'Str>T Ud'ZeboZzel/3CoLa^=L(Mel*Mm#NeN{!N='No^poRgo2Epar@Iacc'Isa0Al*LdaNep)Oc&Oiel*Or$OveR#Ro<T++Udiz'Ur#Us 2Obu*U^<1Omo0BbaLfM{Mmo<Nf'N=Ver$2Aci,A@Af>AmmoAndeAtt&A_(Az?E}EggeIfo<Ig'InzaOt+Uppo2Adag$A'An Ard&FoId&::0Ern#0O=0Ent>Ill'O*RaR>Roge$2Ie<Na)Nor#4A!Le(Log>Lude!0Bal*Bevu Boc]Bu Ma<Mer(Mol#Pac]Pe PiegoPor P)n+0Al&Arc&At^_Can C[d'Chi$Cisi_Clu(Cont)C)c'CuboDagi<D?Do,Ed{Fat^Fil&Fli|Gagg'Geg$G,seGor@G)s(Nes]O@!Oltr&Ond#Sa$Se|SiemeSonn?Suli=Tas#Te)To=]Tu{Umidi!Vali@VeceV{1Erbo,Not>O.siP~1IdeLandaOn>Rig#Ror&0Ol#O poTer>Titu Tr%e0Al?Er&:::Bb)Birin C}Cer#Cri`Cu=D@veGoMpoNcet+N.r=R@(RgaRingeSt-T[zaTi$TtugaVag=Vo)3Ga,Gge)MboN.zzaNzaO<P!Si_Ss#S T.-,VaVig#3Be)DoEv{L/Matu-Mit&Mpi@Ne&NguaQui@RaR~S}TeTig'V!a5CandaDeG~Mb&Nd-Nge_QuaceR[zoToT.r?5CeCid#Ma}Mi$(NgoPoPpo*SingaS(T :Cab)Cchi=Ce)Cin#Da`G>Gl?G<.G)Iol~LafedeLg-@Lin.(Lsa$L Lumo!NaNc?N@r/Ngi&Nifes N=)Nov-NsardaN^deNubr'PpaR#=Rci!Ret+RmoRsup'Sche-Ssa?S^$Te-s(Tr>/T <Tu)Zur}3And)C}n>Ce=.DesimoDit&GaLassaLisLod?NingeNoN(/Rcur'R[daR*Schi$SeSse!S *Tal*To@T.!3Agol&CaCel'Che,C)boDol*E,Gl'!La$Li.MosaNe-,NiNo!Ri$R^l*Sce/SsivaS Sur&TezzaTig&T-T.n.4Emon>0Del*Dif~Du*Ga$G'LeLos(Nas.)N]Ndi=Ne+r'Ni,No $N(<Nt#Nvi(RaRde!Rs%#St)Tiv#TosegaT V[zaVim[ Zzo5C}CosaFfaGhe|G='La|Li<l*L^p*Mm?N Ove!Ra,SaS]*S~Te_,To:BabboF+Nomet)Rci(R%eRr#Sce!Str&Tu-,Ut~Vigl'3Bu*saC)siGa^_Goz'Mme$Ofi+Re|R_Ssu$Ttu$Ut-,VeV)t>3Cch?NfaTi@5Bi,Ci_DoMeMi=Rd>R`,RvegeseSt-$T&Tiz?Ttur$Vel/5C,oL/Me)O_Tri!Vo/Z?,:Si0Bedi!BligoElis]L'O*So, 0Cas'<Ch'Cid[.Cor!!Cult&RaUl#0Ier$Or&1Fer+Fri!Fusc#0Ge|GiNu$4AndeseFa|I#IvaOg-m`T!0Agg'Bel>B-EgaIss'<0Do(E!IceNi_)O!_,Ta1Er#In'<Pos 1A]*AfoDi<Ecchi$Ef%eFa$Gan>Igi<Izzon.MaMegg'Na^_O*g'R[@Ribi,T[s?T~Za+Zo0A!Cur&MosiPeda,Pi.SaSid&Ta]*Te0I.ReTago$TimoTob!1A,EstI$Ipa)Oc{UnqueVi&3Io:Cche|CeCif>Del/D)<EseGaGi=Lazzi=Les&Lli@LoLudeN@)N<l*O*O=zzoPr~Rabo/Rcel/Re!Rgo*RiRl#Ro/R^!Rv[zaRz?,Ssi_St%}Tac}To*g?TtumeVo<3Cc#Dal&Do=,Gg'Lo(N&Nd%eNi(/Nnu Nomb-Ns&N /PePi+Rbe<R]r(R@n#Rfor&Rgame=R'@Rmes(R$Rp,s(Rsua(Rtug'Rva(S#!Sis+SoS^fe)Ta*T^<Tu/n.Zzo3Ace!An+At^$Cci$CozzaEgaEt-Ffe)G?`Gol'G)LaLife)L*/Lo+Mpan.Ne+N=No*Ogg?OmboRamideRet>Ri.RolisiTo<Zz>2AceboAn&As`A+$E=r'2ChezzaDe)(DismoEs?Ggi&L[+Ligo$Ll%eLmoni.Lpet+L(Lt)=Lve!M%eMo@)N.Po*(Rfi@Ro(Rpo-R!R++SaSi^_Sses(Stul#Tass'Te!2AnzoAssiAt~Eclu(Ed~Efis(Egi#Elie_Eme!E$t&Epar#Es[zaE.s Eval(I`IncipeIv#Ob,`Ocu-Odur!OfumoOge|OlungaOmessaO$meOpos+O)gaO.(OvaUd[.Ug=Ur{0Iche1Bbl>D~Gil#G$LceL{Lsan.Nt&PazzoPil/Ro:99Ad)Al]saAsiE!/O+:C]l D@pp'D~,Dun#Ff~GazzoG'<G$Mar)MingoMoNdag'N l&P#Pi=Pp!(Satu-Schi#S[.Sseg=St!l*TaVvedu 3A,Cepi!Cin Clu+Cond{Cupe)Dd{Dime!Gal#Gist)Go/G!s(Laz'<M&Mo N=Pl~Prime!Put&SaSid[.Spon(S+u)TeTi=Tor~T^f~Voc#3Assun Badi!Bel,B!zzoCar~C]Ceve!C%l#Cor@C!du D>*Dur!Fas&F,s(For`Fug'G&Gett#Ghel*Lass#Lev#Ma<!MbalzoMed'Morch'Nasci+N})NforzoN$_Nom#Nsav{N c]Nunc?Nv[i!Par#Petu Pie$Port&P!saPuli!Sa+Sch'ServaSibi,SoSpe|S )Sult#S_l Tar@Teg$Tm>T)_Un'<VaVer(Vinci+Vol Zo`5BaBot>Bus Cc?CoDagg'De!D{!G{Ll'Mant>Mpe!Nz'Sol&SpoTan.Ton@Tu/Vesc'5BizzoBr~GaLli$Mi<Mo)(O*PeSs&St>:B#Bbi&Bot#Go`Las(Ldatu-Lgem`Liv&Lmo<Lo<Lt&Lu L_Pe!Pi@Por{Race$R}smoR S((Telli.Ti-Tol*Tur$Va=V'Zi#0Adigl'AlzoAnc#Ar-At.!Av&End&Irci&Locc#Occi#Rin&Ruffo<Uff&0Ab)(Ad[zaA/Ambi&Anda*Apo/Ar(A.n&Av#El En>Ett)HedaHie=IarpaI[zaInde!IppoI)ppoI_*Ler&Odel/Olp{Ompar Onfor Opri!Or+Os(<OzzeseRibaRoll&Ru^n'Uder?Ul !Uo/U)Us&0Ebit&Ogan&0C}tu-Con@Da$Gg'/G=l#G!g#Gu{Lci#Let^_L/Lvagg'Mafo)Mbr&MeMin#Mp!N(N^!Pol Qu[zaRa+Rb#Re$R'Rp[.R-gl'Rvi!S^=To/T^`=0Ace*Ald&Am#Arzo(At%#E-IdaIl#IngeOc#Oder&OgoOl^!Orz#Ra|Rutt#Ugg{Um&U(0Abel*Arb#Onfi&Orb'Rass#Uar@1Bi*C]meEr-G/G$!L[z'L/baMbo*Mpat>Mul#Nfon?Ngo*Nist)NoN.siNu(idePar'S`S ,Tu#2It+Ogatu-Ove$0Arr{Emor#En^ E-l@IlzoOnt&Ott#Uss#0Elli!Erv#O@0BbalzoBr'C]r(C?,Da,Ffi|G$Ld#L[<Li@L/zzoLoLubi,Lv[.Mat>M`NdaNe|Nnife)Pi!Ppe(P-Rge!Rpas(Rri(R(R.gg'R_l#Spi)S+T^,0AdaAl/Arge!A /Av[ Azzo/EcieEdi!Eg<!E/tu-E-nzaEs(!Ett-,Ezz#IaIgo*(Ill#I$(I-,L[di@Or^_O(RangaRec&Ron#RuzzoUn^$0Uil*0Ad%&O l#1Abi,Ac]AffaAgn&Amp#Ant'Arnu Ase-Atu E*EppaErzoI,|I`IrpeIva,Izzo(On#Or>RappoReg#Ridu*Rozz&Ru|Ucc&UfoUp[@0B[t)C](Do!Gger{GoL+$On&PerboPpor Rgel#R)g#Ssur)Tu-0Ag&EdeseEgl'El&Enu Ez?IluppoIs+Izze-Ol+Uot&:Bac]Bul#Cci&Citur$LeLis`$Mpo<Nni$RaRdi_Rg#RiffaRp&R+rugaS Tt>Ver=Vo/+Zza3CaCn>Lefo$Me-r'MpoMu N@<Ne)Ns'<N+]*O!`RmeR-zzoRze|SiSser#St#T)T ?3F&Gel/Mb)N P>Pog-foRagg'RoTan'To*Tuban.Z'Zzo<5Cc&L,r&L Mbo/MoNfoNsil/Paz'Po*g?PpaRbaRn&R)<R -S}$Ssi!S+tu-Ta$2Aboc]AcheaAfi/Aged?Alc'Amon Ans{Apa$Ar!As*]Att#AveEcc?Emol'Espo*Ibu Iche]Ifogl'Il*InceaIoIs.zzaItur#Ivel/OmbaO$OppoO|/Ov&Ucc#2Batu-Ff#Lipa$Mul Nis?Rb&Rchi$TaTe/:0Ic#0Cel*Ci(!0I!I^_1FaF%'0Ua,4IsseTim#0A$I,Orismo0Ci<|Ge!Ghe!seI]r$If%#I($I+r'Te0Vo0Upa1Aga$G[zaLo0AnzaA C{Ig$*U-'0Ensi,IlizzoOp?:Can.Ccin#Gabon@Gli#LangaLgoL>L,t+Lo)(Lut&L_/Mpa+Ng&N{(NoN+gg'Nve-Po!Ra$Rc#R?n.S}3Det+DovaDu Ge+,I]*Lc)Li=Llu LoceN#Ndemm?N RaceRba,Rgog=Rif~RoRru}Rt~,Sc~Ssil*S+,Te-$Tri=Tus 3Andan.B-n.C[daChingoCi=nzaDim&Gil?G< Go!LeL/$MiniNc{!O/Pe-Rgo/Ro*goRu,n S](S'<SpoSsu Su-TaTel*T^`VandaVi@Zi&5CeGaLa^,Le!LpeRagi<5L}$::::Mpog=N=Pp#T.-Vor-3Fi)Lan.LoNze)Rbi$3Be|N]R]<T 5L/T>5Cche)Fo*LuPpa";
var checksum5 = "0x5c1362d88fd4cf614a96f3234941d29f7d37c08c5292fde03bf62c2db6ff7620";
var wordlist10 = null;

class LangIt extends WordlistOwl {
  constructor() {
    super("it", words5, checksum5);
  }
  static wordlist() {
    if (wordlist10 == null) {
      wordlist10 = new LangIt;
    }
    return wordlist10;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-pt.js
var words6 = "0arad!ototealirertainrasoent hoandoaR#riareha!aroele'oronul0Aca%AixoAl A%rDuz'El]Er$IsmoO$ R<g(Revi Rig Rup$S*$Solu$Sur=Ut[0Ab#Alm Amp Anh A,Ei.El( En ErvoEss E$naHa.IdezImaI}#Irr Lam LiveOlhidaOmod Opl Ord Um~ Us?0Ap.EgaEnt_Ep$Equ Er-%EsivoEusI<%ItivoJetivoJun$M' Or Qu''UboV(,Vog#0R}ave0As.Er'EtivoIn?Iv` Li$Lu-%R}.0Ach Arr As&/Enci Iliz Io)It#O+R! Res%Rup U d Ul]2O`h Ud Us.1AmedaArmeAstr Av<caB(gueB*oCat+De@EcrimEgr@Er.FaceF*e%GumHeioI Ica%I- Inh Ivi Mof^Oc Pis%T( TitudeUc* Ug UnoUsivoVo0Aci A=rA[loAss BasBi-%EixaEniz I=Is$,Iz!eOl?On$ O_,Ost+P  Pli Pola0Ag+maAlis Arqu@A$m@DaimeElExoG~ Im JoOm&@Ot#Sio,T(i|Uid!eUnci Zol1Ag?Alp Anh#EgoEli=Ert^Es Eti%I$Lau,Lic^OioOn.Os)R-dizRov 0Uec(0AmeAn]A+C^D-%E@Ej Eni$Es)Gilo,GolaMaQuivoRai&Reba%Risc Rob>um S-&T(i&TigoVo[=0F&.Il#P' S?S* So&/Sun$Tr&0Ac#Adu+Al/A[f E End(Er_EuIng'Ir?IvoOl{oRac Revi=RizU&Um0Di$rM-.R>o+TismoT|@Tu 0Ali An%Ar@Ent&Es,I?Is Ul,1Ila1Ar E=Ei%Ulejo:B BosaC&]uCh `C@GagemI<oIl I}e)Ir_Ixis)J~ Le@LizaLsaN&Nd{aN/N'Nque%Ra$Rb#R}es>+c>~/Se#S)n%Ta)Te=rTidaTomTuc Unil]3B(IjoIr^IsebolLd!eLezaLgaLisc Ndi$Ng&aNz(RimbauRl*d>_Sou_XigaZ(_3CoCu=En&Foc&Furc G|naLhe%Mest[Mo$rOlog@OmboOsf(aPol Rr-$Scoi$Sne$SpoSsex$TolaZ _2Ind#OcoOque 2A$BagemC#CejoChec]Ico.L^LetimL]LoMb{oNdeNecoNi)Rb~h>d>e&R+c]V*oXe?2AncoAsaAvezaEuIgaIl/Inc OaOchu+Onze O$Uxo2C]DismoF LeRacoScaS$Z*a:B<aB`oBideBoBri$CauCet^C/r_CiqueDast_De#Fez&IaqueIp'aIxo%J#JuLafrioLc~ Ld{aLibr Lm<%Lo)M^Mbis)MisaMomilaMp<]Mufl Navi&Nc` Ne)NguruN/$Nive%NoaNs#N.Nu=Pac/P`aP* Po.Pric/Pt?PuzRacolRb}oRde&Rec>imb Rn{oRpe%R['>)zRv&/SacoScaSeb[S%loS~oT a)Tiv UleUs?U%l V&oV(na3BolaDil]G}]Lebr L~ Nou+N,N%ioRc Rr#R%'oRvejaTimV^2Aco)Al{aAm#Ap^ArmeAticeAveEfeEg^E'oEqueIco%If[In`oOc&/Ov(UmboU.Uva0CatrizCl}eD!eD['aEn%G<aM-$N$Nz><d>cui$Rurg@T 2A[zaE_Ic OneUbe2A=Ag'Ba@B($rBr C^El/Ent_E,Gum`oIb'IfaIo%L L{aLh(Lid'Lme@L}oLunaM<=Mb* M-.MitivaMov(MplexoMumNc]N=rNec.Nfu,Ng` Nhec(Njug Nsum'Nt+$Nvi%Op( P{oPi?PoQue%lRagemRdi&Rne)R}h>p|&R[ioR%joRuj>voSs-oS%laT}e%U_UveVilZ*]2A%+AvoEcheE=rEmeErEspoI^Im*&Io~oIseItic Os)UaUz{o2B<oEcaId#JoLat+Lm* Lp Ltu+Mpr'Nh#Pi=RativoRr&Rs R$Sp'S% T`o:MascoT 3Ba%rBi.BocheB~h C&queCim&CliveCo%C[.D&Dic#Duz'FesaFum G`oG+uGus.It#Ix La$rLeg#L*e L}gaM<daMit'Moli=Ntis)P-#Pil PoisP[ssaPur Riv>+m SafioSbo.Sc<,S-/Sfi#Sgas%Sigu&SlizeSmam SovaSpesaS)queSvi T&h T-$rT} Tri$UsaV(Vi=Vot#Z-a3Ag+maAle$Da)Fu,Gi.Lat#Lu-%M*u'Nast@Nh{oOceseRe$Sc[)Sf ceSp oSque%Ssip S)n%T?UrnoV(,Vi,rV~g Z(5Br?L|i=M?M*#NativoNz`>m-%Rs&SagemUr#U$r2EnagemIbleOg @2El EndeE$PloQues><%Vi=,:1Lod'O Olog@0Ific It&Uc#1Ei$Etiv 3E.1Ab| Eg(Ei$rEncoEv?Im* Ogi 0B goBol#Br~/Buti=EndaErg'Is,rPat@P-/P*#Polg P[goPurr Ul?0CaixeC-#Ch-%C}t_Deus Doss Faix Fei%FimGaj#G-/Glob Gom#G+x Gu@Jo La.Qu<$Raiz Rol#Rug SaioSe^S*oSop#T<$Te#Tid!eT|.Tr^T~/V(g Vi#Volv(XameX($Xof[Xu$1Id(me0Uip 0E$Gui=Ra)VaVil]0B<j B`$CamaColaCri)Cu)F*geFol F[g Fum#GrimaM&%P<$P`/PigaP}jaP[i)Pum Qu(daTacaT{aTic Tof#T[laTu=Vazi 0AnolIque)0F|i>opeu0Acu Ap| AsivoEntu&Id-%Olu'1Ag(oAl Am* A$Aus$Ces,Ci.Clam Ecu.EmploIb'Ig-%On( P<d'P`'P' Pl< Pos$P[s,P~s T(noT*$T+$:Bric B~o,Ce)Ci&DaDigaIxaL L)Mili Nd<goNf +N$cheRd#R`oR*h>of>p>tu+T@T|V|i)X*aZ-da3Ch#Ijo^I+n%L*oM**oNdaNoR>i#RrugemRv(S%j T&Ud&3ApoB_seC Ch{oGur#L{aL/LmeLtr RmezaSg^Ssu+TaV`aX?Xo2AcidezAm*goAn`aEch^O+Utu Uxo2C&C*/Foc GoGue%IceLg#Lhe$Rj Rmig>noR%ScoSsa2Aga)AldaAngoAscoA%rnoE'aEn%E.IezaI,Itu+On]Ustr U%'a2G'L<oLigemNd NgoNilR?Rio,Tebol:B i$B*e%DoIa$IolaIvo)LegaL/L*]Loc]Nh RagemRfoRg&oRimpoRoup>+faSodu$S$TaTil/Ve)Z`a3L#Le@LoM^M(Mi=N(o,NgivaNi&NomaN_Ologi>?Rm* S,S$r3Nas)Nc<aNg#Raf>*o2Aci&IcoseOb&Orio,2ElaIabaLfeLpe Rdu+Rje)R_S$,T{aV(n 2AcejoAdu&Afi%Al]AmpoAn^Atui$Ave$AxaEgoElh EveIloIs&/I.@Os,O%scoUd#Unhi=U)2AcheA+niAx*imEr[ I Inc/Is#LaLo,Ru:Bi.Rm}@S%V(3C.eRd Res@Si.3A$B(n D+.EnaNoPismoPnosePo%ca5JeLofo%MemNes$Nr#Rm}&Sped 5M|#:Te2E@O,2N|#RejaU<a4E,HaUdi=Um* Ustr 0AgemEd@$En,ErsivoIn-%It?Ort&Pac$Ped'Pl<%P|Pr-saPuneUniz 0Al?Ap$AtivoC-,Ch Cid'Clu'Col|Deci,D'e$Du$rEficazEr-%F<tilFes.F*i$Flam F|m&F+$rG('Ibi=Ici&ImigoJe.Oc-%O=_Ov?OxQuie$Scri$Se$Sist'Spe$rSt& S~$Tac$Tegr&Tim Toc#TrigaVa,rV(noVic$Voc 0Gur%2Ani<oOniz Re&Rit#0CaEn$Ol#Qu{o0Ali<o:N{oNg^N)R ac>dimR_SmimToV&iZida3Jum9An*]Elh^G?I>n&Rr Vem5BaDeuDocaIzLg?L/R#Ris)RoS)::B edaB|&C[C)n%Dril/G )GoaJeMb(M-.M* MpejoNchePid P,R<j>{>gu+S<]St_T(&Ti=V<daVou+Vr?X<%Z(3Ald!eB[G#G-d Gis)IgoIlo Itu+Mb[%MeNh?Ntil]OaSmaS%TivoT['oV VezaVi.3B(&Bi=D( G G{oMi.Mo{oMp?NdaNe N]gemQuidezS)gemSu+T|&V_XaX{a5C?Cu$rJis)MboNaNgeNt+RdeT#T(@Ucu+UsaUv 5ArCidezC_Ne)St[T?Va:CacoCe%Ch#CioD{aDr*]Gna)G[zaI|IsL<d_L]Lo%LucoMiloMo{oMu%N^Nc]Nda$NequimN/,Niv`aNobr NsaN%rNuse Pe#Qu* Rc?Resi>fimRgemR*/Rmi)Ro$RquiseR[coR%loRujoSco%Sm|+SsagemStig Tag&T(noT*&Tu.Xil 3D&]DidaDusaGaf}eIgaL<c@L/rMb_M|i&N*oNosNsagemNt&Rec(Rg~/S^Scl SmoSqui)St[T!eTeo_T+gemX(Xic<o3C_G&]Gr Lag[L- Lh M#N( N/caNist_N|@OloR<%RtiloStur 5Cid!eD(noD~ EdaErIn/I)Ldu+LezaL/L*e%LuscoN)n]Quec><goRcegoR=moR-aSaicoSque%S.daT`TimToTriz5DaI$La)Lh(L.Ndi&Ni=R&h>c/Sc~ SeuSic&:Ci}&D?JaMo_R*>r#Sc(TivaTu[zaV&]Veg Vio3Bl*aB~o,GativaGoci Gri$Rvo,TaUr&VascaVo{o3N N/TidezV` 5B[zaI%IvaMe M*&Rdes%R% T Tici TurnoV`oVil/Vo5Bl#DezM(&Pci&Tr'Vem:0Cec#Edec(JetivoRig#Scu_S%t+T(Tur 0Id-%Io,Orr(Ulis)Up#2Eg<%EnsivaEr-daIc*aUsc#0Iva4Ar@Eo,H Iv{a0B_Ele%Is,It'0D~#E_,Tem1Ci}&Er?On-%OrtunoOs$1ArBi.DemD*&F<a$GasmoG~/I-t&IgemIun=LaTo=xoV&/0Cil S^SoT-.0Imismo0S!@T}oTub_Vi=0El]Ul 1Id Ig- :Ca$Ci-%Co%Ctu D @Dr*/G GodeIn`Ir IsagemLav+Lest+Lhe)Li$Lm^Lpi.Nc^N`aNfle$NquecaN)n&PagaioP`^P'oRaf*>ci&Rd&RedeRtidaSmoSs#S%lTam T-%T* T_noUl^Us 3C~i D& Dest[D@t+D+G^I$r&IxeLeLic<oNcaNdur N{aN]scoNs?N%Rceb(Rfei$Rgun)Ri$Rmit'Rn>plexoRsi<>%nceRucaSc#SquisaS,aTisc 3AdaC#Ed!eGm-$Last+Lh#Lo.M-)Nc`NguimN]No%N.On{oPocaQue%R<h>esRue)Sc S$laT<gaVe%2An)Aque)At*aEbeuUmagemUvi&1Eu0DaE'aEtisaLeg^Lici Lu-%Lvil/M MbaNd( N.@P~o,R)Ssu'St&TeUp U,Vo 2A@Anc]A$AxeEceEd?Efei$Emi Ens Ep  Esil]E%x$Ev-'Ez Ima)IncesaIsmaIv#Oces,Odu$Ofe)Oibi=Oje$Ome%rOpag OsaO%$rOv?2Blic DimL Lm} Ls{aNh&N'PiloRezaX?:99Ad+Ant@Ar$AseEbr EdaEijoEn%Eri=Im}oInaIosque:B<^BiscoCh Ci} Di&I In]IoIvaJ^L#M&Ng(Nhu+P!u+P`PidezPosaQue%Rid!eS<%Scun/Sg Sp?S%'aSur Taz<aTo{a3AlezaAnim Av(Baix B`deBol C#C-%CheioCiboC|d Cru.Cu DeDim'D}daDuzidaEnvioF* Flet'Fog F[scoFugi G&@GimeG+In#I$rJei.LativoM?M-=M|,Nov#P oP`'Ple$Pol/P[saPudi Qu((S-]Sfri Sga.Sid'Solv(Spei$SsacaS)n%Sum'T&/T(T' Tom^T+.V` Vi,rVol)3Ac/CaGidezGo_,M NgueS^ScoS}/5B&oChe=D^DeioDov@E=rLe)M<oNc S#S{aS$TaT{oT*aT~ UcoUpaXo5B_Gi=Go,IvoMoPest[S,:B|Ci ColaCud'DioF'aGaGr^Ib_L^L{oLg#LivaLpic Lsic]L.Lv?Mb Mu+iN Nf}aNgueNid!ePa$Rd>g-$Rje)Tur Ud!eXof}eZ}&3C C~ DaD-$Di#Do,Du$rGm-$G[=Gun=IvaLe$LvagemM<&M-%N?N/rNsu&Nt#P #Rei>*g>+RvoTemb_T|3GiloLhue)Lic}eMetr@Mpat@M~ N&Nc(oNg~ NopseN$ni>-eRiTu#5B(<oB+C|_G_JaLdaLetr L%'oMbrioNa)Nd Neg Nh?NoP+noQue%Rr'R%ioSsegoTaqueT(r V#Z*/5Aviz BidaBm(,B,loBt+'Ca)Ces,CoDes%FixoG?G('Jei$Lfa$M'OrP(i|Plic Pos$Prim'Rd*>fis)Rp[s>[&Rt'Sp'oS%n$:B`aBle%Bu^C/G `aLh(LoLvezM</Mb|imMpaNg-%N$P Pioc>dioRef>j>+xaTuagemUr*oXativoXis)3Atr&C(Ci=Cl#Dio,IaIm Lef}eLh#Mp(oN-%N,rN.Rm&RnoRr-oSeSou+St#ToXtu+Xugo3A+G`aJoloMbr MidezNgi=N%'oRagemT~ 5Al]C]L( LiceM^Mil/N`Ntu+Pe%R>ci=RneioRqueRr!>$S.UcaUp{aX*a2Ab&/Acej Adu$rAfeg Aje$AmaAnc ApoAs{oAt?Av E*oEm(Epid EvoIagemIboIcicloId-%Ilog@Ind!eIploItur Iunf&Oc Ombe)OvaUnfoUque2B~ C<oDoLipaPiRboRm>quesaT` T|i&:7V 3Bigo0HaId!eIf|me3Olog@SoTigaUbu0A=InaUfru':C*aDi G o,I=,LaL-%Lid!eLo[sN)gemQu{oR<d>e)Rr(Sc~ Sil]S,u+Z Zio3A=D Ge.Ic~ L{oLhiceLu=Nce=rNdav&N( Nt[Rb&Rd!eRe?Rg}h>m`/RnizRs R%n%SpaSti=T|i&3Adu$AgemAj Atu+Br?D{aDr @ElaGaG-%Gi G| L ejoNcoNhe)NilOle)R!>tudeSi.S$Tr&V{oZ*/5A=rArG&L<%LeibolL)gemLumo,Nt!e5L$Vuz`a::D[zRope3QueRe.Rife3Ng ::Ng#Rp 3BuL?9Mb Olog@5Mbi=";
var checksum6 = "0x2219000926df7b50d8aa0a3d495826b988287df4657fbd100e6fe596c8f737ac";
var wordlist11 = null;

class LangPt extends WordlistOwl {
  constructor() {
    super("pt", words6, checksum6);
  }
  static wordlist() {
    if (wordlist11 == null) {
      wordlist11 = new LangPt;
    }
    return wordlist11;
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/lang-zh.js
var loadWords3 = function(locale) {
  if (_wordlist3[locale] != null) {
    return _wordlist3[locale];
  }
  const wordlist13 = [];
  let deltaOffset = 0;
  for (let i = 0;i < 2048; i++) {
    const s = style.indexOf(data14[i * 3]);
    const bytes10 = [
      228 + (s >> 2),
      128 + codes2.indexOf(data14[i * 3 + 1]),
      128 + codes2.indexOf(data14[i * 3 + 2])
    ];
    if (locale === "zh_tw") {
      const common4 = s % 4;
      for (let i2 = common4;i2 < 3; i2++) {
        bytes10[i2] = codes2.indexOf(deltaData[deltaOffset++]) + (i2 == 0 ? 228 : 128);
      }
    }
    wordlist13.push(toUtf8String(new Uint8Array(bytes10)));
  }
  const checksum7 = id(wordlist13.join("\n") + "\n");
  if (checksum7 !== Checks[locale]) {
    throw new Error(`BIP39 Wordlist for ${locale} (Chinese) FAILED`);
  }
  _wordlist3[locale] = wordlist13;
  return wordlist13;
};
var data14 = "}aE#4A=Yv&co#4N#6G=cJ&SM#66|/Z#4t&kn~46#4K~4q%b9=IR#7l,mB#7W_X2*dl}Uo~7s}Uf&Iw#9c&cw~6O&H6&wx&IG%v5=IQ~8a&Pv#47$PR&50%Ko&QM&3l#5f,D9#4L|/H&tQ;v0~6n]nN<di,AM=W5%QO&ka&ua,hM^tm=zV=JA=wR&+X]7P&NB#4J#5L|/b[dA}tJ<Do&6m&u2[U1&Kb.HM&mC=w0&MW<rY,Hq#6M}QG,13&wP}Jp]Ow%ue&Kg<HP<D9~4k~9T&I2_c6$9T#9/[C5~7O~4a=cs&O7=KK=An&l9$6U$8A&uD&QI|/Y&bg}Ux&F2#6b}E2&JN&kW&kp=U/&bb=Xl<Cj}k+~5J#6L&5z&9i}b4&Fo,ho(X0_g3~4O$Fz&QE<HN=Ww]6/%GF-Vw=tj&/D&PN#9g=YO}cL&Of&PI~5I&Ip=vU=IW#9G;0o-wU}ss&QR<BT&R9=tk$PY_dh&Pq-yh]7T,nj.Xu=EP&76=cI&Fs*Xg}z7$Gb&+I=DF,AF=cA}rL#7j=Dz&3y<Aa$52=PQ}b0(iY$Fa}oL&xV#6U=ec=WZ,xh%RY<dp#9N&Fl&44=WH*A7=sh&TB&8P=07;u+&PK}uh}J5#72)V/=xC,AB$k0&f6;1E|+5=1B,3v]6n&wR%b+&xx]7f=Ol}fl;+D^wG]7E;nB;uh^Ir&l5=JL,nS=cf=g5;u6|/Q$Gc=MH%Hg#5d%M6^86=U+$Gz,l/,ir^5y&Ba&/F-IY&FI&be%IZ#77&PW_Nu$kE(Yf&NX]7Z,Jy&FJ(Xo&Nz#/d=y7&MX<Ag}Z+;nE]Dt(iG#4D=13&Pj~4c%v8&Zo%OL&/X#4W<HR&ie~6J_1O(Y2=y5=Ad*cv_eB#6k&PX:BU#7A;uk&Ft&Fx_dD=U2;vB=U5=4F}+O&GN.HH:9s=b0%NV(jO&IH=JT}Z9=VZ<Af,Kx^4m&uJ%c6,6r;9m#+L}cf%Kh&F3~4H=vP}bu,Hz|++,1w]nv}k6;uu$jw*Kl*WX&uM[x7&Fr[m7$NO&QN]hu=JN}nR^8g#/h(ps|KC;vd}xz=V0}p6&FD$G1#7K<bG_4p~8g&cf;u4=tl}+k%5/}fz;uw<cA=u1}gU}VM=LJ=eX&+L&Pr#4U}p2:nC,2K]7H:jF&9x}uX#9O=MB<fz~8X~5m&4D&kN&u5%E/(h7(ZF&VG<de(qM|/e-Wt=3x(a+,/R]f/&ND$Ro&nU}0g=KA%kH&NK$Ke<dS}cB&IX~5g$TN]6m=Uv,Is&Py=Ef%Kz#+/%bi&+A<F4$OG&4C&FL#9V<Zk=2I_eE&6c]nw&kq$HG}y+&A8$P3}OH=XP]70%IS(AJ_gH%GZ&tY&AZ=vb~6y&/r=VI=Wv<Zi=fl=xf&eL}c8}OL=MJ=g8$F7=YT}9u=0+^xC}JH&nL^N0~4T]K2,Cy%OC#6s;vG(AC^xe^cG&MF}Br#9P;wD-7h$O/&xA}Fn^PC]6i]7G&8V$Qs;vl(TB~73~4l<mW&6V=2y&uY&+3)aP}XF;LP&kx$wU=t7;uy<FN&lz)7E=Oo*Y+;wI}9q}le;J6&Ri&4t&Qr#8B=cb&vG=J5|Ql(h5<Yy~4+}QD,Lx=wn%K/&RK=dO&Pw,Q9=co%4u;9u}g0@6a^4I%b0=zo|/c&tX=dQ=OS#+b=yz_AB&wB&Pm=W9$HP_gR=62=AO=ti=hI,oA&jr&dH=tm&b6$P2(x8=zi;nG~7F;05]0n[Ix&3m}rg=Xp=cd&uz]7t;97=cN;vV<jf&FF&F1=6Q&Ik*Kk&P4,2z=fQ]7D&3u,H0=d/}Uw<ZN<7R}Kv;0f$H7,MD]7n$F0#88~9Z%da=by;+T#/u=VF&fO&kr^kf<AB]sU,I5$Ng&Pz;0i&QD&vM=Yl:BM;nJ_xJ]U7&Kf&30,3f|Z9*dC)je_jA&Q4&Kp$NH(Yz#6S&Id%Ib=KX,AD=KV%dP}tW&Pk^+E_Ni=cq,3R}VZ(Si=b+}rv;0j}rZ]uA,/w(Sx&Jv$w9&4d&wE,NJ$Gy=J/]Ls#7k<ZQ<Y/&uj]Ov$PM;v3,2F&+u:up=On&3e,Jv;90=J+&Qm]6q}bK#+d~8Y(h2]hA;99&AS=I/}qB&dQ}yJ-VM}Vl&ui,iB&G3|Dc]7d=eQ%dX%JC_1L~4d^NP;vJ&/1)ZI#7N]9X[bQ&PL=0L(UZ,Lm&kc&IR}n7(iR<AQ<dg=33=vN}ft}au]7I,Ba=x9=dR~6R&Tq=Xi,3d$Nr&Bc}DI&ku&vf]Dn,/F&iD,Ll&Nw=0y&I7=Ls=/A&tU=Qe}Ua&uk&+F=g4=gh=Vj#+1&Qn}Uy*44#5F,Pc&Rz*Xn=oh=5W;0n_Nf(iE<Y7=vr=Zu]oz#5Z%mI=kN=Bv_Jp(T2;vt_Ml<FS&uI=L/&6P]64$M7}86<bo%QX(SI%IY&VK=Al&Ux;vv;ut*E/%uh<ZE|O3,M2(yc]yu=Wk&tp:Ex}hr,Cl&WE)+Z=8U}I2_4Q,hA_si=iw=OM=tM=yZ%Ia=U7;wT}b+;uo=Za}yS!5x}HD}fb#5O_dA;Nv%uB(yB;01(Sf}Fk;v7}Pt#8v<mZ#7L,/r&Pl~4w&f5=Ph$Fw_LF&8m,bL=yJ&BH}p/*Jn}tU~5Q;wB(h6]Df]8p^+B;E4&Wc=d+;Ea&bw$8C&FN,DM=Yf}mP~5w=fT#6V=mC=Fi=AV}jB&AN}lW}aH#/D)dZ;hl;vE}/7,CJ;31&w8,hj%u9_Js=jJ&4M~8k=TN&eC}nL&uc-wi&lX}dj=Mv=e2#6u=cr$uq$6G]8W}Jb:nm=Yg<b3(UA;vX&6n&xF=KT,jC,De&R8&oY=Zv&oB]7/=Z2&Oa}bf,hh(4h^tZ&72&Nx;D2&xL~5h~40)ZG)h+=OJ&RA]Bv$yB=Oq=df,AQ%Jn}OJ;11,3z&Tl&tj;v+^Hv,Dh(id=s+]7N&N3)9Q~8f,S4=uW=w4&uX,LX&3d]CJ&yp&8x<b2_do&lP=y/<cy_dG=Oi=7R(VH(lt_1T,Iq_AA;12^6T%k6#8K[B1{oO<AU[Bt;1b$9S&Ps<8T=St{bY,jB(Zp&63&Uv$9V,PM]6v&Af}zW[bW_oq}sm}nB&Kq&gC&ff_eq_2m&5F&TI}rf}Gf;Zr_z9;ER&jk}iz_sn<BN~+n&vo=Vi%97|ZR=Wc,WE&6t]6z%85(ly#84=KY)6m_5/=aX,N3}Tm&he&6K]tR_B2-I3;u/&hU&lH<AP=iB&IA=XL;/5&Nh=wv<BH#79=vS=zl<AA=0X_RG}Bw&9p$NW,AX&kP_Lp&/Z(Tc]Mu}hs#6I}5B&cI<bq&H9#6m=K9}vH(Y1(Y0#4B&w6,/9&gG<bE,/O=zb}I4_l8<B/;wL%Qo<HO[Mq=XX}0v&BP&F4(mG}0i}nm,EC=9u{I3,xG&/9=JY*DK&hR)BX=EI=cx=b/{6k}yX%A+&wa}Xb=la;wi^lL;0t}jo&Qb=xg=XB}iO<qo{bR=NV&8f=a0&Jy;0v=uK)HK;vN#6h&jB(h/%ud&NI%wY.X7=Pt}Cu-uL&Gs_hl%mH,tm]78=Lb^Q0#7Y=1u<Bt&+Q=Co_RH,w3;1e}ux<aU;ui}U3&Q5%bt]63&UQ|0l&uL}O7&3o,AV&dm|Nj(Xt*5+(Uu&Hh(p7(UF=VR=Bp^Jl&Hd[ix)9/=Iq]C8<67]66}mB%6f}bb}JI]8T$HA}db=YM&pa=2J}tS&Y0=PS&y4=cX$6E,hX,XP&nR;04,FQ&l0&Vm_Dv#5Y~8Z=Bi%MA]6x=JO:+p,Az&9q,Hj~6/}SD=K1:EJ}nA;Qo#/E]9R,Ie&6X%W3]61&v4=xX_MC=0q;06(Xq=fs}IG}Dv=0l}o7$iZ;9v&LH&DP-7a&OY,SZ,Kz,Cv&dh=fx|Nh,F/~7q=XF&w+;9n&Gw;0h}Z7<7O&JK(S7&LS<AD<ac=wo<Dt&zw%4B=4v#8P;9o~6p*vV=Tm,Or&I6=1q}nY=P0=gq&Bl&Uu,Ch%yb}UY=zh}dh}rl(T4_xk(YA#8R*xH,IN}Jn]7V}C4&Ty}j3]7p=cL=3h&wW%Qv<Z3=f0&RI&+S(ic_zq}oN&/Y=z1;Td=LW=0e=OI(Vc,+b^ju(UL;0r:Za%8v=Rp=zw&58&73&wK}qX]6y&8E)a2}WR=wP^ur&nQ<cH}Re=Aq&wk}Q0&+q=PP,Gc|/d^k5,Fw]8Y}Pg]p3=ju=ed}r5_yf&Cs]7z$/G<Cm&Jp&54_1G_gP_Ll}JZ;0u]k8_7k(Sg]65{9i=LN&Sx&WK,iW&fD&Lk{9a}Em-9c#8N&io=sy]8d&nT&IK(lx#7/$lW(Td<s8~49,3o<7Y=MW(T+_Jr&Wd,iL}Ct=xh&5V;v4&8n%Kx=iF&l2_0B{B+,If(J0,Lv;u8=Kx-vB=HC&vS=Z6&fU&vE^xK;3D=4h=MR#45:Jw;0d}iw=LU}I5=I0]gB*im,K9}GU,1k_4U&Tt=Vs(iX&lU(TF#7y,ZO}oA&m5#5P}PN}Uz=hM<B1&FB<aG,e6~7T<tP(UQ_ZT=wu&F8)aQ]iN,1r_Lo&/g:CD}84{J1_Ki&Na&3n$jz&FE=dc;uv;va}in}ll=fv(h1&3h}fp=Cy}BM(+E~8m}lo%v7=hC(T6$cj=BQ=Bw(DR,2j=Ks,NS|F+;00=fU=70}Mb(YU;+G&m7&hr=Sk%Co]t+(X5_Jw}0r}gC(AS-IP&QK<Z2#8Q$WC]WX}T2&pG_Ka,HC=R4&/N;Z+;ch(C7,D4$3p_Mk&B2$8D=n9%Ky#5z(CT&QJ#7B]DC]gW}nf~5M;Iw#80}Tc_1F#4Z-aC}Hl=ph=fz,/3=aW}JM}nn;DG;vm}wn,4P}T3;wx&RG$u+}zK=0b;+J_Ek{re<aZ=AS}yY#5D]7q,Cp}xN=VP*2C}GZ}aG~+m_Cs=OY#6r]6g<GS}LC(UB=3A=Bo}Jy<c4}Is;1P<AG}Op<Z1}ld}nS=1Z,yM&95&98=CJ(4t:2L$Hk=Zo}Vc;+I}np&N1}9y=iv}CO*7p=jL)px]tb^zh&GS&Vl%v/;vR=14=zJ&49|/f]hF}WG;03=8P}o/&Gg&rp;DB,Kv}Ji&Pb;aA^ll(4j%yt}+K$Ht#4y&hY]7Y<F1,eN}bG(Uh%6Z]t5%G7;+F_RE;it}tL=LS&Da=Xx(S+(4f=8G=yI}cJ}WP=37=jS}pX}hd)fp<A8=Jt~+o$HJ=M6}iX=g9}CS=dv=Cj(mP%Kd,xq|+9&LD(4/=Xm&QP=Lc}LX&fL;+K=Op(lu=Qs.qC:+e&L+=Jj#8w;SL]7S(b+#4I=c1&nG_Lf&uH;+R)ZV<bV%B/,TE&0H&Jq&Ah%OF&Ss(p2,Wv&I3=Wl}Vq;1L&lJ#9b_1H=8r=b8=JH(SZ=hD=J2#7U,/U#/X~6P,FU<eL=jx,mG=hG=CE&PU=Se(qX&LY=X6=y4&tk&QQ&tf=4g&xI}W+&mZ=Dc#7w}Lg;DA;wQ_Kb(cJ=hR%yX&Yb,hw{bX_4X;EP;1W_2M}Uc=b5(YF,CM&Tp^OJ{DD]6s=vF=Yo~8q}XH}Fu%P5(SJ=Qt;MO]s8<F3&B3&8T(Ul-BS*dw&dR<87}/8]62$PZ]Lx<Au}9Q]7c=ja=KR,Go,Us&v6(qk}pG&G2=ev^GM%w4&H4]7F&dv]J6}Ew:9w=sj-ZL}Ym$+h(Ut(Um~4n=Xs(U7%eE=Qc_JR<CA#6t<Fv|/I,IS,EG<F2(Xy$/n<Fa(h9}+9_2o&N4#7X<Zq|+f_Dp=dt&na,Ca=NJ)jY=8C=YG=s6&Q+<DO}D3=xB&R1(lw;Qn<bF(Cu|/B}HV=SS&n7,10&u0]Dm%A6^4Q=WR(TD=Xo<GH,Rj(l8)bP&n/=LM&CF,F5&ml=PJ;0k=LG=tq,Rh,D6@4i=1p&+9=YC%er_Mh;nI;0q=Fw]80=xq=FM$Gv;v6&nc;wK%H2&Kj;vs,AA=YP,66}bI(qR~5U=6q~4b$Ni=K5.X3$So&Iu(p+]8G=Cf=RY(TS_O3(iH&57=fE=Dg_Do#9z#7H;FK{qd_2k%JR}en&gh_z8;Rx}9p<cN_Ne,DO;LN_7o~/p=NF=5Y}gN<ce<C1,QE]Wv=3u<BC}GK]yq}DY&u/_hj=II(pz&rC,jV&+Z}ut=NQ;Cg-SR_ZS,+o=u/;Oy_RK_QF(Fx&xP}Wr&TA,Uh&g1=yr{ax[VF$Pg(YB;Ox=Vy;+W(Sp}XV%dd&33(l/]l4#4Y}OE=6c=bw(A7&9t%wd&N/&mo,JH&Qe)fm=Ao}fu=tH";
var deltaData = "FAZDC6BALcLZCA+GBARCW8wNCcDDZ8LVFBOqqDUiou+M42TFAyERXFb7EjhP+vmBFpFrUpfDV2F7eB+eCltCHJFWLFCED+pWTojEIHFXc3aFn4F68zqjEuKidS1QBVPDEhE7NA4mhMF7oThD49ot3FgtzHFCK0acW1x8DH1EmLoIlrWFBLE+y5+NA3Cx65wJHTaEZVaK1mWAmPGxgYCdxwOjTDIt/faOEhTl1vqNsKtJCOhJWuio2g07KLZEQsFBUpNtwEByBgxFslFheFbiEPvi61msDvApxCzB6rBCzox7joYA5UdDc+Cb4FSgIabpXFAj3bjkmFAxCZE+mD/SFf/0ELecYCt3nLoxC6WEZf2tKDB4oZvrEmqFkKk7BwILA7gtYBpsTq//D4jD0F0wEB9pyQ1BD5Ba0oYHDI+sbDFhvrHXdDHfgFEIJLi5r8qercNFBgFLC4bo5ERJtamWBDFy73KCEb6M8VpmEt330ygCTK58EIIFkYgF84gtGA9Uyh3m68iVrFbWFbcbqiCYHZ9J1jeRPbL8yswhMiDbhEhdNoSwFbZrLT740ABEqgCkO8J1BLd1VhKKR4sD1yUo0z+FF59Mvg71CFbyEhbHSFBKEIKyoQNgQppq9T0KAqePu0ZFGrXOHdKJqkoTFhYvpDNyuuznrN84thJbsCoO6Cu6Xlvntvy0QYuAExQEYtTUBf3CoCqwgGFZ4u1HJFzDVwEy3cjcpV4QvsPaBC3rCGyCF23o4K3pp2gberGgFEJEHo4nHICtyKH2ZqyxhN05KBBJIQlKh/Oujv/DH32VrlqFdIFC7Fz9Ct4kaqFME0UETLprnN9kfy+kFmtQBB0+5CFu0N9Ij8l/VvJDh2oq3hT6EzjTHKFN7ZjZwoTsAZ4Exsko6Fpa6WC+sduz8jyrLpegTv2h1EBeYpLpm2czQW0KoCcS0bCVXCmuWJDBjN1nQNLdF58SFJ0h7i3pC3oEOKy/FjBklL70XvBEEIWp2yZ04xObzAWDDJG7f+DbqBEA7LyiR95j7MDVdDViz2RE5vWlBMv5e4+VfhP3aXNPhvLSynb9O2x4uFBV+3jqu6d5pCG28/sETByvmu/+IJ0L3wb4rj9DNOLBF6XPIODr4L19U9RRofAG6Nxydi8Bki8BhGJbBAJKzbJxkZSlF9Q2Cu8oKqggB9hBArwLLqEBWEtFowy8XK8bEyw9snT+BeyFk1ZCSrdmgfEwFePTgCjELBEnIbjaDDPJm36rG9pztcEzT8dGk23SBhXBB1H4z+OWze0ooFzz8pDBYFvp9j9tvFByf9y4EFdVnz026CGR5qMr7fxMHN8UUdlyJAzlTBDRC28k+L4FB8078ljyD91tUj1ocnTs8vdEf7znbzm+GIjEZnoZE5rnLL700Xc7yHfz05nWxy03vBB9YGHYOWxgMQGBCR24CVYNE1hpfKxN0zKnfJDmmMgMmBWqNbjfSyFCBWSCGCgR8yFXiHyEj+VtD1FB3FpC1zI0kFbzifiKTLm9yq5zFmur+q8FHqjoOBWsBPiDbnCC2ErunV6cJ6TygXFYHYp7MKN9RUlSIS8/xBAGYLzeqUnBF4QbsTuUkUqGs6CaiDWKWjQK9EJkjpkTmNCPYXL";
var _wordlist3 = {
  zh_cn: null,
  zh_tw: null
};
var Checks = {
  zh_cn: "0x17bcc4d8547e5a7135e365d1ab443aaae95e76d8230c2782c67305d4f21497a1",
  zh_tw: "0x51e720e90c7b87bec1d70eb6e74a21a449bd3ec9c020b01d3a40ed991b60ce5d"
};
var codes2 = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
var style = "~!@#$%^&*_-=[]{}|;:,.()<>?";
var wordlists = {};

class LangZh extends Wordlist {
  constructor(dialect) {
    super("zh_" + dialect);
  }
  getWord(index) {
    const words7 = loadWords3(this.locale);
    assertArgument(index >= 0 && index < words7.length, `invalid word index: ${index}`, "index", index);
    return words7[index];
  }
  getWordIndex(word) {
    return loadWords3(this.locale).indexOf(word);
  }
  split(phrase) {
    phrase = phrase.replace(/(?:\u3000| )+/g, "");
    return phrase.split("");
  }
  static wordlist(dialect) {
    if (wordlists[dialect] == null) {
      wordlists[dialect] = new LangZh(dialect);
    }
    return wordlists[dialect];
  }
}

// ../../node_modules/ethers/lib.esm/wordlists/wordlists.js
var wordlists2 = {
  cz: LangCz.wordlist(),
  en: LangEn.wordlist(),
  es: LangEs.wordlist(),
  fr: LangFr.wordlist(),
  it: LangIt.wordlist(),
  pt: LangPt.wordlist(),
  ja: LangJa.wordlist(),
  ko: LangKo.wordlist(),
  zh_cn: LangZh.wordlist("cn"),
  zh_tw: LangZh.wordlist("tw")
};
// packages/compound-v2-liquidator/src/web3/web3.service.ts
class Web3Service extends Service {
  web3;
  websocketProvider;
  constructor(rpcUrl) {
    super();
    if (rpcUrl.startsWith("http")) {
      this.web3 = new web3_default(rpcUrl);
    } else {
      this.websocketProvider = new web3_default.providers.WebsocketProvider(rpcUrl);
      this.web3 = new web3_default(this.websocketProvider);
    }
  }
  async init() {
  }
  async getTransaction(txHash) {
    console.debug("method -> web3Service.getTransaction");
    const method = this.web3.eth.getTransaction.bind(this.web3.eth);
    const transaction13 = await addRetries(method, txHash);
    return transaction13;
  }
  async callContractMethod({
    abi: abi7,
    address: address28,
    args = [],
    params = {},
    blockNumber
  }) {
    const contract7 = new this.web3.eth.Contract([abi7], address28);
    const method = contract7.methods[abi7.name](...args).call;
    const data15 = await addRetries.call(this, method, params, blockNumber);
    return data15;
  }
  async executeContractMethod({
    abi: abi7,
    address: address28,
    args = [],
    from = "",
    privateKey = "",
    blockNumber = "latest"
  }) {
    const contract7 = new this.web3.eth.Contract([abi7], address28);
    const data15 = contract7.methods[abi7.name](...args).encodeABI();
    const transaction13 = {
      from,
      to: address28,
      gas: "100000",
      maxPriorityFeePerGas: this.web3.utils.toWei("2", "gwei"),
      maxFeePerGas: this.web3.utils.toWei("100", "gwei"),
      data: data15
    };
    const signedTransaction = await this.web3.eth.accounts.signTransaction(transaction13, privateKey);
    return this.sendRawTransaction(signedTransaction.rawTransaction);
  }
  async sendRawTransaction(rawTx) {
    return this.web3.eth.sendSignedTransaction(rawTx);
  }
  async getFilteredLogsByPieces(addresses, abi7, eventNames, fromBlock, toBlock) {
    const promises = [];
    for (let i = 0;i < eventNames.length; i += 3) {
      const _eventNames = eventNames.slice(i, i + 3);
      const _abi = filterAbi(abi7, _eventNames);
      promises.push(this.getFilteredLogs(addresses, _abi, fromBlock, toBlock));
    }
    return (await Promise.all(promises)).flat();
  }
  async getFlashbotsSignature(body) {
    console.log("method -> web3Service.getFlashbotsSignature");
    const wallet2 = new Wallet2(env_default.PRIVATE_KEY);
    const signature2 = wallet2.address + ":" + await wallet2.signMessage(exports_ethers.id(body));
    return signature2;
  }
  async getFilteredLogs(address28, abi7, fromBlock = "earliest", toBlock = "latest") {
    const topics = this.getSignatureHashes(abi7);
    const filter3 = {
      fromBlock,
      toBlock,
      address: address28,
      topics: [topics]
    };
    const method = this.web3.eth.getPastLogs.bind(this.web3.eth);
    const logs = await addRetries(method, filter3);
    return logs;
  }
  decodeLogs(logs, abi7) {
    const eventSignatureHashes = this.getSignatureHashes(abi7);
    const decodedLogs = logs.map((log) => {
      const abiItemIndex = eventSignatureHashes.findIndex((signature2) => signature2 === log.topics[0]);
      const abiItem = abi7[abiItemIndex];
      const decodedLog = this.web3.eth.abi.decodeLog(abiItem.inputs, log.data, log.topics.slice(1));
      Object.assign(decodedLog, {
        address: web3_default.utils.toChecksumAddress(log.address),
        eventName: abiItem.name,
        blockNumber: Number(log.blockNumber),
        transactionIndex: Number(log.transactionIndex),
        logIndex: Number(log.logIndex)
      });
      return decodedLog;
    });
    return decodedLogs;
  }
  getSignatureHashes(abi7) {
    return abi7.map((item) => this.web3.utils.sha3(item.name + "(" + item.inputs.map((input) => input.type).join(",") + ")"));
  }
  getSignature(abiItem) {
    const signatureHash = this.getSignatureHashes([abiItem])[0];
    if (!signatureHash)
      throw new Error("No signature hash");
    return signatureHash.slice(0, 10);
  }
  async getNetworkHeight() {
    console.debug("method -> web3Service.getNetworkHeight");
    const fn = this.web3.eth.getBlockNumber.bind(this.web3.eth);
    const result = await addRetries(fn);
    return Number(result);
  }
  decodeArguments(abiItem, txInput) {
    const decodedArguments = this.web3.eth.abi.decodeParameters(abiItem.inputs, txInput.slice(10));
    return decodedArguments;
  }
  decodeParameters(typesArray, reportData) {
    const decodedData = this.web3.eth.abi.decodeParameters(typesArray, reportData);
    return decodedData;
  }
  async createAndSignTx({
    abi: abi7,
    address: address28,
    args,
    gas,
    maxFeePerGas
  }) {
    const contract7 = new this.web3.eth.Contract([abi7], address28);
    const data15 = contract7.methods[abi7.name](...args).encodeABI();
    const transaction13 = {
      from: env_default.FROM_ADDRESS,
      to: address28,
      gas,
      maxFeePerGas,
      maxPriorityFeePerGas: this.web3.utils.toWei("0.01", "gwei"),
      value: 0n,
      data: data15
    };
    const signedTransaction = await this.web3.eth.accounts.signTransaction(transaction13, env_default.PRIVATE_KEY);
    return signedTransaction;
  }
  async createRawTestTx() {
    const transaction13 = {
      from: env_default.FROM_ADDRESS,
      to: env_default.LIQUIDATOR_CONTRACT_ADDRESS,
      gas: "22000",
      maxFeePerGas: this.web3.utils.toWei("100", "gwei"),
      maxPriorityFeePerGas: this.web3.utils.toWei("10", "gwei"),
      value: 0n
    };
    const signedTransaction = await this.web3.eth.accounts.signTransaction(transaction13, env_default.PRIVATE_KEY);
    return signedTransaction.rawTransaction;
  }
  async getNonce(address28) {
    return this.web3.eth.getTransactionCount(env_default.FROM_ADDRESS);
  }
  clearSubAndDisconnect() {
    if (this.websocketProvider) {
      this.web3?.subscriptionManager.clear();
      this.websocketProvider.removeAllListeners("connect");
      this.websocketProvider.removeAllListeners("error");
      this.websocketProvider.removeAllListeners("end");
      this.websocketProvider.disconnect();
      console.log("subscription is cleared and socket is closed");
    }
  }
  async getNetworkBaseFee() {
    const block4 = await this.web3.eth.getBlock("latest");
    return this.web3.utils.fromWei(block4.baseFeePerGas, "gwei");
  }
  async getNetworkGasPrice() {
    const gasPrice = await this.web3.eth.getGasPrice();
    return this.web3.utils.fromWei(gasPrice, "gwei");
  }
}

// packages/compound-v2-liquidator/src/web3/web3.module.ts
class Web3Module extends Module {
  constructor(rpcUrl) {
    super();
    const service3 = new Web3Service(rpcUrl);
    this.registerService("web3Service", service3);
  }
}
// packages/compound-v2-liquidator/artifacts/network/CTokens.json
var CTokens_default = {
  cAAVE: {
    address: "0xe65cdb6479bac1e22340e4e755fae7e509ecd06c",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound Aave Token",
    symbol: "cAAVE",
    underlying: "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9"
  },
  cSUSHI: {
    address: "0x4b0181102a0112a2ef11abee5563bb4a3176c9d7",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound Sushi Token",
    symbol: "cSUSHI",
    underlying: "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2"
  },
  cYFI: {
    address: "0x80a2ae356fc9ef4305676f7a3e2ed04e12c33946",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound yearn.finance",
    symbol: "cYFI",
    underlying: "0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e"
  },
  cTUSD: {
    address: "0x12392f67bdf24fae0af363c24ac620a2f67dad86",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound TrueUSD",
    symbol: "cTUSD",
    underlying: "0x0000000000085d4780b73119b644ae5ecd22b376"
  },
  cLINK: {
    address: "0xface851a4921ce59e912d19329929ce6da6eb0c7",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound ChainLink Token",
    symbol: "cLINK",
    underlying: "0x514910771af9ca656af840dff83e8264ecf986ca"
  },
  cWBTC2: {
    address: "0xccF4429DB6322D5C611ee964527D42E5d685DD6a",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound Wrapped BTC",
    symbol: "cWBTC2",
    underlying: "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599"
  },
  cCOMP: {
    address: "0x70e36f6bf80a52b3b46b3af8e106cc0ed743e8e4",
    contract: "CErc20Delegator",
    decimals: 8,
    initial_exchange_rate_mantissa: "20000000000000000",
    name: "Compound Collateral",
    symbol: "cCOMP",
    underlying: "0xc00e94cb662c3520282e6f5717214004a7f26888"
  },
  cUSDC: {
    name: "Compound USD Coin",
    symbol: "cUSDC",
    decimals: 8,
    underlying: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    contract: "CErc20",
    initial_exchange_rate_mantissa: "200000000000000",
    address: "0x39AA39c021dfbaE8faC545936693aC917d5E7563"
  },
  cDAI: {
    name: "Compound Dai",
    symbol: "cDAI",
    decimals: 8,
    underlying: "0x6B175474E89094C44Da98b954EedeAC495271d0F",
    contract: "CErc20Delegator",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    admin: "0x6d903f6003cca6255D85CcA4D3B5E5146dC33925",
    address: "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643"
  },
  cUSDT: {
    name: "Compound USDT",
    symbol: "cUSDT",
    decimals: 8,
    underlying: "0xdAC17F958D2ee523a2206206994597C13D831ec7",
    contract: "CErc20Delegator",
    initial_exchange_rate_mantissa: "200000000000000",
    admin: "0x6d903f6003cca6255D85CcA4D3B5E5146dC33925",
    address: "0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9"
  },
  cBAT: {
    name: "Compound Basic Attention Token",
    symbol: "cBAT",
    decimals: 8,
    underlying: "0x0D8775F648430679A709E98d2b0Cb6250d2887EF",
    contract: "CErc20",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E"
  },
  cETH: {
    name: "Compound Ether",
    symbol: "cETH",
    decimals: 8,
    underlying: "0x0000000000000000000000000000000000000000",
    contract: "CEther",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5"
  },
  cSAI: {
    name: "Compound Sai",
    symbol: "cSAI",
    decimals: 8,
    underlying: "0x89d24A6b4CcB1B6fAA2625fE562bDD9a23260359",
    contract: "CErc20",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0xF5DCe57282A584D2746FaF1593d3121Fcac444dC"
  },
  cREP: {
    name: "Compound Augur",
    symbol: "cREP",
    decimals: 8,
    underlying: "0x1985365e9f78359a9B6AD760e32412f4a445E862",
    contract: "CErc20",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1"
  },
  cZRX: {
    name: "Compound 0x",
    symbol: "cZRX",
    decimals: 8,
    underlying: "0xE41d2489571d322189246DaFA5ebDe1F4699F498",
    contract: "CErc20",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407"
  },
  cWBTC: {
    name: "Compound Wrapped BTC",
    symbol: "cWBTC",
    decimals: 8,
    underlying: "0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599",
    contract: "CErc20",
    initial_exchange_rate_mantissa: "20000000000000000",
    address: "0xC11b1268C1A384e55C48c2391d8d480264A3A7F4"
  },
  cUNI: {
    name: "Compound Uniswap",
    symbol: "cUNI",
    decimals: 8,
    underlying: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
    contract: "CErc20Delegator",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0x35a18000230da775cac24873d00ff85bccded550"
  },
  cMKR: {
    name: "Compound Maker",
    symbol: "cMKR",
    decimals: 8,
    underlying: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2",
    contract: "CErc20Delegator",
    initial_exchange_rate_mantissa: "200000000000000000000000000",
    address: "0x95b4eF2869eBD94BEb4eEE400a99824BF5DC325b"
  }
};
// packages/compound-v2-liquidator/artifacts/network/Tokens.json
var Tokens_default = {
  AAVE: {
    address: "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
    contract: "Aave Token",
    decimals: 18,
    name: "Aave Token",
    symbol: "AAVE"
  },
  SUSHI: {
    address: "0x6b3595068778dd592e39a122f4f5a5cf09c90fe2",
    contract: "SushiToken",
    decimals: 18,
    name: "SushiToken",
    symbol: "SUSHI"
  },
  YFI: {
    address: "0x0bc529c00c6401aef6d220be8c6ea1667f6ad93e",
    contract: "yearn.finance",
    decimals: 18,
    name: "yearn.finance",
    symbol: "YFI"
  },
  ETH: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18,
    address: "0x0000000000000000000000000000000000000000"
  },
  ZRX: {
    name: "0x",
    symbol: "ZRX",
    decimals: 18,
    address: "0xE41d2489571d322189246DaFA5ebDe1F4699F498"
  },
  DAI: {
    description: "Existing",
    decimals: 18,
    name: "DAI",
    symbol: "DAI",
    contract: "ExistingToken",
    address: "0x6B175474E89094C44Da98b954EedeAC495271d0F"
  },
  USDT: {
    description: "ExistingTether",
    name: "USDT",
    symbol: "USDT",
    contract: "TetherInterface",
    decimals: 6,
    address: "0xdAC17F958D2ee523a2206206994597C13D831ec7"
  },
  COMP: {
    contract: "Comp",
    symbol: "COMP",
    name: "Compound Governance Token",
    decimals: 18,
    address: "0xc00e94Cb662C3520282E6f5717214004A7f26888"
  },
  BAT: {
    name: "Basic Attention Token",
    symbol: "BAT",
    decimals: 18,
    address: "0x0D8775F648430679A709E98d2b0Cb6250d2887EF"
  },
  WBTC: {
    name: "Wrapped BTC",
    symbol: "WBTC",
    decimals: 8,
    address: "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599"
  },
  SAI: {
    name: "Sai (Legacy Dai)",
    symbol: "SAI",
    decimals: 18,
    address: "0x89d24a6b4ccb1b6faa2625fe562bdd9a23260359",
    reader: "0x729D19f657BD0614b4985Cf1D82531c67569197B",
    oracle_key: "0x0000000000000000000000000000000000000002"
  },
  REP: {
    name: "Augur",
    symbol: "REP",
    decimals: 18,
    address: "0x1985365e9f78359a9B6AD760e32412f4a445E862"
  },
  USDC: {
    name: "USD Coin",
    symbol: "USDC",
    decimals: 6,
    address: "0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48",
    oracle_key: "0x0000000000000000000000000000000000000001"
  },
  KNC: {
    name: "Kyber Network Crystal",
    symbol: "KNC",
    decimals: 18,
    address: "0xdd974d5c2e2928dea5f71b9825b8b646686bd200",
    contract: "KyberNetworkCrystal"
  },
  LINK: {
    name: "ChainLink Token",
    symbol: "LINK",
    decimals: 18,
    address: "0x514910771af9ca656af840dff83e8264ecf986ca",
    contract: "LinkToken"
  },
  UNI: {
    name: "Uniswap",
    symbol: "UNI",
    decimals: 18,
    address: "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984",
    contract: "Uniswap"
  },
  TUSD: {
    name: "TrueUSD",
    symbol: "TUSD",
    decimals: 18,
    address: "0x0000000000085d4780B73119b644AE5ecd22b376",
    contract: "TrueUSD"
  },
  MKR: {
    name: "Maker",
    symbol: "MKR",
    decimals: 18,
    address: "0x9f8F72aA9304c8B593d555F12eF6589cC3A579A2",
    contract: "Maker"
  }
};
// common/compound-protocol/artifacts/Comptroller.sol/Comptroller.json
var Comptroller_default = {
  _format: "hh-sol-artifact-1",
  contractName: "Comptroller",
  sourceName: "contracts/Comptroller.sol",
  abi: [
    {
      inputs: [],
      stateMutability: "nonpayable",
      type: "constructor"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "string",
          name: "action",
          type: "string"
        },
        {
          indexed: false,
          internalType: "bool",
          name: "pauseState",
          type: "bool"
        }
      ],
      name: "ActionPaused",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "string",
          name: "action",
          type: "string"
        },
        {
          indexed: false,
          internalType: "bool",
          name: "pauseState",
          type: "bool"
        }
      ],
      name: "ActionPaused",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "user",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "oldCompAccrued",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newCompAccrued",
          type: "uint256"
        }
      ],
      name: "CompAccruedAdjusted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newSpeed",
          type: "uint256"
        }
      ],
      name: "CompBorrowSpeedUpdated",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "recipient",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "CompGranted",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "user",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "oldCompReceivable",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newCompReceivable",
          type: "uint256"
        }
      ],
      name: "CompReceivableUpdated",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newSpeed",
          type: "uint256"
        }
      ],
      name: "CompSupplySpeedUpdated",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "contributor",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newSpeed",
          type: "uint256"
        }
      ],
      name: "ContributorCompSpeedUpdated",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "compDelta",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "compBorrowIndex",
          type: "uint256"
        }
      ],
      name: "DistributedBorrowerComp",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "supplier",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "compDelta",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "compSupplyIndex",
          type: "uint256"
        }
      ],
      name: "DistributedSupplierComp",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "error",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "info",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "detail",
          type: "uint256"
        }
      ],
      name: "Failure",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "MarketEntered",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "MarketExited",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        }
      ],
      name: "MarketListed",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newBorrowCap",
          type: "uint256"
        }
      ],
      name: "NewBorrowCap",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "oldBorrowCapGuardian",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newBorrowCapGuardian",
          type: "address"
        }
      ],
      name: "NewBorrowCapGuardian",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "oldCloseFactorMantissa",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newCloseFactorMantissa",
          type: "uint256"
        }
      ],
      name: "NewCloseFactor",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "oldCollateralFactorMantissa",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newCollateralFactorMantissa",
          type: "uint256"
        }
      ],
      name: "NewCollateralFactor",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "oldLiquidationIncentiveMantissa",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newLiquidationIncentiveMantissa",
          type: "uint256"
        }
      ],
      name: "NewLiquidationIncentive",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "oldPauseGuardian",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newPauseGuardian",
          type: "address"
        }
      ],
      name: "NewPauseGuardian",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract PriceOracle",
          name: "oldPriceOracle",
          type: "address"
        },
        {
          indexed: false,
          internalType: "contract PriceOracle",
          name: "newPriceOracle",
          type: "address"
        }
      ],
      name: "NewPriceOracle",
      type: "event"
    },
    {
      inputs: [
        {
          internalType: "contract Unitroller",
          name: "unitroller",
          type: "address"
        }
      ],
      name: "_become",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "_borrowGuardianPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "recipient",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "_grantComp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "_mintGuardianPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newBorrowCapGuardian",
          type: "address"
        }
      ],
      name: "_setBorrowCapGuardian",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "bool",
          name: "state",
          type: "bool"
        }
      ],
      name: "_setBorrowPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newCloseFactorMantissa",
          type: "uint256"
        }
      ],
      name: "_setCloseFactor",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "newCollateralFactorMantissa",
          type: "uint256"
        }
      ],
      name: "_setCollateralFactor",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken[]",
          name: "cTokens",
          type: "address[]"
        },
        {
          internalType: "uint256[]",
          name: "supplySpeeds",
          type: "uint256[]"
        },
        {
          internalType: "uint256[]",
          name: "borrowSpeeds",
          type: "uint256[]"
        }
      ],
      name: "_setCompSpeeds",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "contributor",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "compSpeed",
          type: "uint256"
        }
      ],
      name: "_setContributorCompSpeed",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newLiquidationIncentiveMantissa",
          type: "uint256"
        }
      ],
      name: "_setLiquidationIncentive",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken[]",
          name: "cTokens",
          type: "address[]"
        },
        {
          internalType: "uint256[]",
          name: "newBorrowCaps",
          type: "uint256[]"
        }
      ],
      name: "_setMarketBorrowCaps",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "bool",
          name: "state",
          type: "bool"
        }
      ],
      name: "_setMintPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "newPauseGuardian",
          type: "address"
        }
      ],
      name: "_setPauseGuardian",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract PriceOracle",
          name: "newOracle",
          type: "address"
        }
      ],
      name: "_setPriceOracle",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bool",
          name: "state",
          type: "bool"
        }
      ],
      name: "_setSeizePaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "bool",
          name: "state",
          type: "bool"
        }
      ],
      name: "_setTransferPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        }
      ],
      name: "_supportMarket",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "accountAssets",
      outputs: [
        {
          internalType: "contract CToken",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "admin",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      name: "allMarkets",
      outputs: [
        {
          internalType: "contract CToken",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "borrowAmount",
          type: "uint256"
        }
      ],
      name: "borrowAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "borrowCapGuardian",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "borrowCaps",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "borrowGuardianPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "borrowAmount",
          type: "uint256"
        }
      ],
      name: "borrowVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        }
      ],
      name: "checkMembership",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "holder",
          type: "address"
        },
        {
          internalType: "contract CToken[]",
          name: "cTokens",
          type: "address[]"
        }
      ],
      name: "claimComp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "holders",
          type: "address[]"
        },
        {
          internalType: "contract CToken[]",
          name: "cTokens",
          type: "address[]"
        },
        {
          internalType: "bool",
          name: "borrowers",
          type: "bool"
        },
        {
          internalType: "bool",
          name: "suppliers",
          type: "bool"
        }
      ],
      name: "claimComp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "holder",
          type: "address"
        }
      ],
      name: "claimComp",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "closeFactorMantissa",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compAccrued",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compBorrowSpeeds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compBorrowState",
      outputs: [
        {
          internalType: "uint224",
          name: "index",
          type: "uint224"
        },
        {
          internalType: "uint32",
          name: "block",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compBorrowerIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compContributorSpeeds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "compInitialIndex",
      outputs: [
        {
          internalType: "uint224",
          name: "",
          type: "uint224"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "compRate",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compReceivable",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compSpeeds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        },
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compSupplierIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compSupplySpeeds",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "compSupplyState",
      outputs: [
        {
          internalType: "uint224",
          name: "index",
          type: "uint224"
        },
        {
          internalType: "uint32",
          name: "block",
          type: "uint32"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "comptrollerImplementation",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "cTokens",
          type: "address[]"
        }
      ],
      name: "enterMarkets",
      outputs: [
        {
          internalType: "uint256[]",
          name: "",
          type: "uint256[]"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cTokenAddress",
          type: "address"
        }
      ],
      name: "exitMarket",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address[]",
          name: "affectedUsers",
          type: "address[]"
        },
        {
          internalType: "uint256[]",
          name: "amounts",
          type: "uint256[]"
        }
      ],
      name: "fixBadAccruals",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "getAccountLiquidity",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getAllMarkets",
      outputs: [
        {
          internalType: "contract CToken[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "getAssetsIn",
      outputs: [
        {
          internalType: "contract CToken[]",
          name: "",
          type: "address[]"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getBlockNumber",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getCompAddress",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        },
        {
          internalType: "address",
          name: "cTokenModify",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "redeemTokens",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "borrowAmount",
          type: "uint256"
        }
      ],
      name: "getHypotheticalAccountLiquidity",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "isComptroller",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract CToken",
          name: "cToken",
          type: "address"
        }
      ],
      name: "isDeprecated",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "lastContributorBlock",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cTokenBorrowed",
          type: "address"
        },
        {
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        }
      ],
      name: "liquidateBorrowAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cTokenBorrowed",
          type: "address"
        },
        {
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "actualRepayAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "liquidateBorrowVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cTokenBorrowed",
          type: "address"
        },
        {
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "actualRepayAmount",
          type: "uint256"
        }
      ],
      name: "liquidateCalculateSeizeTokens",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "liquidationIncentiveMantissa",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "markets",
      outputs: [
        {
          internalType: "bool",
          name: "isListed",
          type: "bool"
        },
        {
          internalType: "uint256",
          name: "collateralFactorMantissa",
          type: "uint256"
        },
        {
          internalType: "bool",
          name: "isComped",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "maxAssets",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "minter",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "mintAmount",
          type: "uint256"
        }
      ],
      name: "mintAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      name: "mintGuardianPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "minter",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "actualMintAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "mintTokens",
          type: "uint256"
        }
      ],
      name: "mintVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "oracle",
      outputs: [
        {
          internalType: "contract PriceOracle",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pauseGuardian",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pendingAdmin",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pendingComptrollerImplementation",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "proposal65FixExecuted",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "redeemer",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "redeemTokens",
          type: "uint256"
        }
      ],
      name: "redeemAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "redeemer",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "redeemAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "redeemTokens",
          type: "uint256"
        }
      ],
      name: "redeemVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "payer",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        }
      ],
      name: "repayBorrowAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "payer",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "actualRepayAmount",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "borrowerIndex",
          type: "uint256"
        }
      ],
      name: "repayBorrowVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          internalType: "address",
          name: "cTokenBorrowed",
          type: "address"
        },
        {
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "seizeAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "seizeGuardianPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          internalType: "address",
          name: "cTokenBorrowed",
          type: "address"
        },
        {
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "seizeVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "src",
          type: "address"
        },
        {
          internalType: "address",
          name: "dst",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "transferTokens",
          type: "uint256"
        }
      ],
      name: "transferAllowed",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "transferGuardianPaused",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "cToken",
          type: "address"
        },
        {
          internalType: "address",
          name: "src",
          type: "address"
        },
        {
          internalType: "address",
          name: "dst",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "transferTokens",
          type: "uint256"
        }
      ],
      name: "transferVerify",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "contributor",
          type: "address"
        }
      ],
      name: "updateContributorRewards",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    }
  ],
  bytecode: "0x60806040523480156200001157600080fd5b50336000806101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550619f5080620000626000396000f3fe608060405234801561001057600080fd5b506004361061048a5760003560e01c8063731f0c2b11610262578063b21be7fd11610151578063dce15449116100ce578063e9af029211610092578063e9af029214610ffe578063eabe7d911461101a578063ede4edd01461104a578063f00a7a921461107a578063f4a433c014611098578063f851a440146110c85761048a565b8063dce1544914610f44578063dcfbc0c714610f74578063e4028eee14610f92578063e6653f3d14610fc2578063e875544614610fe05761048a565b8063c488847b11610115578063c488847b14610e53578063ca0af04314610e84578063cc7ebdc414610eb4578063d02f735114610ee4578063da3d454c14610f145761048a565b8063b21be7fd14610d75578063bb82aa5e14610da5578063bdcdc25814610dc3578063bea6b8b814610df3578063c299823814610e235761048a565b806394b2294b116101df578063a8b43948116101a3578063a8b4394814610ccf578063aa90075414610ceb578063abfceffc14610d09578063ac0b0bb714610d39578063b0772d0b14610d575761048a565b806394b2294b14610c15578063986ab83814610c335780639d1b5a0a14610c63578063a76b3fda14610c81578063a7f0e23114610cb15761048a565b80638c57804e116102265780638c57804e14610b225780638e8f294b14610b535780638ebf636414610b85578063929fe9a114610bb557806394543c1514610be55761048a565b8063731f0c2b14610a6a578063741b252514610a9a5780637dc0d1d014610ab657806385b7beb814610ad457806387f7630314610b045761048a565b80634a5844321161037e5780635ec88c79116102fb5780636a56947e116102bf5780636a56947e146109a15780636aa875b5146109bd5780636b79c38d146109ed5780636d154ea514610a1e5780636d35bf9114610a4e5761048a565b80635ec88c79146108d75780635f5af1aa146109095780635fc7e71e14610939578063607ef6c1146109695780636810dfa6146109855761048a565b806351dff9891161034257806351dff9891461082357806352d84d1e1461083f57806355ee1fe11461086f578063598ee1cb1461089f5780635c778605146108bb5761048a565b80634a584432146107435780634ada90af146107735780634e79238f146107915780634ef4c3e1146107c35780634fd42e17146107f35761048a565b8063267822471161040c5780633bcf7ec1116103d05780633bcf7ec11461069f5780633c94786f146106cf57806341c728b9146106ed57806342cbb15c1461070957806347ef3b3b146107275761048a565b806326782247146105e957806327efe3cb146106075780632d70db7814610623578063317b0b7714610653578063391957d7146106835761048a565b80631d7b33d7116104535780631d7b33d7146105315780631ededc911461056157806321af45691461057d57806324008a621461059b57806324a3d622146105cb5761048a565b80627e3dd21461048f57806316b95e8f146104ad57806318c882a5146104c95780631c3db2e0146104f95780631d504dc614610515575b600080fd5b6104976110e6565b6040516104a49190617848565b60405180910390f35b6104c760048036038101906104c29190617932565b6110eb565b005b6104e360048036038101906104de9190617a4f565b611493565b6040516104f09190617848565b60405180910390f35b610513600480360381019061050e9190617c0a565b611740565b005b61052f600480360381019061052a9190617cb6565b6117ef565b005b61054b60048036038101906105469190617ce3565b611981565b6040516105589190617d29565b60405180910390f35b61057b60048036038101906105769190617d70565b611999565b005b6105856119b1565b6040516105929190617dfa565b60405180910390f35b6105b560048036038101906105b09190617e15565b6119d7565b6040516105c29190617d29565b60405180910390f35b6105d3611afe565b6040516105e09190617dfa565b60405180910390f35b6105f1611b24565b6040516105fe9190617dfa565b60405180910390f35b610621600480360381019061061c9190617e7c565b611b4a565b005b61063d60048036038101906106389190617ebc565b611c20565b60405161064a9190617848565b60405180910390f35b61066d60048036038101906106689190617ee9565b611dfe565b60405161067a9190617d29565b60405180910390f35b61069d60048036038101906106989190617ce3565b611ef4565b005b6106b960048036038101906106b49190617a4f565b612027565b6040516106c69190617848565b60405180910390f35b6106d76122d4565b6040516106e49190617848565b60405180910390f35b61070760048036038101906107029190617f16565b6122e7565b005b6107116122fe565b60405161071e9190617d29565b60405180910390f35b610741600480360381019061073c9190617f7d565b612306565b005b61075d60048036038101906107589190617ce3565b61231f565b60405161076a9190617d29565b60405180910390f35b61077b612337565b6040516107889190617d29565b60405180910390f35b6107ab60048036038101906107a69190617f16565b61233d565b6040516107ba9392919061800a565b60405180910390f35b6107dd60048036038101906107d89190618041565b612380565b6040516107ea9190617d29565b60405180910390f35b61080d60048036038101906108089190617ee9565b6124af565b60405161081a9190617d29565b60405180910390f35b61083d60048036038101906108389190617f16565b61257c565b005b61085960048036038101906108549190617ee9565b6125d2565b60405161086691906180f3565b60405180910390f35b6108896004803603810190610884919061814c565b612611565b6040516108969190617d29565b60405180910390f35b6108b960048036038101906108b49190617e7c565b612738565b005b6108d560048036038101906108d09190618041565b6128bb565b005b6108f160048036038101906108ec9190617ce3565b6128d1565b6040516109009392919061800a565b60405180910390f35b610923600480360381019061091e9190617ce3565b612913565b6040516109309190617d29565b60405180910390f35b610953600480360381019061094e9190618179565b612a5c565b6040516109609190617d29565b60405180910390f35b610983600480360381019061097e919061824a565b612ce5565b005b61099f600480360381019061099a919061838e565b612f63565b005b6109bb60048036038101906109b69190617e15565b61326c565b005b6109d760048036038101906109d29190617ce3565b613283565b6040516109e49190617d29565b60405180910390f35b610a076004803603810190610a029190617ce3565b61329b565b604051610a15929190618483565b60405180910390f35b610a386004803603810190610a339190617ce3565b6132f7565b604051610a459190617848565b60405180910390f35b610a686004803603810190610a639190618179565b613317565b005b610a846004803603810190610a7f9190617ce3565b61332f565b604051610a919190617848565b60405180910390f35b610ab46004803603810190610aaf9190617ce3565b61334f565b005b610abe6134ed565b604051610acb91906184cd565b60405180910390f35b610aee6004803603810190610ae99190617ce3565b613513565b604051610afb9190617d29565b60405180910390f35b610b0c61352b565b604051610b199190617848565b60405180910390f35b610b3c6004803603810190610b379190617ce3565b61353e565b604051610b4a929190618483565b60405180910390f35b610b6d6004803603810190610b689190617ce3565b61359a565b604051610b7c939291906184e8565b60405180910390f35b610b9f6004803603810190610b9a9190617ebc565b6135de565b604051610bac9190617848565b60405180910390f35b610bcf6004803603810190610bca919061851f565b6137bc565b604051610bdc9190617848565b60405180910390f35b610bff6004803603810190610bfa919061855f565b613853565b604051610c0c9190617848565b60405180910390f35b610c1d61397e565b604051610c2a9190617d29565b60405180910390f35b610c4d6004803603810190610c489190617ce3565b613984565b604051610c5a9190617d29565b60405180910390f35b610c6b61399c565b604051610c789190617dfa565b60405180910390f35b610c9b6004803603810190610c96919061855f565b6139b8565b604051610ca89190617d29565b60405180910390f35b610cb9613be6565b604051610cc6919061858c565b60405180910390f35b610ce96004803603810190610ce4919061866a565b613bf9565b005b610cf3613d11565b604051610d009190617d29565b60405180910390f35b610d236004803603810190610d1e9190617ce3565b613d17565b604051610d3091906187cf565b60405180910390f35b610d41613dea565b604051610d4e9190617848565b60405180910390f35b610d5f613dfd565b604051610d6c91906187cf565b60405180910390f35b610d8f6004803603810190610d8a91906187f1565b613e8b565b604051610d9c9190617d29565b60405180910390f35b610dad613eb0565b604051610dba9190617dfa565b60405180910390f35b610ddd6004803603810190610dd89190617e15565b613ed6565b604051610dea9190617d29565b60405180910390f35b610e0d6004803603810190610e089190617ce3565b613f97565b604051610e1a9190617d29565b60405180910390f35b610e3d6004803603810190610e389190618831565b613faf565b604051610e4a9190618938565b60405180910390f35b610e6d6004803603810190610e689190618041565b614088565b604051610e7b92919061895a565b60405180910390f35b610e9e6004803603810190610e9991906187f1565b614320565b604051610eab9190617d29565b60405180910390f35b610ece6004803603810190610ec99190617ce3565b614345565b604051610edb9190617d29565b60405180910390f35b610efe6004803603810190610ef99190618179565b61435d565b604051610f0b9190617d29565b60405180910390f35b610f2e6004803603810190610f299190618041565b6145df565b604051610f3b9190617d29565b60405180910390f35b610f5e6004803603810190610f599190617e7c565b614bdb565b604051610f6b91906180f3565b60405180910390f35b610f7c614c29565b604051610f899190617dfa565b60405180910390f35b610fac6004803603810190610fa79190618983565b614c4f565b604051610fb99190617d29565b60405180910390f35b610fca614ead565b604051610fd79190617848565b60405180910390f35b610fe8614ec0565b604051610ff59190617d29565b60405180910390f35b61101860048036038101906110139190617ce3565b614ec6565b005b611034600480360381019061102f9190618041565b614f59565b6040516110419190617d29565b60405180910390f35b611064600480360381019061105f9190617ce3565b614fbe565b6040516110719190617d29565b60405180910390f35b6110826154cd565b60405161108f9190617848565b60405180910390f35b6110b260048036038101906110ad9190617ce3565b6154e0565b6040516110bf9190617d29565b60405180910390f35b6110d06154f8565b6040516110dd9190617dfa565b60405180910390f35b600181565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611179576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161117090618a46565b60405180910390fd5b601b60009054906101000a900460ff16156111c9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111c090618ad8565b60405180910390fd5b818190508484905014611211576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161120890618b44565b60405180910390fd5b60008060008060005b8888905081101561146d5788888281811061123857611237618b64565b5b905060200201602081019061124d9190617ce3565b9450601460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205493508686828181106112a4576112a3618b64565b5b905060200201359250838311156113b257600084846112c39190618bc2565b90506000601c60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506000611315828461551c565b905080601c60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508773ffffffffffffffffffffffffffffffffffffffff167f17fea09d9a7ca41b2f9f9118f18f44848a62e9c70d55dd4385131eb2cf1b7e4783836040516113a392919061895a565b60405180910390a28695505050505b600083111561145c576113c58484615532565b915081601460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508473ffffffffffffffffffffffffffffffffffffffff167f4a5c134e28b537a76546993ea37f3b60d9190476df7356d3842aa40902e20f04858460405161145392919061895a565b60405180910390a25b8061146690618bf6565b905061121a565b506001601b60006101000a81548160ff0219169083151502179055505050505050505050565b6000600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16611524576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161151b90618cb1565b60405180910390fd5b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806115cb575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b61160a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161160190618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611668575060011515821515145b6116a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161169e90618daf565b60405180910390fd5b81600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055507f71aec636243f9709bb0007ae15e9afb8150ab01716d75fd7573be5cc096e03b0838360405161172f929190618e1b565b60405180910390a181905092915050565b6000600167ffffffffffffffff81111561175d5761175c617acc565b5b60405190808252806020026020018201604052801561178b5781602001602082028036833780820191505090505b50905082816000815181106117a3576117a2618b64565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506117ea8183600180612f63565b505050565b8073ffffffffffffffffffffffffffffffffffffffff1663f851a4406040518163ffffffff1660e01b8152600401602060405180830381865afa15801561183a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061185e9190618e6c565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146118cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118c290618f0b565b60405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff1663c1e803346040518163ffffffff1660e01b81526004016020604051808303816000875af115801561191a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061193e9190618f40565b1461197e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161197590618fb9565b60405180910390fd5b50565b600f6020528060005260406000206000915090505481565b6000156119aa576007546007819055505b5050505050565b601560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16611a485760096011811115611a4157611a40618fd9565b5b9050611af6565b600060405180602001604052808773ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611aa0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac49190618f40565b8152509050611ad38682615548565b611ade868583615868565b60006011811115611af257611af1618fd9565b5b9150505b949350505050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b611b52615c24565b611b91576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b8890619054565b60405180910390fd5b6000611b9d8383615cd3565b905060008114611be2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bd9906190c0565b60405180910390fd5b7f98b2f82a3a07f223a0be64b3d0f47711c64dccd1feafb94aa28156b38cd9695c8383604051611c139291906190e0565b60405180910390a1505050565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611cc9575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b611d08576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611cff90618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611d66575060011515821515145b611da5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d9c90618daf565b60405180910390fd5b81600a60176101000a81548160ff0219169083151502179055507fef159d9a32b2472e32b098f954f3ce62d232939f1c207070b584df1814de2de082604051611dee9190619155565b60405180910390a1819050919050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611e8f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e86906191cf565b60405180910390fd5b60006005549050826005819055507f3b9670cf975d26958e754b57098eaa2ac914d8d2a31b83257997b9f346110fd981600554604051611ed092919061895a565b60405180910390a160006011811115611eec57611eeb618fd9565b5b915050919050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611f82576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f7990619261565b60405180910390fd5b6000601560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081601560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507feda98690e518e9a05f8ec6837663e188211b2da8f4906648b323f2c1d4434e29818360405161201b929190619281565b60405180910390a15050565b6000600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff166120b8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016120af90618cb1565b60405180910390fd5b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061215f575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b61219e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161219590618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806121fc575060011515821515145b61223b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161223290618daf565b60405180910390fd5b81600b60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055507f71aec636243f9709bb0007ae15e9afb8150ab01716d75fd7573be5cc096e03b083836040516122c39291906192f6565b60405180910390a181905092915050565b600a60149054906101000a900460ff1681565b6000156122f8576007546007819055505b50505050565b600043905090565b600015612317576007546007819055505b505050505050565b60166020528060005260406000206000915090505481565b60065481565b6000806000806000806123528a8a8a8a615e09565b92509250925082601181111561236b5761236a618fd9565b5b82829550955095505050509450945094915050565b6000600b60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561240f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016124069061937e565b60405180910390fd5b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1661247e576009601181111561247757612476618fd9565b5b90506124a8565b61248784616267565b612491848461657d565b600060118111156124a5576124a4618fd9565b5b90505b9392505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612518576125116001600b61692f565b9050612577565b60006006549050826006819055507faeba5a6c40a8ac138134bff1aaa65debf25971188a58804bad717f82f0ec1316818460405161255792919061895a565b60405180910390a16000601181111561257357612572618fd9565b5b9150505b919050565b60008114801561258c5750600082115b156125cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016125c3906193ea565b60405180910390fd5b50505050565b600d81815481106125e257600080fd5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461267a576126736001601061692f565b9050612733565b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fd52b2b9b7e9ee655fcb95d2e5b9e0c9f69e7ef2b8e9d2d0ea78402d576d22e22818460405161271392919061940a565b60405180910390a16000601181111561272f5761272e618fd9565b5b9150505b919050565b612740615c24565b61277f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016127769061947f565b60405180910390fd5b6127888261334f565b60008114156127d957601860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009055612825565b6127e16122fe565b601860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80601760008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff167f386537fa92edc3319af95f1f904dcf1900021e4f3f4e08169a577a09076e66b3826040516128af9190617d29565b60405180910390a25050565b6000156128cc576007546007819055505b505050565b6000806000806000806128e8876000806000615e09565b92509250925082601181111561290157612900618fd9565b5b82829550955095505050509193909250565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461297c576129756001601361692f565b9050612a57565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f0613b6ee6a04f0d09f390e4d9318894b9f6ac7fd83897cd8d18896ba579c401e81600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604051612a37929190619281565b60405180910390a160006011811115612a5357612a52618fd9565b5b9150505b919050565b6000600960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff161580612b075750600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16155b15612b275760096011811115612b2057612b1f618fd9565b5b9050612cdc565b60008673ffffffffffffffffffffffffffffffffffffffff166395dd9193856040518263ffffffff1660e01b8152600401612b629190617dfa565b602060405180830381865afa158015612b7f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ba39190618f40565b9050612bae87613853565b15612bfb5782811015612bf6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612bed90619511565b60405180910390fd5b612cc4565b600080612c07866169ac565b925050915060006011811115612c2057612c1f618fd9565b5b826011811115612c3357612c32618fd9565b5b14612c5557816011811115612c4b57612c4a618fd9565b5b9350505050612cdc565b6000811415612c7c5760036011811115612c7257612c71618fd9565b5b9350505050612cdc565b6000612c986040518060200160405280600554815250856169cc565b905080861115612cc057601180811115612cb557612cb4618fd9565b5b945050505050612cdc565b5050505b60006011811115612cd857612cd7618fd9565b5b9150505b95945050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480612d8c5750601560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b612dcb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612dc2906195a3565b60405180910390fd5b6000848490509050600083839050905060008214158015612deb57508082145b612e2a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612e219061960f565b60405180910390fd5b60005b82811015612f5a57848482818110612e4857612e47618b64565b5b9050602002013560166000898985818110612e6657612e65618b64565b5b9050602002016020810190612e7b919061855f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550868682818110612ecc57612ecb618b64565b5b9050602002016020810190612ee1919061855f565b73ffffffffffffffffffffffffffffffffffffffff167f6f1951b2aad10f3fc81b86d91105b413a5b3f847a34bbc5ce1904201b14438f6868684818110612f2b57612f2a618b64565b5b90506020020135604051612f3f9190617d29565b60405180910390a28080612f5290618bf6565b915050612e2d565b50505050505050565b60005b835181101561316b576000848281518110612f8457612f83618b64565b5b60200260200101519050600960008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1661301d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016130149061967b565b60405180910390fd5b6001151584151514156130fc57600060405180602001604052808373ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613082573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130a69190618f40565b81525090506130b58282615548565b60005b87518110156130f9576130e6838983815181106130d8576130d7618b64565b5b602002602001015184615868565b80806130f190618bf6565b9150506130b8565b50505b6001151583151514156131575761311281616267565b60005b8651811015613155576131428288838151811061313557613134618b64565b5b602002602001015161657d565b808061314d90618bf6565b915050613115565b505b50808061316390618bf6565b915050612f66565b5060005b8451811015613265576131f585828151811061318e5761318d618b64565b5b6020026020010151601460008885815181106131ad576131ac618b64565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054615cd3565b6014600087848151811061320c5761320b618b64565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550808061325d90618bf6565b91505061316f565b5050505050565b60001561327d576007546007819055505b50505050565b601a6020528060005260406000206000915090505481565b60106020528060005260406000206000915090508060000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169080600001601c9054906101000a900463ffffffff16905082565b600c6020528060005260406000206000915054906101000a900460ff1681565b600015613328576007546007819055505b5050505050565b600b6020528060005260406000206000915054906101000a900460ff1681565b6000601760008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600061339d6122fe565b905060006133ea82601860008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054615532565b90506000811180156133fc5750600083115b156134e757600061340d82856169ed565b9050600061345a601460008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548361551c565b905080601460008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083601860008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050505b50505050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b601c6020528060005260406000206000915090505481565b600a60169054906101000a900460ff1681565b60116020528060005260406000206000915090508060000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169080600001601c9054906101000a900463ffffffff16905082565b60096020528060005260406000206000915090508060000160009054906101000a900460ff16908060010154908060030160009054906101000a900460ff16905083565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613687575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b6136c6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016136bd90618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613724575060011515821515145b613763576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161375a90618daf565b60405180910390fd5b81600a60166101000a81548160ff0219169083151502179055507fef159d9a32b2472e32b098f954f3ce62d232939f1c207070b584df1814de2de0826040516137ac91906196e7565b60405180910390a1819050919050565b6000600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b600080600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101541480156138f6575060011515600c60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515145b80156139775750670de0b6b3a76400008273ffffffffffffffffffffffffffffffffffffffff1663173b99046040518163ffffffff1660e01b8152600401602060405180830381865afa158015613951573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139759190618f40565b145b9050919050565b60075481565b60176020528060005260406000206000915090505481565b600073c00e94cb662c3520282e6f5717214004a7f26888905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613a2157613a1a6001601261692f565b9050613be1565b600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1615613a8957613a82600a601161692f565b9050613be1565b8173ffffffffffffffffffffffffffffffffffffffff1663fe9c44ae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613ad4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613af8919061972a565b506000600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060018160000160006101000a81548160ff02191690831515021790555060008160030160006101000a81548160ff02191690831515021790555060008160010181905550613b8983616a03565b613b9283616b3a565b7fcf583bb0c569eb967f806b11601c4cb93c10310485c67add5f8362c2f212321f83604051613bc191906180f3565b60405180910390a160006011811115613bdd57613bdc618fd9565b5b9150505b919050565b6ec097ce7bc90715b34b9f100000000081565b613c01615c24565b613c40576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613c379061947f565b60405180910390fd5b600083519050825181148015613c565750815181145b613c95576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613c8c906197c9565b60405180910390fd5b60005b81811015613d0a57613cf9858281518110613cb657613cb5618b64565b5b6020026020010151858381518110613cd157613cd0618b64565b5b6020026020010151858481518110613cec57613ceb618b64565b5b6020026020010151616dc0565b80613d0390618bf6565b9050613c98565b5050505050565b600e5481565b60606000600860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015613dda57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311613d90575b5050505050905080915050919050565b600a60179054906101000a900460ff1681565b6060600d805480602002602001604051908101604052809291908181526020018280548015613e8157602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311613e37575b5050505050905090565b6012602052816000526040600020602052806000526040600020600091509150505481565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600a60169054906101000a900460ff1615613f28576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613f1f90619835565b60405180910390fd5b6000613f358686856170a1565b905060006011811115613f4b57613f4a618fd9565b5b8114613f5a5780915050613f8f565b613f6386616267565b613f6d868661657d565b613f77868561657d565b60006011811115613f8b57613f8a618fd9565b5b9150505b949350505050565b60186020528060005260406000206000915090505481565b606060008251905060008167ffffffffffffffff811115613fd357613fd2617acc565b5b6040519080825280602002602001820160405280156140015781602001602082028036833780820191505090505b50905060005b8281101561407d57600085828151811061402457614023618b64565b5b602002602001015190506140388133617261565b601181111561404a57614049618fd9565b5b83838151811061405d5761405c618b64565b5b60200260200101818152505050808061407590618bf6565b915050614007565b508092505050919050565b6000806000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df876040518263ffffffff1660e01b81526004016140e891906180f3565b602060405180830381865afa158015614105573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141299190618f40565b90506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df876040518263ffffffff1660e01b815260040161418891906180f3565b602060405180830381865afa1580156141a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141c99190618f40565b905060008214806141da5750600081145b1561420057600d60118111156141f3576141f2618fd9565b5b6000935093505050614318565b60008673ffffffffffffffffffffffffffffffffffffffff1663182df0f56040518163ffffffff1660e01b8152600401602060405180830381865afa15801561424d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142719190618f40565b9050600061427d61779c565b61428561779c565b61428d61779c565b6142b5604051806020016040528060065481525060405180602001604052808a815250617469565b92506142dd604051806020016040528088815250604051806020016040528088815250617469565b91506142e983836174ac565b90506142f5818b6169cc565b93506000601181111561430b5761430a618fd9565b5b8498509850505050505050505b935093915050565b6013602052816000526040600020602052806000526040600020600091509150505481565b60146020528060005260406000206000915090505481565b6000600a60179054906101000a900460ff16156143af576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016143a6906198a1565b60405180910390fd5b600960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1615806144585750600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16155b15614478576009601181111561447157614470618fd9565b5b90506145d6565b8473ffffffffffffffffffffffffffffffffffffffff16635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156144c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906144e791906198ff565b73ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015614548573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061456c91906198ff565b73ffffffffffffffffffffffffffffffffffffffff16146145a2576002601181111561459b5761459a618fd9565b5b90506145d6565b6145ab86616267565b6145b5868461657d565b6145bf868561657d565b600060118111156145d3576145d2618fd9565b5b90505b95945050505050565b6000600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561466e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161466590619978565b60405180910390fd5b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff166146dd57600960118111156146d6576146d5618fd9565b5b9050614bd4565b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166148cd578373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146147dc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016147d3906199e4565b60405180910390fd5b60006147e83385617261565b9050600060118111156147fe576147fd618fd9565b5b81601181111561481157614810618fd9565b5b146148315780601181111561482957614828618fd9565b5b915050614bd4565b600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166148cb576148ca619a04565b5b505b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df866040518263ffffffff1660e01b815260040161492a91906180f3565b602060405180830381865afa158015614947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061496b9190618f40565b141561498c57600d601181111561498557614984618fd9565b5b9050614bd4565b6000601660008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060008114614a9e5760008573ffffffffffffffffffffffffffffffffffffffff166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa158015614a25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614a499190618f40565b90506000614a57828661551c565b9050828110614a9b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614a9290619a7f565b60405180910390fd5b50505b600080614aae8688600088615e09565b925050915060006011811115614ac757614ac6618fd9565b5b826011811115614ada57614ad9618fd9565b5b14614afc57816011811115614af257614af1618fd9565b5b9350505050614bd4565b6000811115614b235760046011811115614b1957614b18618fd9565b5b9350505050614bd4565b600060405180602001604052808973ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614b7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614b9f9190618f40565b8152509050614bae8882615548565b614bb9888883615868565b60006011811115614bcd57614bcc618fd9565b5b9450505050505b9392505050565b60086020528160005260406000208181548110614bf757600080fd5b906000526020600020016000915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614cb857614cb16001600661692f565b9050614ea7565b6000600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060000160009054906101000a900460ff16614d2557614d1d6009600761692f565b915050614ea7565b6000604051806020016040528085815250905060006040518060200160405280670c7d713b49da00008152509050614d5d81836174ed565b15614d7857614d6e6006600861692f565b9350505050614ea7565b60008514158015614e2457506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df886040518263ffffffff1660e01b8152600401614de191906180f3565b602060405180830381865afa158015614dfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614e229190618f40565b145b15614e3f57614e35600d600961692f565b9350505050614ea7565b6000836001015490508584600101819055507f70483e6592cd5182d45ac970e05bc62cdcc90e9d8ef2c2dbe686cf383bcd7fc5878288604051614e8493929190619a9f565b60405180910390a160006011811115614ea057614e9f618fd9565b5b9450505050505b92915050565b600a60159054906101000a900460ff1681565b60055481565b614f5681600d805480602002602001604051908101604052809291908181526020018280548015614f4c57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311614f02575b5050505050611740565b50565b600080614f678585856170a1565b905060006011811115614f7d57614f7c618fd9565b5b8114614f8c5780915050614fb7565b614f9585616267565b614f9f858561657d565b60006011811115614fb357614fb2618fd9565b5b9150505b9392505050565b60008082905060008060008373ffffffffffffffffffffffffffffffffffffffff1663c37f68e2336040518263ffffffff1660e01b81526004016150029190617dfa565b608060405180830381865afa15801561501f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906150439190619ad6565b509250925092506000831461508d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161508490619baf565b60405180910390fd5b600081146150ac576150a1600c600261692f565b9450505050506154c8565b60006150b98733856170a1565b9050600081146150dc576150d0600e600383617502565b955050505050506154c8565b6000600960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060020160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16615193576000601181111561518657615185618fd9565b5b96505050505050506154c8565b8060020160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556000600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208054806020026020016040519081016040528092919081815260200182805480156152a557602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161525b575b50505050509050600081519050600081905060005b8281101561532b578973ffffffffffffffffffffffffffffffffffffffff168482815181106152ec576152eb618b64565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1614156153185780915061532b565b808061532390618bf6565b9150506152ba565b5081811061533c5761533b619a04565b5b6000600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905080600182805490506153919190618bc2565b815481106153a2576153a1618b64565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168183815481106153e0576153df618b64565b5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508080548061543957615438619bcf565b5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905590557fe699a64c18b07ac5b7301aa273f36a2287239eb9501d81950672794afba29a0d8a3360405161549f929190619bfe565b60405180910390a1600060118111156154bb576154ba618fd9565b5b9a50505050505050505050505b919050565b601b60009054906101000a900460ff1681565b60196020528060005260406000206000915090505481565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000818361552a9190619c27565b905092915050565b600081836155409190618bc2565b905092915050565b6000601160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000601960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060006156176155dc6122fe565b6040518060400160405280601c81526020017f626c6f636b206e756d626572206578636565647320333220626974730000000081525061757f565b905060006156458263ffffffff1685600001601c9054906101000a900463ffffffff1663ffffffff16615532565b90506000811180156156575750600083115b156158325760006156d68773ffffffffffffffffffffffffffffffffffffffff166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa1580156156ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906156d09190618f40565b876175d5565b905060006156e483866169ed565b90506000808311615704576040518060200160405280600081525061570f565b61570e82846175fe565b5b90506157b561577660405180602001604052808a60000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168152508361763e565b600001516040518060400160405280601a81526020017f6e657720696e646578206578636565647320323234206269747300000000000081525061766e565b8760000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508487600001601c6101000a81548163ffffffff021916908363ffffffff160217905550505050615860565b600081111561585f578184600001601c6101000a81548163ffffffff021916908363ffffffff1602179055505b5b505050505050565b6000601160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690506000601360008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081601360008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550600081148015615a3957506ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168210155b15615a6f576ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690505b60006040518060200160405280615a868585615532565b81525090506000615b108873ffffffffffffffffffffffffffffffffffffffff166395dd9193896040518263ffffffff1660e01b8152600401615ac99190617dfa565b602060405180830381865afa158015615ae6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615b0a9190618f40565b876175d5565b90506000615b1e82846176dc565b90506000615b6b601460008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548361551c565b905080601460008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508873ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff167f1fc3ecc087d8d2d15e23d0032af5a47059c3892d003d8e139fdcb6bb327c99a68489604051615c1092919061895a565b60405180910390a350505050505050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480615cce5750600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b905090565b600080615cde61399c565b905060008173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401615d1b9190617dfa565b602060405180830381865afa158015615d38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615d5c9190618f40565b9050600084118015615d6e5750808411155b15615dfd578173ffffffffffffffffffffffffffffffffffffffff1663a9059cbb86866040518363ffffffff1660e01b8152600401615dae9291906190e0565b6020604051808303816000875af1158015615dcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615df1919061972a565b50600092505050615e03565b83925050505b92915050565b6000806000615e166177af565b600080600860008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015615ed857602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311615e8e575b5050505050905060005b8151811015616205576000828281518110615f0057615eff618b64565b5b602002602001015190508073ffffffffffffffffffffffffffffffffffffffff1663c37f68e28d6040518263ffffffff1660e01b8152600401615f439190617dfa565b608060405180830381865afa158015615f60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615f849190619ad6565b88604001896060018a6080018381525083815250838152508397505050505060008414615fc057600f600080975097509750505050505061625d565b6040518060200160405280600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101548152508560c00181905250604051806020016040528086608001518152508560e00181905250600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df826040518263ffffffff1660e01b815260040161608f91906180f3565b602060405180830381865afa1580156160ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906160d09190618f40565b8560a001818152505060008560a0015114156160fb57600d600080975097509750505050505061625d565b60405180602001604052808660a0015181525085610100018190525061613761612c8660c001518760e00151617469565b866101000151617469565b8561012001819052506161588561012001518660400151876000015161770e565b8560000181815250506161798561010001518660600151876020015161770e565b8560200181815250508a73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156161f1576161ca8561012001518b876020015161770e565b8560200181815250506161e78561010001518a876020015161770e565b8560200181815250505b5080806161fd90618bf6565b915050615ee2565b5082602001518360000151111561623c5760008360200151846000015161622c9190618bc2565b600095509550955050505061625d565b600080846000015185602001516162539190618bc2565b9550955095505050505b9450945094915050565b6000601060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000601a60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060006163366162fb6122fe565b6040518060400160405280601c81526020017f626c6f636b206e756d626572206578636565647320333220626974730000000081525061757f565b905060006163648263ffffffff1685600001601c9054906101000a900463ffffffff1663ffffffff16615532565b90506000811180156163765750600083115b156165485760008573ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156163c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906163ec9190618f40565b905060006163fa83866169ed565b9050600080831161641a5760405180602001604052806000815250616425565b61642482846175fe565b5b90506164cb61648c60405180602001604052808a60000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168152508361763e565b600001516040518060400160405280601a81526020017f6e657720696e646578206578636565647320323234206269747300000000000081525061766e565b8760000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508487600001601c6101000a81548163ffffffff021916908363ffffffff160217905550505050616576565b6000811115616575578184600001601c6101000a81548163ffffffff021916908363ffffffff1602179055505b5b5050505050565b6000601060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690506000601260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081601260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060008114801561674e57506ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168210155b15616784576ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690505b6000604051806020016040528061679b8585615532565b815250905060008673ffffffffffffffffffffffffffffffffffffffff166370a08231876040518263ffffffff1660e01b81526004016167db9190617dfa565b602060405180830381865afa1580156167f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061681c9190618f40565b9050600061682a82846176dc565b90506000616877601460008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548361551c565b905080601460008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167f2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a848960405161691c92919061895a565b60405180910390a3505050505050505050565b60007f45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa083601181111561696557616964618fd9565b5b83601381111561697857616977618fd9565b5b600060405161698993929190619cb8565b60405180910390a18260118111156169a4576169a3618fd9565b5b905092915050565b60008060006169bf846000806000615e09565b9250925092509193909250565b6000806169d98484617739565b90506169e481617765565b91505092915050565b600081836169fb9190619cef565b905092915050565b60005b600d80549050811015616ad3578173ffffffffffffffffffffffffffffffffffffffff16600d8281548110616a3e57616a3d618b64565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415616ac0576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401616ab790619d95565b60405180910390fd5b8080616acb90618bf6565b915050616a06565b50600d819080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b6000616b82616b476122fe565b6040518060400160405280601c81526020017f626c6f636b206e756d626572206578636565647320333220626974730000000081525061757f565b90506000601060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000601160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008260000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161415616cc0576ec097ce7bc90715b34b9f10000000008260000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055505b60008160000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161415616d76576ec097ce7bc90715b34b9f10000000008160000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055505b8281600001601c6101000a81548163ffffffff021916908363ffffffff160217905582600001601c6101000a81548163ffffffff021916908363ffffffff16021790555050505050565b6000600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060000160009054906101000a900460ff16616e54576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401616e4b90619e01565b60405180910390fd5b82601a60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414616f3657616ea384616267565b82601a60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508373ffffffffffffffffffffffffffffffffffffffff167fdeafccd0c0b768b2529f7dcbbe58e155d6023059150b7490ed4535cc3744b92d84604051616f2d9190617d29565b60405180910390a25b81601960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541461709b57600060405180602001604052808673ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015616fd4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190616ff89190618f40565b81525090506170078582615548565b82601960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508473ffffffffffffffffffffffffffffffffffffffff167f20af8e791cc98f74b2d7a391c80980ca8e5aebf3d4060bf581997b6acae2e537846040516170919190617d29565b60405180910390a2505b50505050565b6000600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16617112576009601181111561710b5761710a618fd9565b5b905061725a565b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166171be57600060118111156171b7576171b6618fd9565b5b905061725a565b6000806171ce8587866000615e09565b9250509150600060118111156171e7576171e6618fd9565b5b8260118111156171fa576171f9618fd9565b5b1461721b5781601181111561721257617211618fd9565b5b9250505061725a565b6000811115617241576004601181111561723857617237618fd9565b5b9250505061725a565b6000601181111561725557617254618fd9565b5b925050505b9392505050565b600080600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060000160009054906101000a900460ff166172c5576009915050617463565b600115158160020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515141561732a576000915050617463565b60018160020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550600860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020849080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f3ab23ab0d51cccc0c3085aec51f99228625aa1a922b3a8ca89a26b0f2027a1a58484604051617455929190619bfe565b60405180910390a160009150505b92915050565b61747161779c565b6040518060200160405280670de0b6b3a7640000617497866000015186600001516169ed565b6174a19190619e50565b815250905092915050565b6174b461779c565b60405180602001604052806174e26174d88660000151670de0b6b3a76400006169ed565b8560000151617786565b815250905092915050565b60008160000151836000015110905092915050565b60007f45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa084601181111561753857617537618fd9565b5b84601381111561754b5761754a618fd9565b5b8460405161755b9392919061800a565b60405180910390a183601181111561757657617575618fd9565b5b90509392505050565b6000640100000000831082906175cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016175c29190619ef8565b60405180910390fd5b5082905092915050565b60006175f66175ec84670de0b6b3a76400006169ed565b8360000151617786565b905092915050565b61760661781a565b604051806020016040528061763361762d866ec097ce7bc90715b34b9f10000000006169ed565b85617786565b815250905092915050565b61764661781a565b60405180602001604052806176638560000151856000015161551c565b815250905092915050565b60007c0100000000000000000000000000000000000000000000000000000000831082906176d2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016176c99190619ef8565b60405180910390fd5b5082905092915050565b60006ec097ce7bc90715b34b9f10000000006176fc8484600001516169ed565b6177069190619e50565b905092915050565b60008061771b8585617739565b905061772f61772982617765565b8461551c565b9150509392505050565b61774161779c565b604051806020016040528061775a8560000151856169ed565b815250905092915050565b6000670de0b6b3a7640000826000015161777f9190619e50565b9050919050565b600081836177949190619e50565b905092915050565b6040518060200160405280600081525090565b6040518061014001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016177ed61779c565b81526020016177fa61779c565b815260200161780761779c565b815260200161781461779c565b81525090565b6040518060200160405280600081525090565b60008115159050919050565b6178428161782d565b82525050565b600060208201905061785d6000830184617839565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f84011261789c5761789b617877565b5b8235905067ffffffffffffffff8111156178b9576178b861787c565b5b6020830191508360208202830111156178d5576178d4617881565b5b9250929050565b60008083601f8401126178f2576178f1617877565b5b8235905067ffffffffffffffff81111561790f5761790e61787c565b5b60208301915083602082028301111561792b5761792a617881565b5b9250929050565b6000806000806040858703121561794c5761794b61786d565b5b600085013567ffffffffffffffff81111561796a57617969617872565b5b61797687828801617886565b9450945050602085013567ffffffffffffffff81111561799957617998617872565b5b6179a5878288016178dc565b925092505092959194509250565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006179de826179b3565b9050919050565b60006179f0826179d3565b9050919050565b617a00816179e5565b8114617a0b57600080fd5b50565b600081359050617a1d816179f7565b92915050565b617a2c8161782d565b8114617a3757600080fd5b50565b600081359050617a4981617a23565b92915050565b60008060408385031215617a6657617a6561786d565b5b6000617a7485828601617a0e565b9250506020617a8585828601617a3a565b9150509250929050565b617a98816179d3565b8114617aa357600080fd5b50565b600081359050617ab581617a8f565b92915050565b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b617b0482617abb565b810181811067ffffffffffffffff82111715617b2357617b22617acc565b5b80604052505050565b6000617b36617863565b9050617b428282617afb565b919050565b600067ffffffffffffffff821115617b6257617b61617acc565b5b602082029050602081019050919050565b6000617b86617b8184617b47565b617b2c565b90508083825260208201905060208402830185811115617ba957617ba8617881565b5b835b81811015617bd25780617bbe8882617a0e565b845260208401935050602081019050617bab565b5050509392505050565b600082601f830112617bf157617bf0617877565b5b8135617c01848260208601617b73565b91505092915050565b60008060408385031215617c2157617c2061786d565b5b6000617c2f85828601617aa6565b925050602083013567ffffffffffffffff811115617c5057617c4f617872565b5b617c5c85828601617bdc565b9150509250929050565b6000617c71826179b3565b9050919050565b6000617c8382617c66565b9050919050565b617c9381617c78565b8114617c9e57600080fd5b50565b600081359050617cb081617c8a565b92915050565b600060208284031215617ccc57617ccb61786d565b5b6000617cda84828501617ca1565b91505092915050565b600060208284031215617cf957617cf861786d565b5b6000617d0784828501617aa6565b91505092915050565b6000819050919050565b617d2381617d10565b82525050565b6000602082019050617d3e6000830184617d1a565b92915050565b617d4d81617d10565b8114617d5857600080fd5b50565b600081359050617d6a81617d44565b92915050565b600080600080600060a08688031215617d8c57617d8b61786d565b5b6000617d9a88828901617aa6565b9550506020617dab88828901617aa6565b9450506040617dbc88828901617aa6565b9350506060617dcd88828901617d5b565b9250506080617dde88828901617d5b565b9150509295509295909350565b617df4816179d3565b82525050565b6000602082019050617e0f6000830184617deb565b92915050565b60008060008060808587031215617e2f57617e2e61786d565b5b6000617e3d87828801617aa6565b9450506020617e4e87828801617aa6565b9350506040617e5f87828801617aa6565b9250506060617e7087828801617d5b565b91505092959194509250565b60008060408385031215617e9357617e9261786d565b5b6000617ea185828601617aa6565b9250506020617eb285828601617d5b565b9150509250929050565b600060208284031215617ed257617ed161786d565b5b6000617ee084828501617a3a565b91505092915050565b600060208284031215617eff57617efe61786d565b5b6000617f0d84828501617d5b565b91505092915050565b60008060008060808587031215617f3057617f2f61786d565b5b6000617f3e87828801617aa6565b9450506020617f4f87828801617aa6565b9350506040617f6087828801617d5b565b9250506060617f7187828801617d5b565b91505092959194509250565b60008060008060008060c08789031215617f9a57617f9961786d565b5b6000617fa889828a01617aa6565b9650506020617fb989828a01617aa6565b9550506040617fca89828a01617aa6565b9450506060617fdb89828a01617aa6565b9350506080617fec89828a01617d5b565b92505060a0617ffd89828a01617d5b565b9150509295509295509295565b600060608201905061801f6000830186617d1a565b61802c6020830185617d1a565b6180396040830184617d1a565b949350505050565b60008060006060848603121561805a5761805961786d565b5b600061806886828701617aa6565b935050602061807986828701617aa6565b925050604061808a86828701617d5b565b9150509250925092565b6000819050919050565b60006180b96180b46180af846179b3565b618094565b6179b3565b9050919050565b60006180cb8261809e565b9050919050565b60006180dd826180c0565b9050919050565b6180ed816180d2565b82525050565b600060208201905061810860008301846180e4565b92915050565b6000618119826179d3565b9050919050565b6181298161810e565b811461813457600080fd5b50565b60008135905061814681618120565b92915050565b6000602082840312156181625761816161786d565b5b600061817084828501618137565b91505092915050565b600080600080600060a086880312156181955761819461786d565b5b60006181a388828901617aa6565b95505060206181b488828901617aa6565b94505060406181c588828901617aa6565b93505060606181d688828901617aa6565b92505060806181e788828901617d5b565b9150509295509295909350565b60008083601f84011261820a57618209617877565b5b8235905067ffffffffffffffff8111156182275761822661787c565b5b60208301915083602082028301111561824357618242617881565b5b9250929050565b600080600080604085870312156182645761826361786d565b5b600085013567ffffffffffffffff81111561828257618281617872565b5b61828e878288016181f4565b9450945050602085013567ffffffffffffffff8111156182b1576182b0617872565b5b6182bd878288016178dc565b925092505092959194509250565b600067ffffffffffffffff8211156182e6576182e5617acc565b5b602082029050602081019050919050565b600061830a618305846182cb565b617b2c565b9050808382526020820190506020840283018581111561832d5761832c617881565b5b835b8181101561835657806183428882617aa6565b84526020840193505060208101905061832f565b5050509392505050565b600082601f83011261837557618374617877565b5b81356183858482602086016182f7565b91505092915050565b600080600080608085870312156183a8576183a761786d565b5b600085013567ffffffffffffffff8111156183c6576183c5617872565b5b6183d287828801618360565b945050602085013567ffffffffffffffff8111156183f3576183f2617872565b5b6183ff87828801617bdc565b935050604061841087828801617a3a565b925050606061842187828801617a3a565b91505092959194509250565b60007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff82169050919050565b61845e8161842d565b82525050565b600063ffffffff82169050919050565b61847d81618464565b82525050565b60006040820190506184986000830185618455565b6184a56020830184618474565b9392505050565b60006184b7826180c0565b9050919050565b6184c7816184ac565b82525050565b60006020820190506184e260008301846184be565b92915050565b60006060820190506184fd6000830186617839565b61850a6020830185617d1a565b6185176040830184617839565b949350505050565b600080604083850312156185365761853561786d565b5b600061854485828601617aa6565b925050602061855585828601617a0e565b9150509250929050565b6000602082840312156185755761857461786d565b5b600061858384828501617a0e565b91505092915050565b60006020820190506185a16000830184618455565b92915050565b600067ffffffffffffffff8211156185c2576185c1617acc565b5b602082029050602081019050919050565b60006185e66185e1846185a7565b617b2c565b9050808382526020820190506020840283018581111561860957618608617881565b5b835b81811015618632578061861e8882617d5b565b84526020840193505060208101905061860b565b5050509392505050565b600082601f83011261865157618650617877565b5b81356186618482602086016185d3565b91505092915050565b6000806000606084860312156186835761868261786d565b5b600084013567ffffffffffffffff8111156186a1576186a0617872565b5b6186ad86828701617bdc565b935050602084013567ffffffffffffffff8111156186ce576186cd617872565b5b6186da8682870161863c565b925050604084013567ffffffffffffffff8111156186fb576186fa617872565b5b6187078682870161863c565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b618746816180d2565b82525050565b6000618758838361873d565b60208301905092915050565b6000602082019050919050565b600061877c82618711565b618786818561871c565b93506187918361872d565b8060005b838110156187c25781516187a9888261874c565b97506187b483618764565b925050600181019050618795565b5085935050505092915050565b600060208201905081810360008301526187e98184618771565b905092915050565b600080604083850312156188085761880761786d565b5b600061881685828601617aa6565b925050602061882785828601617aa6565b9150509250929050565b6000602082840312156188475761884661786d565b5b600082013567ffffffffffffffff81111561886557618864617872565b5b61887184828501618360565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6188af81617d10565b82525050565b60006188c183836188a6565b60208301905092915050565b6000602082019050919050565b60006188e58261887a565b6188ef8185618885565b93506188fa83618896565b8060005b8381101561892b57815161891288826188b5565b975061891d836188cd565b9250506001810190506188fe565b5085935050505092915050565b6000602082019050818103600083015261895281846188da565b905092915050565b600060408201905061896f6000830185617d1a565b61897c6020830184617d1a565b9392505050565b6000806040838503121561899a5761899961786d565b5b60006189a885828601617a0e565b92505060206189b985828601617d5b565b9150509250929050565b600082825260208201905092915050565b7f4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f60008201527f6e00000000000000000000000000000000000000000000000000000000000000602082015250565b6000618a306021836189c3565b9150618a3b826189d4565b604082019050919050565b60006020820190508181036000830152618a5f81618a23565b9050919050565b7f416c72656164792065786563757465642074686973206f6e652d6f666620667560008201527f6e6374696f6e0000000000000000000000000000000000000000000000000000602082015250565b6000618ac26026836189c3565b9150618acd82618a66565b604082019050919050565b60006020820190508181036000830152618af181618ab5565b9050919050565b7f496e76616c696420696e70757400000000000000000000000000000000000000600082015250565b6000618b2e600d836189c3565b9150618b3982618af8565b602082019050919050565b60006020820190508181036000830152618b5d81618b21565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000618bcd82617d10565b9150618bd883617d10565b925082821015618beb57618bea618b93565b5b828203905092915050565b6000618c0182617d10565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415618c3457618c33618b93565b5b600182019050919050565b7f63616e6e6f742070617573652061206d61726b65742074686174206973206e6f60008201527f74206c6973746564000000000000000000000000000000000000000000000000602082015250565b6000618c9b6028836189c3565b9150618ca682618c3f565b604082019050919050565b60006020820190508181036000830152618cca81618c8e565b9050919050565b7f6f6e6c7920706175736520677561726469616e20616e642061646d696e20636160008201527f6e20706175736500000000000000000000000000000000000000000000000000602082015250565b6000618d2d6027836189c3565b9150618d3882618cd1565b604082019050919050565b60006020820190508181036000830152618d5c81618d20565b9050919050565b7f6f6e6c792061646d696e2063616e20756e706175736500000000000000000000600082015250565b6000618d996016836189c3565b9150618da482618d63565b602082019050919050565b60006020820190508181036000830152618dc881618d8c565b9050919050565b7f426f72726f770000000000000000000000000000000000000000000000000000600082015250565b6000618e056006836189c3565b9150618e1082618dcf565b602082019050919050565b6000606082019050618e3060008301856180e4565b8181036020830152618e4181618df8565b9050618e506040830184617839565b9392505050565b600081519050618e6681617a8f565b92915050565b600060208284031215618e8257618e8161786d565b5b6000618e9084828501618e57565b91505092915050565b7f6f6e6c7920756e6974726f6c6c65722061646d696e2063616e206368616e676560008201527f20627261696e7300000000000000000000000000000000000000000000000000602082015250565b6000618ef56027836189c3565b9150618f0082618e99565b604082019050919050565b60006020820190508181036000830152618f2481618ee8565b9050919050565b600081519050618f3a81617d44565b92915050565b600060208284031215618f5657618f5561786d565b5b6000618f6484828501618f2b565b91505092915050565b7f6368616e6765206e6f7420617574686f72697a65640000000000000000000000600082015250565b6000618fa36015836189c3565b9150618fae82618f6d565b602082019050919050565b60006020820190508181036000830152618fd281618f96565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f6f6e6c792061646d696e2063616e206772616e7420636f6d7000000000000000600082015250565b600061903e6019836189c3565b915061904982619008565b602082019050919050565b6000602082019050818103600083015261906d81619031565b9050919050565b7f696e73756666696369656e7420636f6d7020666f72206772616e740000000000600082015250565b60006190aa601b836189c3565b91506190b582619074565b602082019050919050565b600060208201905081810360008301526190d98161909d565b9050919050565b60006040820190506190f56000830185617deb565b6191026020830184617d1a565b9392505050565b7f5365697a65000000000000000000000000000000000000000000000000000000600082015250565b600061913f6005836189c3565b915061914a82619109565b602082019050919050565b6000604082019050818103600083015261916e81619132565b905061917d6020830184617839565b92915050565b7f6f6e6c792061646d696e2063616e2073657420636c6f736520666163746f7200600082015250565b60006191b9601f836189c3565b91506191c482619183565b602082019050919050565b600060208201905081810360008301526191e8816191ac565b9050919050565b7f6f6e6c792061646d696e2063616e2073657420626f72726f772063617020677560008201527f61726469616e0000000000000000000000000000000000000000000000000000602082015250565b600061924b6026836189c3565b9150619256826191ef565b604082019050919050565b6000602082019050818103600083015261927a8161923e565b9050919050565b60006040820190506192966000830185617deb565b6192a36020830184617deb565b9392505050565b7f4d696e7400000000000000000000000000000000000000000000000000000000600082015250565b60006192e06004836189c3565b91506192eb826192aa565b602082019050919050565b600060608201905061930b60008301856180e4565b818103602083015261931c816192d3565b905061932b6040830184617839565b9392505050565b7f6d696e7420697320706175736564000000000000000000000000000000000000600082015250565b6000619368600e836189c3565b915061937382619332565b602082019050919050565b600060208201905081810360008301526193978161935b565b9050919050565b7f72656465656d546f6b656e73207a65726f000000000000000000000000000000600082015250565b60006193d46011836189c3565b91506193df8261939e565b602082019050919050565b60006020820190508181036000830152619403816193c7565b9050919050565b600060408201905061941f60008301856184be565b61942c60208301846184be565b9392505050565b7f6f6e6c792061646d696e2063616e2073657420636f6d70207370656564000000600082015250565b6000619469601d836189c3565b915061947482619433565b602082019050919050565b600060208201905081810360008301526194988161945c565b9050919050565b7f43616e206e6f74207265706179206d6f7265207468616e2074686520746f746160008201527f6c20626f72726f77000000000000000000000000000000000000000000000000602082015250565b60006194fb6028836189c3565b91506195068261949f565b604082019050919050565b6000602082019050818103600083015261952a816194ee565b9050919050565b7f6f6e6c792061646d696e206f7220626f72726f7720636170206775617264696160008201527f6e2063616e2073657420626f72726f7720636170730000000000000000000000602082015250565b600061958d6035836189c3565b915061959882619531565b604082019050919050565b600060208201905081810360008301526195bc81619580565b9050919050565b7f696e76616c696420696e70757400000000000000000000000000000000000000600082015250565b60006195f9600d836189c3565b9150619604826195c3565b602082019050919050565b60006020820190508181036000830152619628816195ec565b9050919050565b7f6d61726b6574206d757374206265206c69737465640000000000000000000000600082015250565b60006196656015836189c3565b91506196708261962f565b602082019050919050565b6000602082019050818103600083015261969481619658565b9050919050565b7f5472616e73666572000000000000000000000000000000000000000000000000600082015250565b60006196d16008836189c3565b91506196dc8261969b565b602082019050919050565b60006040820190508181036000830152619700816196c4565b905061970f6020830184617839565b92915050565b60008151905061972481617a23565b92915050565b6000602082840312156197405761973f61786d565b5b600061974e84828501619715565b91505092915050565b7f436f6d7074726f6c6c65723a3a5f736574436f6d7053706565647320696e766160008201527f6c696420696e7075740000000000000000000000000000000000000000000000602082015250565b60006197b36029836189c3565b91506197be82619757565b604082019050919050565b600060208201905081810360008301526197e2816197a6565b9050919050565b7f7472616e73666572206973207061757365640000000000000000000000000000600082015250565b600061981f6012836189c3565b915061982a826197e9565b602082019050919050565b6000602082019050818103600083015261984e81619812565b9050919050565b7f7365697a65206973207061757365640000000000000000000000000000000000600082015250565b600061988b600f836189c3565b915061989682619855565b602082019050919050565b600060208201905081810360008301526198ba8161987e565b9050919050565b60006198cc826179d3565b9050919050565b6198dc816198c1565b81146198e757600080fd5b50565b6000815190506198f9816198d3565b92915050565b6000602082840312156199155761991461786d565b5b6000619923848285016198ea565b91505092915050565b7f626f72726f772069732070617573656400000000000000000000000000000000600082015250565b60006199626010836189c3565b915061996d8261992c565b602082019050919050565b6000602082019050818103600083015261999181619955565b9050919050565b7f73656e646572206d7573742062652063546f6b656e0000000000000000000000600082015250565b60006199ce6015836189c3565b91506199d982619998565b602082019050919050565b600060208201905081810360008301526199fd816199c1565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f6d61726b657420626f72726f7720636170207265616368656400000000000000600082015250565b6000619a696019836189c3565b9150619a7482619a33565b602082019050919050565b60006020820190508181036000830152619a9881619a5c565b9050919050565b6000606082019050619ab460008301866180e4565b619ac16020830185617d1a565b619ace6040830184617d1a565b949350505050565b60008060008060808587031215619af057619aef61786d565b5b6000619afe87828801618f2b565b9450506020619b0f87828801618f2b565b9350506040619b2087828801618f2b565b9250506060619b3187828801618f2b565b91505092959194509250565b7f657869744d61726b65743a206765744163636f756e74536e617073686f74206660008201527f61696c6564000000000000000000000000000000000000000000000000000000602082015250565b6000619b996025836189c3565b9150619ba482619b3d565b604082019050919050565b60006020820190508181036000830152619bc881619b8c565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6000604082019050619c1360008301856180e4565b619c206020830184617deb565b9392505050565b6000619c3282617d10565b9150619c3d83617d10565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115619c7257619c71618b93565b5b828201905092915050565b6000819050919050565b6000619ca2619c9d619c9884619c7d565b618094565b617d10565b9050919050565b619cb281619c87565b82525050565b6000606082019050619ccd6000830186617d1a565b619cda6020830185617d1a565b619ce76040830184619ca9565b949350505050565b6000619cfa82617d10565b9150619d0583617d10565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615619d3e57619d3d618b93565b5b828202905092915050565b7f6d61726b657420616c7265616479206164646564000000000000000000000000600082015250565b6000619d7f6014836189c3565b9150619d8a82619d49565b602082019050919050565b60006020820190508181036000830152619dae81619d72565b9050919050565b7f636f6d70206d61726b6574206973206e6f74206c697374656400000000000000600082015250565b6000619deb6019836189c3565b9150619df682619db5565b602082019050919050565b60006020820190508181036000830152619e1a81619dde565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000619e5b82617d10565b9150619e6683617d10565b925082619e7657619e75619e21565b5b828204905092915050565b600081519050919050565b60005b83811015619eaa578082015181840152602081019050619e8f565b83811115619eb9576000848401525b50505050565b6000619eca82619e81565b619ed481856189c3565b9350619ee4818560208601619e8c565b619eed81617abb565b840191505092915050565b60006020820190508181036000830152619f128184619ebf565b90509291505056fea2646970667358221220949641e013f0816e3c99b4a1e95fdd4ddb139bf0a3ccf92bbdf574aa6d9d2dae64736f6c634300080a0033",
  deployedBytecode: "0x608060405234801561001057600080fd5b506004361061048a5760003560e01c8063731f0c2b11610262578063b21be7fd11610151578063dce15449116100ce578063e9af029211610092578063e9af029214610ffe578063eabe7d911461101a578063ede4edd01461104a578063f00a7a921461107a578063f4a433c014611098578063f851a440146110c85761048a565b8063dce1544914610f44578063dcfbc0c714610f74578063e4028eee14610f92578063e6653f3d14610fc2578063e875544614610fe05761048a565b8063c488847b11610115578063c488847b14610e53578063ca0af04314610e84578063cc7ebdc414610eb4578063d02f735114610ee4578063da3d454c14610f145761048a565b8063b21be7fd14610d75578063bb82aa5e14610da5578063bdcdc25814610dc3578063bea6b8b814610df3578063c299823814610e235761048a565b806394b2294b116101df578063a8b43948116101a3578063a8b4394814610ccf578063aa90075414610ceb578063abfceffc14610d09578063ac0b0bb714610d39578063b0772d0b14610d575761048a565b806394b2294b14610c15578063986ab83814610c335780639d1b5a0a14610c63578063a76b3fda14610c81578063a7f0e23114610cb15761048a565b80638c57804e116102265780638c57804e14610b225780638e8f294b14610b535780638ebf636414610b85578063929fe9a114610bb557806394543c1514610be55761048a565b8063731f0c2b14610a6a578063741b252514610a9a5780637dc0d1d014610ab657806385b7beb814610ad457806387f7630314610b045761048a565b80634a5844321161037e5780635ec88c79116102fb5780636a56947e116102bf5780636a56947e146109a15780636aa875b5146109bd5780636b79c38d146109ed5780636d154ea514610a1e5780636d35bf9114610a4e5761048a565b80635ec88c79146108d75780635f5af1aa146109095780635fc7e71e14610939578063607ef6c1146109695780636810dfa6146109855761048a565b806351dff9891161034257806351dff9891461082357806352d84d1e1461083f57806355ee1fe11461086f578063598ee1cb1461089f5780635c778605146108bb5761048a565b80634a584432146107435780634ada90af146107735780634e79238f146107915780634ef4c3e1146107c35780634fd42e17146107f35761048a565b8063267822471161040c5780633bcf7ec1116103d05780633bcf7ec11461069f5780633c94786f146106cf57806341c728b9146106ed57806342cbb15c1461070957806347ef3b3b146107275761048a565b806326782247146105e957806327efe3cb146106075780632d70db7814610623578063317b0b7714610653578063391957d7146106835761048a565b80631d7b33d7116104535780631d7b33d7146105315780631ededc911461056157806321af45691461057d57806324008a621461059b57806324a3d622146105cb5761048a565b80627e3dd21461048f57806316b95e8f146104ad57806318c882a5146104c95780631c3db2e0146104f95780631d504dc614610515575b600080fd5b6104976110e6565b6040516104a49190617848565b60405180910390f35b6104c760048036038101906104c29190617932565b6110eb565b005b6104e360048036038101906104de9190617a4f565b611493565b6040516104f09190617848565b60405180910390f35b610513600480360381019061050e9190617c0a565b611740565b005b61052f600480360381019061052a9190617cb6565b6117ef565b005b61054b60048036038101906105469190617ce3565b611981565b6040516105589190617d29565b60405180910390f35b61057b60048036038101906105769190617d70565b611999565b005b6105856119b1565b6040516105929190617dfa565b60405180910390f35b6105b560048036038101906105b09190617e15565b6119d7565b6040516105c29190617d29565b60405180910390f35b6105d3611afe565b6040516105e09190617dfa565b60405180910390f35b6105f1611b24565b6040516105fe9190617dfa565b60405180910390f35b610621600480360381019061061c9190617e7c565b611b4a565b005b61063d60048036038101906106389190617ebc565b611c20565b60405161064a9190617848565b60405180910390f35b61066d60048036038101906106689190617ee9565b611dfe565b60405161067a9190617d29565b60405180910390f35b61069d60048036038101906106989190617ce3565b611ef4565b005b6106b960048036038101906106b49190617a4f565b612027565b6040516106c69190617848565b60405180910390f35b6106d76122d4565b6040516106e49190617848565b60405180910390f35b61070760048036038101906107029190617f16565b6122e7565b005b6107116122fe565b60405161071e9190617d29565b60405180910390f35b610741600480360381019061073c9190617f7d565b612306565b005b61075d60048036038101906107589190617ce3565b61231f565b60405161076a9190617d29565b60405180910390f35b61077b612337565b6040516107889190617d29565b60405180910390f35b6107ab60048036038101906107a69190617f16565b61233d565b6040516107ba9392919061800a565b60405180910390f35b6107dd60048036038101906107d89190618041565b612380565b6040516107ea9190617d29565b60405180910390f35b61080d60048036038101906108089190617ee9565b6124af565b60405161081a9190617d29565b60405180910390f35b61083d60048036038101906108389190617f16565b61257c565b005b61085960048036038101906108549190617ee9565b6125d2565b60405161086691906180f3565b60405180910390f35b6108896004803603810190610884919061814c565b612611565b6040516108969190617d29565b60405180910390f35b6108b960048036038101906108b49190617e7c565b612738565b005b6108d560048036038101906108d09190618041565b6128bb565b005b6108f160048036038101906108ec9190617ce3565b6128d1565b6040516109009392919061800a565b60405180910390f35b610923600480360381019061091e9190617ce3565b612913565b6040516109309190617d29565b60405180910390f35b610953600480360381019061094e9190618179565b612a5c565b6040516109609190617d29565b60405180910390f35b610983600480360381019061097e919061824a565b612ce5565b005b61099f600480360381019061099a919061838e565b612f63565b005b6109bb60048036038101906109b69190617e15565b61326c565b005b6109d760048036038101906109d29190617ce3565b613283565b6040516109e49190617d29565b60405180910390f35b610a076004803603810190610a029190617ce3565b61329b565b604051610a15929190618483565b60405180910390f35b610a386004803603810190610a339190617ce3565b6132f7565b604051610a459190617848565b60405180910390f35b610a686004803603810190610a639190618179565b613317565b005b610a846004803603810190610a7f9190617ce3565b61332f565b604051610a919190617848565b60405180910390f35b610ab46004803603810190610aaf9190617ce3565b61334f565b005b610abe6134ed565b604051610acb91906184cd565b60405180910390f35b610aee6004803603810190610ae99190617ce3565b613513565b604051610afb9190617d29565b60405180910390f35b610b0c61352b565b604051610b199190617848565b60405180910390f35b610b3c6004803603810190610b379190617ce3565b61353e565b604051610b4a929190618483565b60405180910390f35b610b6d6004803603810190610b689190617ce3565b61359a565b604051610b7c939291906184e8565b60405180910390f35b610b9f6004803603810190610b9a9190617ebc565b6135de565b604051610bac9190617848565b60405180910390f35b610bcf6004803603810190610bca919061851f565b6137bc565b604051610bdc9190617848565b60405180910390f35b610bff6004803603810190610bfa919061855f565b613853565b604051610c0c9190617848565b60405180910390f35b610c1d61397e565b604051610c2a9190617d29565b60405180910390f35b610c4d6004803603810190610c489190617ce3565b613984565b604051610c5a9190617d29565b60405180910390f35b610c6b61399c565b604051610c789190617dfa565b60405180910390f35b610c9b6004803603810190610c96919061855f565b6139b8565b604051610ca89190617d29565b60405180910390f35b610cb9613be6565b604051610cc6919061858c565b60405180910390f35b610ce96004803603810190610ce4919061866a565b613bf9565b005b610cf3613d11565b604051610d009190617d29565b60405180910390f35b610d236004803603810190610d1e9190617ce3565b613d17565b604051610d3091906187cf565b60405180910390f35b610d41613dea565b604051610d4e9190617848565b60405180910390f35b610d5f613dfd565b604051610d6c91906187cf565b60405180910390f35b610d8f6004803603810190610d8a91906187f1565b613e8b565b604051610d9c9190617d29565b60405180910390f35b610dad613eb0565b604051610dba9190617dfa565b60405180910390f35b610ddd6004803603810190610dd89190617e15565b613ed6565b604051610dea9190617d29565b60405180910390f35b610e0d6004803603810190610e089190617ce3565b613f97565b604051610e1a9190617d29565b60405180910390f35b610e3d6004803603810190610e389190618831565b613faf565b604051610e4a9190618938565b60405180910390f35b610e6d6004803603810190610e689190618041565b614088565b604051610e7b92919061895a565b60405180910390f35b610e9e6004803603810190610e9991906187f1565b614320565b604051610eab9190617d29565b60405180910390f35b610ece6004803603810190610ec99190617ce3565b614345565b604051610edb9190617d29565b60405180910390f35b610efe6004803603810190610ef99190618179565b61435d565b604051610f0b9190617d29565b60405180910390f35b610f2e6004803603810190610f299190618041565b6145df565b604051610f3b9190617d29565b60405180910390f35b610f5e6004803603810190610f599190617e7c565b614bdb565b604051610f6b91906180f3565b60405180910390f35b610f7c614c29565b604051610f899190617dfa565b60405180910390f35b610fac6004803603810190610fa79190618983565b614c4f565b604051610fb99190617d29565b60405180910390f35b610fca614ead565b604051610fd79190617848565b60405180910390f35b610fe8614ec0565b604051610ff59190617d29565b60405180910390f35b61101860048036038101906110139190617ce3565b614ec6565b005b611034600480360381019061102f9190618041565b614f59565b6040516110419190617d29565b60405180910390f35b611064600480360381019061105f9190617ce3565b614fbe565b6040516110719190617d29565b60405180910390f35b6110826154cd565b60405161108f9190617848565b60405180910390f35b6110b260048036038101906110ad9190617ce3565b6154e0565b6040516110bf9190617d29565b60405180910390f35b6110d06154f8565b6040516110dd9190617dfa565b60405180910390f35b600181565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611179576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161117090618a46565b60405180910390fd5b601b60009054906101000a900460ff16156111c9576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016111c090618ad8565b60405180910390fd5b818190508484905014611211576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161120890618b44565b60405180910390fd5b60008060008060005b8888905081101561146d5788888281811061123857611237618b64565b5b905060200201602081019061124d9190617ce3565b9450601460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205493508686828181106112a4576112a3618b64565b5b905060200201359250838311156113b257600084846112c39190618bc2565b90506000601c60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490506000611315828461551c565b905080601c60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508773ffffffffffffffffffffffffffffffffffffffff167f17fea09d9a7ca41b2f9f9118f18f44848a62e9c70d55dd4385131eb2cf1b7e4783836040516113a392919061895a565b60405180910390a28695505050505b600083111561145c576113c58484615532565b915081601460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508473ffffffffffffffffffffffffffffffffffffffff167f4a5c134e28b537a76546993ea37f3b60d9190476df7356d3842aa40902e20f04858460405161145392919061895a565b60405180910390a25b8061146690618bf6565b905061121a565b506001601b60006101000a81548160ff0219169083151502179055505050505050505050565b6000600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16611524576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161151b90618cb1565b60405180910390fd5b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806115cb575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b61160a576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161160190618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611668575060011515821515145b6116a7576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161169e90618daf565b60405180910390fd5b81600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055507f71aec636243f9709bb0007ae15e9afb8150ab01716d75fd7573be5cc096e03b0838360405161172f929190618e1b565b60405180910390a181905092915050565b6000600167ffffffffffffffff81111561175d5761175c617acc565b5b60405190808252806020026020018201604052801561178b5781602001602082028036833780820191505090505b50905082816000815181106117a3576117a2618b64565b5b602002602001019073ffffffffffffffffffffffffffffffffffffffff16908173ffffffffffffffffffffffffffffffffffffffff16815250506117ea8183600180612f63565b505050565b8073ffffffffffffffffffffffffffffffffffffffff1663f851a4406040518163ffffffff1660e01b8152600401602060405180830381865afa15801561183a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061185e9190618e6c565b73ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146118cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118c290618f0b565b60405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff1663c1e803346040518163ffffffff1660e01b81526004016020604051808303816000875af115801561191a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061193e9190618f40565b1461197e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161197590618fb9565b60405180910390fd5b50565b600f6020528060005260406000206000915090505481565b6000156119aa576007546007819055505b5050505050565b601560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16611a485760096011811115611a4157611a40618fd9565b5b9050611af6565b600060405180602001604052808773ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015611aa0573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611ac49190618f40565b8152509050611ad38682615548565b611ade868583615868565b60006011811115611af257611af1618fd9565b5b9150505b949350505050565b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b611b52615c24565b611b91576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611b8890619054565b60405180910390fd5b6000611b9d8383615cd3565b905060008114611be2576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611bd9906190c0565b60405180910390fd5b7f98b2f82a3a07f223a0be64b3d0f47711c64dccd1feafb94aa28156b38cd9695c8383604051611c139291906190e0565b60405180910390a1505050565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611cc9575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b611d08576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611cff90618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480611d66575060011515821515145b611da5576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d9c90618daf565b60405180910390fd5b81600a60176101000a81548160ff0219169083151502179055507fef159d9a32b2472e32b098f954f3ce62d232939f1c207070b584df1814de2de082604051611dee9190619155565b60405180910390a1819050919050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611e8f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611e86906191cf565b60405180910390fd5b60006005549050826005819055507f3b9670cf975d26958e754b57098eaa2ac914d8d2a31b83257997b9f346110fd981600554604051611ed092919061895a565b60405180910390a160006011811115611eec57611eeb618fd9565b5b915050919050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611f82576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f7990619261565b60405180910390fd5b6000601560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905081601560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507feda98690e518e9a05f8ec6837663e188211b2da8f4906648b323f2c1d4434e29818360405161201b929190619281565b60405180910390a15050565b6000600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff166120b8576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016120af90618cb1565b60405180910390fd5b600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16148061215f575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b61219e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161219590618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614806121fc575060011515821515145b61223b576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161223290618daf565b60405180910390fd5b81600b60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff0219169083151502179055507f71aec636243f9709bb0007ae15e9afb8150ab01716d75fd7573be5cc096e03b083836040516122c39291906192f6565b60405180910390a181905092915050565b600a60149054906101000a900460ff1681565b6000156122f8576007546007819055505b50505050565b600043905090565b600015612317576007546007819055505b505050505050565b60166020528060005260406000206000915090505481565b60065481565b6000806000806000806123528a8a8a8a615e09565b92509250925082601181111561236b5761236a618fd9565b5b82829550955095505050509450945094915050565b6000600b60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561240f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016124069061937e565b60405180910390fd5b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1661247e576009601181111561247757612476618fd9565b5b90506124a8565b61248784616267565b612491848461657d565b600060118111156124a5576124a4618fd9565b5b90505b9392505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612518576125116001600b61692f565b9050612577565b60006006549050826006819055507faeba5a6c40a8ac138134bff1aaa65debf25971188a58804bad717f82f0ec1316818460405161255792919061895a565b60405180910390a16000601181111561257357612572618fd9565b5b9150505b919050565b60008114801561258c5750600082115b156125cc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016125c3906193ea565b60405180910390fd5b50505050565b600d81815481106125e257600080fd5b906000526020600020016000915054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461267a576126736001601061692f565b9050612733565b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fd52b2b9b7e9ee655fcb95d2e5b9e0c9f69e7ef2b8e9d2d0ea78402d576d22e22818460405161271392919061940a565b60405180910390a16000601181111561272f5761272e618fd9565b5b9150505b919050565b612740615c24565b61277f576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016127769061947f565b60405180910390fd5b6127888261334f565b60008114156127d957601860008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009055612825565b6127e16122fe565b601860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b80601760008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508173ffffffffffffffffffffffffffffffffffffffff167f386537fa92edc3319af95f1f904dcf1900021e4f3f4e08169a577a09076e66b3826040516128af9190617d29565b60405180910390a25050565b6000156128cc576007546007819055505b505050565b6000806000806000806128e8876000806000615e09565b92509250925082601181111561290157612900618fd9565b5b82829550955095505050509193909250565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461297c576129756001601361692f565b9050612a57565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082600a60006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f0613b6ee6a04f0d09f390e4d9318894b9f6ac7fd83897cd8d18896ba579c401e81600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604051612a37929190619281565b60405180910390a160006011811115612a5357612a52618fd9565b5b9150505b919050565b6000600960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff161580612b075750600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16155b15612b275760096011811115612b2057612b1f618fd9565b5b9050612cdc565b60008673ffffffffffffffffffffffffffffffffffffffff166395dd9193856040518263ffffffff1660e01b8152600401612b629190617dfa565b602060405180830381865afa158015612b7f573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612ba39190618f40565b9050612bae87613853565b15612bfb5782811015612bf6576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612bed90619511565b60405180910390fd5b612cc4565b600080612c07866169ac565b925050915060006011811115612c2057612c1f618fd9565b5b826011811115612c3357612c32618fd9565b5b14612c5557816011811115612c4b57612c4a618fd9565b5b9350505050612cdc565b6000811415612c7c5760036011811115612c7257612c71618fd9565b5b9350505050612cdc565b6000612c986040518060200160405280600554815250856169cc565b905080861115612cc057601180811115612cb557612cb4618fd9565b5b945050505050612cdc565b5050505b60006011811115612cd857612cd7618fd9565b5b9150505b95945050505050565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480612d8c5750601560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b612dcb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612dc2906195a3565b60405180910390fd5b6000848490509050600083839050905060008214158015612deb57508082145b612e2a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612e219061960f565b60405180910390fd5b60005b82811015612f5a57848482818110612e4857612e47618b64565b5b9050602002013560166000898985818110612e6657612e65618b64565b5b9050602002016020810190612e7b919061855f565b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550868682818110612ecc57612ecb618b64565b5b9050602002016020810190612ee1919061855f565b73ffffffffffffffffffffffffffffffffffffffff167f6f1951b2aad10f3fc81b86d91105b413a5b3f847a34bbc5ce1904201b14438f6868684818110612f2b57612f2a618b64565b5b90506020020135604051612f3f9190617d29565b60405180910390a28080612f5290618bf6565b915050612e2d565b50505050505050565b60005b835181101561316b576000848281518110612f8457612f83618b64565b5b60200260200101519050600960008273ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1661301d576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016130149061967b565b60405180910390fd5b6001151584151514156130fc57600060405180602001604052808373ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613082573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906130a69190618f40565b81525090506130b58282615548565b60005b87518110156130f9576130e6838983815181106130d8576130d7618b64565b5b602002602001015184615868565b80806130f190618bf6565b9150506130b8565b50505b6001151583151514156131575761311281616267565b60005b8651811015613155576131428288838151811061313557613134618b64565b5b602002602001015161657d565b808061314d90618bf6565b915050613115565b505b50808061316390618bf6565b915050612f66565b5060005b8451811015613265576131f585828151811061318e5761318d618b64565b5b6020026020010151601460008885815181106131ad576131ac618b64565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054615cd3565b6014600087848151811061320c5761320b618b64565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550808061325d90618bf6565b91505061316f565b5050505050565b60001561327d576007546007819055505b50505050565b601a6020528060005260406000206000915090505481565b60106020528060005260406000206000915090508060000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169080600001601c9054906101000a900463ffffffff16905082565b600c6020528060005260406000206000915054906101000a900460ff1681565b600015613328576007546007819055505b5050505050565b600b6020528060005260406000206000915054906101000a900460ff1681565b6000601760008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050600061339d6122fe565b905060006133ea82601860008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054615532565b90506000811180156133fc5750600083115b156134e757600061340d82856169ed565b9050600061345a601460008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548361551c565b905080601460008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083601860008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555050505b50505050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b601c6020528060005260406000206000915090505481565b600a60169054906101000a900460ff1681565b60116020528060005260406000206000915090508060000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff169080600001601c9054906101000a900463ffffffff16905082565b60096020528060005260406000206000915090508060000160009054906101000a900460ff16908060010154908060030160009054906101000a900460ff16905083565b6000600a60009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613687575060008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b6136c6576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016136bd90618d43565b60405180910390fd5b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480613724575060011515821515145b613763576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161375a90618daf565b60405180910390fd5b81600a60166101000a81548160ff0219169083151502179055507fef159d9a32b2472e32b098f954f3ce62d232939f1c207070b584df1814de2de0826040516137ac91906196e7565b60405180910390a1819050919050565b6000600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16905092915050565b600080600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101541480156138f6575060011515600c60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515145b80156139775750670de0b6b3a76400008273ffffffffffffffffffffffffffffffffffffffff1663173b99046040518163ffffffff1660e01b8152600401602060405180830381865afa158015613951573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906139759190618f40565b145b9050919050565b60075481565b60176020528060005260406000206000915090505481565b600073c00e94cb662c3520282e6f5717214004a7f26888905090565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614613a2157613a1a6001601261692f565b9050613be1565b600960008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1615613a8957613a82600a601161692f565b9050613be1565b8173ffffffffffffffffffffffffffffffffffffffff1663fe9c44ae6040518163ffffffff1660e01b8152600401602060405180830381865afa158015613ad4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613af8919061972a565b506000600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060018160000160006101000a81548160ff02191690831515021790555060008160030160006101000a81548160ff02191690831515021790555060008160010181905550613b8983616a03565b613b9283616b3a565b7fcf583bb0c569eb967f806b11601c4cb93c10310485c67add5f8362c2f212321f83604051613bc191906180f3565b60405180910390a160006011811115613bdd57613bdc618fd9565b5b9150505b919050565b6ec097ce7bc90715b34b9f100000000081565b613c01615c24565b613c40576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613c379061947f565b60405180910390fd5b600083519050825181148015613c565750815181145b613c95576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613c8c906197c9565b60405180910390fd5b60005b81811015613d0a57613cf9858281518110613cb657613cb5618b64565b5b6020026020010151858381518110613cd157613cd0618b64565b5b6020026020010151858481518110613cec57613ceb618b64565b5b6020026020010151616dc0565b80613d0390618bf6565b9050613c98565b5050505050565b600e5481565b60606000600860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015613dda57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311613d90575b5050505050905080915050919050565b600a60179054906101000a900460ff1681565b6060600d805480602002602001604051908101604052809291908181526020018280548015613e8157602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311613e37575b5050505050905090565b6012602052816000526040600020602052806000526040600020600091509150505481565b600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600a60169054906101000a900460ff1615613f28576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613f1f90619835565b60405180910390fd5b6000613f358686856170a1565b905060006011811115613f4b57613f4a618fd9565b5b8114613f5a5780915050613f8f565b613f6386616267565b613f6d868661657d565b613f77868561657d565b60006011811115613f8b57613f8a618fd9565b5b9150505b949350505050565b60186020528060005260406000206000915090505481565b606060008251905060008167ffffffffffffffff811115613fd357613fd2617acc565b5b6040519080825280602002602001820160405280156140015781602001602082028036833780820191505090505b50905060005b8281101561407d57600085828151811061402457614023618b64565b5b602002602001015190506140388133617261565b601181111561404a57614049618fd9565b5b83838151811061405d5761405c618b64565b5b60200260200101818152505050808061407590618bf6565b915050614007565b508092505050919050565b6000806000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df876040518263ffffffff1660e01b81526004016140e891906180f3565b602060405180830381865afa158015614105573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141299190618f40565b90506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df876040518263ffffffff1660e01b815260040161418891906180f3565b602060405180830381865afa1580156141a5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906141c99190618f40565b905060008214806141da5750600081145b1561420057600d60118111156141f3576141f2618fd9565b5b6000935093505050614318565b60008673ffffffffffffffffffffffffffffffffffffffff1663182df0f56040518163ffffffff1660e01b8152600401602060405180830381865afa15801561424d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906142719190618f40565b9050600061427d61779c565b61428561779c565b61428d61779c565b6142b5604051806020016040528060065481525060405180602001604052808a815250617469565b92506142dd604051806020016040528088815250604051806020016040528088815250617469565b91506142e983836174ac565b90506142f5818b6169cc565b93506000601181111561430b5761430a618fd9565b5b8498509850505050505050505b935093915050565b6013602052816000526040600020602052806000526040600020600091509150505481565b60146020528060005260406000206000915090505481565b6000600a60179054906101000a900460ff16156143af576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016143a6906198a1565b60405180910390fd5b600960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff1615806144585750600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16155b15614478576009601181111561447157614470618fd9565b5b90506145d6565b8473ffffffffffffffffffffffffffffffffffffffff16635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa1580156144c3573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906144e791906198ff565b73ffffffffffffffffffffffffffffffffffffffff168673ffffffffffffffffffffffffffffffffffffffff16635fe3b5676040518163ffffffff1660e01b8152600401602060405180830381865afa158015614548573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061456c91906198ff565b73ffffffffffffffffffffffffffffffffffffffff16146145a2576002601181111561459b5761459a618fd9565b5b90506145d6565b6145ab86616267565b6145b5868461657d565b6145bf868561657d565b600060118111156145d3576145d2618fd9565b5b90505b95945050505050565b6000600c60008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161561466e576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161466590619978565b60405180910390fd5b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff166146dd57600960118111156146d6576146d5618fd9565b5b9050614bd4565b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166148cd578373ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146147dc576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016147d3906199e4565b60405180910390fd5b60006147e83385617261565b9050600060118111156147fe576147fd618fd9565b5b81601181111561481157614810618fd9565b5b146148315780601181111561482957614828618fd9565b5b915050614bd4565b600960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166148cb576148ca619a04565b5b505b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df866040518263ffffffff1660e01b815260040161492a91906180f3565b602060405180830381865afa158015614947573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061496b9190618f40565b141561498c57600d601181111561498557614984618fd9565b5b9050614bd4565b6000601660008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060008114614a9e5760008573ffffffffffffffffffffffffffffffffffffffff166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa158015614a25573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614a499190618f40565b90506000614a57828661551c565b9050828110614a9b576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614a9290619a7f565b60405180910390fd5b50505b600080614aae8688600088615e09565b925050915060006011811115614ac757614ac6618fd9565b5b826011811115614ada57614ad9618fd9565b5b14614afc57816011811115614af257614af1618fd9565b5b9350505050614bd4565b6000811115614b235760046011811115614b1957614b18618fd9565b5b9350505050614bd4565b600060405180602001604052808973ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614b7b573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614b9f9190618f40565b8152509050614bae8882615548565b614bb9888883615868565b60006011811115614bcd57614bcc618fd9565b5b9450505050505b9392505050565b60086020528160005260406000208181548110614bf757600080fd5b906000526020600020016000915091509054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600360009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614614cb857614cb16001600661692f565b9050614ea7565b6000600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060000160009054906101000a900460ff16614d2557614d1d6009600761692f565b915050614ea7565b6000604051806020016040528085815250905060006040518060200160405280670c7d713b49da00008152509050614d5d81836174ed565b15614d7857614d6e6006600861692f565b9350505050614ea7565b60008514158015614e2457506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df886040518263ffffffff1660e01b8152600401614de191906180f3565b602060405180830381865afa158015614dfe573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614e229190618f40565b145b15614e3f57614e35600d600961692f565b9350505050614ea7565b6000836001015490508584600101819055507f70483e6592cd5182d45ac970e05bc62cdcc90e9d8ef2c2dbe686cf383bcd7fc5878288604051614e8493929190619a9f565b60405180910390a160006011811115614ea057614e9f618fd9565b5b9450505050505b92915050565b600a60159054906101000a900460ff1681565b60055481565b614f5681600d805480602002602001604051908101604052809291908181526020018280548015614f4c57602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311614f02575b5050505050611740565b50565b600080614f678585856170a1565b905060006011811115614f7d57614f7c618fd9565b5b8114614f8c5780915050614fb7565b614f9585616267565b614f9f858561657d565b60006011811115614fb357614fb2618fd9565b5b9150505b9392505050565b60008082905060008060008373ffffffffffffffffffffffffffffffffffffffff1663c37f68e2336040518263ffffffff1660e01b81526004016150029190617dfa565b608060405180830381865afa15801561501f573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906150439190619ad6565b509250925092506000831461508d576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161508490619baf565b60405180910390fd5b600081146150ac576150a1600c600261692f565b9450505050506154c8565b60006150b98733856170a1565b9050600081146150dc576150d0600e600383617502565b955050505050506154c8565b6000600960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060020160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff16615193576000601181111561518657615185618fd9565b5b96505050505050506154c8565b8060020160003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81549060ff02191690556000600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208054806020026020016040519081016040528092919081815260200182805480156152a557602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001906001019080831161525b575b50505050509050600081519050600081905060005b8281101561532b578973ffffffffffffffffffffffffffffffffffffffff168482815181106152ec576152eb618b64565b5b602002602001015173ffffffffffffffffffffffffffffffffffffffff1614156153185780915061532b565b808061532390618bf6565b9150506152ba565b5081811061533c5761533b619a04565b5b6000600860003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905080600182805490506153919190618bc2565b815481106153a2576153a1618b64565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff168183815481106153e0576153df618b64565b5b9060005260206000200160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055508080548061543957615438619bcf565b5b6001900381819060005260206000200160006101000a81549073ffffffffffffffffffffffffffffffffffffffff021916905590557fe699a64c18b07ac5b7301aa273f36a2287239eb9501d81950672794afba29a0d8a3360405161549f929190619bfe565b60405180910390a1600060118111156154bb576154ba618fd9565b5b9a50505050505050505050505b919050565b601b60009054906101000a900460ff1681565b60196020528060005260406000206000915090505481565b60008054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000818361552a9190619c27565b905092915050565b600081836155409190618bc2565b905092915050565b6000601160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000601960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060006156176155dc6122fe565b6040518060400160405280601c81526020017f626c6f636b206e756d626572206578636565647320333220626974730000000081525061757f565b905060006156458263ffffffff1685600001601c9054906101000a900463ffffffff1663ffffffff16615532565b90506000811180156156575750600083115b156158325760006156d68773ffffffffffffffffffffffffffffffffffffffff166347bd37186040518163ffffffff1660e01b8152600401602060405180830381865afa1580156156ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906156d09190618f40565b876175d5565b905060006156e483866169ed565b90506000808311615704576040518060200160405280600081525061570f565b61570e82846175fe565b5b90506157b561577660405180602001604052808a60000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168152508361763e565b600001516040518060400160405280601a81526020017f6e657720696e646578206578636565647320323234206269747300000000000081525061766e565b8760000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508487600001601c6101000a81548163ffffffff021916908363ffffffff160217905550505050615860565b600081111561585f578184600001601c6101000a81548163ffffffff021916908363ffffffff1602179055505b5b505050505050565b6000601160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690506000601360008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081601360008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002081905550600081148015615a3957506ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168210155b15615a6f576ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690505b60006040518060200160405280615a868585615532565b81525090506000615b108873ffffffffffffffffffffffffffffffffffffffff166395dd9193896040518263ffffffff1660e01b8152600401615ac99190617dfa565b602060405180830381865afa158015615ae6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615b0a9190618f40565b876175d5565b90506000615b1e82846176dc565b90506000615b6b601460008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548361551c565b905080601460008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508873ffffffffffffffffffffffffffffffffffffffff168a73ffffffffffffffffffffffffffffffffffffffff167f1fc3ecc087d8d2d15e23d0032af5a47059c3892d003d8e139fdcb6bb327c99a68489604051615c1092919061895a565b60405180910390a350505050505050505050565b60008060009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161480615cce5750600260009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b905090565b600080615cde61399c565b905060008173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401615d1b9190617dfa565b602060405180830381865afa158015615d38573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615d5c9190618f40565b9050600084118015615d6e5750808411155b15615dfd578173ffffffffffffffffffffffffffffffffffffffff1663a9059cbb86866040518363ffffffff1660e01b8152600401615dae9291906190e0565b6020604051808303816000875af1158015615dcd573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615df1919061972a565b50600092505050615e03565b83925050505b92915050565b6000806000615e166177af565b600080600860008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020805480602002602001604051908101604052809291908181526020018280548015615ed857602002820191906000526020600020905b8160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019060010190808311615e8e575b5050505050905060005b8151811015616205576000828281518110615f0057615eff618b64565b5b602002602001015190508073ffffffffffffffffffffffffffffffffffffffff1663c37f68e28d6040518263ffffffff1660e01b8152600401615f439190617dfa565b608060405180830381865afa158015615f60573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190615f849190619ad6565b88604001896060018a6080018381525083815250838152508397505050505060008414615fc057600f600080975097509750505050505061625d565b6040518060200160405280600960008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600101548152508560c00181905250604051806020016040528086608001518152508560e00181905250600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663fc57d4df826040518263ffffffff1660e01b815260040161608f91906180f3565b602060405180830381865afa1580156160ac573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906160d09190618f40565b8560a001818152505060008560a0015114156160fb57600d600080975097509750505050505061625d565b60405180602001604052808660a0015181525085610100018190525061613761612c8660c001518760e00151617469565b866101000151617469565b8561012001819052506161588561012001518660400151876000015161770e565b8560000181815250506161798561010001518660600151876020015161770e565b8560200181815250508a73ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff1614156161f1576161ca8561012001518b876020015161770e565b8560200181815250506161e78561010001518a876020015161770e565b8560200181815250505b5080806161fd90618bf6565b915050615ee2565b5082602001518360000151111561623c5760008360200151846000015161622c9190618bc2565b600095509550955050505061625d565b600080846000015185602001516162539190618bc2565b9550955095505050505b9450945094915050565b6000601060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000601a60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905060006163366162fb6122fe565b6040518060400160405280601c81526020017f626c6f636b206e756d626572206578636565647320333220626974730000000081525061757f565b905060006163648263ffffffff1685600001601c9054906101000a900463ffffffff1663ffffffff16615532565b90506000811180156163765750600083115b156165485760008573ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156163c8573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906163ec9190618f40565b905060006163fa83866169ed565b9050600080831161641a5760405180602001604052806000815250616425565b61642482846175fe565b5b90506164cb61648c60405180602001604052808a60000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168152508361763e565b600001516040518060400160405280601a81526020017f6e657720696e646578206578636565647320323234206269747300000000000081525061766e565b8760000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055508487600001601c6101000a81548163ffffffff021916908363ffffffff160217905550505050616576565b6000811115616575578184600001601c6101000a81548163ffffffff021916908363ffffffff1602179055505b5b5050505050565b6000601060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008160000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690506000601260008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905081601260008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555060008114801561674e57506ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff168210155b15616784576ec097ce7bc90715b34b9f10000000007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1690505b6000604051806020016040528061679b8585615532565b815250905060008673ffffffffffffffffffffffffffffffffffffffff166370a08231876040518263ffffffff1660e01b81526004016167db9190617dfa565b602060405180830381865afa1580156167f8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061681c9190618f40565b9050600061682a82846176dc565b90506000616877601460008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548361551c565b905080601460008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167f2caecd17d02f56fa897705dcc740da2d237c373f70686f4e0d9bd3bf0400ea7a848960405161691c92919061895a565b60405180910390a3505050505050505050565b60007f45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa083601181111561696557616964618fd9565b5b83601381111561697857616977618fd9565b5b600060405161698993929190619cb8565b60405180910390a18260118111156169a4576169a3618fd9565b5b905092915050565b60008060006169bf846000806000615e09565b9250925092509193909250565b6000806169d98484617739565b90506169e481617765565b91505092915050565b600081836169fb9190619cef565b905092915050565b60005b600d80549050811015616ad3578173ffffffffffffffffffffffffffffffffffffffff16600d8281548110616a3e57616a3d618b64565b5b9060005260206000200160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff161415616ac0576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401616ab790619d95565b60405180910390fd5b8080616acb90618bf6565b915050616a06565b50600d819080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff16021790555050565b6000616b82616b476122fe565b6040518060400160405280601c81526020017f626c6f636b206e756d626572206578636565647320333220626974730000000081525061757f565b90506000601060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090506000601160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020905060008260000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161415616cc0576ec097ce7bc90715b34b9f10000000008260000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055505b60008160000160009054906101000a90047bffffffffffffffffffffffffffffffffffffffffffffffffffffffff167bffffffffffffffffffffffffffffffffffffffffffffffffffffffff161415616d76576ec097ce7bc90715b34b9f10000000008160000160006101000a8154817bffffffffffffffffffffffffffffffffffffffffffffffffffffffff02191690837bffffffffffffffffffffffffffffffffffffffffffffffffffffffff1602179055505b8281600001601c6101000a81548163ffffffff021916908363ffffffff160217905582600001601c6101000a81548163ffffffff021916908363ffffffff16021790555050505050565b6000600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060000160009054906101000a900460ff16616e54576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401616e4b90619e01565b60405180910390fd5b82601a60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205414616f3657616ea384616267565b82601a60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508373ffffffffffffffffffffffffffffffffffffffff167fdeafccd0c0b768b2529f7dcbbe58e155d6023059150b7490ed4535cc3744b92d84604051616f2d9190617d29565b60405180910390a25b81601960008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541461709b57600060405180602001604052808673ffffffffffffffffffffffffffffffffffffffff1663aa5af0fd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015616fd4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190616ff89190618f40565b81525090506170078582615548565b82601960008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508473ffffffffffffffffffffffffffffffffffffffff167f20af8e791cc98f74b2d7a391c80980ca8e5aebf3d4060bf581997b6acae2e537846040516170919190617d29565b60405180910390a2505b50505050565b6000600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000160009054906101000a900460ff16617112576009601181111561710b5761710a618fd9565b5b905061725a565b600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060020160008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff166171be57600060118111156171b7576171b6618fd9565b5b905061725a565b6000806171ce8587866000615e09565b9250509150600060118111156171e7576171e6618fd9565b5b8260118111156171fa576171f9618fd9565b5b1461721b5781601181111561721257617211618fd9565b5b9250505061725a565b6000811115617241576004601181111561723857617237618fd9565b5b9250505061725a565b6000601181111561725557617254618fd9565b5b925050505b9392505050565b600080600960008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002090508060000160009054906101000a900460ff166172c5576009915050617463565b600115158160020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060009054906101000a900460ff161515141561732a576000915050617463565b60018160020160008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060006101000a81548160ff021916908315150217905550600860008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020849080600181540180825580915050600190039060005260206000200160009091909190916101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f3ab23ab0d51cccc0c3085aec51f99228625aa1a922b3a8ca89a26b0f2027a1a58484604051617455929190619bfe565b60405180910390a160009150505b92915050565b61747161779c565b6040518060200160405280670de0b6b3a7640000617497866000015186600001516169ed565b6174a19190619e50565b815250905092915050565b6174b461779c565b60405180602001604052806174e26174d88660000151670de0b6b3a76400006169ed565b8560000151617786565b815250905092915050565b60008160000151836000015110905092915050565b60007f45b96fe442630264581b197e84bbada861235052c5a1aadfff9ea4e40a969aa084601181111561753857617537618fd9565b5b84601381111561754b5761754a618fd9565b5b8460405161755b9392919061800a565b60405180910390a183601181111561757657617575618fd9565b5b90509392505050565b6000640100000000831082906175cb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016175c29190619ef8565b60405180910390fd5b5082905092915050565b60006175f66175ec84670de0b6b3a76400006169ed565b8360000151617786565b905092915050565b61760661781a565b604051806020016040528061763361762d866ec097ce7bc90715b34b9f10000000006169ed565b85617786565b815250905092915050565b61764661781a565b60405180602001604052806176638560000151856000015161551c565b815250905092915050565b60007c0100000000000000000000000000000000000000000000000000000000831082906176d2576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016176c99190619ef8565b60405180910390fd5b5082905092915050565b60006ec097ce7bc90715b34b9f10000000006176fc8484600001516169ed565b6177069190619e50565b905092915050565b60008061771b8585617739565b905061772f61772982617765565b8461551c565b9150509392505050565b61774161779c565b604051806020016040528061775a8560000151856169ed565b815250905092915050565b6000670de0b6b3a7640000826000015161777f9190619e50565b9050919050565b600081836177949190619e50565b905092915050565b6040518060200160405280600081525090565b6040518061014001604052806000815260200160008152602001600081526020016000815260200160008152602001600081526020016177ed61779c565b81526020016177fa61779c565b815260200161780761779c565b815260200161781461779c565b81525090565b6040518060200160405280600081525090565b60008115159050919050565b6178428161782d565b82525050565b600060208201905061785d6000830184617839565b92915050565b6000604051905090565b600080fd5b600080fd5b600080fd5b600080fd5b600080fd5b60008083601f84011261789c5761789b617877565b5b8235905067ffffffffffffffff8111156178b9576178b861787c565b5b6020830191508360208202830111156178d5576178d4617881565b5b9250929050565b60008083601f8401126178f2576178f1617877565b5b8235905067ffffffffffffffff81111561790f5761790e61787c565b5b60208301915083602082028301111561792b5761792a617881565b5b9250929050565b6000806000806040858703121561794c5761794b61786d565b5b600085013567ffffffffffffffff81111561796a57617969617872565b5b61797687828801617886565b9450945050602085013567ffffffffffffffff81111561799957617998617872565b5b6179a5878288016178dc565b925092505092959194509250565b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b60006179de826179b3565b9050919050565b60006179f0826179d3565b9050919050565b617a00816179e5565b8114617a0b57600080fd5b50565b600081359050617a1d816179f7565b92915050565b617a2c8161782d565b8114617a3757600080fd5b50565b600081359050617a4981617a23565b92915050565b60008060408385031215617a6657617a6561786d565b5b6000617a7485828601617a0e565b9250506020617a8585828601617a3a565b9150509250929050565b617a98816179d3565b8114617aa357600080fd5b50565b600081359050617ab581617a8f565b92915050565b6000601f19601f8301169050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b617b0482617abb565b810181811067ffffffffffffffff82111715617b2357617b22617acc565b5b80604052505050565b6000617b36617863565b9050617b428282617afb565b919050565b600067ffffffffffffffff821115617b6257617b61617acc565b5b602082029050602081019050919050565b6000617b86617b8184617b47565b617b2c565b90508083825260208201905060208402830185811115617ba957617ba8617881565b5b835b81811015617bd25780617bbe8882617a0e565b845260208401935050602081019050617bab565b5050509392505050565b600082601f830112617bf157617bf0617877565b5b8135617c01848260208601617b73565b91505092915050565b60008060408385031215617c2157617c2061786d565b5b6000617c2f85828601617aa6565b925050602083013567ffffffffffffffff811115617c5057617c4f617872565b5b617c5c85828601617bdc565b9150509250929050565b6000617c71826179b3565b9050919050565b6000617c8382617c66565b9050919050565b617c9381617c78565b8114617c9e57600080fd5b50565b600081359050617cb081617c8a565b92915050565b600060208284031215617ccc57617ccb61786d565b5b6000617cda84828501617ca1565b91505092915050565b600060208284031215617cf957617cf861786d565b5b6000617d0784828501617aa6565b91505092915050565b6000819050919050565b617d2381617d10565b82525050565b6000602082019050617d3e6000830184617d1a565b92915050565b617d4d81617d10565b8114617d5857600080fd5b50565b600081359050617d6a81617d44565b92915050565b600080600080600060a08688031215617d8c57617d8b61786d565b5b6000617d9a88828901617aa6565b9550506020617dab88828901617aa6565b9450506040617dbc88828901617aa6565b9350506060617dcd88828901617d5b565b9250506080617dde88828901617d5b565b9150509295509295909350565b617df4816179d3565b82525050565b6000602082019050617e0f6000830184617deb565b92915050565b60008060008060808587031215617e2f57617e2e61786d565b5b6000617e3d87828801617aa6565b9450506020617e4e87828801617aa6565b9350506040617e5f87828801617aa6565b9250506060617e7087828801617d5b565b91505092959194509250565b60008060408385031215617e9357617e9261786d565b5b6000617ea185828601617aa6565b9250506020617eb285828601617d5b565b9150509250929050565b600060208284031215617ed257617ed161786d565b5b6000617ee084828501617a3a565b91505092915050565b600060208284031215617eff57617efe61786d565b5b6000617f0d84828501617d5b565b91505092915050565b60008060008060808587031215617f3057617f2f61786d565b5b6000617f3e87828801617aa6565b9450506020617f4f87828801617aa6565b9350506040617f6087828801617d5b565b9250506060617f7187828801617d5b565b91505092959194509250565b60008060008060008060c08789031215617f9a57617f9961786d565b5b6000617fa889828a01617aa6565b9650506020617fb989828a01617aa6565b9550506040617fca89828a01617aa6565b9450506060617fdb89828a01617aa6565b9350506080617fec89828a01617d5b565b92505060a0617ffd89828a01617d5b565b9150509295509295509295565b600060608201905061801f6000830186617d1a565b61802c6020830185617d1a565b6180396040830184617d1a565b949350505050565b60008060006060848603121561805a5761805961786d565b5b600061806886828701617aa6565b935050602061807986828701617aa6565b925050604061808a86828701617d5b565b9150509250925092565b6000819050919050565b60006180b96180b46180af846179b3565b618094565b6179b3565b9050919050565b60006180cb8261809e565b9050919050565b60006180dd826180c0565b9050919050565b6180ed816180d2565b82525050565b600060208201905061810860008301846180e4565b92915050565b6000618119826179d3565b9050919050565b6181298161810e565b811461813457600080fd5b50565b60008135905061814681618120565b92915050565b6000602082840312156181625761816161786d565b5b600061817084828501618137565b91505092915050565b600080600080600060a086880312156181955761819461786d565b5b60006181a388828901617aa6565b95505060206181b488828901617aa6565b94505060406181c588828901617aa6565b93505060606181d688828901617aa6565b92505060806181e788828901617d5b565b9150509295509295909350565b60008083601f84011261820a57618209617877565b5b8235905067ffffffffffffffff8111156182275761822661787c565b5b60208301915083602082028301111561824357618242617881565b5b9250929050565b600080600080604085870312156182645761826361786d565b5b600085013567ffffffffffffffff81111561828257618281617872565b5b61828e878288016181f4565b9450945050602085013567ffffffffffffffff8111156182b1576182b0617872565b5b6182bd878288016178dc565b925092505092959194509250565b600067ffffffffffffffff8211156182e6576182e5617acc565b5b602082029050602081019050919050565b600061830a618305846182cb565b617b2c565b9050808382526020820190506020840283018581111561832d5761832c617881565b5b835b8181101561835657806183428882617aa6565b84526020840193505060208101905061832f565b5050509392505050565b600082601f83011261837557618374617877565b5b81356183858482602086016182f7565b91505092915050565b600080600080608085870312156183a8576183a761786d565b5b600085013567ffffffffffffffff8111156183c6576183c5617872565b5b6183d287828801618360565b945050602085013567ffffffffffffffff8111156183f3576183f2617872565b5b6183ff87828801617bdc565b935050604061841087828801617a3a565b925050606061842187828801617a3a565b91505092959194509250565b60007bffffffffffffffffffffffffffffffffffffffffffffffffffffffff82169050919050565b61845e8161842d565b82525050565b600063ffffffff82169050919050565b61847d81618464565b82525050565b60006040820190506184986000830185618455565b6184a56020830184618474565b9392505050565b60006184b7826180c0565b9050919050565b6184c7816184ac565b82525050565b60006020820190506184e260008301846184be565b92915050565b60006060820190506184fd6000830186617839565b61850a6020830185617d1a565b6185176040830184617839565b949350505050565b600080604083850312156185365761853561786d565b5b600061854485828601617aa6565b925050602061855585828601617a0e565b9150509250929050565b6000602082840312156185755761857461786d565b5b600061858384828501617a0e565b91505092915050565b60006020820190506185a16000830184618455565b92915050565b600067ffffffffffffffff8211156185c2576185c1617acc565b5b602082029050602081019050919050565b60006185e66185e1846185a7565b617b2c565b9050808382526020820190506020840283018581111561860957618608617881565b5b835b81811015618632578061861e8882617d5b565b84526020840193505060208101905061860b565b5050509392505050565b600082601f83011261865157618650617877565b5b81356186618482602086016185d3565b91505092915050565b6000806000606084860312156186835761868261786d565b5b600084013567ffffffffffffffff8111156186a1576186a0617872565b5b6186ad86828701617bdc565b935050602084013567ffffffffffffffff8111156186ce576186cd617872565b5b6186da8682870161863c565b925050604084013567ffffffffffffffff8111156186fb576186fa617872565b5b6187078682870161863c565b9150509250925092565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b618746816180d2565b82525050565b6000618758838361873d565b60208301905092915050565b6000602082019050919050565b600061877c82618711565b618786818561871c565b93506187918361872d565b8060005b838110156187c25781516187a9888261874c565b97506187b483618764565b925050600181019050618795565b5085935050505092915050565b600060208201905081810360008301526187e98184618771565b905092915050565b600080604083850312156188085761880761786d565b5b600061881685828601617aa6565b925050602061882785828601617aa6565b9150509250929050565b6000602082840312156188475761884661786d565b5b600082013567ffffffffffffffff81111561886557618864617872565b5b61887184828501618360565b91505092915050565b600081519050919050565b600082825260208201905092915050565b6000819050602082019050919050565b6188af81617d10565b82525050565b60006188c183836188a6565b60208301905092915050565b6000602082019050919050565b60006188e58261887a565b6188ef8185618885565b93506188fa83618896565b8060005b8381101561892b57815161891288826188b5565b975061891d836188cd565b9250506001810190506188fe565b5085935050505092915050565b6000602082019050818103600083015261895281846188da565b905092915050565b600060408201905061896f6000830185617d1a565b61897c6020830184617d1a565b9392505050565b6000806040838503121561899a5761899961786d565b5b60006189a885828601617a0e565b92505060206189b985828601617d5b565b9150509250929050565b600082825260208201905092915050565b7f4f6e6c792061646d696e2063616e2063616c6c20746869732066756e6374696f60008201527f6e00000000000000000000000000000000000000000000000000000000000000602082015250565b6000618a306021836189c3565b9150618a3b826189d4565b604082019050919050565b60006020820190508181036000830152618a5f81618a23565b9050919050565b7f416c72656164792065786563757465642074686973206f6e652d6f666620667560008201527f6e6374696f6e0000000000000000000000000000000000000000000000000000602082015250565b6000618ac26026836189c3565b9150618acd82618a66565b604082019050919050565b60006020820190508181036000830152618af181618ab5565b9050919050565b7f496e76616c696420696e70757400000000000000000000000000000000000000600082015250565b6000618b2e600d836189c3565b9150618b3982618af8565b602082019050919050565b60006020820190508181036000830152618b5d81618b21565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603260045260246000fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b6000618bcd82617d10565b9150618bd883617d10565b925082821015618beb57618bea618b93565b5b828203905092915050565b6000618c0182617d10565b91507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff821415618c3457618c33618b93565b5b600182019050919050565b7f63616e6e6f742070617573652061206d61726b65742074686174206973206e6f60008201527f74206c6973746564000000000000000000000000000000000000000000000000602082015250565b6000618c9b6028836189c3565b9150618ca682618c3f565b604082019050919050565b60006020820190508181036000830152618cca81618c8e565b9050919050565b7f6f6e6c7920706175736520677561726469616e20616e642061646d696e20636160008201527f6e20706175736500000000000000000000000000000000000000000000000000602082015250565b6000618d2d6027836189c3565b9150618d3882618cd1565b604082019050919050565b60006020820190508181036000830152618d5c81618d20565b9050919050565b7f6f6e6c792061646d696e2063616e20756e706175736500000000000000000000600082015250565b6000618d996016836189c3565b9150618da482618d63565b602082019050919050565b60006020820190508181036000830152618dc881618d8c565b9050919050565b7f426f72726f770000000000000000000000000000000000000000000000000000600082015250565b6000618e056006836189c3565b9150618e1082618dcf565b602082019050919050565b6000606082019050618e3060008301856180e4565b8181036020830152618e4181618df8565b9050618e506040830184617839565b9392505050565b600081519050618e6681617a8f565b92915050565b600060208284031215618e8257618e8161786d565b5b6000618e9084828501618e57565b91505092915050565b7f6f6e6c7920756e6974726f6c6c65722061646d696e2063616e206368616e676560008201527f20627261696e7300000000000000000000000000000000000000000000000000602082015250565b6000618ef56027836189c3565b9150618f0082618e99565b604082019050919050565b60006020820190508181036000830152618f2481618ee8565b9050919050565b600081519050618f3a81617d44565b92915050565b600060208284031215618f5657618f5561786d565b5b6000618f6484828501618f2b565b91505092915050565b7f6368616e6765206e6f7420617574686f72697a65640000000000000000000000600082015250565b6000618fa36015836189c3565b9150618fae82618f6d565b602082019050919050565b60006020820190508181036000830152618fd281618f96565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602160045260246000fd5b7f6f6e6c792061646d696e2063616e206772616e7420636f6d7000000000000000600082015250565b600061903e6019836189c3565b915061904982619008565b602082019050919050565b6000602082019050818103600083015261906d81619031565b9050919050565b7f696e73756666696369656e7420636f6d7020666f72206772616e740000000000600082015250565b60006190aa601b836189c3565b91506190b582619074565b602082019050919050565b600060208201905081810360008301526190d98161909d565b9050919050565b60006040820190506190f56000830185617deb565b6191026020830184617d1a565b9392505050565b7f5365697a65000000000000000000000000000000000000000000000000000000600082015250565b600061913f6005836189c3565b915061914a82619109565b602082019050919050565b6000604082019050818103600083015261916e81619132565b905061917d6020830184617839565b92915050565b7f6f6e6c792061646d696e2063616e2073657420636c6f736520666163746f7200600082015250565b60006191b9601f836189c3565b91506191c482619183565b602082019050919050565b600060208201905081810360008301526191e8816191ac565b9050919050565b7f6f6e6c792061646d696e2063616e2073657420626f72726f772063617020677560008201527f61726469616e0000000000000000000000000000000000000000000000000000602082015250565b600061924b6026836189c3565b9150619256826191ef565b604082019050919050565b6000602082019050818103600083015261927a8161923e565b9050919050565b60006040820190506192966000830185617deb565b6192a36020830184617deb565b9392505050565b7f4d696e7400000000000000000000000000000000000000000000000000000000600082015250565b60006192e06004836189c3565b91506192eb826192aa565b602082019050919050565b600060608201905061930b60008301856180e4565b818103602083015261931c816192d3565b905061932b6040830184617839565b9392505050565b7f6d696e7420697320706175736564000000000000000000000000000000000000600082015250565b6000619368600e836189c3565b915061937382619332565b602082019050919050565b600060208201905081810360008301526193978161935b565b9050919050565b7f72656465656d546f6b656e73207a65726f000000000000000000000000000000600082015250565b60006193d46011836189c3565b91506193df8261939e565b602082019050919050565b60006020820190508181036000830152619403816193c7565b9050919050565b600060408201905061941f60008301856184be565b61942c60208301846184be565b9392505050565b7f6f6e6c792061646d696e2063616e2073657420636f6d70207370656564000000600082015250565b6000619469601d836189c3565b915061947482619433565b602082019050919050565b600060208201905081810360008301526194988161945c565b9050919050565b7f43616e206e6f74207265706179206d6f7265207468616e2074686520746f746160008201527f6c20626f72726f77000000000000000000000000000000000000000000000000602082015250565b60006194fb6028836189c3565b91506195068261949f565b604082019050919050565b6000602082019050818103600083015261952a816194ee565b9050919050565b7f6f6e6c792061646d696e206f7220626f72726f7720636170206775617264696160008201527f6e2063616e2073657420626f72726f7720636170730000000000000000000000602082015250565b600061958d6035836189c3565b915061959882619531565b604082019050919050565b600060208201905081810360008301526195bc81619580565b9050919050565b7f696e76616c696420696e70757400000000000000000000000000000000000000600082015250565b60006195f9600d836189c3565b9150619604826195c3565b602082019050919050565b60006020820190508181036000830152619628816195ec565b9050919050565b7f6d61726b6574206d757374206265206c69737465640000000000000000000000600082015250565b60006196656015836189c3565b91506196708261962f565b602082019050919050565b6000602082019050818103600083015261969481619658565b9050919050565b7f5472616e73666572000000000000000000000000000000000000000000000000600082015250565b60006196d16008836189c3565b91506196dc8261969b565b602082019050919050565b60006040820190508181036000830152619700816196c4565b905061970f6020830184617839565b92915050565b60008151905061972481617a23565b92915050565b6000602082840312156197405761973f61786d565b5b600061974e84828501619715565b91505092915050565b7f436f6d7074726f6c6c65723a3a5f736574436f6d7053706565647320696e766160008201527f6c696420696e7075740000000000000000000000000000000000000000000000602082015250565b60006197b36029836189c3565b91506197be82619757565b604082019050919050565b600060208201905081810360008301526197e2816197a6565b9050919050565b7f7472616e73666572206973207061757365640000000000000000000000000000600082015250565b600061981f6012836189c3565b915061982a826197e9565b602082019050919050565b6000602082019050818103600083015261984e81619812565b9050919050565b7f7365697a65206973207061757365640000000000000000000000000000000000600082015250565b600061988b600f836189c3565b915061989682619855565b602082019050919050565b600060208201905081810360008301526198ba8161987e565b9050919050565b60006198cc826179d3565b9050919050565b6198dc816198c1565b81146198e757600080fd5b50565b6000815190506198f9816198d3565b92915050565b6000602082840312156199155761991461786d565b5b6000619923848285016198ea565b91505092915050565b7f626f72726f772069732070617573656400000000000000000000000000000000600082015250565b60006199626010836189c3565b915061996d8261992c565b602082019050919050565b6000602082019050818103600083015261999181619955565b9050919050565b7f73656e646572206d7573742062652063546f6b656e0000000000000000000000600082015250565b60006199ce6015836189c3565b91506199d982619998565b602082019050919050565b600060208201905081810360008301526199fd816199c1565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052600160045260246000fd5b7f6d61726b657420626f72726f7720636170207265616368656400000000000000600082015250565b6000619a696019836189c3565b9150619a7482619a33565b602082019050919050565b60006020820190508181036000830152619a9881619a5c565b9050919050565b6000606082019050619ab460008301866180e4565b619ac16020830185617d1a565b619ace6040830184617d1a565b949350505050565b60008060008060808587031215619af057619aef61786d565b5b6000619afe87828801618f2b565b9450506020619b0f87828801618f2b565b9350506040619b2087828801618f2b565b9250506060619b3187828801618f2b565b91505092959194509250565b7f657869744d61726b65743a206765744163636f756e74536e617073686f74206660008201527f61696c6564000000000000000000000000000000000000000000000000000000602082015250565b6000619b996025836189c3565b9150619ba482619b3d565b604082019050919050565b60006020820190508181036000830152619bc881619b8c565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052603160045260246000fd5b6000604082019050619c1360008301856180e4565b619c206020830184617deb565b9392505050565b6000619c3282617d10565b9150619c3d83617d10565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff03821115619c7257619c71618b93565b5b828201905092915050565b6000819050919050565b6000619ca2619c9d619c9884619c7d565b618094565b617d10565b9050919050565b619cb281619c87565b82525050565b6000606082019050619ccd6000830186617d1a565b619cda6020830185617d1a565b619ce76040830184619ca9565b949350505050565b6000619cfa82617d10565b9150619d0583617d10565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0483118215151615619d3e57619d3d618b93565b5b828202905092915050565b7f6d61726b657420616c7265616479206164646564000000000000000000000000600082015250565b6000619d7f6014836189c3565b9150619d8a82619d49565b602082019050919050565b60006020820190508181036000830152619dae81619d72565b9050919050565b7f636f6d70206d61726b6574206973206e6f74206c697374656400000000000000600082015250565b6000619deb6019836189c3565b9150619df682619db5565b602082019050919050565b60006020820190508181036000830152619e1a81619dde565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b6000619e5b82617d10565b9150619e6683617d10565b925082619e7657619e75619e21565b5b828204905092915050565b600081519050919050565b60005b83811015619eaa578082015181840152602081019050619e8f565b83811115619eb9576000848401525b50505050565b6000619eca82619e81565b619ed481856189c3565b9350619ee4818560208601619e8c565b619eed81617abb565b840191505092915050565b60006020820190508181036000830152619f128184619ebf565b90509291505056fea2646970667358221220949641e013f0816e3c99b4a1e95fdd4ddb139bf0a3ccf92bbdf574aa6d9d2dae64736f6c634300080a0033",
  linkReferences: {},
  deployedLinkReferences: {}
};

// packages/compound-v2-liquidator/src/comptroller/comptroller.constants.ts
var CompEventName;
(function(CompEventName2) {
  CompEventName2["MarketListed"] = "MarketListed";
  CompEventName2["MarketEntered"] = "MarketEntered";
  CompEventName2["MarketExited"] = "MarketExited";
  CompEventName2["NewCloseFactor"] = "NewCloseFactor";
  CompEventName2["NewCollateralFactor"] = "NewCollateralFactor";
  CompEventName2["NewPriceOracle"] = "NewPriceOracle";
  CompEventName2["NewLiquidationIncentive"] = "NewLiquidationIncentive";
})(CompEventName || (CompEventName = {}));
var CompEventToOutputMap = {
  [CompEventName.MarketListed]: "cToken",
  [CompEventName.MarketEntered]: "cToken,account",
  [CompEventName.MarketExited]: "cToken,account",
  [CompEventName.NewCloseFactor]: "newCloseFactorMantissa",
  [CompEventName.NewCollateralFactor]: "cToken,newCollateralFactorMantissa",
  [CompEventName.NewLiquidationIncentive]: "newLiquidationIncentiveMantissa",
  [CompEventName.NewPriceOracle]: "newPriceOracle"
};

// packages/compound-v2-liquidator/src/comptroller/comptroller.service.ts
class ComptrollerService extends Service {
  storageService;
  web3Service;
  marketService;
  accountService;
  priceOracleService;
  workerService;
  constructor(storageService, web3Service, marketService, accountService, priceOracleService, workerService) {
    super();
    this.storageService = storageService;
    this.web3Service = web3Service;
    this.marketService = marketService;
    this.accountService = accountService;
    this.priceOracleService = priceOracleService;
    this.workerService = workerService;
  }
  async processLogs(logs) {
    console.debug("method -> comptrollerService.processComptrollerLogs");
    for (const log of logs) {
      switch (log.eventName) {
        case CompEventName.MarketListed:
          await this.marketListed(log);
          break;
        case CompEventName.NewPriceOracle:
          await this.newPriceOracle(log);
          break;
        case CompEventName.MarketEntered:
          this.marketEntered(log);
          break;
        case CompEventName.MarketExited:
          this.marketExited(log);
          break;
        case CompEventName.NewCloseFactor:
          this.newCloseFactor(log);
          break;
        case CompEventName.NewCollateralFactor:
          this.newCollateralFactor(log);
          break;
        case CompEventName.NewLiquidationIncentive:
          this.newLiquidationIncentive(log);
          break;
        default:
          console.warn("Unknown event", log.eventName);
      }
    }
  }
  newCollateralFactor(log) {
    console.debug("method -> comptrollerService.newCollateralFactor");
    const [key1, key2] = CompEventToOutputMap[CompEventName.NewCollateralFactor].split(",");
    const cToken = log[key1];
    const newCollateralFactorMantissa = log[key2];
    const market = this.storageService.getMarket(cToken);
    market.collateralFactorMantissa = newCollateralFactorMantissa;
  }
  newCloseFactor(log) {
    console.debug("method -> comptrollerService.newCloseFactor");
    const key = CompEventToOutputMap[CompEventName.NewCloseFactor];
    const newCloseFactorMantissa = log[key];
    const comptroller = this.storageService.getComptroller();
    comptroller.closeFactorMantissa = newCloseFactorMantissa;
  }
  async newPriceOracle(log) {
    console.debug("method -> comptrollerService.newPriceOracle");
    const newPriceOracle = CompEventToOutputMap[CompEventName.NewPriceOracle];
    const comptroller = this.storageService.getComptroller();
    comptroller.priceOracle = log[newPriceOracle];
    if (log.blockNumber < env_default.NORMAL_PRICE_ORACLE_START_BLOCK) {
      return;
    }
    const allMarkets = comptroller.allMarkets.values();
    const newTokenConfigs = [];
    for (const cToken of allMarkets) {
      newTokenConfigs.push(await this.priceOracleService.createTokenConfig(cToken, log.blockNumber));
      await this.priceOracleService.fetchAndUpdateUnderlyingPrice(cToken, log.blockNumber);
    }
    this.workerService.emitNewTokenConfigs(newTokenConfigs);
  }
  marketEntered(log) {
    console.debug("method -> comptrollerService.marketEntered");
    const [cTokenKey, accountKey] = CompEventToOutputMap[CompEventName.MarketEntered].split(",");
    const cToken = log[cTokenKey];
    const address28 = log[accountKey];
    const market = this.storageService.getMarket(cToken);
    if (!market)
      throw new Error("No market to enter found");
    market.accounts.add(address28);
    const account2 = this.storageService.getAccount(address28);
    if (account2) {
      this.accountService.enterMarket(account2, cToken);
    } else {
      this.accountService.createAccountWithAsset(address28, cToken);
    }
  }
  marketExited(log) {
    console.debug("method -> comptrollerService.marketExited");
    const [cTokenKey, accountKey] = CompEventToOutputMap[CompEventName.MarketEntered].split(",");
    const cToken = log[cTokenKey];
    const address28 = log[accountKey];
    const market = this.storageService.getMarket(cToken);
    market.accounts.delete(address28);
    const account2 = this.storageService.getAccount(address28);
    if (account2) {
      this.accountService.exitMarket(account2, cToken);
    } else {
      throw new Error("Account not found");
    }
  }
  async marketListed(log) {
    console.debug("method -> comptrollerService.marketListed");
    const key = CompEventToOutputMap[CompEventName.MarketListed];
    const cToken = log[key];
    const comptroller = this.storageService.getComptroller();
    comptroller.allMarkets.add(cToken);
    const market = this.storageService.getMarket(cToken);
    if (market) {
      return;
    }
    const newMarket = await this.createMarket(cToken, log.blockNumber);
    this.storageService.setMarket(cToken, newMarket);
  }
  newLiquidationIncentive(log) {
    console.debug("method -> comptrollerService.newLiquidationIncentive");
    const key = CompEventToOutputMap[CompEventName.NewLiquidationIncentive];
    const newLiquidationIncentiveMantissa = log[key];
    const comptroller = this.storageService.getComptroller();
    comptroller.liquidationIncentiveMantissa = newLiquidationIncentiveMantissa;
  }
  async createMarket(cToken, blockNumber) {
    console.debug("method -> comptrollerService.createMarket");
    console.log("comptroller", this.storageService.getComptroller());
    const newMarket = {
      address: cToken,
      accounts: new Set,
      borrowIndex: BigInt(1000000000000000000),
      underlyingPriceMantissa: await this.priceOracleService.fetchUnderlyingPrice(cToken, blockNumber),
      accrualBlockNumber: 0n,
      reserveFactorMantissa: 0n,
      closeFactorMantissa: 0n,
      collateralFactorMantissa: 0n,
      borrowRateMantissa: 0n,
      exchangeRateLastUpdateBlock: 0
    };
    if (blockNumber && blockNumber >= env_default.NORMAL_PRICE_ORACLE_START_BLOCK) {
      await this.priceOracleService.createTokenConfig(cToken, blockNumber);
    }
    const cTokenData = Object.values(CTokens_default).find(({ address: address28 }) => address28.toLowerCase() === cToken.toLowerCase());
    const underlyingData = Object.values(Tokens_default).find(({ address: address28 }) => address28.toLowerCase() === cTokenData?.underlying.toLowerCase());
    if (!cTokenData || !underlyingData) {
      return Object.assign(newMarket, await this.fetchMarketConstants(cToken, blockNumber));
    } else {
      return Object.assign(newMarket, await this.createMarketFromData(cTokenData, underlyingData));
    }
  }
  async createMarketFromData(cTokenData, underlyingData) {
    const {
      underlying: underlyingAddress,
      decimals,
      symbol: symbol2,
      initial_exchange_rate_mantissa: exchangeRateMantissa
    } = cTokenData;
    const { decimals: underlyingDecimals, symbol: underlyingSymbol } = underlyingData;
    return {
      underlyingAddress,
      decimals,
      symbol: symbol2,
      exchangeRateMantissa: toBigInt2(exchangeRateMantissa),
      underlyingDecimals,
      underlyingSymbol
    };
  }
  async fetchMarketConstants(cToken, blockNumber) {
    console.debug("method -> comptrollerService.fetchMarketConstants");
    const exchangeRateMantissa = await this.marketService.fetchExchangeRateMantissa(cToken, blockNumber);
    const underlyingAddress = await this.marketService.fetchUnderlingAddress(cToken, blockNumber);
    const symbol2 = await this.marketService.fetchSymbol(cToken);
    const decimals = await this.marketService.fetchDecimalsErc20(cToken);
    const underlyingDecimals = await this.marketService.fetchDecimalsErc20(underlyingAddress);
    const underlyingSymbol = await this.marketService.fetchSymbol(underlyingAddress);
    return {
      exchangeRateMantissa,
      underlyingAddress,
      symbol: symbol2,
      decimals,
      underlyingDecimals,
      underlyingSymbol
    };
  }
  async collectLogs(fromBlock, toBlock) {
    console.debug("method -> collectComptrollerLogs");
    const address28 = [env_default.COMPTROLLER_PROXY_ADDRESS];
    const eventNames = Object.values(CompEventName);
    const abi7 = filterAbi(Comptroller_default.abi, eventNames);
    const logs = await this.web3Service.getFilteredLogsByPieces(address28, abi7, eventNames, fromBlock, toBlock);
    const decodedLogs = sortLogs(this.web3Service.decodeLogs(logs, abi7));
    return decodedLogs;
  }
  async fetchAccountLiquidity(address28, blockNumber) {
    console.debug("method -> comptrollerService.fetchAccountLiquidity");
    const { abi: abi7 } = Comptroller_default;
    const getAccountLiquidityAbiItem = getAbiItem(abi7, "function", "getAccountLiquidity");
    const accountLiquidity = await this.web3Service.callContractMethod({
      abi: getAccountLiquidityAbiItem,
      address: env_default.COMPTROLLER_PROXY_ADDRESS,
      args: [address28],
      blockNumber
    });
    if (!accountLiquidity)
      throw new Error("Couldn't get accountLiquidity");
    return accountLiquidity;
  }
  async fetchLiquidateCalculateSeizeTokens(cTokenBorrowed, cTokenCollateral, actualRepayAmount, blockNumber) {
    console.debug("method -> comptrollerService.fetchLiquidateCalculateSeizeTokens");
    const { abi: abi7 } = Comptroller_default;
    const calculateSeizeTokensAbiItem = getAbiItem(abi7, "function", "liquidateCalculateSeizeTokens");
    const seizeTokens = await this.web3Service.callContractMethod({
      abi: calculateSeizeTokensAbiItem,
      address: env_default.COMPTROLLER_PROXY_ADDRESS,
      args: [cTokenBorrowed, cTokenCollateral, actualRepayAmount],
      blockNumber
    });
    if (!seizeTokens)
      throw new Error("Couldn't get seizeTokens");
    return seizeTokens;
  }
  async fetchLiquidationIncentiveMantissa(blockNumber) {
    console.debug("method -> comptrollerService.fetchLiquidationIncentiveMantissa");
    const { abi: abi7 } = Comptroller_default;
    const getLiquidationIncentiveAbiItem = getAbiItem(abi7, "function", "liquidationIncentiveMantissa");
    const liquidationIncentiveMantissa = await this.web3Service.callContractMethod({
      abi: getLiquidationIncentiveAbiItem,
      address: env_default.COMPTROLLER_PROXY_ADDRESS,
      args: [],
      blockNumber
    });
    if (!liquidationIncentiveMantissa)
      throw new Error("Couldn't get liquidationIncentiveMantissa");
    return liquidationIncentiveMantissa;
  }
  async fetchAllMarkets() {
    console.debug("method -> comptrollerService.fetchAllMarkets");
    const { abi: abi7 } = Comptroller_default;
    const getAllMarketsAbiItem = getAbiItem(abi7, "function", "getAllMarkets");
    const allMarkets = await this.web3Service.callContractMethod({
      abi: getAllMarketsAbiItem,
      address: env_default.COMPTROLLER_PROXY_ADDRESS,
      args: []
    });
    if (!allMarkets)
      throw new Error("Couldn't get allMarkets");
    return allMarkets;
  }
  async collectActualTokenConfigs() {
    const comptroller = this.storageService.getComptroller();
    comptroller.priceOracle = "0x50ce56A3239671Ab62f185704Caedf626352741e";
    const addresses = [
      "0x6C8c6b02E7b2BE14d4fA6022Dfd6d75921D90E4E",
      "0x5d3a536E4D6DbD6114cc1Ead35777bAB948E3643",
      "0x4Ddc2D193948926D02f9B1fE9e1daa0718270ED5",
      "0x158079Ee67Fce2f58472A96584A73C7Ab9AC95c1",
      "0x39AA39c021dfbaE8faC545936693aC917d5E7563",
      "0xf650C3d88D12dB855b8bf7D11Be6C55A4e07dCC9",
      "0xC11b1268C1A384e55C48c2391d8d480264A3A7F4",
      "0xB3319f5D18Bc0D84dD1b4825Dcde5d5f7266d407",
      "0xF5DCe57282A584D2746FaF1593d3121Fcac444dC",
      "0x35A18000230DA775CAc24873d00Ff85BccdeD550",
      "0x70e36f6BF80a52b3B46b3aF8e106CC0ed743E8e4",
      "0xccF4429DB6322D5C611ee964527D42E5d685DD6a",
      "0x12392F67bdf24faE0AF363c24aC620a2f67DAd86",
      "0xFAce851a4921ce59e912d19329929CE6da6EB0c7",
      "0x95b4eF2869eBD94BEb4eEE400a99824BF5DC325b",
      "0x4B0181102A0112A2ef11AbEE5563bb4a3176c9d7",
      "0xe65cdB6479BaC1e22340E4E755fAE7E509EcD06c",
      "0x80a2AE356fc9ef4305676f7a3E2Ed04e12C33946",
      "0x041171993284df560249B57358F931D9eB7b925D",
      "0x7713DD9Ca933848F6819F38B8352D9A15EA73F67"
    ];
    for (const address28 of addresses) {
      await this.createMarket(address28, 19469068);
    }
    await this.storageService.cacheTokenConfigs();
  }
}

// packages/compound-v2-liquidator/src/comptroller/comptroller.module.ts
class ComptrollerModule extends Module {
  constructor(storageModule, web3Module, accountModule, priceOracleModule, marketModule, workerModule) {
    super();
    const storageService = storageModule.getService("storageService");
    const web3Service = web3Module.getService("web3Service");
    const accountService = accountModule.getService("accountService");
    const priceOracleService = priceOracleModule.getService("priceOracleService");
    const marketService = marketModule.getService("marketService");
    const workerService = workerModule.getService("workerService");
    const service4 = new ComptrollerService(storageService, web3Service, marketService, accountService, priceOracleService, workerService);
    this.registerService("comptrollerService", service4);
  }
}

// packages/compound-v2-liquidator/src/market/market.constants.ts
var MarketEventName;
(function(MarketEventName2) {
  MarketEventName2["Borrow"] = "Borrow";
  MarketEventName2["RepayBorrow"] = "RepayBorrow";
  MarketEventName2["AccrueInterest"] = "AccrueInterest";
  MarketEventName2["ReservesAdded"] = "ReservesAdded";
  MarketEventName2["ReservesReduced"] = "ReservesReduced";
  MarketEventName2["NewReserveFactor"] = "NewReserveFactor";
  MarketEventName2["Transfer"] = "Transfer";
})(MarketEventName || (MarketEventName = {}));
var MarketEventToOutput = {
  [MarketEventName.AccrueInterest]: "interestAccumulated,borrowIndex,totalBorrows,cashPrior",
  [MarketEventName.ReservesAdded]: "addAmount,newTotalReserves",
  [MarketEventName.ReservesReduced]: "reduceAmount,newTotalReserves",
  [MarketEventName.Transfer]: "from,to,amount",
  [MarketEventName.Borrow]: "borrower,borrowAmount,accountBorrows,totalBorrows",
  [MarketEventName.RepayBorrow]: "payer,borrower,repayAmount,accountBorrows,totalBorrows",
  [MarketEventName.NewReserveFactor]: "newReserveFactorMantissa"
};
// common/compound-protocol/artifacts/CToken.sol/CToken.json
var CToken_default = {
  _format: "hh-sol-artifact-1",
  contractName: "CToken",
  sourceName: "contracts/CToken.sol",
  abi: [
    {
      inputs: [],
      name: "AcceptAdminPendingAdminCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "actualAddAmount",
          type: "uint256"
        }
      ],
      name: "AddReservesFactorFreshCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "BorrowCashNotAvailable",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "BorrowComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "BorrowFreshnessCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateAccrueBorrowInterestFailed",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateAccrueCollateralInterestFailed",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateCloseAmountIsUintMax",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateCloseAmountIsZero",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateCollateralFreshnessCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateFreshnessCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateLiquidatorIsBorrower",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateRepayBorrowFreshFailed",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateSeizeComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateSeizeLiquidatorIsBorrower",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "MintComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "MintFreshnessCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "RedeemComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "RedeemFreshnessCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "RedeemTransferOutNotPossible",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesAdminCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesCashNotAvailable",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesCashValidation",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesFreshCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "RepayBorrowComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "RepayBorrowFreshnessCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetComptrollerOwnerCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetInterestRateModelFreshCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetInterestRateModelOwnerCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetPendingAdminOwnerCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetReserveFactorAdminCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetReserveFactorBoundsCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetReserveFactorFreshCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "TransferComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "TransferNotAllowed",
      type: "error"
    },
    {
      inputs: [],
      name: "TransferNotEnough",
      type: "error"
    },
    {
      inputs: [],
      name: "TransferTooMuch",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "cashPrior",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "interestAccumulated",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "borrowIndex",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "AccrueInterest",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "borrowAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "accountBorrows",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "Borrow",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "LiquidateBorrow",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "minter",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "mintAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "mintTokens",
          type: "uint256"
        }
      ],
      name: "Mint",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "oldAdmin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "NewAdmin",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract ComptrollerInterface",
          name: "oldComptroller",
          type: "address"
        },
        {
          indexed: false,
          internalType: "contract ComptrollerInterface",
          name: "newComptroller",
          type: "address"
        }
      ],
      name: "NewComptroller",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract InterestRateModel",
          name: "oldInterestRateModel",
          type: "address"
        },
        {
          indexed: false,
          internalType: "contract InterestRateModel",
          name: "newInterestRateModel",
          type: "address"
        }
      ],
      name: "NewMarketInterestRateModel",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "oldPendingAdmin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newPendingAdmin",
          type: "address"
        }
      ],
      name: "NewPendingAdmin",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "oldReserveFactorMantissa",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newReserveFactorMantissa",
          type: "uint256"
        }
      ],
      name: "NewReserveFactor",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "redeemer",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "redeemAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "redeemTokens",
          type: "uint256"
        }
      ],
      name: "Redeem",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "payer",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "accountBorrows",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "RepayBorrow",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "benefactor",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "addAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newTotalReserves",
          type: "uint256"
        }
      ],
      name: "ReservesAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "admin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "reduceAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newTotalReserves",
          type: "uint256"
        }
      ],
      name: "ReservesReduced",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      inputs: [],
      name: "NO_ERROR",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "_acceptAdmin",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "reduceAmount",
          type: "uint256"
        }
      ],
      name: "_reduceReserves",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ComptrollerInterface",
          name: "newComptroller",
          type: "address"
        }
      ],
      name: "_setComptroller",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract InterestRateModel",
          name: "newInterestRateModel",
          type: "address"
        }
      ],
      name: "_setInterestRateModel",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address payable",
          name: "newPendingAdmin",
          type: "address"
        }
      ],
      name: "_setPendingAdmin",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newReserveFactorMantissa",
          type: "uint256"
        }
      ],
      name: "_setReserveFactor",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "accrualBlockNumber",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "accrueInterest",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "admin",
      outputs: [
        {
          internalType: "address payable",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "spender",
          type: "address"
        }
      ],
      name: "allowance",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "balanceOfUnderlying",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "borrowBalanceCurrent",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "borrowBalanceStored",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "borrowIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "borrowRatePerBlock",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "comptroller",
      outputs: [
        {
          internalType: "contract ComptrollerInterface",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "decimals",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "exchangeRateCurrent",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "exchangeRateStored",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "getAccountSnapshot",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getCash",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ComptrollerInterface",
          name: "comptroller_",
          type: "address"
        },
        {
          internalType: "contract InterestRateModel",
          name: "interestRateModel_",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "initialExchangeRateMantissa_",
          type: "uint256"
        },
        {
          internalType: "string",
          name: "name_",
          type: "string"
        },
        {
          internalType: "string",
          name: "symbol_",
          type: "string"
        },
        {
          internalType: "uint8",
          name: "decimals_",
          type: "uint8"
        }
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "interestRateModel",
      outputs: [
        {
          internalType: "contract InterestRateModel",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "isCToken",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pendingAdmin",
      outputs: [
        {
          internalType: "address payable",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "protocolSeizeShareMantissa",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "reserveFactorMantissa",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "seize",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "supplyRatePerBlock",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalBorrows",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalBorrowsCurrent",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "totalReserves",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "dst",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transfer",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "src",
          type: "address"
        },
        {
          internalType: "address",
          name: "dst",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    }
  ],
  bytecode: "0x",
  deployedBytecode: "0x",
  linkReferences: {},
  deployedLinkReferences: {}
};
// common/compound-protocol/artifacts/CErc20.sol/CErc20.json
var CErc20_default = {
  _format: "hh-sol-artifact-1",
  contractName: "CErc20",
  sourceName: "contracts/CErc20.sol",
  abi: [
    {
      inputs: [],
      name: "AcceptAdminPendingAdminCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "actualAddAmount",
          type: "uint256"
        }
      ],
      name: "AddReservesFactorFreshCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "BorrowCashNotAvailable",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "BorrowComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "BorrowFreshnessCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateAccrueBorrowInterestFailed",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateAccrueCollateralInterestFailed",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateCloseAmountIsUintMax",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateCloseAmountIsZero",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateCollateralFreshnessCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateFreshnessCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateLiquidatorIsBorrower",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateRepayBorrowFreshFailed",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "LiquidateSeizeComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "LiquidateSeizeLiquidatorIsBorrower",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "MintComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "MintFreshnessCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "RedeemComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "RedeemFreshnessCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "RedeemTransferOutNotPossible",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesAdminCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesCashNotAvailable",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesCashValidation",
      type: "error"
    },
    {
      inputs: [],
      name: "ReduceReservesFreshCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "RepayBorrowComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "RepayBorrowFreshnessCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetComptrollerOwnerCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetInterestRateModelFreshCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetInterestRateModelOwnerCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetPendingAdminOwnerCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetReserveFactorAdminCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetReserveFactorBoundsCheck",
      type: "error"
    },
    {
      inputs: [],
      name: "SetReserveFactorFreshCheck",
      type: "error"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "errorCode",
          type: "uint256"
        }
      ],
      name: "TransferComptrollerRejection",
      type: "error"
    },
    {
      inputs: [],
      name: "TransferNotAllowed",
      type: "error"
    },
    {
      inputs: [],
      name: "TransferNotEnough",
      type: "error"
    },
    {
      inputs: [],
      name: "TransferTooMuch",
      type: "error"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "interestAccumulated",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "borrowIndex",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "AccrueInterest",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "cashPrior",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "interestAccumulated",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "borrowIndex",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "AccrueInterest",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Approval",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "borrowAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "accountBorrows",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "Borrow",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "address",
          name: "cTokenCollateral",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "LiquidateBorrow",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "minter",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "mintAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "mintTokens",
          type: "uint256"
        }
      ],
      name: "Mint",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "oldAdmin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newAdmin",
          type: "address"
        }
      ],
      name: "NewAdmin",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract ComptrollerInterface",
          name: "oldComptroller",
          type: "address"
        },
        {
          indexed: false,
          internalType: "contract ComptrollerInterface",
          name: "newComptroller",
          type: "address"
        }
      ],
      name: "NewComptroller",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "contract InterestRateModel",
          name: "oldInterestRateModel",
          type: "address"
        },
        {
          indexed: false,
          internalType: "contract InterestRateModel",
          name: "newInterestRateModel",
          type: "address"
        }
      ],
      name: "NewMarketInterestRateModel",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "oldPendingAdmin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "newPendingAdmin",
          type: "address"
        }
      ],
      name: "NewPendingAdmin",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "uint256",
          name: "oldReserveFactorMantissa",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newReserveFactorMantissa",
          type: "uint256"
        }
      ],
      name: "NewReserveFactor",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "redeemer",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "redeemAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "redeemTokens",
          type: "uint256"
        }
      ],
      name: "Redeem",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "payer",
          type: "address"
        },
        {
          indexed: false,
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "accountBorrows",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "totalBorrows",
          type: "uint256"
        }
      ],
      name: "RepayBorrow",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "benefactor",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "addAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newTotalReserves",
          type: "uint256"
        }
      ],
      name: "ReservesAdded",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: false,
          internalType: "address",
          name: "admin",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "reduceAmount",
          type: "uint256"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "newTotalReserves",
          type: "uint256"
        }
      ],
      name: "ReservesReduced",
      type: "event"
    },
    {
      anonymous: false,
      inputs: [
        {
          indexed: true,
          internalType: "address",
          name: "from",
          type: "address"
        },
        {
          indexed: true,
          internalType: "address",
          name: "to",
          type: "address"
        },
        {
          indexed: false,
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "Transfer",
      type: "event"
    },
    {
      inputs: [],
      name: "NO_ERROR",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "_acceptAdmin",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "addAmount",
          type: "uint256"
        }
      ],
      name: "_addReserves",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "compLikeDelegatee",
          type: "address"
        }
      ],
      name: "_delegateCompLikeTo",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "reduceAmount",
          type: "uint256"
        }
      ],
      name: "_reduceReserves",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ComptrollerInterface",
          name: "newComptroller",
          type: "address"
        }
      ],
      name: "_setComptroller",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract InterestRateModel",
          name: "newInterestRateModel",
          type: "address"
        }
      ],
      name: "_setInterestRateModel",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address payable",
          name: "newPendingAdmin",
          type: "address"
        }
      ],
      name: "_setPendingAdmin",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "newReserveFactorMantissa",
          type: "uint256"
        }
      ],
      name: "_setReserveFactor",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "accrualBlockNumber",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "accrueInterest",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "admin",
      outputs: [
        {
          internalType: "address payable",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        },
        {
          internalType: "address",
          name: "spender",
          type: "address"
        }
      ],
      name: "allowance",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "spender",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "approve",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "balanceOf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "owner",
          type: "address"
        }
      ],
      name: "balanceOfUnderlying",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "borrowAmount",
          type: "uint256"
        }
      ],
      name: "borrow",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "borrowBalanceCurrent",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "borrowBalanceStored",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "borrowIndex",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "borrowRatePerBlock",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "comptroller",
      outputs: [
        {
          internalType: "contract ComptrollerInterface",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "decimals",
      outputs: [
        {
          internalType: "uint8",
          name: "",
          type: "uint8"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "exchangeRateCurrent",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "exchangeRateStored",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "account",
          type: "address"
        }
      ],
      name: "getAccountSnapshot",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        },
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "getCash",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "underlying_",
          type: "address"
        },
        {
          internalType: "contract ComptrollerInterface",
          name: "comptroller_",
          type: "address"
        },
        {
          internalType: "contract InterestRateModel",
          name: "interestRateModel_",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "initialExchangeRateMantissa_",
          type: "uint256"
        },
        {
          internalType: "string",
          name: "name_",
          type: "string"
        },
        {
          internalType: "string",
          name: "symbol_",
          type: "string"
        },
        {
          internalType: "uint8",
          name: "decimals_",
          type: "uint8"
        }
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract ComptrollerInterface",
          name: "comptroller_",
          type: "address"
        },
        {
          internalType: "contract InterestRateModel",
          name: "interestRateModel_",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "initialExchangeRateMantissa_",
          type: "uint256"
        },
        {
          internalType: "string",
          name: "name_",
          type: "string"
        },
        {
          internalType: "string",
          name: "symbol_",
          type: "string"
        },
        {
          internalType: "uint8",
          name: "decimals_",
          type: "uint8"
        }
      ],
      name: "initialize",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "interestRateModel",
      outputs: [
        {
          internalType: "contract InterestRateModel",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "isCToken",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        },
        {
          internalType: "contract CTokenInterface",
          name: "cTokenCollateral",
          type: "address"
        }
      ],
      name: "liquidateBorrow",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "mintAmount",
          type: "uint256"
        }
      ],
      name: "mint",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "name",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "pendingAdmin",
      outputs: [
        {
          internalType: "address payable",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "protocolSeizeShareMantissa",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "redeemTokens",
          type: "uint256"
        }
      ],
      name: "redeem",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "redeemAmount",
          type: "uint256"
        }
      ],
      name: "redeemUnderlying",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        }
      ],
      name: "repayBorrow",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "repayAmount",
          type: "uint256"
        }
      ],
      name: "repayBorrowBehalf",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "reserveFactorMantissa",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "liquidator",
          type: "address"
        },
        {
          internalType: "address",
          name: "borrower",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "seizeTokens",
          type: "uint256"
        }
      ],
      name: "seize",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "supplyRatePerBlock",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "contract EIP20NonStandardInterface",
          name: "token",
          type: "address"
        }
      ],
      name: "sweepToken",
      outputs: [],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "symbol",
      outputs: [
        {
          internalType: "string",
          name: "",
          type: "string"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalBorrows",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalBorrowsCurrent",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "totalReserves",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [],
      name: "totalSupply",
      outputs: [
        {
          internalType: "uint256",
          name: "",
          type: "uint256"
        }
      ],
      stateMutability: "view",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "dst",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transfer",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [
        {
          internalType: "address",
          name: "src",
          type: "address"
        },
        {
          internalType: "address",
          name: "dst",
          type: "address"
        },
        {
          internalType: "uint256",
          name: "amount",
          type: "uint256"
        }
      ],
      name: "transferFrom",
      outputs: [
        {
          internalType: "bool",
          name: "",
          type: "bool"
        }
      ],
      stateMutability: "nonpayable",
      type: "function"
    },
    {
      inputs: [],
      name: "underlying",
      outputs: [
        {
          internalType: "address",
          name: "",
          type: "address"
        }
      ],
      stateMutability: "view",
      type: "function"
    }
  ],
  bytecode: "0x608060405234801561001057600080fd5b50616a5a80620000216000396000f3fe608060405234801561001057600080fd5b506004361061030c5760003560e01c80637f1e06be1161019d578063bd6d894d116100e9578063f2b3abbd116100a2578063f851a4401161007c578063f851a44014610a38578063f8f9da2814610a56578063fca7820b14610a74578063fe9c44ae14610aa45761030c565b8063f2b3abbd146109ba578063f3fdb15a146109ea578063f5e3c46214610a085761030c565b8063bd6d894d146108bb578063c37f68e2146108d9578063c5ebeaec1461090c578063db006a751461093c578063dd62ed3e1461096c578063e9c714f21461099c5761030c565b8063a0712d6811610156578063aa5af0fd11610130578063aa5af0fd1461081f578063ae9d70b01461083d578063b2a02ff11461085b578063b71d1a0c1461088b5761030c565b8063a0712d68146107a1578063a6afed95146107d1578063a9059cbb146107ef5761030c565b80637f1e06be146106cd578063852a12e3146106e95780638f840ddd1461071957806395d89b411461073757806395dd91931461075557806399d8c1b4146107855761030c565b80633af9e6691161025c578063601a0bf1116102155780636c540baf116101ef5780636c540baf146106435780636f307dc31461066157806370a082311461067f57806373acee98146106af5761030c565b8063601a0bf1146105d75780636752e7021461060757806369ab3250146106255761030c565b80633af9e669146104ed5780633b1d21a21461051d5780633e9410101461053b5780634576b5db1461056b57806347bd37181461059b5780635fe3b567146105b95761030c565b8063182df0f5116102c957806323b872dd116102a357806323b872dd146104515780632608f8181461048157806326782247146104b1578063313ce567146104cf5761030c565b8063182df0f5146103fb5780631a31d465146104195780631be19560146104355761030c565b806306fdde0314610311578063095ea7b31461032f5780630e7527021461035f578063173b99041461038f57806317bfdfbc146103ad57806318160ddd146103dd575b600080fd5b610319610ac2565b6040516103269190615210565b60405180910390f35b610349600480360381019061034491906152da565b610b50565b6040516103569190615335565b60405180910390f35b61037960048036038101906103749190615350565b610c47565b604051610386919061538c565b60405180910390f35b610397610c5b565b6040516103a4919061538c565b60405180910390f35b6103c760048036038101906103c291906153a7565b610c61565b6040516103d4919061538c565b60405180910390f35b6103e5610cfe565b6040516103f2919061538c565b60405180910390f35b610403610d04565b604051610410919061538c565b60405180910390f35b610433600480360381019061042e91906155be565b610d13565b005b61044f600480360381019061044a91906156d6565b610dfd565b005b61046b60048036038101906104669190615703565b61102f565b6040516104789190615335565b60405180910390f35b61049b600480360381019061049691906152da565b6110cb565b6040516104a8919061538c565b60405180910390f35b6104b96110e1565b6040516104c69190615777565b60405180910390f35b6104d7611107565b6040516104e491906157a1565b60405180910390f35b610507600480360381019061050291906153a7565b61111a565b604051610514919061538c565b60405180910390f35b610525611186565b604051610532919061538c565b60405180910390f35b61055560048036038101906105509190615350565b611195565b604051610562919061538c565b60405180910390f35b610585600480360381019061058091906157bc565b6111a7565b604051610592919061538c565b60405180910390f35b6105a3611388565b6040516105b0919061538c565b60405180910390f35b6105c161138e565b6040516105ce9190615848565b60405180910390f35b6105f160048036038101906105ec9190615350565b6113b4565b6040516105fe919061538c565b60405180910390f35b61060f611451565b60405161061c919061538c565b60405180910390f35b61062d61145c565b60405161063a919061538c565b60405180910390f35b61064b611461565b604051610658919061538c565b60405180910390f35b610669611467565b6040516106769190615872565b60405180910390f35b610699600480360381019061069491906153a7565b61148d565b6040516106a6919061538c565b60405180910390f35b6106b76114d6565b6040516106c4919061538c565b60405180910390f35b6106e760048036038101906106e291906153a7565b61156b565b005b61070360048036038101906106fe9190615350565b61168b565b604051610710919061538c565b60405180910390f35b61072161169f565b60405161072e919061538c565b60405180910390f35b61073f6116a5565b60405161074c9190615210565b60405180910390f35b61076f600480360381019061076a91906153a7565b611733565b60405161077c919061538c565b60405180910390f35b61079f600480360381019061079a919061588d565b611745565b005b6107bb60048036038101906107b69190615350565b61199b565b6040516107c8919061538c565b60405180910390f35b6107d96119af565b6040516107e6919061538c565b60405180910390f35b610809600480360381019061080491906152da565b611bca565b6040516108169190615335565b60405180910390f35b610827611c65565b604051610834919061538c565b60405180910390f35b610845611c6b565b604051610852919061538c565b60405180910390f35b61087560048036038101906108709190615703565b611d21565b604051610882919061538c565b60405180910390f35b6108a560048036038101906108a0919061597e565b611dbc565b6040516108b2919061538c565b60405180910390f35b6108c3611ef0565b6040516108d0919061538c565b60405180910390f35b6108f360048036038101906108ee91906153a7565b611f8a565b60405161090394939291906159ab565b60405180910390f35b61092660048036038101906109219190615350565b611ff2565b604051610933919061538c565b60405180910390f35b61095660048036038101906109519190615350565b612006565b604051610963919061538c565b60405180910390f35b610986600480360381019061098191906159f0565b61201a565b604051610993919061538c565b60405180910390f35b6109a46120a1565b6040516109b1919061538c565b60405180910390f35b6109d460048036038101906109cf9190615a30565b612315565b6040516109e1919061538c565b60405180910390f35b6109f2612330565b6040516109ff9190615a7e565b60405180910390f35b610a226004803603810190610a1d9190615ad7565b612356565b604051610a2f919061538c565b60405180910390f35b610a4061236e565b604051610a4d9190615777565b60405180910390f35b610a5e612394565b604051610a6b919061538c565b60405180910390f35b610a8e6004803603810190610a899190615350565b612446565b604051610a9b919061538c565b60405180910390f35b610aac6124e3565b604051610ab99190615335565b60405180910390f35b60018054610acf90615b59565b80601f0160208091040260200160405190810160405280929190818152602001828054610afb90615b59565b8015610b485780601f10610b1d57610100808354040283529160200191610b48565b820191906000526020600020905b815481529060010190602001808311610b2b57829003601f168201915b505050505081565b60008033905082600f60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92585604051610c34919061538c565b60405180910390a3600191505092915050565b6000610c52826124e8565b60009050919050565b60085481565b60008060009054906101000a900460ff16610cb1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ca890615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550610cd36119af565b50610cdd82611733565b905060016000806101000a81548160ff021916908315150217905550919050565b600d5481565b6000610d0e612581565b905090565b610d21868686868686611745565b86601160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610dcf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df39190615c0c565b5050505050505050565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610e8d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e8490615cab565b60405180910390fd5b601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610f1e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f1590615d3d565b60405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f599190615872565b602060405180830381865afa158015610f76573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9a9190615c0c565b90508173ffffffffffffffffffffffffffffffffffffffff1663a9059cbb600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836040518363ffffffff1660e01b8152600401610ff9929190615d7e565b600060405180830381600087803b15801561101357600080fd5b505af1158015611027573d6000803e3d6000fd5b505050505050565b60008060009054906101000a900460ff1661107f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161107690615bd7565b60405180910390fd5b60008060006101000a81548160ff02191690831515021790555060006110a7338686866125f6565b14905060016000806101000a81548160ff0219169083151502179055509392505050565b60006110d78383612a7d565b6000905092915050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600360009054906101000a900460ff1681565b6000806040518060200160405280611130611ef0565b815250905061117e81600e60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612b17565b915050919050565b6000611190612b38565b905090565b60006111a082612be0565b9050919050565b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611230576040517fd219dc1f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508273ffffffffffffffffffffffffffffffffffffffff16627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa1580156112a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112c59190615dd3565b611304576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112fb90615e4c565b60405180910390fd5b82600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f7ac369dbd14fa5ea3f473ed67cc9d598964a77501540ba6751eb0b3decf5870d8184604051611376929190615e6c565b60405180910390a16000915050919050565b600b5481565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060009054906101000a900460ff16611404576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113fb90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506114266119af565b5061143082612c81565b905060016000806101000a81548160ff021916908315150217905550919050565b666379da05b6000081565b600081565b60095481565b601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600e60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60008060009054906101000a900460ff16611526576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161151d90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506115486119af565b50600b54905060016000806101000a81548160ff02191690831515021790555090565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146115fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115f290615f07565b60405180910390fd5b601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635c19a95c826040518263ffffffff1660e01b81526004016116569190615872565b600060405180830381600087803b15801561167057600080fd5b505af1158015611684573d6000803e3d6000fd5b5050505050565b600061169682612e74565b60009050919050565b600c5481565b600280546116b290615b59565b80601f01602080910402602001604051908101604052809291908181526020018280546116de90615b59565b801561172b5780601f106117005761010080835404028352916020019161172b565b820191906000526020600020905b81548152906001019060200180831161170e57829003601f168201915b505050505081565b600061173e82612f0d565b9050919050565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146117d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117cc90615f99565b60405180910390fd5b60006009541480156117e957506000600a54145b611828576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161181f9061602b565b60405180910390fd5b83600781905550600060075411611874576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161186b906160bd565b60405180910390fd5b600061187f876111a7565b9050600081146118c4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118bb90616129565b60405180910390fd5b6118cc612f98565b600981905550670de0b6b3a7640000600a819055506118ea86612fa0565b90506000811461192f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611926906161bb565b60405180910390fd5b83600190805190602001906119459291906150c1565b50826002908051906020019061195c9291906150c1565b5081600360006101000a81548160ff021916908360ff16021790555060016000806101000a81548160ff02191690831515021790555050505050505050565b60006119a6826131c3565b60009050919050565b6000806119ba612f98565b905060006009549050818114156119d657600092505050611bc7565b60006119e0612b38565b90506000600b5490506000600c5490506000600a5490506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166315f240538686866040518463ffffffff1660e01b8152600401611a58939291906161db565b602060405180830381865afa158015611a75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a999190615c0c565b905065048c27395000811115611ae4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611adb9061625e565b60405180910390fd5b60008688611af291906162ad565b90506000611b0e6040518060200160405280858152508361325a565b90506000611b1c8288612b17565b905060008782611b2c91906162e1565b90506000611b4b6040518060200160405280600854815250848a613286565b90506000611b5a85898a613286565b90508c60098190555080600a8190555082600b8190555081600c819055507f4dec04e750ca11537cabcd8a9eab06494de08da3735bc8871cd41250e190bc048b858386604051611bad94939291906159ab565b60405180910390a160009d50505050505050505050505050505b90565b60008060009054906101000a900460ff16611c1a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c1190615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506000611c42333386866125f6565b14905060016000806101000a81548160ff02191690831515021790555092915050565b600a5481565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b8168816611cb3612b38565b600b54600c546008546040518563ffffffff1660e01b8152600401611cdb94939291906159ab565b602060405180830381865afa158015611cf8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d1c9190615c0c565b905090565b60008060009054906101000a900460ff16611d71576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d6890615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550611d97338585856132b1565b6000905060016000806101000a81548160ff0219169083151502179055509392505050565b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611e45576040517f5cb56c2b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a98184604051611ede929190616337565b60405180910390a16000915050919050565b60008060009054906101000a900460ff16611f40576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f3790615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550611f626119af565b50611f6b610d04565b905060016000806101000a81548160ff02191690831515021790555090565b6000806000806000600e60008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054611fdb87612f0d565b611fe3612581565b93509350935093509193509193565b6000611ffd826136bb565b60009050919050565b600061201182613752565b60009050919050565b6000600f60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614158061212c5750600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b15612163576040517f6e893ca400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600360016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507ff9ffabca9c8276e99321725bcb43fb076a6c66a54b7f21c4e8146d8519b417dc82600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516122a9929190616337565b60405180910390a17fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a981600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604051612304929190616337565b60405180910390a160009250505090565b600061231f6119af565b5061232982612fa0565b9050919050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60006123638484846137eb565b600090509392505050565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166315f240536123dc612b38565b600b54600c546040518463ffffffff1660e01b8152600401612400939291906161db565b602060405180830381865afa15801561241d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124419190615c0c565b905090565b60008060009054906101000a900460ff16612496576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161248d90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506124b86119af565b506124c282613941565b905060016000806101000a81548160ff021916908315150217905550919050565b600181565b60008054906101000a900460ff16612535576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161252c90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506125576119af565b50612563333383613a9f565b5060016000806101000a81548160ff02191690831515021790555050565b600080600d549050600081141561259d576007549150506125f3565b60006125a7612b38565b90506000600c54600b54836125bc91906162e1565b6125c691906162ad565b9050600083670de0b6b3a7640000836125df9190616360565b6125e991906163e9565b9050809450505050505b90565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663bdcdc258308787876040518563ffffffff1660e01b815260040161265a949392919061641a565b6020604051808303816000875af1158015612679573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269d9190615c0c565b9050600081146126e457806040517f113a84ee0000000000000000000000000000000000000000000000000000000081526004016126db919061538c565b60405180910390fd5b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16141561274a576040517f8cd22d1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff1614156127a8577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9050612828565b600f60008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490505b6000848261283691906162ad565b9050600085600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461288591906162ad565b9050600086600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546128d491906162e1565b905081600e60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8414612a075782600f60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b8773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef89604051612a64919061538c565b60405180910390a3600095505050505050949350505050565b60008054906101000a900460ff16612aca576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612ac190615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550612aec6119af565b50612af8338383613a9f565b5060016000806101000a81548160ff0219169083151502179055505050565b600080612b24848461325a565b9050612b2f81613d25565b91505092915050565b600080601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401612b999190615872565b602060405180830381865afa158015612bb6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bda9190615c0c565b91505090565b60008060009054906101000a900460ff16612c30576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612c2790615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550612c526119af565b50612c5c82613d46565b50506000905060016000806101000a81548160ff021916908315150217905550919050565b600080600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612d0b576040517ff7e5e6d000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612d13612f98565b60095414612d4d576040517fdff50cb000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82612d56612b38565b1015612d8e576040517f3345e99900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600c54831115612dca576040517ff1a5300a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600c54612dd891906162ad565b905080600c81905550612e0d600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1684613e05565b7f3bad0c59cf2f06e7314077049f48a93578cd16f5ef92329f1dab1420a99c177e600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168483604051612e629392919061645f565b60405180910390a16000915050919050565b60008054906101000a900460ff16612ec1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612eb890615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550612ee36119af565b50612ef033600083613f0e565b60016000806101000a81548160ff02191690831515021790555050565b600080601060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600081600001541415612f68576000915050612f93565b6000600a548260000154612f7c9190616360565b9050816001015481612f8e91906163e9565b925050505b919050565b600043905090565b600080600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461302a576040517f407fded500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b613032612f98565b6009541461306c576040517f17c54b9600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508273ffffffffffffffffffffffffffffffffffffffff16632191f92a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156130dc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131009190615dd3565b61313f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161313690615e4c565b60405180910390fd5b82600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fedffc32e068c7c95dfd4bdfd5c4d939a084d6b11c4199eac8436ed234d72f92681846040516131b1929190616496565b60405180910390a16000915050919050565b60008054906101000a900460ff16613210576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161320790615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506132326119af565b5061323d33826142fc565b60016000806101000a81548160ff02191690831515021790555050565b613262615147565b604051806020016040528061327b8560000151856145a9565b815250905092915050565b600080613293858561325a565b90506132a76132a182613d25565b846145bf565b9150509392505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d02f735130878787876040518663ffffffff1660e01b81526004016133169594939291906164bf565b6020604051808303816000875af1158015613335573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133599190615c0c565b9050600081146133a057806040517fc7c01c66000000000000000000000000000000000000000000000000000000008152600401613397919061538c565b60405180910390fd5b8373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415613406576040517f7528c4ce00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000613427836040518060200160405280666379da05b600008152506145d5565b90506000818461343791906162ad565b90506000604051806020016040528061344e612581565b8152509050600061345f8285612b17565b9050600081600c5461347191906162e1565b905080600c8190555084600d5461348891906162ad565b600d8190555086600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546134d991906162ad565b600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600e60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461356791906162e1565b600e60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508873ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef86604051613607919061538c565b60405180910390a33073ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8760405161366c919061538c565b60405180910390a37fa91e67c5ea634cd43a12c5a482724b03de01e85ca68702a53d0c2f45cb7c1dc53083836040516136a793929190616512565b60405180910390a150505050505050505050565b60008054906101000a900460ff16613708576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016136ff90615bd7565b60405180910390fd5b60008060006101000a81548160ff02191690831515021790555061372a6119af565b506137353382614600565b60016000806101000a81548160ff02191690831515021790555050565b60008054906101000a900460ff1661379f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161379690615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506137c16119af565b506137ce33826000613f0e565b60016000806101000a81548160ff02191690831515021790555050565b60008054906101000a900460ff16613838576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161382f90615bd7565b60405180910390fd5b60008060006101000a81548160ff02191690831515021790555061385a6119af565b5060008173ffffffffffffffffffffffffffffffffffffffff1663a6afed956040518163ffffffff1660e01b81526004016020604051808303816000875af11580156138aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138ce9190615c0c565b90506000811461391557806040517f7dd4936e00000000000000000000000000000000000000000000000000000000815260040161390c919061538c565b60405180910390fd5b61392133858585614883565b5060016000806101000a81548160ff021916908315150217905550505050565b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146139ca576040517f240b6af600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6139d2612f98565b60095414613a0c576040517ffbf94d6e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b670de0b6b3a7640000821115613a4e576040517fe2e441e600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006008549050826008819055507faaa68312e2ea9d50e16af5068410ab56e1a1fd06037b1a35664812c30f8214608184604051613a8d929190616549565b60405180910390a16000915050919050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166324008a62308787876040518563ffffffff1660e01b8152600401613b03949392919061641a565b6020604051808303816000875af1158015613b22573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b469190615c0c565b905060008114613b8d57806040517f8c81362d000000000000000000000000000000000000000000000000000000008152600401613b84919061538c565b60405180910390fd5b613b95612f98565b60095414613bcf576040517fc9021e2f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000613bda85612f0d565b905060007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8514613c0b5784613c0d565b815b90506000613c1b8883614e62565b905060008184613c2b91906162ad565b9050600082600b54613c3d91906162ad565b905081601060008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000181905550600a54601060008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018190555080600b819055507f1a2a22cb034d26d1854bdc6666a5b91fe25efbbb5dcad3b0355478d6f5c362a18a8a858585604051613d0d959493929190616572565b60405180910390a18296505050505050509392505050565b6000670de0b6b3a76400008260000151613d3f91906163e9565b9050919050565b600080600080613d54612f98565b60095414613d9957806040517f38acf799000000000000000000000000000000000000000000000000000000008152600401613d90919061538c565b60405180910390fd5b613da33386614e62565b905080600c54613db391906162e1565b915081600c819055507fa91e67c5ea634cd43a12c5a482724b03de01e85ca68702a53d0c2f45cb7c1dc5338284604051613def93929190616512565b60405180910390a1600081935093505050915091565b6000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb84846040518363ffffffff1660e01b8152600401613e67929190615d7e565b600060405180830381600087803b158015613e8157600080fd5b505af1158015613e95573d6000803e3d6000fd5b5050505060003d60008114613eb15760208114613ebb57600080fd5b6000199150613ec7565b60206000803e60005191505b5080613f08576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613eff90616611565b60405180910390fd5b50505050565b6000821480613f1d5750600081145b613f5c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613f53906166a3565b60405180910390fd5b60006040518060200160405280613f71612581565b81525090506000806000851115613f9657849150613f8f8386612b17565b9050613fa6565b613fa08484615082565b91508390505b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eabe7d913089866040518463ffffffff1660e01b8152600401614007939291906166c3565b6020604051808303816000875af1158015614026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061404a9190615c0c565b90506000811461409157806040517f480f4247000000000000000000000000000000000000000000000000000000008152600401614088919061538c565b60405180910390fd5b614099612f98565b600954146140d3576040517f97b5cfcd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816140dc612b38565b1015614114576040517f91240a1b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600d5461412291906162ad565b600d8190555082600e60008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461417391906162ad565b600e60008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506141c08783613e05565b3073ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8560405161421d919061538c565b60405180910390a37fe5b754fb1abb7f01b499791d0b820ae3b6af3424ac1c59768edb53f4ec31a9298783856040516142589392919061645f565b60405180910390a1600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166351dff989308985876040518563ffffffff1660e01b81526004016142c194939291906166fa565b600060405180830381600087803b1580156142db57600080fd5b505af11580156142ef573d6000803e3d6000fd5b5050505050505050505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634ef4c3e13085856040518463ffffffff1660e01b815260040161435d9392919061673f565b6020604051808303816000875af115801561437c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143a09190615c0c565b9050600081146143e757806040517f49abd4fd0000000000000000000000000000000000000000000000000000000081526004016143de919061538c565b60405180910390fd5b6143ef612f98565b60095414614429576040517f38d8859700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000604051806020016040528061443e612581565b8152509050600061444f8585614e62565b9050600061445d8284615082565b905080600d5461446d91906162e1565b600d8190555080600e60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546144be91906162e1565b600e60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f86838360405161453493929190616512565b60405180910390a18573ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051614599919061538c565b60405180910390a3505050505050565b600081836145b79190616360565b905092915050565b600081836145cd91906162e1565b905092915050565b6000670de0b6b3a76400006145ee8484600001516145a9565b6145f891906163e9565b905092915050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663da3d454c3085856040518463ffffffff1660e01b8152600401614661939291906166c3565b6020604051808303816000875af1158015614680573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146a49190615c0c565b9050600081146146eb57806040517f918db40f0000000000000000000000000000000000000000000000000000000081526004016146e2919061538c565b60405180910390fd5b6146f3612f98565b6009541461472d576040517f3a36318400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81614736612b38565b101561476e576040517f48c2588100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061477984612f0d565b90506000838261478991906162e1565b9050600084600b5461479b91906162e1565b905081601060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000181905550600a54601060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018190555080600b8190555061483e8686613e05565b7f13ed6866d4e1ee6da46f845c46d7e54120883d75c5ea9a2dacc1c4ca8984ab80868684846040516148739493929190616776565b60405180910390a1505050505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635fc7e71e30848888886040518663ffffffff1660e01b81526004016148e89594939291906164bf565b6020604051808303816000875af1158015614907573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061492b9190615c0c565b90506000811461497257806040517f1429a2f2000000000000000000000000000000000000000000000000000000008152600401614969919061538c565b60405180910390fd5b61497a612f98565b600954146149b4576040517f80965b1b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6149bc612f98565b8273ffffffffffffffffffffffffffffffffffffffff16636c540baf6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614a07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614a2b9190615c0c565b14614a62576040517f82379c6800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161415614ac8576040517f6f46988400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000831415614b03576040517fd29da7ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831415614b5d576040517fb3058b7600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000614b6a868686613a9f565b9050600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c488847b3087866040518463ffffffff1660e01b8152600401614bce9392919061673f565b6040805180830381865afa158015614bea573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614c0e91906167bb565b9150915060008214614c55576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614c4c9061686d565b60405180910390fd5b808573ffffffffffffffffffffffffffffffffffffffff166370a08231896040518263ffffffff1660e01b8152600401614c8f9190615872565b602060405180830381865afa158015614cac573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614cd09190615c0c565b1015614d11576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614d08906168d9565b60405180910390fd5b3073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161415614d5657614d51308989846132b1565b614e19565b60008573ffffffffffffffffffffffffffffffffffffffff1663b2a02ff18a8a856040518463ffffffff1660e01b8152600401614d959392919061673f565b6020604051808303816000875af1158015614db4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614dd89190615c0c565b14614e18576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614e0f90616945565b60405180910390fd5b5b7f298637f684da70674f26509b10f07ec2fbc77a335ab1e7d6215a4b2484d8bb528888858885604051614e50959493929190616965565b60405180910390a15050505050505050565b600080601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600081905060008273ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401614eca9190615872565b602060405180830381865afa158015614ee7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614f0b9190615c0c565b90508173ffffffffffffffffffffffffffffffffffffffff166323b872dd8730886040518463ffffffff1660e01b8152600401614f4a9392919061673f565b600060405180830381600087803b158015614f6457600080fd5b505af1158015614f78573d6000803e3d6000fd5b5050505060003d60008114614f945760208114614f9e57600080fd5b6000199150614faa565b60206000803e60005191505b5080614feb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614fe290616a04565b60405180910390fd5b60008473ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016150269190615872565b602060405180830381865afa158015615043573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906150679190615c0c565b9050828161507591906162ad565b9550505050505092915050565b60006150a361509984670de0b6b3a76400006145a9565b83600001516150ab565b905092915050565b600081836150b991906163e9565b905092915050565b8280546150cd90615b59565b90600052602060002090601f0160209004810192826150ef5760008555615136565b82601f1061510857805160ff1916838001178555615136565b82800160010185558215615136579182015b8281111561513557825182559160200191906001019061511a565b5b509050615143919061515a565b5090565b6040518060200160405280600081525090565b5b8082111561517357600081600090555060010161515b565b5090565b600081519050919050565b600082825260208201905092915050565b60005b838110156151b1578082015181840152602081019050615196565b838111156151c0576000848401525b50505050565b6000601f19601f8301169050919050565b60006151e282615177565b6151ec8185615182565b93506151fc818560208601615193565b615205816151c6565b840191505092915050565b6000602082019050818103600083015261522a81846151d7565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061527182615246565b9050919050565b61528181615266565b811461528c57600080fd5b50565b60008135905061529e81615278565b92915050565b6000819050919050565b6152b7816152a4565b81146152c257600080fd5b50565b6000813590506152d4816152ae565b92915050565b600080604083850312156152f1576152f061523c565b5b60006152ff8582860161528f565b9250506020615310858286016152c5565b9150509250929050565b60008115159050919050565b61532f8161531a565b82525050565b600060208201905061534a6000830184615326565b92915050565b6000602082840312156153665761536561523c565b5b6000615374848285016152c5565b91505092915050565b615386816152a4565b82525050565b60006020820190506153a1600083018461537d565b92915050565b6000602082840312156153bd576153bc61523c565b5b60006153cb8482850161528f565b91505092915050565b60006153df82615266565b9050919050565b6153ef816153d4565b81146153fa57600080fd5b50565b60008135905061540c816153e6565b92915050565b600061541d82615266565b9050919050565b61542d81615412565b811461543857600080fd5b50565b60008135905061544a81615424565b92915050565b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b615492826151c6565b810181811067ffffffffffffffff821117156154b1576154b061545a565b5b80604052505050565b60006154c4615232565b90506154d08282615489565b919050565b600067ffffffffffffffff8211156154f0576154ef61545a565b5b6154f9826151c6565b9050602081019050919050565b82818337600083830152505050565b6000615528615523846154d5565b6154ba565b90508281526020810184848401111561554457615543615455565b5b61554f848285615506565b509392505050565b600082601f83011261556c5761556b615450565b5b813561557c848260208601615515565b91505092915050565b600060ff82169050919050565b61559b81615585565b81146155a657600080fd5b50565b6000813590506155b881615592565b92915050565b600080600080600080600060e0888a0312156155dd576155dc61523c565b5b60006155eb8a828b0161528f565b97505060206155fc8a828b016153fd565b965050604061560d8a828b0161543b565b955050606061561e8a828b016152c5565b945050608088013567ffffffffffffffff81111561563f5761563e615241565b5b61564b8a828b01615557565b93505060a088013567ffffffffffffffff81111561566c5761566b615241565b5b6156788a828b01615557565b92505060c06156898a828b016155a9565b91505092959891949750929550565b60006156a382615266565b9050919050565b6156b381615698565b81146156be57600080fd5b50565b6000813590506156d0816156aa565b92915050565b6000602082840312156156ec576156eb61523c565b5b60006156fa848285016156c1565b91505092915050565b60008060006060848603121561571c5761571b61523c565b5b600061572a8682870161528f565b935050602061573b8682870161528f565b925050604061574c868287016152c5565b9150509250925092565b600061576182615246565b9050919050565b61577181615756565b82525050565b600060208201905061578c6000830184615768565b92915050565b61579b81615585565b82525050565b60006020820190506157b66000830184615792565b92915050565b6000602082840312156157d2576157d161523c565b5b60006157e0848285016153fd565b91505092915050565b6000819050919050565b600061580e61580961580484615246565b6157e9565b615246565b9050919050565b6000615820826157f3565b9050919050565b600061583282615815565b9050919050565b61584281615827565b82525050565b600060208201905061585d6000830184615839565b92915050565b61586c81615266565b82525050565b60006020820190506158876000830184615863565b92915050565b60008060008060008060c087890312156158aa576158a961523c565b5b60006158b889828a016153fd565b96505060206158c989828a0161543b565b95505060406158da89828a016152c5565b945050606087013567ffffffffffffffff8111156158fb576158fa615241565b5b61590789828a01615557565b935050608087013567ffffffffffffffff81111561592857615927615241565b5b61593489828a01615557565b92505060a061594589828a016155a9565b9150509295509295509295565b61595b81615756565b811461596657600080fd5b50565b60008135905061597881615952565b92915050565b6000602082840312156159945761599361523c565b5b60006159a284828501615969565b91505092915050565b60006080820190506159c0600083018761537d565b6159cd602083018661537d565b6159da604083018561537d565b6159e7606083018461537d565b95945050505050565b60008060408385031215615a0757615a0661523c565b5b6000615a158582860161528f565b9250506020615a268582860161528f565b9150509250929050565b600060208284031215615a4657615a4561523c565b5b6000615a548482850161543b565b91505092915050565b6000615a6882615815565b9050919050565b615a7881615a5d565b82525050565b6000602082019050615a936000830184615a6f565b92915050565b6000615aa482615266565b9050919050565b615ab481615a99565b8114615abf57600080fd5b50565b600081359050615ad181615aab565b92915050565b600080600060608486031215615af057615aef61523c565b5b6000615afe8682870161528f565b9350506020615b0f868287016152c5565b9250506040615b2086828701615ac2565b9150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680615b7157607f821691505b60208210811415615b8557615b84615b2a565b5b50919050565b7f72652d656e746572656400000000000000000000000000000000000000000000600082015250565b6000615bc1600a83615182565b9150615bcc82615b8b565b602082019050919050565b60006020820190508181036000830152615bf081615bb4565b9050919050565b600081519050615c06816152ae565b92915050565b600060208284031215615c2257615c2161523c565b5b6000615c3084828501615bf7565b91505092915050565b7f4345726332303a3a7377656570546f6b656e3a206f6e6c792061646d696e206360008201527f616e20737765657020746f6b656e730000000000000000000000000000000000602082015250565b6000615c95602f83615182565b9150615ca082615c39565b604082019050919050565b60006020820190508181036000830152615cc481615c88565b9050919050565b7f4345726332303a3a7377656570546f6b656e3a2063616e206e6f74207377656560008201527f7020756e6465726c79696e6720746f6b656e0000000000000000000000000000602082015250565b6000615d27603283615182565b9150615d3282615ccb565b604082019050919050565b60006020820190508181036000830152615d5681615d1a565b9050919050565b6000615d6882615815565b9050919050565b615d7881615d5d565b82525050565b6000604082019050615d936000830185615d6f565b615da0602083018461537d565b9392505050565b615db08161531a565b8114615dbb57600080fd5b50565b600081519050615dcd81615da7565b92915050565b600060208284031215615de957615de861523c565b5b6000615df784828501615dbe565b91505092915050565b7f6d61726b6572206d6574686f642072657475726e65642066616c736500000000600082015250565b6000615e36601c83615182565b9150615e4182615e00565b602082019050919050565b60006020820190508181036000830152615e6581615e29565b9050919050565b6000604082019050615e816000830185615839565b615e8e6020830184615839565b9392505050565b7f6f6e6c79207468652061646d696e206d6179207365742074686520636f6d702d60008201527f6c696b652064656c656761746500000000000000000000000000000000000000602082015250565b6000615ef1602d83615182565b9150615efc82615e95565b604082019050919050565b60006020820190508181036000830152615f2081615ee4565b9050919050565b7f6f6e6c792061646d696e206d617920696e697469616c697a6520746865206d6160008201527f726b657400000000000000000000000000000000000000000000000000000000602082015250565b6000615f83602483615182565b9150615f8e82615f27565b604082019050919050565b60006020820190508181036000830152615fb281615f76565b9050919050565b7f6d61726b6574206d6179206f6e6c7920626520696e697469616c697a6564206f60008201527f6e63650000000000000000000000000000000000000000000000000000000000602082015250565b6000616015602383615182565b915061602082615fb9565b604082019050919050565b6000602082019050818103600083015261604481616008565b9050919050565b7f696e697469616c2065786368616e67652072617465206d75737420626520677260008201527f6561746572207468616e207a65726f2e00000000000000000000000000000000602082015250565b60006160a7603083615182565b91506160b28261604b565b604082019050919050565b600060208201905081810360008301526160d68161609a565b9050919050565b7f73657474696e6720636f6d7074726f6c6c6572206661696c6564000000000000600082015250565b6000616113601a83615182565b915061611e826160dd565b602082019050919050565b6000602082019050818103600083015261614281616106565b9050919050565b7f73657474696e6720696e7465726573742072617465206d6f64656c206661696c60008201527f6564000000000000000000000000000000000000000000000000000000000000602082015250565b60006161a5602283615182565b91506161b082616149565b604082019050919050565b600060208201905081810360008301526161d481616198565b9050919050565b60006060820190506161f0600083018661537d565b6161fd602083018561537d565b61620a604083018461537d565b949350505050565b7f626f72726f772072617465206973206162737572646c79206869676800000000600082015250565b6000616248601c83615182565b915061625382616212565b602082019050919050565b600060208201905081810360008301526162778161623b565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006162b8826152a4565b91506162c3836152a4565b9250828210156162d6576162d561627e565b5b828203905092915050565b60006162ec826152a4565b91506162f7836152a4565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561632c5761632b61627e565b5b828201905092915050565b600060408201905061634c6000830185615863565b6163596020830184615d6f565b9392505050565b600061636b826152a4565b9150616376836152a4565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156163af576163ae61627e565b5b828202905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006163f4826152a4565b91506163ff836152a4565b92508261640f5761640e6163ba565b5b828204905092915050565b600060808201905061642f6000830187615863565b61643c6020830186615863565b6164496040830185615863565b616456606083018461537d565b95945050505050565b60006060820190506164746000830186615d6f565b616481602083018561537d565b61648e604083018461537d565b949350505050565b60006040820190506164ab6000830185615a6f565b6164b86020830184615a6f565b9392505050565b600060a0820190506164d46000830188615863565b6164e16020830187615863565b6164ee6040830186615863565b6164fb6060830185615863565b616508608083018461537d565b9695505050505050565b60006060820190506165276000830186615863565b616534602083018561537d565b616541604083018461537d565b949350505050565b600060408201905061655e600083018561537d565b61656b602083018461537d565b9392505050565b600060a0820190506165876000830188615863565b6165946020830187615863565b6165a1604083018661537d565b6165ae606083018561537d565b6165bb608083018461537d565b9695505050505050565b7f544f4b454e5f5452414e534645525f4f55545f4641494c454400000000000000600082015250565b60006165fb601983615182565b9150616606826165c5565b602082019050919050565b6000602082019050818103600083015261662a816165ee565b9050919050565b7f6f6e65206f662072656465656d546f6b656e73496e206f722072656465656d4160008201527f6d6f756e74496e206d757374206265207a65726f000000000000000000000000602082015250565b600061668d603483615182565b915061669882616631565b604082019050919050565b600060208201905081810360008301526166bc81616680565b9050919050565b60006060820190506166d86000830186615863565b6166e56020830185615d6f565b6166f2604083018461537d565b949350505050565b600060808201905061670f6000830187615863565b61671c6020830186615d6f565b616729604083018561537d565b616736606083018461537d565b95945050505050565b60006060820190506167546000830186615863565b6167616020830185615863565b61676e604083018461537d565b949350505050565b600060808201905061678b6000830187615d6f565b616798602083018661537d565b6167a5604083018561537d565b6167b2606083018461537d565b95945050505050565b600080604083850312156167d2576167d161523c565b5b60006167e085828601615bf7565b92505060206167f185828601615bf7565b9150509250929050565b7f4c49515549444154455f434f4d5054524f4c4c45525f43414c43554c4154455f60008201527f414d4f554e545f5345495a455f4641494c454400000000000000000000000000602082015250565b6000616857603383615182565b9150616862826167fb565b604082019050919050565b600060208201905081810360008301526168868161684a565b9050919050565b7f4c49515549444154455f5345495a455f544f4f5f4d5543480000000000000000600082015250565b60006168c3601883615182565b91506168ce8261688d565b602082019050919050565b600060208201905081810360008301526168f2816168b6565b9050919050565b7f746f6b656e207365697a757265206661696c6564000000000000000000000000600082015250565b600061692f601483615182565b915061693a826168f9565b602082019050919050565b6000602082019050818103600083015261695e81616922565b9050919050565b600060a08201905061697a6000830188615863565b6169876020830187615863565b616994604083018661537d565b6169a16060830185615863565b6169ae608083018461537d565b9695505050505050565b7f544f4b454e5f5452414e534645525f494e5f4641494c45440000000000000000600082015250565b60006169ee601883615182565b91506169f9826169b8565b602082019050919050565b60006020820190508181036000830152616a1d816169e1565b905091905056fea26469706673582212204ca6d65a17d076fcff62c17a0ca3d046917b327008ac99c82974b173ca10690064736f6c634300080a0033",
  deployedBytecode: "0x608060405234801561001057600080fd5b506004361061030c5760003560e01c80637f1e06be1161019d578063bd6d894d116100e9578063f2b3abbd116100a2578063f851a4401161007c578063f851a44014610a38578063f8f9da2814610a56578063fca7820b14610a74578063fe9c44ae14610aa45761030c565b8063f2b3abbd146109ba578063f3fdb15a146109ea578063f5e3c46214610a085761030c565b8063bd6d894d146108bb578063c37f68e2146108d9578063c5ebeaec1461090c578063db006a751461093c578063dd62ed3e1461096c578063e9c714f21461099c5761030c565b8063a0712d6811610156578063aa5af0fd11610130578063aa5af0fd1461081f578063ae9d70b01461083d578063b2a02ff11461085b578063b71d1a0c1461088b5761030c565b8063a0712d68146107a1578063a6afed95146107d1578063a9059cbb146107ef5761030c565b80637f1e06be146106cd578063852a12e3146106e95780638f840ddd1461071957806395d89b411461073757806395dd91931461075557806399d8c1b4146107855761030c565b80633af9e6691161025c578063601a0bf1116102155780636c540baf116101ef5780636c540baf146106435780636f307dc31461066157806370a082311461067f57806373acee98146106af5761030c565b8063601a0bf1146105d75780636752e7021461060757806369ab3250146106255761030c565b80633af9e669146104ed5780633b1d21a21461051d5780633e9410101461053b5780634576b5db1461056b57806347bd37181461059b5780635fe3b567146105b95761030c565b8063182df0f5116102c957806323b872dd116102a357806323b872dd146104515780632608f8181461048157806326782247146104b1578063313ce567146104cf5761030c565b8063182df0f5146103fb5780631a31d465146104195780631be19560146104355761030c565b806306fdde0314610311578063095ea7b31461032f5780630e7527021461035f578063173b99041461038f57806317bfdfbc146103ad57806318160ddd146103dd575b600080fd5b610319610ac2565b6040516103269190615210565b60405180910390f35b610349600480360381019061034491906152da565b610b50565b6040516103569190615335565b60405180910390f35b61037960048036038101906103749190615350565b610c47565b604051610386919061538c565b60405180910390f35b610397610c5b565b6040516103a4919061538c565b60405180910390f35b6103c760048036038101906103c291906153a7565b610c61565b6040516103d4919061538c565b60405180910390f35b6103e5610cfe565b6040516103f2919061538c565b60405180910390f35b610403610d04565b604051610410919061538c565b60405180910390f35b610433600480360381019061042e91906155be565b610d13565b005b61044f600480360381019061044a91906156d6565b610dfd565b005b61046b60048036038101906104669190615703565b61102f565b6040516104789190615335565b60405180910390f35b61049b600480360381019061049691906152da565b6110cb565b6040516104a8919061538c565b60405180910390f35b6104b96110e1565b6040516104c69190615777565b60405180910390f35b6104d7611107565b6040516104e491906157a1565b60405180910390f35b610507600480360381019061050291906153a7565b61111a565b604051610514919061538c565b60405180910390f35b610525611186565b604051610532919061538c565b60405180910390f35b61055560048036038101906105509190615350565b611195565b604051610562919061538c565b60405180910390f35b610585600480360381019061058091906157bc565b6111a7565b604051610592919061538c565b60405180910390f35b6105a3611388565b6040516105b0919061538c565b60405180910390f35b6105c161138e565b6040516105ce9190615848565b60405180910390f35b6105f160048036038101906105ec9190615350565b6113b4565b6040516105fe919061538c565b60405180910390f35b61060f611451565b60405161061c919061538c565b60405180910390f35b61062d61145c565b60405161063a919061538c565b60405180910390f35b61064b611461565b604051610658919061538c565b60405180910390f35b610669611467565b6040516106769190615872565b60405180910390f35b610699600480360381019061069491906153a7565b61148d565b6040516106a6919061538c565b60405180910390f35b6106b76114d6565b6040516106c4919061538c565b60405180910390f35b6106e760048036038101906106e291906153a7565b61156b565b005b61070360048036038101906106fe9190615350565b61168b565b604051610710919061538c565b60405180910390f35b61072161169f565b60405161072e919061538c565b60405180910390f35b61073f6116a5565b60405161074c9190615210565b60405180910390f35b61076f600480360381019061076a91906153a7565b611733565b60405161077c919061538c565b60405180910390f35b61079f600480360381019061079a919061588d565b611745565b005b6107bb60048036038101906107b69190615350565b61199b565b6040516107c8919061538c565b60405180910390f35b6107d96119af565b6040516107e6919061538c565b60405180910390f35b610809600480360381019061080491906152da565b611bca565b6040516108169190615335565b60405180910390f35b610827611c65565b604051610834919061538c565b60405180910390f35b610845611c6b565b604051610852919061538c565b60405180910390f35b61087560048036038101906108709190615703565b611d21565b604051610882919061538c565b60405180910390f35b6108a560048036038101906108a0919061597e565b611dbc565b6040516108b2919061538c565b60405180910390f35b6108c3611ef0565b6040516108d0919061538c565b60405180910390f35b6108f360048036038101906108ee91906153a7565b611f8a565b60405161090394939291906159ab565b60405180910390f35b61092660048036038101906109219190615350565b611ff2565b604051610933919061538c565b60405180910390f35b61095660048036038101906109519190615350565b612006565b604051610963919061538c565b60405180910390f35b610986600480360381019061098191906159f0565b61201a565b604051610993919061538c565b60405180910390f35b6109a46120a1565b6040516109b1919061538c565b60405180910390f35b6109d460048036038101906109cf9190615a30565b612315565b6040516109e1919061538c565b60405180910390f35b6109f2612330565b6040516109ff9190615a7e565b60405180910390f35b610a226004803603810190610a1d9190615ad7565b612356565b604051610a2f919061538c565b60405180910390f35b610a4061236e565b604051610a4d9190615777565b60405180910390f35b610a5e612394565b604051610a6b919061538c565b60405180910390f35b610a8e6004803603810190610a899190615350565b612446565b604051610a9b919061538c565b60405180910390f35b610aac6124e3565b604051610ab99190615335565b60405180910390f35b60018054610acf90615b59565b80601f0160208091040260200160405190810160405280929190818152602001828054610afb90615b59565b8015610b485780601f10610b1d57610100808354040283529160200191610b48565b820191906000526020600020905b815481529060010190602001808311610b2b57829003601f168201915b505050505081565b60008033905082600f60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508373ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b92585604051610c34919061538c565b60405180910390a3600191505092915050565b6000610c52826124e8565b60009050919050565b60085481565b60008060009054906101000a900460ff16610cb1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610ca890615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550610cd36119af565b50610cdd82611733565b905060016000806101000a81548160ff021916908315150217905550919050565b600d5481565b6000610d0e612581565b905090565b610d21868686868686611745565b86601160006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff160217905550601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166318160ddd6040518163ffffffff1660e01b8152600401602060405180830381865afa158015610dcf573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610df39190615c0c565b5050505050505050565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614610e8d576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610e8490615cab565b60405180910390fd5b601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168173ffffffffffffffffffffffffffffffffffffffff161415610f1e576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401610f1590615d3d565b60405180910390fd5b60008173ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401610f599190615872565b602060405180830381865afa158015610f76573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f9a9190615c0c565b90508173ffffffffffffffffffffffffffffffffffffffff1663a9059cbb600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff16836040518363ffffffff1660e01b8152600401610ff9929190615d7e565b600060405180830381600087803b15801561101357600080fd5b505af1158015611027573d6000803e3d6000fd5b505050505050565b60008060009054906101000a900460ff1661107f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161107690615bd7565b60405180910390fd5b60008060006101000a81548160ff02191690831515021790555060006110a7338686866125f6565b14905060016000806101000a81548160ff0219169083151502179055509392505050565b60006110d78383612a7d565b6000905092915050565b600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b600360009054906101000a900460ff1681565b6000806040518060200160405280611130611ef0565b815250905061117e81600e60008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054612b17565b915050919050565b6000611190612b38565b905090565b60006111a082612be0565b9050919050565b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611230576040517fd219dc1f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508273ffffffffffffffffffffffffffffffffffffffff16627e3dd26040518163ffffffff1660e01b8152600401602060405180830381865afa1580156112a1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112c59190615dd3565b611304576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016112fb90615e4c565b60405180910390fd5b82600560006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507f7ac369dbd14fa5ea3f473ed67cc9d598964a77501540ba6751eb0b3decf5870d8184604051611376929190615e6c565b60405180910390a16000915050919050565b600b5481565b600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60008060009054906101000a900460ff16611404576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016113fb90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506114266119af565b5061143082612c81565b905060016000806101000a81548160ff021916908315150217905550919050565b666379da05b6000081565b600081565b60095481565b601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600e60008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020549050919050565b60008060009054906101000a900460ff16611526576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161151d90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506115486119af565b50600b54905060016000806101000a81548160ff02191690831515021790555090565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146115fb576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016115f290615f07565b60405180910390fd5b601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635c19a95c826040518263ffffffff1660e01b81526004016116569190615872565b600060405180830381600087803b15801561167057600080fd5b505af1158015611684573d6000803e3d6000fd5b5050505050565b600061169682612e74565b60009050919050565b600c5481565b600280546116b290615b59565b80601f01602080910402602001604051908101604052809291908181526020018280546116de90615b59565b801561172b5780601f106117005761010080835404028352916020019161172b565b820191906000526020600020905b81548152906001019060200180831161170e57829003601f168201915b505050505081565b600061173e82612f0d565b9050919050565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146117d5576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016117cc90615f99565b60405180910390fd5b60006009541480156117e957506000600a54145b611828576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161181f9061602b565b60405180910390fd5b83600781905550600060075411611874576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161186b906160bd565b60405180910390fd5b600061187f876111a7565b9050600081146118c4576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016118bb90616129565b60405180910390fd5b6118cc612f98565b600981905550670de0b6b3a7640000600a819055506118ea86612fa0565b90506000811461192f576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611926906161bb565b60405180910390fd5b83600190805190602001906119459291906150c1565b50826002908051906020019061195c9291906150c1565b5081600360006101000a81548160ff021916908360ff16021790555060016000806101000a81548160ff02191690831515021790555050505050505050565b60006119a6826131c3565b60009050919050565b6000806119ba612f98565b905060006009549050818114156119d657600092505050611bc7565b60006119e0612b38565b90506000600b5490506000600c5490506000600a5490506000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166315f240538686866040518463ffffffff1660e01b8152600401611a58939291906161db565b602060405180830381865afa158015611a75573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611a999190615c0c565b905065048c27395000811115611ae4576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611adb9061625e565b60405180910390fd5b60008688611af291906162ad565b90506000611b0e6040518060200160405280858152508361325a565b90506000611b1c8288612b17565b905060008782611b2c91906162e1565b90506000611b4b6040518060200160405280600854815250848a613286565b90506000611b5a85898a613286565b90508c60098190555080600a8190555082600b8190555081600c819055507f4dec04e750ca11537cabcd8a9eab06494de08da3735bc8871cd41250e190bc048b858386604051611bad94939291906159ab565b60405180910390a160009d50505050505050505050505050505b90565b60008060009054906101000a900460ff16611c1a576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611c1190615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506000611c42333386866125f6565b14905060016000806101000a81548160ff02191690831515021790555092915050565b600a5481565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663b8168816611cb3612b38565b600b54600c546008546040518563ffffffff1660e01b8152600401611cdb94939291906159ab565b602060405180830381865afa158015611cf8573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190611d1c9190615c0c565b905090565b60008060009054906101000a900460ff16611d71576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611d6890615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550611d97338585856132b1565b6000905060016000806101000a81548160ff0219169083151502179055509392505050565b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614611e45576040517f5cb56c2b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16905082600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a98184604051611ede929190616337565b60405180910390a16000915050919050565b60008060009054906101000a900460ff16611f40576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401611f3790615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550611f626119af565b50611f6b610d04565b905060016000806101000a81548160ff02191690831515021790555090565b6000806000806000600e60008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054611fdb87612f0d565b611fe3612581565b93509350935093509193509193565b6000611ffd826136bb565b60009050919050565b600061201182613752565b60009050919050565b6000600f60008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054905092915050565b6000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614158061212c5750600073ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16145b15612163576040517f6e893ca400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690506000600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16600360016101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055506000600460006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507ff9ffabca9c8276e99321725bcb43fb076a6c66a54b7f21c4e8146d8519b417dc82600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff166040516122a9929190616337565b60405180910390a17fca4f2f25d0898edd99413412fb94012f9e54ec8142f9b093e7720646a95b16a981600460009054906101000a900473ffffffffffffffffffffffffffffffffffffffff16604051612304929190616337565b60405180910390a160009250505090565b600061231f6119af565b5061232982612fa0565b9050919050565b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b60006123638484846137eb565b600090509392505050565b600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1681565b6000600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166315f240536123dc612b38565b600b54600c546040518463ffffffff1660e01b8152600401612400939291906161db565b602060405180830381865afa15801561241d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906124419190615c0c565b905090565b60008060009054906101000a900460ff16612496576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161248d90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506124b86119af565b506124c282613941565b905060016000806101000a81548160ff021916908315150217905550919050565b600181565b60008054906101000a900460ff16612535576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161252c90615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506125576119af565b50612563333383613a9f565b5060016000806101000a81548160ff02191690831515021790555050565b600080600d549050600081141561259d576007549150506125f3565b60006125a7612b38565b90506000600c54600b54836125bc91906162e1565b6125c691906162ad565b9050600083670de0b6b3a7640000836125df9190616360565b6125e991906163e9565b9050809450505050505b90565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663bdcdc258308787876040518563ffffffff1660e01b815260040161265a949392919061641a565b6020604051808303816000875af1158015612679573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061269d9190615c0c565b9050600081146126e457806040517f113a84ee0000000000000000000000000000000000000000000000000000000081526004016126db919061538c565b60405180910390fd5b8373ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff16141561274a576040517f8cd22d1900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60008573ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff1614156127a8577fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9050612828565b600f60008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205490505b6000848261283691906162ad565b9050600085600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461288591906162ad565b9050600086600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546128d491906162e1565b905081600e60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555080600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8414612a075782600f60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008c73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055505b8773ffffffffffffffffffffffffffffffffffffffff168973ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef89604051612a64919061538c565b60405180910390a3600095505050505050949350505050565b60008054906101000a900460ff16612aca576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612ac190615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550612aec6119af565b50612af8338383613a9f565b5060016000806101000a81548160ff0219169083151502179055505050565b600080612b24848461325a565b9050612b2f81613d25565b91505092915050565b600080601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508073ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401612b999190615872565b602060405180830381865afa158015612bb6573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190612bda9190615c0c565b91505090565b60008060009054906101000a900460ff16612c30576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612c2790615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550612c526119af565b50612c5c82613d46565b50506000905060016000806101000a81548160ff021916908315150217905550919050565b600080600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff1614612d0b576040517ff7e5e6d000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b612d13612f98565b60095414612d4d576040517fdff50cb000000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82612d56612b38565b1015612d8e576040517f3345e99900000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600c54831115612dca576040517ff1a5300a00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600c54612dd891906162ad565b905080600c81905550612e0d600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1684613e05565b7f3bad0c59cf2f06e7314077049f48a93578cd16f5ef92329f1dab1420a99c177e600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff168483604051612e629392919061645f565b60405180910390a16000915050919050565b60008054906101000a900460ff16612ec1576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401612eb890615bd7565b60405180910390fd5b60008060006101000a81548160ff021916908315150217905550612ee36119af565b50612ef033600083613f0e565b60016000806101000a81548160ff02191690831515021790555050565b600080601060008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000209050600081600001541415612f68576000915050612f93565b6000600a548260000154612f7c9190616360565b9050816001015481612f8e91906163e9565b925050505b919050565b600043905090565b600080600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff161461302a576040517f407fded500000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b613032612f98565b6009541461306c576040517f17c54b9600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600660009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508273ffffffffffffffffffffffffffffffffffffffff16632191f92a6040518163ffffffff1660e01b8152600401602060405180830381865afa1580156130dc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906131009190615dd3565b61313f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161313690615e4c565b60405180910390fd5b82600660006101000a81548173ffffffffffffffffffffffffffffffffffffffff021916908373ffffffffffffffffffffffffffffffffffffffff1602179055507fedffc32e068c7c95dfd4bdfd5c4d939a084d6b11c4199eac8436ed234d72f92681846040516131b1929190616496565b60405180910390a16000915050919050565b60008054906101000a900460ff16613210576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161320790615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506132326119af565b5061323d33826142fc565b60016000806101000a81548160ff02191690831515021790555050565b613262615147565b604051806020016040528061327b8560000151856145a9565b815250905092915050565b600080613293858561325a565b90506132a76132a182613d25565b846145bf565b9150509392505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663d02f735130878787876040518663ffffffff1660e01b81526004016133169594939291906164bf565b6020604051808303816000875af1158015613335573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906133599190615c0c565b9050600081146133a057806040517fc7c01c66000000000000000000000000000000000000000000000000000000008152600401613397919061538c565b60405180910390fd5b8373ffffffffffffffffffffffffffffffffffffffff168373ffffffffffffffffffffffffffffffffffffffff161415613406576040517f7528c4ce00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000613427836040518060200160405280666379da05b600008152506145d5565b90506000818461343791906162ad565b90506000604051806020016040528061344e612581565b8152509050600061345f8285612b17565b9050600081600c5461347191906162e1565b905080600c8190555084600d5461348891906162ad565b600d8190555086600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546134d991906162ad565b600e60008a73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000208190555083600e60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461356791906162e1565b600e60008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508873ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef86604051613607919061538c565b60405180910390a33073ffffffffffffffffffffffffffffffffffffffff168873ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8760405161366c919061538c565b60405180910390a37fa91e67c5ea634cd43a12c5a482724b03de01e85ca68702a53d0c2f45cb7c1dc53083836040516136a793929190616512565b60405180910390a150505050505050505050565b60008054906101000a900460ff16613708576040517f08c379a00000000000000000000000000000000000000000000000000000000081526004016136ff90615bd7565b60405180910390fd5b60008060006101000a81548160ff02191690831515021790555061372a6119af565b506137353382614600565b60016000806101000a81548160ff02191690831515021790555050565b60008054906101000a900460ff1661379f576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161379690615bd7565b60405180910390fd5b60008060006101000a81548160ff0219169083151502179055506137c16119af565b506137ce33826000613f0e565b60016000806101000a81548160ff02191690831515021790555050565b60008054906101000a900460ff16613838576040517f08c379a000000000000000000000000000000000000000000000000000000000815260040161382f90615bd7565b60405180910390fd5b60008060006101000a81548160ff02191690831515021790555061385a6119af565b5060008173ffffffffffffffffffffffffffffffffffffffff1663a6afed956040518163ffffffff1660e01b81526004016020604051808303816000875af11580156138aa573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906138ce9190615c0c565b90506000811461391557806040517f7dd4936e00000000000000000000000000000000000000000000000000000000815260040161390c919061538c565b60405180910390fd5b61392133858585614883565b5060016000806101000a81548160ff021916908315150217905550505050565b6000600360019054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff16146139ca576040517f240b6af600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6139d2612f98565b60095414613a0c576040517ffbf94d6e00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b670de0b6b3a7640000821115613a4e576040517fe2e441e600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b60006008549050826008819055507faaa68312e2ea9d50e16af5068410ab56e1a1fd06037b1a35664812c30f8214608184604051613a8d929190616549565b60405180910390a16000915050919050565b600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166324008a62308787876040518563ffffffff1660e01b8152600401613b03949392919061641a565b6020604051808303816000875af1158015613b22573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190613b469190615c0c565b905060008114613b8d57806040517f8c81362d000000000000000000000000000000000000000000000000000000008152600401613b84919061538c565b60405180910390fd5b613b95612f98565b60095414613bcf576040517fc9021e2f00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000613bda85612f0d565b905060007fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8514613c0b5784613c0d565b815b90506000613c1b8883614e62565b905060008184613c2b91906162ad565b9050600082600b54613c3d91906162ad565b905081601060008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000181905550600a54601060008b73ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018190555080600b819055507f1a2a22cb034d26d1854bdc6666a5b91fe25efbbb5dcad3b0355478d6f5c362a18a8a858585604051613d0d959493929190616572565b60405180910390a18296505050505050509392505050565b6000670de0b6b3a76400008260000151613d3f91906163e9565b9050919050565b600080600080613d54612f98565b60095414613d9957806040517f38acf799000000000000000000000000000000000000000000000000000000008152600401613d90919061538c565b60405180910390fd5b613da33386614e62565b905080600c54613db391906162e1565b915081600c819055507fa91e67c5ea634cd43a12c5a482724b03de01e85ca68702a53d0c2f45cb7c1dc5338284604051613def93929190616512565b60405180910390a1600081935093505050915091565b6000601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1690508073ffffffffffffffffffffffffffffffffffffffff1663a9059cbb84846040518363ffffffff1660e01b8152600401613e67929190615d7e565b600060405180830381600087803b158015613e8157600080fd5b505af1158015613e95573d6000803e3d6000fd5b5050505060003d60008114613eb15760208114613ebb57600080fd5b6000199150613ec7565b60206000803e60005191505b5080613f08576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613eff90616611565b60405180910390fd5b50505050565b6000821480613f1d5750600081145b613f5c576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401613f53906166a3565b60405180910390fd5b60006040518060200160405280613f71612581565b81525090506000806000851115613f9657849150613f8f8386612b17565b9050613fa6565b613fa08484615082565b91508390505b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663eabe7d913089866040518463ffffffff1660e01b8152600401614007939291906166c3565b6020604051808303816000875af1158015614026573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061404a9190615c0c565b90506000811461409157806040517f480f4247000000000000000000000000000000000000000000000000000000008152600401614088919061538c565b60405180910390fd5b614099612f98565b600954146140d3576040517f97b5cfcd00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b816140dc612b38565b1015614114576040517f91240a1b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b82600d5461412291906162ad565b600d8190555082600e60008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205461417391906162ad565b600e60008973ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055506141c08783613e05565b3073ffffffffffffffffffffffffffffffffffffffff168773ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef8560405161421d919061538c565b60405180910390a37fe5b754fb1abb7f01b499791d0b820ae3b6af3424ac1c59768edb53f4ec31a9298783856040516142589392919061645f565b60405180910390a1600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff166351dff989308985876040518563ffffffff1660e01b81526004016142c194939291906166fa565b600060405180830381600087803b1580156142db57600080fd5b505af11580156142ef573d6000803e3d6000fd5b5050505050505050505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16634ef4c3e13085856040518463ffffffff1660e01b815260040161435d9392919061673f565b6020604051808303816000875af115801561437c573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906143a09190615c0c565b9050600081146143e757806040517f49abd4fd0000000000000000000000000000000000000000000000000000000081526004016143de919061538c565b60405180910390fd5b6143ef612f98565b60095414614429576040517f38d8859700000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000604051806020016040528061443e612581565b8152509050600061444f8585614e62565b9050600061445d8284615082565b905080600d5461446d91906162e1565b600d8190555080600e60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020546144be91906162e1565b600e60008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055507f4c209b5fc8ad50758f13e2e1088ba56a560dff690a1c6fef26394f4c03821c4f86838360405161453493929190616512565b60405180910390a18573ffffffffffffffffffffffffffffffffffffffff163073ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef83604051614599919061538c565b60405180910390a3505050505050565b600081836145b79190616360565b905092915050565b600081836145cd91906162e1565b905092915050565b6000670de0b6b3a76400006145ee8484600001516145a9565b6145f891906163e9565b905092915050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663da3d454c3085856040518463ffffffff1660e01b8152600401614661939291906166c3565b6020604051808303816000875af1158015614680573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906146a49190615c0c565b9050600081146146eb57806040517f918db40f0000000000000000000000000000000000000000000000000000000081526004016146e2919061538c565b60405180910390fd5b6146f3612f98565b6009541461472d576040517f3a36318400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b81614736612b38565b101561476e576040517f48c2588100000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b600061477984612f0d565b90506000838261478991906162e1565b9050600084600b5461479b91906162e1565b905081601060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060000181905550600a54601060008873ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206001018190555080600b8190555061483e8686613e05565b7f13ed6866d4e1ee6da46f845c46d7e54120883d75c5ea9a2dacc1c4ca8984ab80868684846040516148739493929190616776565b60405180910390a1505050505050565b6000600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16635fc7e71e30848888886040518663ffffffff1660e01b81526004016148e89594939291906164bf565b6020604051808303816000875af1158015614907573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061492b9190615c0c565b90506000811461497257806040517f1429a2f2000000000000000000000000000000000000000000000000000000008152600401614969919061538c565b60405180910390fd5b61497a612f98565b600954146149b4576040517f80965b1b00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6149bc612f98565b8273ffffffffffffffffffffffffffffffffffffffff16636c540baf6040518163ffffffff1660e01b8152600401602060405180830381865afa158015614a07573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614a2b9190615c0c565b14614a62576040517f82379c6800000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b8473ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff161415614ac8576040517f6f46988400000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000831415614b03576040517fd29da7ef00000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff831415614b5d576040517fb3058b7600000000000000000000000000000000000000000000000000000000815260040160405180910390fd5b6000614b6a868686613a9f565b9050600080600560009054906101000a900473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1663c488847b3087866040518463ffffffff1660e01b8152600401614bce9392919061673f565b6040805180830381865afa158015614bea573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614c0e91906167bb565b9150915060008214614c55576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614c4c9061686d565b60405180910390fd5b808573ffffffffffffffffffffffffffffffffffffffff166370a08231896040518263ffffffff1660e01b8152600401614c8f9190615872565b602060405180830381865afa158015614cac573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614cd09190615c0c565b1015614d11576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614d08906168d9565b60405180910390fd5b3073ffffffffffffffffffffffffffffffffffffffff168573ffffffffffffffffffffffffffffffffffffffff161415614d5657614d51308989846132b1565b614e19565b60008573ffffffffffffffffffffffffffffffffffffffff1663b2a02ff18a8a856040518463ffffffff1660e01b8152600401614d959392919061673f565b6020604051808303816000875af1158015614db4573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614dd89190615c0c565b14614e18576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614e0f90616945565b60405180910390fd5b5b7f298637f684da70674f26509b10f07ec2fbc77a335ab1e7d6215a4b2484d8bb528888858885604051614e50959493929190616965565b60405180910390a15050505050505050565b600080601160009054906101000a900473ffffffffffffffffffffffffffffffffffffffff169050600081905060008273ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b8152600401614eca9190615872565b602060405180830381865afa158015614ee7573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190614f0b9190615c0c565b90508173ffffffffffffffffffffffffffffffffffffffff166323b872dd8730886040518463ffffffff1660e01b8152600401614f4a9392919061673f565b600060405180830381600087803b158015614f6457600080fd5b505af1158015614f78573d6000803e3d6000fd5b5050505060003d60008114614f945760208114614f9e57600080fd5b6000199150614faa565b60206000803e60005191505b5080614feb576040517f08c379a0000000000000000000000000000000000000000000000000000000008152600401614fe290616a04565b60405180910390fd5b60008473ffffffffffffffffffffffffffffffffffffffff166370a08231306040518263ffffffff1660e01b81526004016150269190615872565b602060405180830381865afa158015615043573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906150679190615c0c565b9050828161507591906162ad565b9550505050505092915050565b60006150a361509984670de0b6b3a76400006145a9565b83600001516150ab565b905092915050565b600081836150b991906163e9565b905092915050565b8280546150cd90615b59565b90600052602060002090601f0160209004810192826150ef5760008555615136565b82601f1061510857805160ff1916838001178555615136565b82800160010185558215615136579182015b8281111561513557825182559160200191906001019061511a565b5b509050615143919061515a565b5090565b6040518060200160405280600081525090565b5b8082111561517357600081600090555060010161515b565b5090565b600081519050919050565b600082825260208201905092915050565b60005b838110156151b1578082015181840152602081019050615196565b838111156151c0576000848401525b50505050565b6000601f19601f8301169050919050565b60006151e282615177565b6151ec8185615182565b93506151fc818560208601615193565b615205816151c6565b840191505092915050565b6000602082019050818103600083015261522a81846151d7565b905092915050565b6000604051905090565b600080fd5b600080fd5b600073ffffffffffffffffffffffffffffffffffffffff82169050919050565b600061527182615246565b9050919050565b61528181615266565b811461528c57600080fd5b50565b60008135905061529e81615278565b92915050565b6000819050919050565b6152b7816152a4565b81146152c257600080fd5b50565b6000813590506152d4816152ae565b92915050565b600080604083850312156152f1576152f061523c565b5b60006152ff8582860161528f565b9250506020615310858286016152c5565b9150509250929050565b60008115159050919050565b61532f8161531a565b82525050565b600060208201905061534a6000830184615326565b92915050565b6000602082840312156153665761536561523c565b5b6000615374848285016152c5565b91505092915050565b615386816152a4565b82525050565b60006020820190506153a1600083018461537d565b92915050565b6000602082840312156153bd576153bc61523c565b5b60006153cb8482850161528f565b91505092915050565b60006153df82615266565b9050919050565b6153ef816153d4565b81146153fa57600080fd5b50565b60008135905061540c816153e6565b92915050565b600061541d82615266565b9050919050565b61542d81615412565b811461543857600080fd5b50565b60008135905061544a81615424565b92915050565b600080fd5b600080fd5b7f4e487b7100000000000000000000000000000000000000000000000000000000600052604160045260246000fd5b615492826151c6565b810181811067ffffffffffffffff821117156154b1576154b061545a565b5b80604052505050565b60006154c4615232565b90506154d08282615489565b919050565b600067ffffffffffffffff8211156154f0576154ef61545a565b5b6154f9826151c6565b9050602081019050919050565b82818337600083830152505050565b6000615528615523846154d5565b6154ba565b90508281526020810184848401111561554457615543615455565b5b61554f848285615506565b509392505050565b600082601f83011261556c5761556b615450565b5b813561557c848260208601615515565b91505092915050565b600060ff82169050919050565b61559b81615585565b81146155a657600080fd5b50565b6000813590506155b881615592565b92915050565b600080600080600080600060e0888a0312156155dd576155dc61523c565b5b60006155eb8a828b0161528f565b97505060206155fc8a828b016153fd565b965050604061560d8a828b0161543b565b955050606061561e8a828b016152c5565b945050608088013567ffffffffffffffff81111561563f5761563e615241565b5b61564b8a828b01615557565b93505060a088013567ffffffffffffffff81111561566c5761566b615241565b5b6156788a828b01615557565b92505060c06156898a828b016155a9565b91505092959891949750929550565b60006156a382615266565b9050919050565b6156b381615698565b81146156be57600080fd5b50565b6000813590506156d0816156aa565b92915050565b6000602082840312156156ec576156eb61523c565b5b60006156fa848285016156c1565b91505092915050565b60008060006060848603121561571c5761571b61523c565b5b600061572a8682870161528f565b935050602061573b8682870161528f565b925050604061574c868287016152c5565b9150509250925092565b600061576182615246565b9050919050565b61577181615756565b82525050565b600060208201905061578c6000830184615768565b92915050565b61579b81615585565b82525050565b60006020820190506157b66000830184615792565b92915050565b6000602082840312156157d2576157d161523c565b5b60006157e0848285016153fd565b91505092915050565b6000819050919050565b600061580e61580961580484615246565b6157e9565b615246565b9050919050565b6000615820826157f3565b9050919050565b600061583282615815565b9050919050565b61584281615827565b82525050565b600060208201905061585d6000830184615839565b92915050565b61586c81615266565b82525050565b60006020820190506158876000830184615863565b92915050565b60008060008060008060c087890312156158aa576158a961523c565b5b60006158b889828a016153fd565b96505060206158c989828a0161543b565b95505060406158da89828a016152c5565b945050606087013567ffffffffffffffff8111156158fb576158fa615241565b5b61590789828a01615557565b935050608087013567ffffffffffffffff81111561592857615927615241565b5b61593489828a01615557565b92505060a061594589828a016155a9565b9150509295509295509295565b61595b81615756565b811461596657600080fd5b50565b60008135905061597881615952565b92915050565b6000602082840312156159945761599361523c565b5b60006159a284828501615969565b91505092915050565b60006080820190506159c0600083018761537d565b6159cd602083018661537d565b6159da604083018561537d565b6159e7606083018461537d565b95945050505050565b60008060408385031215615a0757615a0661523c565b5b6000615a158582860161528f565b9250506020615a268582860161528f565b9150509250929050565b600060208284031215615a4657615a4561523c565b5b6000615a548482850161543b565b91505092915050565b6000615a6882615815565b9050919050565b615a7881615a5d565b82525050565b6000602082019050615a936000830184615a6f565b92915050565b6000615aa482615266565b9050919050565b615ab481615a99565b8114615abf57600080fd5b50565b600081359050615ad181615aab565b92915050565b600080600060608486031215615af057615aef61523c565b5b6000615afe8682870161528f565b9350506020615b0f868287016152c5565b9250506040615b2086828701615ac2565b9150509250925092565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052602260045260246000fd5b60006002820490506001821680615b7157607f821691505b60208210811415615b8557615b84615b2a565b5b50919050565b7f72652d656e746572656400000000000000000000000000000000000000000000600082015250565b6000615bc1600a83615182565b9150615bcc82615b8b565b602082019050919050565b60006020820190508181036000830152615bf081615bb4565b9050919050565b600081519050615c06816152ae565b92915050565b600060208284031215615c2257615c2161523c565b5b6000615c3084828501615bf7565b91505092915050565b7f4345726332303a3a7377656570546f6b656e3a206f6e6c792061646d696e206360008201527f616e20737765657020746f6b656e730000000000000000000000000000000000602082015250565b6000615c95602f83615182565b9150615ca082615c39565b604082019050919050565b60006020820190508181036000830152615cc481615c88565b9050919050565b7f4345726332303a3a7377656570546f6b656e3a2063616e206e6f74207377656560008201527f7020756e6465726c79696e6720746f6b656e0000000000000000000000000000602082015250565b6000615d27603283615182565b9150615d3282615ccb565b604082019050919050565b60006020820190508181036000830152615d5681615d1a565b9050919050565b6000615d6882615815565b9050919050565b615d7881615d5d565b82525050565b6000604082019050615d936000830185615d6f565b615da0602083018461537d565b9392505050565b615db08161531a565b8114615dbb57600080fd5b50565b600081519050615dcd81615da7565b92915050565b600060208284031215615de957615de861523c565b5b6000615df784828501615dbe565b91505092915050565b7f6d61726b6572206d6574686f642072657475726e65642066616c736500000000600082015250565b6000615e36601c83615182565b9150615e4182615e00565b602082019050919050565b60006020820190508181036000830152615e6581615e29565b9050919050565b6000604082019050615e816000830185615839565b615e8e6020830184615839565b9392505050565b7f6f6e6c79207468652061646d696e206d6179207365742074686520636f6d702d60008201527f6c696b652064656c656761746500000000000000000000000000000000000000602082015250565b6000615ef1602d83615182565b9150615efc82615e95565b604082019050919050565b60006020820190508181036000830152615f2081615ee4565b9050919050565b7f6f6e6c792061646d696e206d617920696e697469616c697a6520746865206d6160008201527f726b657400000000000000000000000000000000000000000000000000000000602082015250565b6000615f83602483615182565b9150615f8e82615f27565b604082019050919050565b60006020820190508181036000830152615fb281615f76565b9050919050565b7f6d61726b6574206d6179206f6e6c7920626520696e697469616c697a6564206f60008201527f6e63650000000000000000000000000000000000000000000000000000000000602082015250565b6000616015602383615182565b915061602082615fb9565b604082019050919050565b6000602082019050818103600083015261604481616008565b9050919050565b7f696e697469616c2065786368616e67652072617465206d75737420626520677260008201527f6561746572207468616e207a65726f2e00000000000000000000000000000000602082015250565b60006160a7603083615182565b91506160b28261604b565b604082019050919050565b600060208201905081810360008301526160d68161609a565b9050919050565b7f73657474696e6720636f6d7074726f6c6c6572206661696c6564000000000000600082015250565b6000616113601a83615182565b915061611e826160dd565b602082019050919050565b6000602082019050818103600083015261614281616106565b9050919050565b7f73657474696e6720696e7465726573742072617465206d6f64656c206661696c60008201527f6564000000000000000000000000000000000000000000000000000000000000602082015250565b60006161a5602283615182565b91506161b082616149565b604082019050919050565b600060208201905081810360008301526161d481616198565b9050919050565b60006060820190506161f0600083018661537d565b6161fd602083018561537d565b61620a604083018461537d565b949350505050565b7f626f72726f772072617465206973206162737572646c79206869676800000000600082015250565b6000616248601c83615182565b915061625382616212565b602082019050919050565b600060208201905081810360008301526162778161623b565b9050919050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601160045260246000fd5b60006162b8826152a4565b91506162c3836152a4565b9250828210156162d6576162d561627e565b5b828203905092915050565b60006162ec826152a4565b91506162f7836152a4565b9250827fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff0382111561632c5761632b61627e565b5b828201905092915050565b600060408201905061634c6000830185615863565b6163596020830184615d6f565b9392505050565b600061636b826152a4565b9150616376836152a4565b9250817fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff04831182151516156163af576163ae61627e565b5b828202905092915050565b7f4e487b7100000000000000000000000000000000000000000000000000000000600052601260045260246000fd5b60006163f4826152a4565b91506163ff836152a4565b92508261640f5761640e6163ba565b5b828204905092915050565b600060808201905061642f6000830187615863565b61643c6020830186615863565b6164496040830185615863565b616456606083018461537d565b95945050505050565b60006060820190506164746000830186615d6f565b616481602083018561537d565b61648e604083018461537d565b949350505050565b60006040820190506164ab6000830185615a6f565b6164b86020830184615a6f565b9392505050565b600060a0820190506164d46000830188615863565b6164e16020830187615863565b6164ee6040830186615863565b6164fb6060830185615863565b616508608083018461537d565b9695505050505050565b60006060820190506165276000830186615863565b616534602083018561537d565b616541604083018461537d565b949350505050565b600060408201905061655e600083018561537d565b61656b602083018461537d565b9392505050565b600060a0820190506165876000830188615863565b6165946020830187615863565b6165a1604083018661537d565b6165ae606083018561537d565b6165bb608083018461537d565b9695505050505050565b7f544f4b454e5f5452414e534645525f4f55545f4641494c454400000000000000600082015250565b60006165fb601983615182565b9150616606826165c5565b602082019050919050565b6000602082019050818103600083015261662a816165ee565b9050919050565b7f6f6e65206f662072656465656d546f6b656e73496e206f722072656465656d4160008201527f6d6f756e74496e206d757374206265207a65726f000000000000000000000000602082015250565b600061668d603483615182565b915061669882616631565b604082019050919050565b600060208201905081810360008301526166bc81616680565b9050919050565b60006060820190506166d86000830186615863565b6166e56020830185615d6f565b6166f2604083018461537d565b949350505050565b600060808201905061670f6000830187615863565b61671c6020830186615d6f565b616729604083018561537d565b616736606083018461537d565b95945050505050565b60006060820190506167546000830186615863565b6167616020830185615863565b61676e604083018461537d565b949350505050565b600060808201905061678b6000830187615d6f565b616798602083018661537d565b6167a5604083018561537d565b6167b2606083018461537d565b95945050505050565b600080604083850312156167d2576167d161523c565b5b60006167e085828601615bf7565b92505060206167f185828601615bf7565b9150509250929050565b7f4c49515549444154455f434f4d5054524f4c4c45525f43414c43554c4154455f60008201527f414d4f554e545f5345495a455f4641494c454400000000000000000000000000602082015250565b6000616857603383615182565b9150616862826167fb565b604082019050919050565b600060208201905081810360008301526168868161684a565b9050919050565b7f4c49515549444154455f5345495a455f544f4f5f4d5543480000000000000000600082015250565b60006168c3601883615182565b91506168ce8261688d565b602082019050919050565b600060208201905081810360008301526168f2816168b6565b9050919050565b7f746f6b656e207365697a757265206661696c6564000000000000000000000000600082015250565b600061692f601483615182565b915061693a826168f9565b602082019050919050565b6000602082019050818103600083015261695e81616922565b9050919050565b600060a08201905061697a6000830188615863565b6169876020830187615863565b616994604083018661537d565b6169a16060830185615863565b6169ae608083018461537d565b9695505050505050565b7f544f4b454e5f5452414e534645525f494e5f4641494c45440000000000000000600082015250565b60006169ee601883615182565b91506169f9826169b8565b602082019050919050565b60006020820190508181036000830152616a1d816169e1565b905091905056fea26469706673582212204ca6d65a17d076fcff62c17a0ca3d046917b327008ac99c82974b173ca10690064736f6c634300080a0033",
  linkReferences: {},
  deployedLinkReferences: {}
};

// packages/compound-v2-liquidator/src/market/market.service.ts
class MarketService extends Service {
  storageService;
  web3Service;
  accountService;
  constructor(storageService, web3Service, accountService) {
    super();
    this.storageService = storageService;
    this.web3Service = web3Service;
    this.accountService = accountService;
  }
  async processLogs(logs) {
    for (const log of logs) {
      switch (log.eventName) {
        case MarketEventName.AccrueInterest:
          await this.accrueInterest(log);
          break;
        case MarketEventName.Transfer:
          await this.transfer(log);
          break;
        case MarketEventName.Borrow:
          await this.borrow(log);
          break;
        case MarketEventName.RepayBorrow:
          await this.repayBorrow(log);
          break;
        case MarketEventName.ReservesAdded:
          await this.reservesAdded(log);
          break;
        case MarketEventName.ReservesReduced:
          await this.reservesReduced(log);
          break;
        case MarketEventName.NewReserveFactor:
          this.newReserveFactor(log);
          break;
        default:
          break;
      }
    }
  }
  async accrueInterest(log) {
    console.debug("function -> accrueInterest");
    const [key1, key2, key3, key4] = MarketEventToOutput[MarketEventName.AccrueInterest].split(",");
    const borrowIndex = log[key2];
    const market = this.storageService.getMarket(log.address);
    market.borrowIndex = borrowIndex;
    market.accrualBlockNumber = BigInt(log.blockNumber);
    await this.fetchAndUpdateExchangeRate(log.address, log.blockNumber);
  }
  async transfer(log) {
    console.debug("function -> transfer");
    const [key1, key2, key3] = MarketEventToOutput[MarketEventName.Transfer].split(",");
    const from = log[key1];
    const to = log[key2];
    const amount = log[key3];
    const cToken = log.address;
    const accountFrom = this.storageService.getAccount(from);
    const marketFrom = this.storageService.getMarket(from);
    const accountTo = this.storageService.getAccount(to);
    const marketTo = this.storageService.getMarket(to);
    if (marketFrom) {
    } else if (accountFrom) {
      await this.accountService.defundAccountBalance(accountFrom, cToken, amount, log);
    }
    if (marketTo) {
    } else if (accountTo) {
      this.accountService.fundAccountTokens(accountTo, cToken, amount);
    } else {
      this.accountService.createAccountWithToken(to, cToken, amount);
    }
    await this.fetchAndUpdateExchangeRate(cToken, log.blockNumber);
  }
  async updateUnderlyingPrice(cToken, newPriceMantissa, blockNumber) {
    const market = this.storageService.getMarket(cToken);
    if (!market) {
      throw new Error("Market not found\n" + `marketAddress: ${cToken}`);
    }
    market.underlyingPriceMantissa = newPriceMantissa;
    await this.fetchAndUpdateExchangeRate(cToken, blockNumber);
  }
  async fetchAndUpdateExchangeRate(cToken, blockNumber) {
    console.debug("method -> updateExchangeRate");
    const market = this.storageService.getMarket(cToken);
    if (blockNumber >= env_default.NORMAL_PRICE_ORACLE_START_BLOCK && blockNumber > market.exchangeRateLastUpdateBlock) {
      market.exchangeRateMantissa = await this.fetchExchangeRateMantissa(cToken, blockNumber);
      market.exchangeRateLastUpdateBlock = blockNumber;
    }
  }
  newReserveFactor(log) {
    console.debug("function -> newReserveFactor");
    const key = MarketEventToOutput[MarketEventName.NewReserveFactor];
    const newReserveFactorMantissa = log[key];
    const market = this.storageService.getMarket(log.address);
    market.reserveFactorMantissa = newReserveFactorMantissa;
  }
  async borrow(log) {
    console.debug("function -> borrow");
    const [key1, key2, key3, key4] = MarketEventToOutput[MarketEventName.Borrow].split(",");
    const cToken = log.address;
    const borrower = log[key1];
    const accountBorrows = log[key3];
    const market = this.storageService.getMarket(cToken);
    const account2 = this.storageService.getAccount(borrower);
    if (!account2) {
      throw new Error("Account not found");
    }
    await this.fetchAndUpdateExchangeRate(cToken, log.blockNumber);
    this.accountService.addBorrows(account2, cToken, accountBorrows, market.borrowIndex);
  }
  async repayBorrow(log) {
    console.debug("function -> repayBorrow");
    const [key1, key2, key3, key4, key5] = MarketEventToOutput[MarketEventName.RepayBorrow].split(",");
    const borrower = log[key2];
    const accountBorrows = log[key4];
    const cToken = log.address;
    const market = this.storageService.getMarket(cToken);
    const account2 = this.storageService.getAccount(borrower);
    if (!account2) {
      return;
    }
    const asset = findAsset(account2, cToken);
    if (!asset) {
      return;
    }
    asset.principal = accountBorrows;
    asset.interestIndex = market.borrowIndex;
    await this.fetchAndUpdateExchangeRate(cToken, log.blockNumber);
  }
  async reservesAdded(log) {
    console.debug("function -> reservesAdded");
    await this.fetchAndUpdateExchangeRate(log.address, log.blockNumber);
  }
  async reservesReduced(log) {
    console.debug("function -> reservesReduced");
    await this.fetchAndUpdateExchangeRate(log.address, log.blockNumber);
  }
  fetchBorrowRateMantissa(cToken) {
    const { abi: abi7 } = CToken_default;
    const borrowRateMantissaItem = getAbiItem(abi7, "function", "borrowRatePerBlock");
    return this.web3Service.callContractMethod({
      address: cToken,
      abi: borrowRateMantissaItem
    });
  }
  async fetchMarketTotalReserves(cToken, blockNumber) {
    const { abi: abi7 } = CToken_default;
    const totalReservesItem = getAbiItem(abi7, "function", "totalReserves");
    const totalReserves = await this.web3Service.callContractMethod({
      address: cToken,
      abi: totalReservesItem,
      blockNumber
    });
    if (totalReserves === undefined) {
      throw new Error("Total reserves not found");
    }
    return totalReserves;
  }
  async fetchMarketTotalBorrows(cToken, blockNumber) {
    const { abi: abi7 } = CToken_default;
    const totalBorrowsItem = getAbiItem(abi7, "function", "totalBorrows");
    const totalBorrows = await this.web3Service.callContractMethod({
      address: cToken,
      abi: totalBorrowsItem,
      blockNumber
    });
    if (totalBorrows === undefined) {
      throw new Error("Total borrows not found");
    }
    return totalBorrows;
  }
  async fetchMarketBorrowIndex(cToken, blockNumber) {
    const { abi: abi7 } = CToken_default;
    const borrowIndexItem = getAbiItem(abi7, "function", "borrowIndex");
    const borrowIndex = await this.web3Service.callContractMethod({
      address: cToken,
      abi: borrowIndexItem,
      blockNumber
    });
    if (borrowIndex === undefined) {
      throw new Error("Borrow index not found");
    }
    return borrowIndex;
  }
  async collectLogs(fromBlock, toBlock) {
    console.debug("method -> collectMarketsLogs");
    const comptroller = this.storageService.getComptroller();
    const addresses = Array.from(comptroller.allMarkets);
    if (addresses.length === 0) {
      return [];
    }
    const eventNames = Object.values(MarketEventName);
    const abi7 = filterAbi(CErc20_default.abi, eventNames);
    const logs = await this.web3Service.getFilteredLogsByPieces(addresses, abi7, eventNames, fromBlock, toBlock);
    const decodedLogs = sortLogs(this.web3Service.decodeLogs(logs, abi7));
    return decodedLogs;
  }
  async fetchBalanceOf(tokenAddress, account2) {
    const { abi: abi7 } = CErc20_default;
    const balanceOfItem = getAbiItem(abi7, "function", "balanceOf");
    const balance = await this.web3Service.callContractMethod({
      address: tokenAddress,
      abi: balanceOfItem,
      args: [account2]
    });
    if (balance === undefined) {
      throw new Error("Balance not found");
    }
    return balance;
  }
  async fetchExchangeRateMantissa(cToken, blockNumber) {
    console.debug("method -> fetchExchangeRateMantissa");
    const { abi: abi7 } = CToken_default;
    const exchangeRateItem = getAbiItem(abi7, "function", "exchangeRateStored");
    const exchangeRate = await this.web3Service.callContractMethod({
      address: cToken,
      abi: exchangeRateItem,
      blockNumber
    });
    if (exchangeRate === undefined) {
      throw new Error("Exchange rate not found");
    }
    return exchangeRate;
  }
  async executeBorrow({ address: address28, from, privateKey, amount }) {
    const abi7 = CErc20_default.abi.find((a) => a.name === "borrow");
    const receipt = await this.web3Service.executeContractMethod({
      address: address28,
      abi: abi7,
      from,
      privateKey,
      args: [amount]
    });
    return receipt;
  }
  async executeMint({ address: address28, from, privateKey, amount }) {
    const abi7 = CErc20_default.abi.find((a) => a.name === "mint");
    const receipt = await this.web3Service.executeContractMethod({
      address: address28,
      abi: abi7,
      from,
      privateKey,
      args: [amount]
    });
    return receipt;
  }
  async fetchCollateralFactor(cToken, blockNumber) {
    const { abi: abi7 } = CToken_default;
    const collateralFactorItem = getAbiItem(abi7, "function", "collateralFactorMantissa");
    const collateralFactor = await this.web3Service.callContractMethod({
      address: cToken,
      abi: collateralFactorItem,
      blockNumber
    });
    if (collateralFactor === undefined) {
      throw new Error("Collateral factor not found");
    }
    return collateralFactor;
  }
  async fetchUnderlingAddress(cToken, blockNumber) {
    const underlyingAbiItem = getAbiItem(CErc20_default.abi, "function", "underlying");
    const underlyingAddress = await this.web3Service.callContractMethod({
      abi: underlyingAbiItem,
      address: cToken,
      blockNumber
    });
    if (!underlyingAddress)
      throw new Error("Couldn't get underlyingAddress");
    return underlyingAddress;
  }
  async fetchSymbol(cToken, blockNumber) {
    const symbolAbiItem = getAbiItem(CErc20_default.abi, "function", "symbol");
    const symbol2 = await this.web3Service.callContractMethod({
      abi: symbolAbiItem,
      address: cToken
    });
    if (!symbol2)
      throw new Error("Couldn't get symbol");
    return symbol2;
  }
  async fetchDecimalsErc20(cToken, blockNumber) {
    const decimalsAbiItem = getAbiItem(CErc20_default.abi, "function", "decimals");
    const decimals = Number(await this.web3Service.callContractMethod({
      abi: decimalsAbiItem,
      address: cToken
    }));
    if (Number.isNaN(decimals))
      throw new Error("Couldn't get decimals");
    return decimals;
  }
}

// packages/compound-v2-liquidator/src/market/market.module.ts
class MarketModule extends Module {
  storageModule;
  web3Module;
  accountModule;
  constructor(storageModule, web3Module, accountModule) {
    super();
    this.storageModule = storageModule;
    this.web3Module = web3Module;
    this.accountModule = accountModule;
    const storageService = this.storageModule.getService("storageService");
    const web3Service = this.web3Module.getService("web3Service");
    const accountService = this.accountModule.getService("accountService");
    const service5 = new MarketService(storageService, web3Service, accountService);
    this.registerService("marketService", service5);
  }
}

// packages/compound-v2-liquidator/src/account/account.service.ts
class AccountService extends Service {
  storageService;
  web3Service;
  constructor(storageService, web3Service) {
    super();
    this.storageService = storageService;
    this.web3Service = web3Service;
  }
  async init() {
  }
  async fetchAccountTokenBalance(address28, cToken, blockNumber) {
    const accountSnapshot = await this.fetchAccountSnapshot(address28, cToken, blockNumber);
    return accountSnapshot["1"];
  }
  async fetchAccountSnapshot(address28, cToken, blockNumber) {
    const { abi: abi7 } = CToken_default;
    const borrowSnapshotAbi = getAbiItem(abi7, "function", "getAccountSnapshot");
    const accountSnapshot = await this.web3Service.callContractMethod({
      abi: borrowSnapshotAbi,
      address: cToken,
      args: [address28],
      params: {},
      blockNumber
    });
    return accountSnapshot;
  }
  async fetchAccountBorrows(address28, cToken, blockNumber) {
    const accountSnapshot = await this.fetchAccountSnapshot(address28, cToken, blockNumber);
    return accountSnapshot["2"];
  }
  addBorrows(account2, cToken, accountBorrows, borrowIndex) {
    console.debug("function -> addBorrows");
    console.log("accountBorrows", accountBorrows);
    let asset = findAsset(account2, cToken);
    if (!asset) {
      asset = {
        address: cToken,
        principal: 0n,
        interestIndex: 0n
      };
      account2.assets.push(asset);
    }
    asset.principal = accountBorrows;
    asset.interestIndex = borrowIndex;
  }
  fundAccountTokens(_account, _cToken, _amount) {
    console.debug("function -> fundAccountBalance");
    const token = _account.tokens[_cToken];
    if (token) {
      _account.tokens[_cToken] += _amount;
    } else {
      _account.tokens[_cToken] = _amount;
    }
  }
  async defundAccountBalance(_account, _cToken, _amount, log) {
    console.debug("function -> defundAccountBalance");
    const balance = _account.tokens[_cToken];
    if (balance === undefined) {
      return;
    }
    _account.tokens[_cToken] -= _amount;
    if (_account.tokens[_cToken] < 0n) {
      throw new Error("");
    }
  }
  createAccountWithToken(address28, cTokenToFund, fundAmount) {
    console.log("function -> createAccountWithBalance");
    const newAccount3 = {
      address: address28,
      assets: [],
      tokens: {
        [cTokenToFund]: fundAmount || 0n
      }
    };
    this.storageService.setAccount(address28, newAccount3);
  }
  createAccountWithAsset(address28, cToken, balance) {
    console.debug("function -> createAccountWithAsset");
    const newAccount3 = {
      address: address28,
      tokens: {
        [cToken]: balance || 0n
      },
      assets: [
        {
          address: cToken,
          interestIndex: 0n,
          principal: 0n
        }
      ]
    };
    this.storageService.setAccount(address28, newAccount3);
    return newAccount3;
  }
  enterMarket(account2, cToken) {
    const asset = findAsset(account2, cToken);
    const token = account2.tokens[cToken];
    if (!token) {
      account2.tokens[cToken] = 0n;
    }
    if (!asset) {
      account2.assets.push({
        address: cToken,
        principal: 0n,
        interestIndex: 0n
      });
    }
  }
  exitMarket(account2, cToken) {
    const assetIndex = findIndexByAddr(account2.assets, cToken);
    if (assetIndex === -1) {
      return;
    }
    account2.assets.splice(assetIndex, 1);
  }
  borrowBalance(asset, _borrowIndex) {
    const { address: address28, principal, interestIndex } = asset;
    const borrowIndex = _borrowIndex || this.storageService.getMarket(address28).borrowIndex;
    if (principal === 0n) {
      return 0n;
    }
    return principal * borrowIndex / interestIndex;
  }
}

// packages/compound-v2-liquidator/src/account/account.module.ts
class AccountModule extends Module {
  storageModule;
  web3Module;
  constructor(storageModule, web3Module) {
    super();
    this.storageModule = storageModule;
    this.web3Module = web3Module;
    const storageService = this.storageModule.getService("storageService");
    const web3Service = this.web3Module.getService("web3Service");
    const accountService = new AccountService(storageService, web3Service);
    this.registerService("accountService", accountService);
  }
}

// packages/compound-v2-liquidator/src/collector/collector.service.ts
class CollectorService extends Service {
  storageService;
  web3Service;
  comptrollerService;
  marketService;
  priceOracleService;
  validatorProxyService;
  constructor(storageService, web3Service, comptrollerService, marketService, priceOracleService, validatorProxyService) {
    super();
    this.storageService = storageService;
    this.web3Service = web3Service;
    this.comptrollerService = comptrollerService;
    this.marketService = marketService;
    this.priceOracleService = priceOracleService;
    this.validatorProxyService = validatorProxyService;
  }
  async collectPastEvents(shouldUpdateNetworkHeight = true) {
    console.debug("method -> collectPastEvents");
    if (shouldUpdateNetworkHeight) {
      await this.updateNetworkHeight();
    }
    while (!this.getStatusSync()) {
      const pointerHeight = this.storageService.getPointerHeight();
      const networkHeight = this.storageService.getNetworkHeight();
      const fromBlock = pointerHeight + 1;
      if (fromBlock > networkHeight) {
        throw new Error("Pointer height is greater than network height");
      }
      let toBlock = fromBlock + env_default.BLOCK_FILTER_BATCH;
      if (toBlock > networkHeight)
        toBlock = networkHeight;
      console.log("fromBlock", fromBlock);
      console.log("toBlock", toBlock);
      const comptrollerLogs = await this.comptrollerService.collectLogs(fromBlock, toBlock);
      if (comptrollerLogs.length > 0) {
        await this.comptrollerService.processLogs(comptrollerLogs);
      }
      const marketsLogs = await this.marketService.collectLogs(fromBlock, toBlock);
      if (marketsLogs.length > 0) {
        await this.marketService.processLogs(marketsLogs);
      }
      const priceOracleLogs = await this.priceOracleService.collectLogs(fromBlock, toBlock);
      if (priceOracleLogs.length > 0) {
        await this.priceOracleService.processLogs(priceOracleLogs);
      }
      const validatorProxyLogs = await this.validatorProxyService.collectLogs(fromBlock, toBlock);
      if (validatorProxyLogs.length > 0) {
        this.validatorProxyService.processLogs(validatorProxyLogs);
      }
      this.storageService.setPointerHeight(toBlock);
      if (comptrollerLogs[0] || marketsLogs[0] || priceOracleLogs[0] || validatorProxyLogs[0]) {
        await this.storageService.cacheMemory();
      } else {
        await this.storageService.cachePointerHeight();
      }
      if (shouldUpdateNetworkHeight) {
        await this.updateNetworkHeight();
      }
    }
    console.debug("Sync complete");
  }
  getStatusSync() {
    return this.storageService.getPointerHeight() >= this.storageService.getNetworkHeight();
  }
  async updateNetworkHeight() {
    const networkHeight = await this.web3Service.getNetworkHeight();
    this.storageService.setNetworkHeight(networkHeight);
  }
}

// packages/compound-v2-liquidator/src/collector/collector.module.ts
class CollectorModule extends Module {
  constructor(storageModule, web3Module, comptrollerModule, marketModule, priceOracleModule, validatorProxyModule) {
    super();
    const storageService = storageModule.getService("storageService");
    const web3Service = web3Module.getService("web3Service");
    const comptrollerService = comptrollerModule.getService("comptrollerService");
    const marketService = marketModule.getService("marketService");
    const priceOracleService = priceOracleModule.getService("priceOracleService");
    const validatorProxyService = validatorProxyModule.getService("validatorProxyService");
    const collectorService = new CollectorService(storageService, web3Service, comptrollerService, marketService, priceOracleService, validatorProxyService);
    this.registerService("collectorService", collectorService);
  }
}

// packages/compound-v2-liquidator/utils/types/message.type.ts
var MessageType;
(function(MessageType2) {
  MessageType2["pendingPriceUpdate"] = "pendingPriceUpdate";
  MessageType2["newTokenConfigs"] = "newTokenConfigs";
  MessageType2["init"] = "init";
})(MessageType || (MessageType = {}));

// packages/compound-v2-liquidator/src/worker/worker.service.ts
class WorkerService {
  mempoolWorker;
  liquidatorService;
  constructor(mempoolWorker, liquidatorService) {
    this.mempoolWorker = mempoolWorker;
    this.liquidatorService = liquidatorService;
  }
  init() {
    if (!this.mempoolWorker) {
      return;
    }
    this.listenForMessages();
    this.initMempoolListener();
  }
  emitNewTokenConfigs(newTokenConfigs) {
    this.mempoolWorker?.postMessage({
      type: MessageType.newTokenConfigs,
      data: newTokenConfigs
    });
  }
  initMempoolListener() {
    this.mempoolWorker?.postMessage({ type: MessageType.init });
  }
  listenForMessages() {
    if (!this.mempoolWorker) {
      return;
    }
    this.mempoolWorker.onmessage = async (event) => {
      console.debug("method -> workerService.listenForMessages");
      const message = event.data;
      switch (message.type) {
        case MessageType.pendingPriceUpdate:
          await this.liquidatorService.processPendingPriceUpdate(message);
          break;
      }
    };
  }
  listenForMempoolWorkerStop() {
    if (this.mempoolWorker) {
      this.mempoolWorker.addEventListener("close", () => {
        console.log("Mempool worker terminated by itself");
      });
    }
  }
  terminate() {
    console.log("method -> workerService.terminate");
    if (this.mempoolWorker) {
      this.mempoolWorker.terminate();
    }
  }
}

// packages/compound-v2-liquidator/src/worker/worker.module.ts
class WorkerModule extends Module {
  constructor(mempoolWorker, liquidatorModule) {
    super();
    const liquidatorService = liquidatorModule.getService("liquidatorService");
    const service7 = new WorkerService(mempoolWorker, liquidatorService);
    this.registerService("workerService", service7);
  }
}

// packages/compound-v2-liquidator/src/master/master.service.ts
class MasterService extends Service {
  storageService;
  workerService;
  web3Service;
  collectorService;
  blockService;
  constructor(storageService, workerService, web3Service, collectorService, blockService) {
    super();
    this.storageService = storageService;
    this.workerService = workerService;
    this.web3Service = web3Service;
    this.collectorService = collectorService;
    this.blockService = blockService;
  }
  async init() {
    this.listenForShutdown();
    await this.storageService.init().catch(this.cleanUpAndExit.bind(this));
    await this.collectorService.collectPastEvents().catch(this.cleanUpAndExit.bind(this));
    env_default.SHOULD_FETCH_EXCHANGE_RATES = true;
    this.blockService.listenForNewBlocks();
    this.workerService.init();
  }
  listenForShutdown() {
    process.on("SIGINT", this.cleanUpAndExit.bind(this));
    process.on("SIGTERM", this.cleanUpAndExit.bind(this));
    process.on("uncaughtException", this.cleanUpAndExit.bind(this));
    process.on("unhandledRejection", this.cleanUpAndExit.bind(this));
    this.workerService.listenForMempoolWorkerStop();
  }
  cleanUpAndExit(message) {
    console.debug("method -> masterService.cleanUpAndExit");
    console.log(message);
    this.workerService.terminate();
    this.blockService.terminate();
    process.exit(1);
  }
}

// common/uniswap/artifacts/UniswapAnchoredView.sol/UniswapAnchoredView.json
var UniswapAnchoredView_default = [
  {
    inputs: [
      {
        internalType: "uint256",
        name: "anchorToleranceMantissa_",
        type: "uint256"
      },
      {
        internalType: "uint32",
        name: "anchorPeriod_",
        type: "uint32"
      },
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig[]",
        name: "configs",
        type: "tuple[]"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: false,
        internalType: "address",
        name: "asset",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousPriceMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "requestedPriceMantissa",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "newPriceMantissa",
        type: "uint256"
      }
    ],
    name: "PricePosted",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      }
    ],
    name: "FailoverActivated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      }
    ],
    name: "FailoverDeactivated",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "reporterPrice",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "anchorPrice",
        type: "uint256"
      }
    ],
    name: "PriceGuarded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "price",
        type: "uint256"
      }
    ],
    name: "PriceUpdated",
    type: "event"
  },
  {
    inputs: [],
    name: "ETH_BASE_UNIT",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "EXP_SCALE",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_INTEGER",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "MAX_TOKENS",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      }
    ],
    name: "activateFailover",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "anchorPeriod",
    outputs: [
      {
        internalType: "uint32",
        name: "",
        type: "uint32"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      }
    ],
    name: "deactivateFailover",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "i",
        type: "uint256"
      }
    ],
    name: "getTokenConfig",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "cToken",
        type: "address"
      }
    ],
    name: "getTokenConfigByCToken",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "reporter",
        type: "address"
      }
    ],
    name: "getTokenConfigByReporter",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      }
    ],
    name: "getTokenConfigBySymbol",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      }
    ],
    name: "getTokenConfigBySymbolHash",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "underlying",
        type: "address"
      }
    ],
    name: "getTokenConfigByUnderlying",
    outputs: [
      {
        components: [
          {
            internalType: "address",
            name: "cToken",
            type: "address"
          },
          {
            internalType: "address",
            name: "underlying",
            type: "address"
          },
          {
            internalType: "bytes32",
            name: "symbolHash",
            type: "bytes32"
          },
          {
            internalType: "uint256",
            name: "baseUnit",
            type: "uint256"
          },
          {
            internalType: "enum UniswapConfig.PriceSource",
            name: "priceSource",
            type: "uint8"
          },
          {
            internalType: "uint256",
            name: "fixedPrice",
            type: "uint256"
          },
          {
            internalType: "address",
            name: "uniswapMarket",
            type: "address"
          },
          {
            internalType: "address",
            name: "reporter",
            type: "address"
          },
          {
            internalType: "uint256",
            name: "reporterMultiplier",
            type: "uint256"
          },
          {
            internalType: "bool",
            name: "isUniswapReversed",
            type: "bool"
          }
        ],
        internalType: "struct UniswapConfig.TokenConfig",
        name: "",
        type: "tuple"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "cToken",
        type: "address"
      }
    ],
    name: "getUnderlyingPrice",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "lowerBoundAnchorRatio",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "numTokens",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "symbolHash",
        type: "bytes32"
      }
    ],
    name: "pokeFailedOverPrice",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "string",
        name: "symbol",
        type: "string"
      }
    ],
    name: "price",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "bytes32",
        name: "",
        type: "bytes32"
      }
    ],
    name: "prices",
    outputs: [
      {
        internalType: "uint248",
        name: "price",
        type: "uint248"
      },
      {
        internalType: "bool",
        name: "failoverActive",
        type: "bool"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "upperBoundAnchorRatio",
    outputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "int256",
        name: "",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "",
        type: "uint256"
      },
      {
        internalType: "int256",
        name: "currentAnswer",
        type: "int256"
      }
    ],
    name: "validate",
    outputs: [
      {
        internalType: "bool",
        name: "valid",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// packages/compound-v2-liquidator/utils/math/FullMath.ts
function mulDiv(a, b2, denominator) {
  if (denominator === 0n) {
    throw new Error("Denominator cannot be zero");
  }
  let prod0 = a * b2;
  const fullProduct = a * b2;
  let prod1 = fullProduct / (1n << 256n);
  if (prod1 === 0n) {
    return prod0 / denominator;
  }
  if (denominator <= prod1) {
    throw new Error("Denominator must be greater than the most significant part of the product");
  }
  const remainder = fullProduct % denominator;
  if (remainder > prod0) {
    prod1 -= 1n;
    prod0 = prod0 + (1n << 256n) - remainder;
  } else {
    prod0 -= remainder;
  }
  const twos = denominator & -denominator;
  denominator /= twos;
  prod0 /= twos;
  const shift = 256n - BigInt(Math.clz32(Number(twos)));
  prod0 += prod1 << shift;
  let inv = 3n * denominator ^ 2n;
  inv *= 2n - denominator * inv;
  inv *= 2n - denominator * inv;
  inv *= 2n - denominator * inv;
  inv *= 2n - denominator * inv;
  inv *= 2n - denominator * inv;
  inv *= 2n - denominator * inv;
  return prod0 * inv;
}

// packages/compound-v2-liquidator/src/price-oracle/price-oracle.service.ts
class PriceOracleService extends Service {
  web3Service;
  storageService;
  validatorProxyService;
  marketService;
  constructor(web3Service, storageService, validatorProxyService, marketService) {
    super();
    this.web3Service = web3Service;
    this.storageService = storageService;
    this.validatorProxyService = validatorProxyService;
    this.marketService = marketService;
  }
  async processLogs(logs) {
    console.debug("method -> processLogs");
    for (const log of logs) {
      switch (log.eventName) {
        case PriceOracleEventName.PriceUpdated:
          await this.priceUpdated(log);
          break;
        case PriceOracleEventName.PriceGuarded:
          await this.priceGuarded(log);
          break;
        case PriceOracleEventName.FailoverActivated:
          console.log("FailoverActivated");
          break;
        case PriceOracleEventName.FailoverDeactivated:
          console.log("FailoverDeactivated");
          break;
        case PriceOracleEventName.PricePosted:
          this.pricePosted(log);
          break;
        default:
          console.warn("Unknown event", log.eventName);
      }
    }
  }
  async priceGuarded(log) {
    console.debug("method -> priceOracleService.priceGuarded");
    const [key1, key2] = PriceOracleEventToOutput[PriceOracleEventName.PriceGuarded].split(",");
    const symbolHash = log[key1];
    const anchorPrice = log[key2];
    const tokenConfigs = this.storageService.getTokenConfigsBySymbolHash(symbolHash);
    if (!tokenConfigs.length) {
      console.log("Token configs not found");
      return;
    }
    const underlyingPriceMantissa = await this.fetchUnderlyingPrice(tokenConfigs[0].marketAddress, log.blockNumber);
    for (const tokenConfig of tokenConfigs) {
      console.log("new anchor price", anchorPrice);
      tokenConfig.price = anchorPrice;
      await this.updateUnderlyingPrice(tokenConfig, underlyingPriceMantissa, log.blockNumber);
    }
  }
  pricePosted(log) {
    console.debug("method -> priceOracleService.pricePosted");
    const [key1, key2] = PriceOracleEventToOutput[PriceOracleEventName.PricePosted].split(",");
    const asset = log[key1];
    const newPriceMantissa = log[key2];
    const markets = this.storageService.getMarkets();
    const market = Object.values(markets).find((m) => m.underlyingAddress === asset);
    if (!market) {
      throw new Error("Market not found\n" + `asset: ${asset}`);
    }
    market.underlyingPriceMantissa = newPriceMantissa;
  }
  async priceUpdated(log) {
    console.debug("method -> priceOracleService.priceUpdated");
    const [key1, key2] = PriceOracleEventToOutput[PriceOracleEventName.PriceUpdated].split(",");
    const symbolHash = log[key1];
    console.log("symbolHash", symbolHash);
    const price = log[key2];
    const tokenConfigs = this.storageService.getTokenConfigsBySymbolHash(symbolHash);
    if (!tokenConfigs.length) {
      console.log("Token configs not found");
      return;
    }
    const underlyingPriceMantissa = await this.fetchUnderlyingPrice(tokenConfigs[0].marketAddress, log.blockNumber);
    for (const tokenConfig of tokenConfigs) {
      console.log("new underlying price", underlyingPriceMantissa);
      tokenConfig.price = price;
      await this.updateUnderlyingPrice(tokenConfig, underlyingPriceMantissa, log.blockNumber);
    }
  }
  async updateUnderlyingPrice(tokenConfig, underlyingPriceMantissa, blockNumber) {
    const { symbolHash, marketAddress } = tokenConfig;
    await this.marketService.updateUnderlyingPrice(marketAddress, underlyingPriceMantissa, blockNumber);
    if (symbolHash === EthSymbolHash) {
      await this.updateEthFixedPriceMarkets(blockNumber);
    }
  }
  async updateEthFixedPriceMarkets(blockNumber) {
    console.log("method -> priceOracleService.updateEthFixedPriceMarkets");
    const ethFixedPriceTokenConfigs = this.storageService.getTokenConfigsByPriceSource(PriceSource.FIXED_ETH);
    for (const config5 of ethFixedPriceTokenConfigs) {
      console.log("market address", config5.marketAddress);
      const underlyingPrice = this.getUnderlyingPrice(config5);
      await this.marketService.updateUnderlyingPrice(config5.marketAddress, underlyingPrice, blockNumber);
      await delay(500);
    }
  }
  async collectLogs(fromBlock, toBlock) {
    console.debug("method -> priceOracleService.collectLogs");
    const comptroller = this.storageService.getComptroller();
    const priceOracle = comptroller.priceOracle;
    if (!priceOracle) {
      return [];
    }
    const eventNames = Object.values(PriceOracleEventName);
    const abi7 = filterAbi(UniswapAnchoredView_default, eventNames);
    const logs = await this.web3Service.getFilteredLogsByPieces([priceOracle], abi7, eventNames, fromBlock, toBlock);
    const decodedLogs = sortLogs(this.web3Service.decodeLogs(logs, abi7));
    return decodedLogs;
  }
  getUnderlyingPrice(tokenConfig) {
    const priceInternal = () => {
      if (tokenConfig.priceSource === PriceSource.REPORTER) {
        return tokenConfig.price;
      } else if (tokenConfig.priceSource == PriceSource.FIXED_USD) {
        return tokenConfig.fixedPrice;
      } else {
        const [usdPerEth, ethBaseUnit] = this.getEthPriceAndBaseUnit();
        return mulDiv(usdPerEth, tokenConfig.fixedPrice, ethBaseUnit);
      }
    };
    const underlyingPrice = mulDiv(BigInt(1000000000000000000000000000000), priceInternal(), tokenConfig.baseUnit);
    return underlyingPrice;
  }
  getUnderlyingPriceForTransmit(tokenConfig) {
    const underlyingPrice = this.getUnderlyingPrice(tokenConfig);
    return BigInt(underlyingPrice.toString() + "00");
  }
  getEthPriceAndBaseUnit() {
    const ethTokenConfig = this.storageService.getEthTokenConfig();
    if (!ethTokenConfig) {
      throw new Error("ETH token config not found");
    }
    return [ethTokenConfig.price, ethTokenConfig.baseUnit];
  }
  async fetchTokenConfig({
    symbolHash,
    cToken,
    blockNumber
  }) {
    console.debug("method -> priceOracleService.fetchTokenConfig");
    const address28 = this.storageService.getComptroller().priceOracle;
    const abiItem = getAbiItem(UniswapAnchoredView_default, "function", `getTokenConfigBy${symbolHash ? "SymbolHash" : "CToken"}`);
    const rawTokenConfig = await this.web3Service.callContractMethod({
      address: address28,
      abi: abiItem,
      args: [symbolHash || cToken],
      blockNumber
    });
    const newTokenConfig = {
      marketAddress: rawTokenConfig.cToken,
      baseUnit: rawTokenConfig.baseUnit,
      priceSource: Number(rawTokenConfig.priceSource),
      fixedPrice: rawTokenConfig.fixedPrice,
      reporterMultiplier: rawTokenConfig.reporterMultiplier,
      reporter: rawTokenConfig.reporter,
      aggregator: "",
      failoverActive: rawTokenConfig.failoverActive,
      symbolHash: rawTokenConfig.symbolHash
    };
    return newTokenConfig;
  }
  async fetchPrice(symbol2, blockNumber) {
    const address28 = this.storageService.getComptroller().priceOracle;
    const abiItem = getAbiItem(UniswapAnchoredView_default, "function", "price");
    return this.web3Service.callContractMethod({
      address: address28,
      abi: abiItem,
      args: [symbol2],
      blockNumber
    });
  }
  async createTokenConfig(cToken, blockNumber) {
    console.debug("method -> priceOracleService.createTokenConfig");
    const tokenConfig = await this.fetchTokenConfig({ cToken, blockNumber });
    if (!tokenConfig) {
      throw new Error("Token config not found,\n" + `cToken: ${cToken}`);
    }
    if (tokenConfig.priceSource === PriceSource.REPORTER) {
      const aggregator = await this.validatorProxyService.fetchAggregator(tokenConfig.reporter, blockNumber);
      if (!aggregator) {
        throw new Error("Aggregator not found,\n" + `reporter: ${tokenConfig.reporter}`);
      }
      tokenConfig.aggregator = aggregator;
    }
    this.storageService.setTokenConfig(cToken, tokenConfig);
    return tokenConfig;
  }
  convertReportedPrice(config5, reportedPrice) {
    if (reportedPrice < 0)
      throw new Error("Cant be neg");
    const unsignedPrice = BigInt(reportedPrice);
    const convertedPrice = mulDiv(unsignedPrice, config5.reporterMultiplier, config5.baseUnit);
    return convertedPrice;
  }
  async fetchUnderlyingPrice(cToken, blockNumber, priceOracle) {
    console.debug("method -> priceOracleService.fetchUnderlyingPrice");
    if (blockNumber && env_default.NORMAL_PRICE_ORACLE_START_BLOCK > blockNumber) {
      return BigInt(0);
    }
    const address28 = priceOracle || this.storageService.getComptroller().priceOracle;
    const abiItem = getAbiItem(UniswapAnchoredView_default, "function", "getUnderlyingPrice");
    return this.web3Service.callContractMethod({
      address: address28,
      abi: abiItem,
      args: [cToken],
      blockNumber
    });
  }
  async fetchAndUpdateUnderlyingPrice(cToken, blockNumber) {
    const underlyingPrice = await this.fetchUnderlyingPrice(cToken, blockNumber);
    const market = this.storageService.getMarket(cToken);
    market.underlyingPriceMantissa = underlyingPrice;
  }
}

// packages/compound-v2-liquidator/src/price-oracle/price-oracle.module.ts
class PriceOracleModule extends Module {
  web3Module;
  storageModule;
  validatorProxyModule;
  marketModule;
  constructor(web3Module, storageModule, validatorProxyModule, marketModule) {
    super();
    this.web3Module = web3Module;
    this.storageModule = storageModule;
    this.validatorProxyModule = validatorProxyModule;
    this.marketModule = marketModule;
    const priceOracleService = new PriceOracleService(this.web3Module.getService("web3Service"), this.storageModule.getService("storageService"), this.validatorProxyModule.getService("validatorProxyService"), this.marketModule.getService("marketService"));
    this.registerService("priceOracleService", priceOracleService);
  }
}

// common/uniswap/artifacts/ValidatorProxy.sol/ValidatorProxy.json
var ValidatorProxy_default = [
  {
    inputs: [
      {
        internalType: "address",
        name: "aggregator",
        type: "address"
      },
      {
        internalType: "contract AggregatorValidatorInterface",
        name: "validator",
        type: "address"
      }
    ],
    stateMutability: "nonpayable",
    type: "constructor"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "aggregator",
        type: "address"
      }
    ],
    name: "AggregatorProposed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "previous",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "current",
        type: "address"
      }
    ],
    name: "AggregatorUpgraded",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferRequested",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "from",
        type: "address"
      },
      {
        indexed: true,
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "OwnershipTransferred",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "address",
        name: "proposed",
        type: "address"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "previousRoundId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "int256",
        name: "previousAnswer",
        type: "int256"
      },
      {
        indexed: false,
        internalType: "uint256",
        name: "currentRoundId",
        type: "uint256"
      },
      {
        indexed: false,
        internalType: "int256",
        name: "currentAnswer",
        type: "int256"
      }
    ],
    name: "ProposedAggregatorValidateCall",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract AggregatorValidatorInterface",
        name: "validator",
        type: "address"
      }
    ],
    name: "ValidatorProposed",
    type: "event"
  },
  {
    anonymous: false,
    inputs: [
      {
        indexed: true,
        internalType: "contract AggregatorValidatorInterface",
        name: "previous",
        type: "address"
      },
      {
        indexed: true,
        internalType: "contract AggregatorValidatorInterface",
        name: "current",
        type: "address"
      }
    ],
    name: "ValidatorUpgraded",
    type: "event"
  },
  {
    inputs: [],
    name: "acceptOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "getAggregators",
    outputs: [
      {
        internalType: "address",
        name: "current",
        type: "address"
      },
      {
        internalType: "bool",
        name: "hasProposal",
        type: "bool"
      },
      {
        internalType: "address",
        name: "proposed",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "getValidators",
    outputs: [
      {
        internalType: "contract AggregatorValidatorInterface",
        name: "current",
        type: "address"
      },
      {
        internalType: "bool",
        name: "hasProposal",
        type: "bool"
      },
      {
        internalType: "contract AggregatorValidatorInterface",
        name: "proposed",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [],
    name: "owner",
    outputs: [
      {
        internalType: "address",
        name: "",
        type: "address"
      }
    ],
    stateMutability: "view",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "proposed",
        type: "address"
      }
    ],
    name: "proposeNewAggregator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "contract AggregatorValidatorInterface",
        name: "proposed",
        type: "address"
      }
    ],
    name: "proposeNewValidator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "address",
        name: "to",
        type: "address"
      }
    ],
    name: "transferOwnership",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "typeAndVersion",
    outputs: [
      {
        internalType: "string",
        name: "",
        type: "string"
      }
    ],
    stateMutability: "pure",
    type: "function"
  },
  {
    inputs: [],
    name: "upgradeAggregator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [],
    name: "upgradeValidator",
    outputs: [],
    stateMutability: "nonpayable",
    type: "function"
  },
  {
    inputs: [
      {
        internalType: "uint256",
        name: "previousRoundId",
        type: "uint256"
      },
      {
        internalType: "int256",
        name: "previousAnswer",
        type: "int256"
      },
      {
        internalType: "uint256",
        name: "currentRoundId",
        type: "uint256"
      },
      {
        internalType: "int256",
        name: "currentAnswer",
        type: "int256"
      }
    ],
    name: "validate",
    outputs: [
      {
        internalType: "bool",
        name: "",
        type: "bool"
      }
    ],
    stateMutability: "nonpayable",
    type: "function"
  }
];

// packages/compound-v2-liquidator/src/validator-proxy/validator-proxy.constants.ts
var ValidatorProxyEventName;
(function(ValidatorProxyEventName2) {
  ValidatorProxyEventName2["AggregatorUpgraded"] = "AggregatorUpgraded";
})(ValidatorProxyEventName || (ValidatorProxyEventName = {}));
var ValidatorProxyEventToOutput = {
  [ValidatorProxyEventName.AggregatorUpgraded]: "current"
};

// packages/compound-v2-liquidator/src/validator-proxy/validator-proxy.service.ts
class ValidatorProxyService extends Service {
  storageService;
  web3Service;
  workerService;
  constructor(storageService, web3Service) {
    super();
    this.storageService = storageService;
    this.web3Service = web3Service;
  }
  processLogs(logs) {
    console.debug("method -> processLogs");
    for (const log of logs) {
      switch (log.eventName) {
        case ValidatorProxyEventName.AggregatorUpgraded:
          this.aggregatorUpdated(log);
          break;
        default:
          console.warn("Unknown event", log.eventName);
      }
    }
  }
  async collectLogs(fromBlock, toBlock) {
    console.debug("method -> validatorProxySer.collectLogs");
    const reporters = Object.values(this.storageService.getTokenConfigs()).map((tokenC) => tokenC.reporter);
    if (reporters.length === 0) {
      return [];
    }
    const eventNames = Object.values(ValidatorProxyEventName);
    const abi7 = ValidatorProxy_default;
    const logs = await this.web3Service.getFilteredLogsByPieces(reporters, abi7, eventNames, fromBlock, toBlock);
    const decodedLogs = sortLogs(this.web3Service.decodeLogs(logs, abi7));
    return decodedLogs;
  }
  aggregatorUpdated(log) {
    const key1 = ValidatorProxyEventToOutput[ValidatorProxyEventName.AggregatorUpgraded];
    const newAggregator = log[key1];
    const reporter = log.address;
    const tokenConfig = this.storageService.getTokenConfigByReporter(reporter);
    if (!tokenConfig) {
      throw new Error(`Token config not found.\nreporter: ${reporter}`);
    }
    tokenConfig.aggregator = newAggregator;
    const newTokenConfigs = Object.values(this.storageService.getTokenConfigs());
    this.workerService?.emitNewTokenConfigs(newTokenConfigs);
  }
  async fetchAggregator(reporter, blockNumber) {
    console.debug("method -> fetchAggregator");
    const abiItem = getAbiItem(ValidatorProxy_default, "function", "getAggregators");
    const aggregators = await this.web3Service.callContractMethod({
      address: reporter,
      abi: abiItem,
      blockNumber
    });
    return aggregators["current"];
  }
}

// packages/compound-v2-liquidator/src/validator-proxy/validator-proxy.module.ts
class ValidatorProxyModule extends Module {
  web3Module;
  storageModule;
  workerModule;
  service;
  constructor(web3Module, storageModule) {
    super();
    this.web3Module = web3Module;
    this.storageModule = storageModule;
    const storageService = storageModule.getService("storageService");
    const web3Service = web3Module.getService("web3Service");
    this.service = new ValidatorProxyService(storageService, web3Service);
    this.registerService("validatorProxyService", this.service);
  }
  setupWorkerModule(workerModule) {
    this.workerModule = workerModule;
    const workerService = this.workerModule.getService("workerService");
    this.service.workerService = workerService;
  }
}

// packages/compound-v2-liquidator/utils/math/ExpNoError.ts
function mulScalarTruncateAddUInt(mantissa, scalar, addend) {
  const truncatedProduct = mul_Mantissa(mantissa, scalar);
  const result = truncatedProduct + addend;
  return result;
}
function mul_Mantissa(a, b2) {
  const product = a * b2;
  return product / expScale;
}
function div_MantissaB(a, bMantissa) {
  return a * expScale / bMantissa;
}
var expScale = BigInt(1000000000000000000);
// packages/compound-v2-liquidator/artifacts/LiqBot_v1.sol/LiqBot_v1.json
var LiqBot_v1_default = {
  abi: [
    {
      type: "constructor",
      inputs: [
        { name: "_owner1", type: "address", internalType: "address" },
        { name: "_owner2", type: "address", internalType: "address" },
        { name: "_offchain", type: "address", internalType: "address" },
        { name: "_morpho", type: "address", internalType: "address" },
        {
          name: "_uniV3Router",
          type: "address",
          internalType: "contract ISwapRouter"
        }
      ],
      stateMutability: "nonpayable"
    },
    { type: "receive", stateMutability: "payable" },
    {
      type: "function",
      name: "changeOffchain",
      inputs: [
        { name: "_offchain", type: "address", internalType: "address" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "changeOwner1",
      inputs: [
        { name: "_newOwner1", type: "address", internalType: "address" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "changeOwner2",
      inputs: [
        { name: "_newOwner2", type: "address", internalType: "address" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "liquidate",
      inputs: [
        {
          name: "_repayTokens",
          type: "address[]",
          internalType: "address[]"
        },
        {
          name: "_cMarkets",
          type: "address[]",
          internalType: "address[]"
        },
        {
          name: "_borrowers",
          type: "address[]",
          internalType: "address[]"
        },
        {
          name: "_repayAmounts",
          type: "uint256[]",
          internalType: "uint256[]"
        },
        {
          name: "_cMarketCollaterals",
          type: "address[]",
          internalType: "address[]"
        },
        { name: "_path", type: "bytes[]", internalType: "bytes[]" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "offchain",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "onMorphoFlashLoan",
      inputs: [
        { name: "_amount", type: "uint256", internalType: "uint256" },
        { name: "FLdata", type: "bytes", internalType: "bytes" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "owner1",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "owner2",
      inputs: [],
      outputs: [{ name: "", type: "address", internalType: "address" }],
      stateMutability: "view"
    },
    {
      type: "function",
      name: "setApprove",
      inputs: [
        {
          name: "_tokenAddress",
          type: "address[]",
          internalType: "address[]"
        },
        { name: "_target", type: "address[]", internalType: "address[]" },
        { name: "_amount", type: "uint256", internalType: "uint256" },
        { name: "_every2every", type: "bool", internalType: "bool" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "setvalidatorShare",
      inputs: [
        { name: "_share", type: "uint256", internalType: "uint256" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "sweepNative",
      inputs: [
        { name: "_to", type: "address", internalType: "address" },
        { name: "_amount", type: "uint256", internalType: "uint256" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    },
    {
      type: "function",
      name: "sweepToken",
      inputs: [
        { name: "_token", type: "address", internalType: "address" },
        { name: "_to", type: "address", internalType: "address" },
        { name: "_amount", type: "uint256", internalType: "uint256" }
      ],
      outputs: [],
      stateMutability: "nonpayable"
    }
  ],
  bytecode: {
    object: "0x60c0604052600380546001600160a01b031990811673c02aaa39b223fe8d0a0e5c4f27ead9083c756cc21790915560048054909116734ddc2d193948926d02f9b1fe9e1daa0718270ed51790556113886005553480156200005f57600080fd5b50604051620020d8380380620020d88339810160408190526200008291620000eb565b600080546001600160a01b03199081166001600160a01b03978816179091556001805482169587169590951790945560028054909416928516929092179092559082166080521660a0526200016b565b6001600160a01b0381168114620000e857600080fd5b50565b600080600080600060a086880312156200010457600080fd5b85516200011181620000d2565b60208701519095506200012481620000d2565b60408701519094506200013781620000d2565b60608701519093506200014a81620000d2565b60808701519092506200015d81620000d2565b809150509295509295909350565b60805160a051611f40620001986000396000610dfd0152600081816102ae0152610b090152611f406000f3fe6080604052600436106100ab5760003560e01c80637672a626116100645780637672a62614610195578063840a1128146101b55780639646f3ea146101d55780639ade7279146101f5578063c16e76b214610215578063fbf783491461023557600080fd5b80630251acae146100b75780630ee7f143146100f357806331f5707214610115578063527097251461013557806364aff9ec14610155578063736889141461017557600080fd5b366100b257005b600080fd5b3480156100c357600080fd5b506002546100d7906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b3480156100ff57600080fd5b5061011361010e36600461172b565b610255565b005b34801561012157600080fd5b5061011361013036600461174f565b6102a3565b34801561014157600080fd5b506001546100d7906001600160a01b031681565b34801561016157600080fd5b506101136101703660046117cb565b610853565b34801561018157600080fd5b506000546100d7906001600160a01b031681565b3480156101a157600080fd5b506101136101b036600461180c565b6108f8565b3480156101c157600080fd5b506101136101d036600461172b565b610929565b3480156101e157600080fd5b506101136101f0366004611825565b610962565b34801561020157600080fd5b5061011361021036600461189d565b6109e3565b34801561022157600080fd5b5061011361023036600461172b565b610c66565b34801561024157600080fd5b50610113610250366004611a45565b610c9f565b6000546001600160a01b031633148061027857506001546001600160a01b031633145b61028157600080fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146102d857600080fd5b600080808080806102eb87890189611b3a565b600354959b509399509197509550935091506001600160a01b03908116908716036103d857600354604051632e1a7d4d60e01b8152600481018b90526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b15801561035657600080fd5b505af115801561036a573d6000803e3d6000fd5b5050604051635572051560e11b81526001600160a01b03878116600483015285811660248301528816925063aae40a2a91508b906044016000604051808303818588803b1580156103ba57600080fd5b505af11580156103ce573d6000803e3d6000fd5b505050505061049a565b604051637af1e23160e11b81526001600160a01b0385811660048301526024820185905283811660448301526000919087169063f5e3c462906064016020604051808303816000875af1158015610433573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104579190611c22565b905080156104985760405162461bcd60e51b81526020600482015260096024820152680726573756c742021360bc1b60448201526064015b60405180910390fd5b505b6004546001600160a01b039081169083160361069c576040516370a0823160e01b81523060048201526001600160a01b0383169063db006a759082906370a0823190602401602060405180830381865afa1580156104fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105209190611c22565b6040518263ffffffff1660e01b815260040161053e91815260200190565b6020604051808303816000875af115801561055d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105819190611c22565b50600360009054906101000a90046001600160a01b03166001600160a01b031663d0e30db0476040518263ffffffff1660e01b81526004016000604051808303818588803b1580156105d257600080fd5b505af11580156105e6573d6000803e3d6000fd5b50506003546040516370a0823160e01b81523060048201526000945061069493506001600160a01b0390911691506370a0823190602401602060405180830381865afa15801561063a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065e9190611c22565b600354604051610680916001600160a01b031690610bb8908c90602001611c3b565b604051602081830303815290604052610dc7565b905050610848565b6040516370a0823160e01b81523060048201526001600160a01b0383169063db006a759082906370a0823190602401602060405180830381865afa1580156106e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070c9190611c22565b6040518263ffffffff1660e01b815260040161072a91815260200190565b6020604051808303816000875af1158015610749573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076d9190611c22565b506000610845836001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d59190611c76565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa15801561081b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083f9190611c22565b83610dc7565b50505b505050505050505050565b6000546001600160a01b031633148061087657506001546001600160a01b031633145b61087f57600080fd5b60405163a9059cbb60e01b81526001600160a01b0383811660048301526024820183905284169063a9059cbb906044016020604051808303816000875af11580156108ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f29190611c93565b50505050565b6000546001600160a01b031633148061091b57506001546001600160a01b031633145b61092457600080fd5b600555565b6000546001600160a01b0316331461094057600080fd5b600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633148061098557506001546001600160a01b031633145b61098e57600080fd5b6040516001600160a01b038316908290600081818185875af1925050503d80600081146109d7576040519150601f19603f3d011682016040523d82523d6000602084013e6109dc565b606091505b5050505050565b6002546001600160a01b031633146109fa57600080fd5b60005b8b811015610bdb5760008d8d83818110610a1957610a19611cb0565b9050602002016020810190610a2e919061172b565b8c8c84818110610a4057610a40611cb0565b9050602002016020810190610a55919061172b565b8b8b85818110610a6757610a67611cb0565b9050602002016020810190610a7c919061172b565b8a8a86818110610a8e57610a8e611cb0565b90506020020135898987818110610aa757610aa7611cb0565b9050602002016020810190610abc919061172b565b888888818110610ace57610ace611cb0565b9050602002810190610ae09190611cc6565b604051602001610af69796959493929190611d0d565b60405160208183030381529060405290507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e0232b428f8f85818110610b4857610b48611cb0565b9050602002016020810190610b5d919061172b565b8a8a86818110610b6f57610b6f611cb0565b90506020020135846040518463ffffffff1660e01b8152600401610b9593929190611dc3565b600060405180830381600087803b158015610baf57600080fd5b505af1158015610bc3573d6000803e3d6000fd5b50505050508080610bd390611e09565b9150506109fd565b5060005b8b811015610c5757610c168d8d83818110610bfc57610bfc611cb0565b9050602002016020810190610c11919061172b565b610e85565b610c458d8d83818110610c2b57610c2b611cb0565b9050602002016020810190610c40919061172b565b61119e565b80610c4f81611e09565b915050610bdf565b50505050505050505050505050565b6001546001600160a01b03163314610c7d57600080fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b0316331480610cc257506001546001600160a01b031633145b610ccb57600080fd5b82518490821515600003610d6f5760005b82811015610d695760005b82811015610d5657610d44878281518110610d0457610d04611cb0565b6020026020010151878b8b86818110610d1f57610d1f611cb0565b9050602002016020810190610d34919061172b565b6001600160a01b0316919061137c565b80610d4e81611e09565b915050610ce7565b5080610d6181611e09565b915050610cdc565b50610dbe565b60005b82811015610dbc57610daa868281518110610d8f57610d8f611cb0565b6020026020010151868a8a85818110610d1f57610d1f611cb0565b80610db481611e09565b915050610d72565b505b50505050505050565b6040805160a081018252828152306020820152428183015260608101849052600060808201819052915163c04b8d5960e01b81527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063c04b8d5990610e3a908490600401611e22565b6020604051808303816000875af1158015610e59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e7d9190611c22565b949350505050565b6003546001600160a01b0390811690821603610feb576040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610ee2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f069190611c22565b9050600061271060055483610f1b9190611e7a565b610f259190611e97565b600354604051632e1a7d4d60e01b8152600481018390529192506001600160a01b031690632e1a7d4d90602401600060405180830381600087803b158015610f6c57600080fd5b505af1158015610f80573d6000803e3d6000fd5b505060408051600081526020810191829052419350849250610fa191611eb9565b60006040518083038185875af1925050503d8060008114610fde576040519150601f19603f3d011682016040523d82523d6000602084013e610fe3565b606091505b505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015611032573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110569190611c22565b905060006127106005548361106b9190611e7a565b6110759190611e97565b6003546040519192506000916110a3918491610680918891610bb8916001600160a01b031690602001611c3b565b600354604051632e1a7d4d60e01b8152600481018390529192506001600160a01b031690632e1a7d4d90602401600060405180830381600087803b1580156110ea57600080fd5b505af11580156110fe573d6000803e3d6000fd5b50506040805160008152602081019182905241935084925061111f91611eb9565b60006040518083038185875af1925050503d806000811461115c576040519150601f19603f3d011682016040523d82523d6000602084013e611161565b606091505b5050506108f260405180604001604052806015815260200174020b6b7bab73a103a37903b30b634b230ba37b91d1605d1b815250826114b8565b50565b6000546040516370a0823160e01b81523060048201526001600160a01b038381169263a9059cbb9291169060029084906370a0823190602401602060405180830381865afa1580156111f4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112189190611c22565b6112229190611e97565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af115801561126d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112919190611c93565b506001546040516370a0823160e01b81523060048201526001600160a01b038381169263a9059cbb9291169083906370a0823190602401602060405180830381865afa1580156112e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113099190611c22565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af1158015611354573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113789190611c93565b5050565b8015806113f65750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa1580156113d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f49190611c22565b155b6114615760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b606482015260840161048f565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b1790526114b39084906114fd565b505050565b61137882826040516024016114ce929190611ed5565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b1790526115d2565b6000611552826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166115f39092919063ffffffff16565b90508051600014806115735750808060200190518101906115739190611c93565b6114b35760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161048f565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b6060610e7d848460008585600080866001600160a01b0316858760405161161a9190611eb9565b60006040518083038185875af1925050503d8060008114611657576040519150601f19603f3d011682016040523d82523d6000602084013e61165c565b606091505b509150915061166d87838387611678565b979650505050505050565b606083156116e75782516000036116e0576001600160a01b0385163b6116e05760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161048f565b5081610e7d565b610e7d83838151156116fc5781518083602001fd5b8060405162461bcd60e51b815260040161048f9190611ef7565b6001600160a01b038116811461119b57600080fd5b60006020828403121561173d57600080fd5b813561174881611716565b9392505050565b60008060006040848603121561176457600080fd5b83359250602084013567ffffffffffffffff8082111561178357600080fd5b818601915086601f83011261179757600080fd5b8135818111156117a657600080fd5b8760208285010111156117b857600080fd5b6020830194508093505050509250925092565b6000806000606084860312156117e057600080fd5b83356117eb81611716565b925060208401356117fb81611716565b929592945050506040919091013590565b60006020828403121561181e57600080fd5b5035919050565b6000806040838503121561183857600080fd5b823561184381611716565b946020939093013593505050565b60008083601f84011261186357600080fd5b50813567ffffffffffffffff81111561187b57600080fd5b6020830191508360208260051b850101111561189657600080fd5b9250929050565b60008060008060008060008060008060008060c08d8f0312156118bf57600080fd5b67ffffffffffffffff8d3511156118d557600080fd5b6118e28e8e358f01611851565b909c509a5067ffffffffffffffff60208e0135111561190057600080fd5b6119108e60208f01358f01611851565b909a50985067ffffffffffffffff60408e0135111561192e57600080fd5b61193e8e60408f01358f01611851565b909850965067ffffffffffffffff60608e0135111561195c57600080fd5b61196c8e60608f01358f01611851565b909650945067ffffffffffffffff60808e0135111561198a57600080fd5b61199a8e60808f01358f01611851565b909450925067ffffffffffffffff60a08e013511156119b857600080fd5b6119c88e60a08f01358f01611851565b81935080925050509295989b509295989b509295989b565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611a1f57611a1f6119e0565b604052919050565b801515811461119b57600080fd5b8035611a4081611a27565b919050565b600080600080600060808688031215611a5d57600080fd5b853567ffffffffffffffff80821115611a7557600080fd5b611a8189838a01611851565b9097509550602091508782013581811115611a9b57600080fd5b8801601f81018a13611aac57600080fd5b803582811115611abe57611abe6119e0565b8060051b9250611acf8484016119f6565b818152928201840192848101908c851115611ae957600080fd5b928501925b84841015611b135783359250611b0383611716565b8282529285019290850190611aee565b975050505060408801359350611b2e91505060608701611a35565b90509295509295909350565b60008060008060008060c08789031215611b5357600080fd5b8635611b5e81611716565b9550602087810135611b6f81611716565b95506040880135611b7f81611716565b9450606088013593506080880135611b9681611716565b925060a088013567ffffffffffffffff80821115611bb357600080fd5b818a0191508a601f830112611bc757600080fd5b813581811115611bd957611bd96119e0565b611beb601f8201601f191685016119f6565b91508082528b84828501011115611c0157600080fd5b80848401858401376000848284010152508093505050509295509295509295565b600060208284031215611c3457600080fd5b5051919050565b606093841b6bffffffffffffffffffffffff19908116825260e89390931b6001600160e81b0319166014820152921b166017820152602b0190565b600060208284031215611c8857600080fd5b815161174881611716565b600060208284031215611ca557600080fd5b815161174881611a27565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112611cdd57600080fd5b83018035915067ffffffffffffffff821115611cf857600080fd5b60200191503681900382131561189657600080fd5b6001600160a01b03888116825287811660208301528681166040830152606082018690528416608082015260c060a0820181905281018290526000828460e0840137600060e0848401015260e0601f19601f850116830101905098975050505050505050565b60005b83811015611d8e578181015183820152602001611d76565b50506000910152565b60008151808452611daf816020860160208601611d73565b601f01601f19169290920160200192915050565b60018060a01b0384168152826020820152606060408201526000611dea6060830184611d97565b95945050505050565b634e487b7160e01b600052601160045260246000fd5b600060018201611e1b57611e1b611df3565b5060010190565b602081526000825160a06020840152611e3e60c0840182611d97565b905060018060a01b0360208501511660408401526040840151606084015260608401516080840152608084015160a08401528091505092915050565b8082028115828204841417611e9157611e91611df3565b92915050565b600082611eb457634e487b7160e01b600052601260045260246000fd5b500490565b60008251611ecb818460208701611d73565b9190910192915050565b604081526000611ee86040830185611d97565b90508260208301529392505050565b6020815260006117486020830184611d9756fea2646970667358221220494051380816a47a091b7889a4483134ba3cce6309c18fa50ce33c108aad65a764736f6c63430008140033",
    sourceMap: "781:7176:70:-:0;;;1039:65;;;-1:-1:-1;;;;;;1039:65:70;;;1062:42;1039:65;;;;1110;;;;;;1133:42;1110:65;;;1207:4;1182:29;;1351:291;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;1469:6;:24;;-1:-1:-1;;;;;;1469:24:70;;;-1:-1:-1;;;;;1469:24:70;;;;;;;-1:-1:-1;1503:24:70;;;;;;;;;;;;;;1537:8;:26;;;;;;;;;;;;;;;1573:24;;;;;1607:28;;;781:7176;;14:131:88;-1:-1:-1;;;;;89:31:88;;79:42;;69:70;;135:1;132;125:12;69:70;14:131;:::o;150:810::-;277:6;285;293;301;309;362:3;350:9;341:7;337:23;333:33;330:53;;;379:1;376;369:12;330:53;411:9;405:16;430:31;455:5;430:31;:::i;:::-;530:2;515:18;;509:25;480:5;;-1:-1:-1;543:33:88;509:25;543:33;:::i;:::-;647:2;632:18;;626:25;595:7;;-1:-1:-1;660:33:88;626:25;660:33;:::i;:::-;764:2;749:18;;743:25;712:7;;-1:-1:-1;777:33:88;743:25;777:33;:::i;:::-;881:3;866:19;;860:26;829:7;;-1:-1:-1;895:33:88;860:26;895:33;:::i;:::-;947:7;937:17;;;150:810;;;;;;;;:::o;:::-;781:7176:70;;;;;;;;;;;;;;;;;;;;;;;",
    linkReferences: {}
  },
  deployedBytecode: {
    object: "0x6080604052600436106100ab5760003560e01c80637672a626116100645780637672a62614610195578063840a1128146101b55780639646f3ea146101d55780639ade7279146101f5578063c16e76b214610215578063fbf783491461023557600080fd5b80630251acae146100b75780630ee7f143146100f357806331f5707214610115578063527097251461013557806364aff9ec14610155578063736889141461017557600080fd5b366100b257005b600080fd5b3480156100c357600080fd5b506002546100d7906001600160a01b031681565b6040516001600160a01b03909116815260200160405180910390f35b3480156100ff57600080fd5b5061011361010e36600461172b565b610255565b005b34801561012157600080fd5b5061011361013036600461174f565b6102a3565b34801561014157600080fd5b506001546100d7906001600160a01b031681565b34801561016157600080fd5b506101136101703660046117cb565b610853565b34801561018157600080fd5b506000546100d7906001600160a01b031681565b3480156101a157600080fd5b506101136101b036600461180c565b6108f8565b3480156101c157600080fd5b506101136101d036600461172b565b610929565b3480156101e157600080fd5b506101136101f0366004611825565b610962565b34801561020157600080fd5b5061011361021036600461189d565b6109e3565b34801561022157600080fd5b5061011361023036600461172b565b610c66565b34801561024157600080fd5b50610113610250366004611a45565b610c9f565b6000546001600160a01b031633148061027857506001546001600160a01b031633145b61028157600080fd5b600280546001600160a01b0319166001600160a01b0392909216919091179055565b336001600160a01b037f000000000000000000000000000000000000000000000000000000000000000016146102d857600080fd5b600080808080806102eb87890189611b3a565b600354959b509399509197509550935091506001600160a01b03908116908716036103d857600354604051632e1a7d4d60e01b8152600481018b90526001600160a01b0390911690632e1a7d4d90602401600060405180830381600087803b15801561035657600080fd5b505af115801561036a573d6000803e3d6000fd5b5050604051635572051560e11b81526001600160a01b03878116600483015285811660248301528816925063aae40a2a91508b906044016000604051808303818588803b1580156103ba57600080fd5b505af11580156103ce573d6000803e3d6000fd5b505050505061049a565b604051637af1e23160e11b81526001600160a01b0385811660048301526024820185905283811660448301526000919087169063f5e3c462906064016020604051808303816000875af1158015610433573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906104579190611c22565b905080156104985760405162461bcd60e51b81526020600482015260096024820152680726573756c742021360bc1b60448201526064015b60405180910390fd5b505b6004546001600160a01b039081169083160361069c576040516370a0823160e01b81523060048201526001600160a01b0383169063db006a759082906370a0823190602401602060405180830381865afa1580156104fc573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105209190611c22565b6040518263ffffffff1660e01b815260040161053e91815260200190565b6020604051808303816000875af115801561055d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906105819190611c22565b50600360009054906101000a90046001600160a01b03166001600160a01b031663d0e30db0476040518263ffffffff1660e01b81526004016000604051808303818588803b1580156105d257600080fd5b505af11580156105e6573d6000803e3d6000fd5b50506003546040516370a0823160e01b81523060048201526000945061069493506001600160a01b0390911691506370a0823190602401602060405180830381865afa15801561063a573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061065e9190611c22565b600354604051610680916001600160a01b031690610bb8908c90602001611c3b565b604051602081830303815290604052610dc7565b905050610848565b6040516370a0823160e01b81523060048201526001600160a01b0383169063db006a759082906370a0823190602401602060405180830381865afa1580156106e8573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061070c9190611c22565b6040518263ffffffff1660e01b815260040161072a91815260200190565b6020604051808303816000875af1158015610749573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061076d9190611c22565b506000610845836001600160a01b0316636f307dc36040518163ffffffff1660e01b8152600401602060405180830381865afa1580156107b1573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906107d59190611c76565b6040516370a0823160e01b81523060048201526001600160a01b0391909116906370a0823190602401602060405180830381865afa15801561081b573d6000803e3d6000fd5b505050506040513d601f19601f8201168201806040525081019061083f9190611c22565b83610dc7565b50505b505050505050505050565b6000546001600160a01b031633148061087657506001546001600160a01b031633145b61087f57600080fd5b60405163a9059cbb60e01b81526001600160a01b0383811660048301526024820183905284169063a9059cbb906044016020604051808303816000875af11580156108ce573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906108f29190611c93565b50505050565b6000546001600160a01b031633148061091b57506001546001600160a01b031633145b61092457600080fd5b600555565b6000546001600160a01b0316331461094057600080fd5b600080546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b031633148061098557506001546001600160a01b031633145b61098e57600080fd5b6040516001600160a01b038316908290600081818185875af1925050503d80600081146109d7576040519150601f19603f3d011682016040523d82523d6000602084013e6109dc565b606091505b5050505050565b6002546001600160a01b031633146109fa57600080fd5b60005b8b811015610bdb5760008d8d83818110610a1957610a19611cb0565b9050602002016020810190610a2e919061172b565b8c8c84818110610a4057610a40611cb0565b9050602002016020810190610a55919061172b565b8b8b85818110610a6757610a67611cb0565b9050602002016020810190610a7c919061172b565b8a8a86818110610a8e57610a8e611cb0565b90506020020135898987818110610aa757610aa7611cb0565b9050602002016020810190610abc919061172b565b888888818110610ace57610ace611cb0565b9050602002810190610ae09190611cc6565b604051602001610af69796959493929190611d0d565b60405160208183030381529060405290507f00000000000000000000000000000000000000000000000000000000000000006001600160a01b031663e0232b428f8f85818110610b4857610b48611cb0565b9050602002016020810190610b5d919061172b565b8a8a86818110610b6f57610b6f611cb0565b90506020020135846040518463ffffffff1660e01b8152600401610b9593929190611dc3565b600060405180830381600087803b158015610baf57600080fd5b505af1158015610bc3573d6000803e3d6000fd5b50505050508080610bd390611e09565b9150506109fd565b5060005b8b811015610c5757610c168d8d83818110610bfc57610bfc611cb0565b9050602002016020810190610c11919061172b565b610e85565b610c458d8d83818110610c2b57610c2b611cb0565b9050602002016020810190610c40919061172b565b61119e565b80610c4f81611e09565b915050610bdf565b50505050505050505050505050565b6001546001600160a01b03163314610c7d57600080fd5b600180546001600160a01b0319166001600160a01b0392909216919091179055565b6000546001600160a01b0316331480610cc257506001546001600160a01b031633145b610ccb57600080fd5b82518490821515600003610d6f5760005b82811015610d695760005b82811015610d5657610d44878281518110610d0457610d04611cb0565b6020026020010151878b8b86818110610d1f57610d1f611cb0565b9050602002016020810190610d34919061172b565b6001600160a01b0316919061137c565b80610d4e81611e09565b915050610ce7565b5080610d6181611e09565b915050610cdc565b50610dbe565b60005b82811015610dbc57610daa868281518110610d8f57610d8f611cb0565b6020026020010151868a8a85818110610d1f57610d1f611cb0565b80610db481611e09565b915050610d72565b505b50505050505050565b6040805160a081018252828152306020820152428183015260608101849052600060808201819052915163c04b8d5960e01b81527f00000000000000000000000000000000000000000000000000000000000000006001600160a01b03169063c04b8d5990610e3a908490600401611e22565b6020604051808303816000875af1158015610e59573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610e7d9190611c22565b949350505050565b6003546001600160a01b0390811690821603610feb576040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015610ee2573d6000803e3d6000fd5b505050506040513d601f19601f82011682018060405250810190610f069190611c22565b9050600061271060055483610f1b9190611e7a565b610f259190611e97565b600354604051632e1a7d4d60e01b8152600481018390529192506001600160a01b031690632e1a7d4d90602401600060405180830381600087803b158015610f6c57600080fd5b505af1158015610f80573d6000803e3d6000fd5b505060408051600081526020810191829052419350849250610fa191611eb9565b60006040518083038185875af1925050503d8060008114610fde576040519150601f19603f3d011682016040523d82523d6000602084013e610fe3565b606091505b505050505050565b6040516370a0823160e01b81523060048201526000906001600160a01b038316906370a0823190602401602060405180830381865afa158015611032573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906110569190611c22565b905060006127106005548361106b9190611e7a565b6110759190611e97565b6003546040519192506000916110a3918491610680918891610bb8916001600160a01b031690602001611c3b565b600354604051632e1a7d4d60e01b8152600481018390529192506001600160a01b031690632e1a7d4d90602401600060405180830381600087803b1580156110ea57600080fd5b505af11580156110fe573d6000803e3d6000fd5b50506040805160008152602081019182905241935084925061111f91611eb9565b60006040518083038185875af1925050503d806000811461115c576040519150601f19603f3d011682016040523d82523d6000602084013e611161565b606091505b5050506108f260405180604001604052806015815260200174020b6b7bab73a103a37903b30b634b230ba37b91d1605d1b815250826114b8565b50565b6000546040516370a0823160e01b81523060048201526001600160a01b038381169263a9059cbb9291169060029084906370a0823190602401602060405180830381865afa1580156111f4573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112189190611c22565b6112229190611e97565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af115801561126d573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906112919190611c93565b506001546040516370a0823160e01b81523060048201526001600160a01b038381169263a9059cbb9291169083906370a0823190602401602060405180830381865afa1580156112e5573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113099190611c22565b6040516001600160e01b031960e085901b1681526001600160a01b03909216600483015260248201526044016020604051808303816000875af1158015611354573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113789190611c93565b5050565b8015806113f65750604051636eb1769f60e11b81523060048201526001600160a01b03838116602483015284169063dd62ed3e90604401602060405180830381865afa1580156113d0573d6000803e3d6000fd5b505050506040513d601f19601f820116820180604052508101906113f49190611c22565b155b6114615760405162461bcd60e51b815260206004820152603660248201527f5361666545524332303a20617070726f76652066726f6d206e6f6e2d7a65726f60448201527520746f206e6f6e2d7a65726f20616c6c6f77616e636560501b606482015260840161048f565b604080516001600160a01b038416602482015260448082018490528251808303909101815260649091019091526020810180516001600160e01b031663095ea7b360e01b1790526114b39084906114fd565b505050565b61137882826040516024016114ce929190611ed5565b60408051601f198184030181529190526020810180516001600160e01b03166309710a9d60e41b1790526115d2565b6000611552826040518060400160405280602081526020017f5361666545524332303a206c6f772d6c6576656c2063616c6c206661696c6564815250856001600160a01b03166115f39092919063ffffffff16565b90508051600014806115735750808060200190518101906115739190611c93565b6114b35760405162461bcd60e51b815260206004820152602a60248201527f5361666545524332303a204552433230206f7065726174696f6e20646964206e6044820152691bdd081cdd58d8d9595960b21b606482015260840161048f565b80516a636f6e736f6c652e6c6f67602083016000808483855afa5050505050565b6060610e7d848460008585600080866001600160a01b0316858760405161161a9190611eb9565b60006040518083038185875af1925050503d8060008114611657576040519150601f19603f3d011682016040523d82523d6000602084013e61165c565b606091505b509150915061166d87838387611678565b979650505050505050565b606083156116e75782516000036116e0576001600160a01b0385163b6116e05760405162461bcd60e51b815260206004820152601d60248201527f416464726573733a2063616c6c20746f206e6f6e2d636f6e7472616374000000604482015260640161048f565b5081610e7d565b610e7d83838151156116fc5781518083602001fd5b8060405162461bcd60e51b815260040161048f9190611ef7565b6001600160a01b038116811461119b57600080fd5b60006020828403121561173d57600080fd5b813561174881611716565b9392505050565b60008060006040848603121561176457600080fd5b83359250602084013567ffffffffffffffff8082111561178357600080fd5b818601915086601f83011261179757600080fd5b8135818111156117a657600080fd5b8760208285010111156117b857600080fd5b6020830194508093505050509250925092565b6000806000606084860312156117e057600080fd5b83356117eb81611716565b925060208401356117fb81611716565b929592945050506040919091013590565b60006020828403121561181e57600080fd5b5035919050565b6000806040838503121561183857600080fd5b823561184381611716565b946020939093013593505050565b60008083601f84011261186357600080fd5b50813567ffffffffffffffff81111561187b57600080fd5b6020830191508360208260051b850101111561189657600080fd5b9250929050565b60008060008060008060008060008060008060c08d8f0312156118bf57600080fd5b67ffffffffffffffff8d3511156118d557600080fd5b6118e28e8e358f01611851565b909c509a5067ffffffffffffffff60208e0135111561190057600080fd5b6119108e60208f01358f01611851565b909a50985067ffffffffffffffff60408e0135111561192e57600080fd5b61193e8e60408f01358f01611851565b909850965067ffffffffffffffff60608e0135111561195c57600080fd5b61196c8e60608f01358f01611851565b909650945067ffffffffffffffff60808e0135111561198a57600080fd5b61199a8e60808f01358f01611851565b909450925067ffffffffffffffff60a08e013511156119b857600080fd5b6119c88e60a08f01358f01611851565b81935080925050509295989b509295989b509295989b565b634e487b7160e01b600052604160045260246000fd5b604051601f8201601f1916810167ffffffffffffffff81118282101715611a1f57611a1f6119e0565b604052919050565b801515811461119b57600080fd5b8035611a4081611a27565b919050565b600080600080600060808688031215611a5d57600080fd5b853567ffffffffffffffff80821115611a7557600080fd5b611a8189838a01611851565b9097509550602091508782013581811115611a9b57600080fd5b8801601f81018a13611aac57600080fd5b803582811115611abe57611abe6119e0565b8060051b9250611acf8484016119f6565b818152928201840192848101908c851115611ae957600080fd5b928501925b84841015611b135783359250611b0383611716565b8282529285019290850190611aee565b975050505060408801359350611b2e91505060608701611a35565b90509295509295909350565b60008060008060008060c08789031215611b5357600080fd5b8635611b5e81611716565b9550602087810135611b6f81611716565b95506040880135611b7f81611716565b9450606088013593506080880135611b9681611716565b925060a088013567ffffffffffffffff80821115611bb357600080fd5b818a0191508a601f830112611bc757600080fd5b813581811115611bd957611bd96119e0565b611beb601f8201601f191685016119f6565b91508082528b84828501011115611c0157600080fd5b80848401858401376000848284010152508093505050509295509295509295565b600060208284031215611c3457600080fd5b5051919050565b606093841b6bffffffffffffffffffffffff19908116825260e89390931b6001600160e81b0319166014820152921b166017820152602b0190565b600060208284031215611c8857600080fd5b815161174881611716565b600060208284031215611ca557600080fd5b815161174881611a27565b634e487b7160e01b600052603260045260246000fd5b6000808335601e19843603018112611cdd57600080fd5b83018035915067ffffffffffffffff821115611cf857600080fd5b60200191503681900382131561189657600080fd5b6001600160a01b03888116825287811660208301528681166040830152606082018690528416608082015260c060a0820181905281018290526000828460e0840137600060e0848401015260e0601f19601f850116830101905098975050505050505050565b60005b83811015611d8e578181015183820152602001611d76565b50506000910152565b60008151808452611daf816020860160208601611d73565b601f01601f19169290920160200192915050565b60018060a01b0384168152826020820152606060408201526000611dea6060830184611d97565b95945050505050565b634e487b7160e01b600052601160045260246000fd5b600060018201611e1b57611e1b611df3565b5060010190565b602081526000825160a06020840152611e3e60c0840182611d97565b905060018060a01b0360208501511660408401526040840151606084015260608401516080840152608084015160a08401528091505092915050565b8082028115828204841417611e9157611e91611df3565b92915050565b600082611eb457634e487b7160e01b600052601260045260246000fd5b500490565b60008251611ecb818460208701611d73565b9190910192915050565b604081526000611ee86040830185611d97565b90508260208301529392505050565b6020815260006117486020830184611d9756fea2646970667358221220494051380816a47a091b7889a4483134ba3cce6309c18fa50ce33c108aad65a764736f6c63430008140033",
    sourceMap: "781:7176:70:-:0;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;937:23;;;;;;;;;;-1:-1:-1;937:23:70;;;;-1:-1:-1;;;;;937:23:70;;;;;;-1:-1:-1;;;;;178:32:88;;;160:51;;148:2;133:18;937:23:70;;;;;;;7416:110;;;;;;;;;;-1:-1:-1;7416:110:70;;;;;:::i;:::-;;:::i;:::-;;3801:1391;;;;;;;;;;-1:-1:-1;3801:1391:70;;;;;:::i;:::-;;:::i;909:21::-;;;;;;;;;;-1:-1:-1;909:21:70;;;;-1:-1:-1;;;;;909:21:70;;;7532:145;;;;;;;;;;-1:-1:-1;7532:145:70;;;;;:::i;:::-;;:::i;882:21::-;;;;;;;;;;-1:-1:-1;882:21:70;;;;-1:-1:-1;;;;;882:21:70;;;7810:108;;;;;;;;;;-1:-1:-1;7810:108:70;;;;;:::i;:::-;;:::i;7152:126::-;;;;;;;;;;-1:-1:-1;7152:126:70;;;;;:::i;:::-;;:::i;7683:121::-;;;;;;;;;;-1:-1:-1;7683:121:70;;;;;:::i;:::-;;:::i;2649:1137::-;;;;;;;;;;-1:-1:-1;2649:1137:70;;;;;:::i;:::-;;:::i;7284:126::-;;;;;;;;;;-1:-1:-1;7284:126:70;;;;;:::i;:::-;;:::i;1918:658::-;;;;;;;;;;-1:-1:-1;1918:658:70;;;;;:::i;:::-;;:::i;7416:110::-;7097:6;;-1:-1:-1;;;;;7097:6:70;7083:10;:20;;:44;;-1:-1:-1;7121:6:70;;-1:-1:-1;;;;;7121:6:70;7107:10;:20;7083:44;7075:53;;;;;;7494:8:::1;:20:::0;;-1:-1:-1;;;;;;7494:20:70::1;-1:-1:-1::0;;;;;7494:20:70;;;::::1;::::0;;;::::1;::::0;;7416:110::o;3801:1391::-;3895:10;-1:-1:-1;;;;;3917:6:70;3895:29;;3887:38;;;;;;3936:19;;;;;;4066:67;;;;4077:6;4066:67;:::i;:::-;4163:4;;3935:198;;-1:-1:-1;3935:198:70;;-1:-1:-1;3935:198:70;;-1:-1:-1;3935:198:70;-1:-1:-1;3935:198:70;-1:-1:-1;3935:198:70;-1:-1:-1;;;;;;4163:4:70;;;4148:19;;;;4144:376;;4189:4;;4183:29;;-1:-1:-1;;;4183:29:70;;;;;8397:25:88;;;-1:-1:-1;;;;;4189:4:70;;;;4183:20;;8370:18:88;;4183:29:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;4226:88:70;;-1:-1:-1;;;4226:88:70;;-1:-1:-1;;;;;8679:15:88;;;4226:88:70;;;8661:34:88;8731:15;;;8711:18;;;8704:43;4226:33:70;;;-1:-1:-1;4226:33:70;;-1:-1:-1;4267:7:70;;8596:18:88;;4226:88:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;4144:376;;;4359:101;;-1:-1:-1;;;4359:101:70;;-1:-1:-1;;;;;9041:15:88;;;4359:101:70;;;9023:34:88;9073:18;;;9066:34;;;9136:15;;;9116:18;;;9109:43;4345:11:70;;4359:41;;;;;;8958:18:88;;4359:101:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4345:115;-1:-1:-1;4485:11:70;;4477:32;;;;-1:-1:-1;;;4477:32:70;;9554:2:88;4477:32:70;;;9536:21:88;9593:1;9573:18;;;9566:29;-1:-1:-1;;;9611:18:88;;;9604:39;9660:18;;4477:32:70;;;;;;;;;4331:189;4144:376;4557:4;;-1:-1:-1;;;;;4557:4:70;;;4535:26;;;;4531:655;;4613:52;;-1:-1:-1;;;4613:52:70;;4659:4;4613:52;;;160:51:88;-1:-1:-1;;;;;4578:34:70;;;;;;;4613:37;;133:18:88;;4613:52:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4578:88;;;;;;;;;;;;;8397:25:88;;8385:2;8370:18;;8251:177;4578:88:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;4686:4;;;;;;;;;-1:-1:-1;;;;;4686:4:70;-1:-1:-1;;;;;4680:19:70;;4708:21;4680:53;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;4798:4:70;;4791:37;;-1:-1:-1;;;4791:37:70;;4822:4;4791:37;;;160:51:88;4747:17:70;;-1:-1:-1;4767:112:70;;-1:-1:-1;;;;;;4798:4:70;;;;-1:-1:-1;4791:22:70;;133:18:88;;4791:37:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4846:4;;4829:49;;;;-1:-1:-1;;;;;4846:4:70;;4859;;4866:11;;4829:49;;;:::i;:::-;;;;;;;;;;;;;4767:23;:112::i;:::-;4747:132;;4563:328;4531:655;;;4967:60;;-1:-1:-1;;;4967:60:70;;5021:4;4967:60;;;160:51:88;-1:-1:-1;;;;;4924:42:70;;;;;;;4967:45;;133:18:88;;4967:60:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;4924:104;;;;;;;;;;;;;8397:25:88;;8385:2;8370:18;;8251:177;4924:104:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;5042:17;5062:113;5109:18;-1:-1:-1;;;;;5093:46:70;;:48;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5086:81;;-1:-1:-1;;;5086:81:70;;5161:4;5086:81;;;160:51:88;-1:-1:-1;;;;;5086:66:70;;;;;;;133:18:88;;5086:81:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5169:5;5062:23;:113::i;:::-;-1:-1:-1;;4531:655:70;3877:1315;;;;;;3801:1391;;;:::o;7532:145::-;7097:6;;-1:-1:-1;;;;;7097:6:70;7083:10;:20;;:44;;-1:-1:-1;7121:6:70;;-1:-1:-1;;;;;7121:6:70;7107:10;:20;7083:44;7075:53;;;;;;7633:37:::1;::::0;-1:-1:-1;;;7633:37:70;;-1:-1:-1;;;;;10573:32:88;;;7633:37:70::1;::::0;::::1;10555:51:88::0;10622:18;;;10615:34;;;7633:23:70;::::1;::::0;::::1;::::0;10528:18:88;;7633:37:70::1;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;7532:145:::0;;;:::o;7810:108::-;7097:6;;-1:-1:-1;;;;;7097:6:70;7083:10;:20;;:44;;-1:-1:-1;7121:6:70;;-1:-1:-1;;;;;7121:6:70;7107:10;:20;7083:44;7075:53;;;;;;7888:14:::1;:23:::0;7810:108::o;7152:126::-;7235:6;;-1:-1:-1;;;;;7235:6:70;7221:10;:20;7213:29;;;;;;7252:6;:19;;-1:-1:-1;;;;;;7252:19:70;-1:-1:-1;;;;;7252:19:70;;;;;;;;;;7152:126::o;7683:121::-;7097:6;;-1:-1:-1;;;;;7097:6:70;7083:10;:20;;:44;;-1:-1:-1;7121:6:70;;-1:-1:-1;;;;;7121:6:70;7107:10;:20;7083:44;7075:53;;;;;;7769:28:::1;::::0;-1:-1:-1;;;;;7769:8:70;::::1;::::0;7785:7;;7769:28:::1;::::0;;;7785:7;7769:8;:28:::1;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;7683:121:::0;;:::o;2649:1137::-;6981:8;;-1:-1:-1;;;;;6981:8:70;6967:10;:22;6959:31;;;;;;3082:9:::1;3078:438;3097:23:::0;;::::1;3078:438;;;3221:19;3254:12;;3267:1;3254:15;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3270:9;;3280:1;3270:12;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3283:10;;3294:1;3283:13;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3297;;3311:1;3297:16;;;;;;;:::i;:::-;;;;;;;3314:19;;3334:1;3314:22;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3338:5;;3344:1;3338:8;;;;;;;:::i;:::-;;;;;;;;;;;;:::i;:::-;3243:104;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;3221:126;;3377:6;-1:-1:-1::0;;;;;3365:29:70::1;;3395:12;;3408:1;3395:15;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3411:13;;3425:1;3411:16;;;;;;;:::i;:::-;;;;;;;3429:6;3365:71;;;;;;;;;;;;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;::::0;::::1;;;;;;;;;;;;::::0;::::1;;;;;;;;;3127:389;3122:3;;;;;:::i;:::-;;;;3078:438;;;;3533:9;3529:249;3548:23:::0;;::::1;3529:249;;;3592:32;3608:12;;3621:1;3608:15;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3592;:32::i;:::-;3738:29;3751:12;;3764:1;3751:15;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;3738:12;:29::i;:::-;3573:3:::0;::::1;::::0;::::1;:::i;:::-;;;;3529:249;;;;2649:1137:::0;;;;;;;;;;;;:::o;7284:126::-;7367:6;;-1:-1:-1;;;;;7367:6:70;7353:10;:20;7345:29;;;;;;7384:6;:19;;-1:-1:-1;;;;;;7384:19:70;-1:-1:-1;;;;;7384:19:70;;;;;;;;;;7284:126::o;1918:658::-;7097:6;;-1:-1:-1;;;;;7097:6:70;7083:10;:20;;:44;;-1:-1:-1;7121:6:70;;-1:-1:-1;;;;;7121:6:70;7107:10;:20;7083:44;7075:53;;;;;;2133:14;;2086:13;;2162:21;::::1;;2069:14;2162:21:::0;2158:412:::1;;2204:9;2199:204;2219:9;2215:1;:13;2199:204;;;2259:9;2254:135;2274:9;2270:1;:13;2254:135;;;2312:57;2349:7;2357:1;2349:10;;;;;;;;:::i;:::-;;;;;;;2361:7;2319:13;;2333:1;2319:16;;;;;;;:::i;:::-;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1::0;;;;;2312:36:70::1;::::0;:57;:36:::1;:57::i;:::-;2285:3:::0;::::1;::::0;::::1;:::i;:::-;;;;2254:135;;;-1:-1:-1::0;2230:3:70;::::1;::::0;::::1;:::i;:::-;;;;2199:204;;;;2158:412;;;2438:9;2433:127;2453:9;2449:1;:13;2433:127;;;2487:57;2524:7;2532:1;2524:10;;;;;;;;:::i;:::-;;;;;;;2536:7;2494:13;;2508:1;2494:16;;;;;;;:::i;2487:57::-;2464:3:::0;::::1;::::0;::::1;:::i;:::-;;;;2433:127;;;;2158:412;2059:517;;1918:658:::0;;;;;:::o;5198:464::-;5371:231;;;;;;;;;;;5466:4;5371:231;;;;5499:15;5371:231;;;;;;;;;;5287:14;5371:231;;;;;;5625:29;;-1:-1:-1;;;5625:29:70;;:10;-1:-1:-1;;;;;5625:21:70;;;;:29;;5371:231;;5625:29;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5613:41;5198:464;-1:-1:-1;;;;5198:464:70:o;5938:981::-;6029:4;;-1:-1:-1;;;;;6029:4:70;;;6013:20;;;;6009:899;;6081:45;;-1:-1:-1;;;6081:45:70;;6120:4;6081:45;;;160:51:88;6053:25:70;;-1:-1:-1;;;;;6081:30:70;;;;;133:18:88;;6081:45:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6053:73;;6144:22;6209:6;6192:14;;6172:17;:34;;;;:::i;:::-;:43;;;;:::i;:::-;6239:4;;6233:36;;-1:-1:-1;;;6233:36:70;;;;;8397:25:88;;;6144:71:70;;-1:-1:-1;;;;;;6239:4:70;;6233:20;;8370:18:88;;6233:36:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;6330:12:70;;;6340:1;6330:12;;;;;;;;;6287:14;;-1:-1:-1;6314:14:70;;-1:-1:-1;6287:56:70;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6035:340;;5938:981;:::o;6009:899::-;6427:45;;-1:-1:-1;;;6427:45:70;;6466:4;6427:45;;;160:51:88;6399:25:70;;-1:-1:-1;;;;;6427:30:70;;;;;133:18:88;;6427:45:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;6399:73;;6490:22;6555:6;6538:14;;6518:17;:34;;;;:::i;:::-;:43;;;;:::i;:::-;6687:4;;6642:50;;6490:71;;-1:-1:-1;6579:21:70;;6603:90;;6490:71;;6642:50;;6659:12;;6680:4;;-1:-1:-1;;;;;6687:4:70;;6642:50;;;:::i;6603:90::-;6717:4;;6711:35;;-1:-1:-1;;;6711:35:70;;;;;8397:25:88;;;6579:114:70;;-1:-1:-1;;;;;;6717:4:70;;6711:20;;8370:18:88;;6711:35:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;-1:-1:-1;;6806:12:70;;;6816:1;6806:12;;;;;;;;;6764:14;;-1:-1:-1;6791:13:70;;-1:-1:-1;6764:55:70;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;6842:51;;;;;;;;;;;;;;-1:-1:-1;;;6842:51:70;;;6879:13;6842:11;:51::i;6009:899::-;5938:981;:::o;5668:264::-;5771:6;;5778:45;;-1:-1:-1;;;5778:45:70;;5817:4;5778:45;;;160:51:88;-1:-1:-1;;;;;5741:29:70;;;;;;5771:6;;;5824:1;;5741:29;;5778:30;;133:18:88;;5778:45:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:47;;;;:::i;:::-;5741:85;;-1:-1:-1;;;;;;5741:85:70;;;;;;;-1:-1:-1;;;;;10573:32:88;;;5741:85:70;;;10555:51:88;10622:18;;;10615:34;10528:18;;5741:85:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;-1:-1:-1;5866:6:70;;5873:45;;-1:-1:-1;;;5873:45:70;;5912:4;5873:45;;;160:51:88;-1:-1:-1;;;;;5836:29:70;;;;;;5866:6;;;5836:29;;5873:30;;133:18:88;;5873:45:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;5836:83;;-1:-1:-1;;;;;;5836:83:70;;;;;;;-1:-1:-1;;;;;10573:32:88;;;5836:83:70;;;10555:51:88;10622:18;;;10615:34;10528:18;;5836:83:70;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;;5668:264;:::o;1818:573:26:-;2143:10;;;2142:62;;-1:-1:-1;2159:39:26;;-1:-1:-1;;;2159:39:26;;2183:4;2159:39;;;8661:34:88;-1:-1:-1;;;;;8731:15:88;;;8711:18;;;8704:43;2159:15:26;;;;;8596:18:88;;2159:39:26;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;:::i;:::-;:44;2142:62;2121:163;;;;-1:-1:-1;;;2121:163:26;;15656:2:88;2121:163:26;;;15638:21:88;15695:2;15675:18;;;15668:30;15734:34;15714:18;;;15707:62;-1:-1:-1;;;15785:18:88;;;15778:52;15847:19;;2121:163:26;15454:418:88;2121:163:26;2321:62;;;-1:-1:-1;;;;;10573:32:88;;2321:62:26;;;10555:51:88;10622:18;;;;10615:34;;;2321:62:26;;;;;;;;;;10528:18:88;;;;2321:62:26;;;;;;;;-1:-1:-1;;;;;2321:62:26;-1:-1:-1;;;2321:62:26;;;2294:90;;2314:5;;2294:19;:90::i;:::-;1818:573;;;:::o;6548:139:15:-;6612:68;6672:2;6676;6628:51;;;;;;;;;:::i;:::-;;;;-1:-1:-1;;6628:51:15;;;;;;;;;;;;;;-1:-1:-1;;;;;6628:51:15;-1:-1:-1;;;6628:51:15;;;6612:15;:68::i;5173:642:26:-;5592:23;5618:69;5646:4;5618:69;;;;;;;;;;;;;;;;;5626:5;-1:-1:-1;;;;;5618:27:26;;;:69;;;;;:::i;:::-;5592:95;;5705:10;:17;5726:1;5705:22;:56;;;;5742:10;5731:30;;;;;;;;;;;;:::i;:::-;5697:111;;;;-1:-1:-1;;;5697:111:26;;16374:2:88;5697:111:26;;;16356:21:88;16413:2;16393:18;;;16386:30;16452:34;16432:18;;;16425:62;-1:-1:-1;;;16503:18:88;;;16496:40;16553:19;;5697:111:26;16172:406:88;181:376:15;275:14;;131:42;448:2;435:16;;251:21;;275:14;435:16;131:42;484:5;473:68;464:77;;401:150;;181:376;:::o;4108:223:27:-;4241:12;4272:52;4294:6;4302:4;4308:1;4311:12;4241;5446;5460:23;5487:6;-1:-1:-1;;;;;5487:11:27;5506:5;5513:4;5487:31;;;;;;:::i;:::-;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;5445:73;;;;5535:69;5562:6;5570:7;5579:10;5591:12;5535:26;:69::i;:::-;5528:76;5165:446;-1:-1:-1;;;;;;;5165:446:27:o;7671:628::-;7851:12;7879:7;7875:418;;;7906:10;:17;7927:1;7906:22;7902:286;;-1:-1:-1;;;;;1702:19:27;;;8113:60;;;;-1:-1:-1;;;8113:60:27;;17192:2:88;8113:60:27;;;17174:21:88;17231:2;17211:18;;;17204:30;17270:31;17250:18;;;17243:59;17319:18;;8113:60:27;16990:353:88;8113:60:27;-1:-1:-1;8208:10:27;8201:17;;7875:418;8249:33;8257:10;8269:12;8980:17;;:21;8976:379;;9208:10;9202:17;9264:15;9251:10;9247:2;9243:19;9236:44;8976:379;9331:12;9324:20;;-1:-1:-1;;;9324:20:27;;;;;;;;:::i;222:131:88:-;-1:-1:-1;;;;;297:31:88;;287:42;;277:70;;343:1;340;333:12;358:247;417:6;470:2;458:9;449:7;445:23;441:32;438:52;;;486:1;483;476:12;438:52;525:9;512:23;544:31;569:5;544:31;:::i;:::-;594:5;358:247;-1:-1:-1;;;358:247:88:o;610:659::-;689:6;697;705;758:2;746:9;737:7;733:23;729:32;726:52;;;774:1;771;764:12;726:52;810:9;797:23;787:33;;871:2;860:9;856:18;843:32;894:18;935:2;927:6;924:14;921:34;;;951:1;948;941:12;921:34;989:6;978:9;974:22;964:32;;1034:7;1027:4;1023:2;1019:13;1015:27;1005:55;;1056:1;1053;1046:12;1005:55;1096:2;1083:16;1122:2;1114:6;1111:14;1108:34;;;1138:1;1135;1128:12;1108:34;1183:7;1178:2;1169:6;1165:2;1161:15;1157:24;1154:37;1151:57;;;1204:1;1201;1194:12;1151:57;1235:2;1231;1227:11;1217:21;;1257:6;1247:16;;;;;610:659;;;;;:::o;1274:456::-;1351:6;1359;1367;1420:2;1408:9;1399:7;1395:23;1391:32;1388:52;;;1436:1;1433;1426:12;1388:52;1475:9;1462:23;1494:31;1519:5;1494:31;:::i;:::-;1544:5;-1:-1:-1;1601:2:88;1586:18;;1573:32;1614:33;1573:32;1614:33;:::i;:::-;1274:456;;1666:7;;-1:-1:-1;;;1720:2:88;1705:18;;;;1692:32;;1274:456::o;1735:180::-;1794:6;1847:2;1835:9;1826:7;1822:23;1818:32;1815:52;;;1863:1;1860;1853:12;1815:52;-1:-1:-1;1886:23:88;;1735:180;-1:-1:-1;1735:180:88:o;1920:315::-;1988:6;1996;2049:2;2037:9;2028:7;2024:23;2020:32;2017:52;;;2065:1;2062;2055:12;2017:52;2104:9;2091:23;2123:31;2148:5;2123:31;:::i;:::-;2173:5;2225:2;2210:18;;;;2197:32;;-1:-1:-1;;;1920:315:88:o;2240:367::-;2303:8;2313:6;2367:3;2360:4;2352:6;2348:17;2344:27;2334:55;;2385:1;2382;2375:12;2334:55;-1:-1:-1;2408:20:88;;2451:18;2440:30;;2437:50;;;2483:1;2480;2473:12;2437:50;2520:4;2512:6;2508:17;2496:29;;2580:3;2573:4;2563:6;2560:1;2556:14;2548:6;2544:27;2540:38;2537:47;2534:67;;;2597:1;2594;2587:12;2534:67;2240:367;;;;;:::o;2612:2059::-;2889:6;2897;2905;2913;2921;2929;2937;2945;2953;2961;2969:7;2978;3032:3;3020:9;3011:7;3007:23;3003:33;3000:53;;;3049:1;3046;3039:12;3000:53;3093:18;3081:9;3068:23;3065:47;3062:67;;;3125:1;3122;3115:12;3062:67;3164:87;3243:7;3230:9;3217:23;3206:9;3202:39;3164:87;:::i;:::-;3270:8;;-1:-1:-1;3297:8:88;-1:-1:-1;3354:18:88;3348:2;3333:18;;3320:32;3317:56;3314:76;;;3386:1;3383;3376:12;3314:76;3425:96;3513:7;3506:2;3495:9;3491:18;3478:32;3467:9;3463:48;3425:96;:::i;:::-;3540:8;;-1:-1:-1;3567:8:88;-1:-1:-1;3624:18:88;3618:2;3603:18;;3590:32;3587:56;3584:76;;;3656:1;3653;3646:12;3584:76;3695:96;3783:7;3776:2;3765:9;3761:18;3748:32;3737:9;3733:48;3695:96;:::i;:::-;3810:8;;-1:-1:-1;3837:8:88;-1:-1:-1;3894:18:88;3888:2;3873:18;;3860:32;3857:56;3854:76;;;3926:1;3923;3916:12;3854:76;3965:96;4053:7;4046:2;4035:9;4031:18;4018:32;4007:9;4003:48;3965:96;:::i;:::-;4080:8;;-1:-1:-1;4107:8:88;-1:-1:-1;4165:18:88;4158:3;4143:19;;4130:33;4127:57;4124:77;;;4197:1;4194;4187:12;4124:77;4236:97;4325:7;4317:3;4306:9;4302:19;4289:33;4278:9;4274:49;4236:97;:::i;:::-;4352:8;;-1:-1:-1;4379:8:88;-1:-1:-1;4437:18:88;4430:3;4415:19;;4402:33;4399:57;4396:77;;;4469:1;4466;4459:12;4396:77;4510:97;4599:7;4591:3;4580:9;4576:19;4563:33;4552:9;4548:49;4510:97;:::i;:::-;4627:9;4616:20;;4656:9;4645:20;;;;2612:2059;;;;;;;;;;;;;;:::o;4676:127::-;4737:10;4732:3;4728:20;4725:1;4718:31;4768:4;4765:1;4758:15;4792:4;4789:1;4782:15;4808:275;4879:2;4873:9;4944:2;4925:13;;-1:-1:-1;;4921:27:88;4909:40;;4979:18;4964:34;;5000:22;;;4961:62;4958:88;;;5026:18;;:::i;:::-;5062:2;5055:22;4808:275;;-1:-1:-1;4808:275:88:o;5088:118::-;5174:5;5167:13;5160:21;5153:5;5150:32;5140:60;;5196:1;5193;5186:12;5211:128;5276:20;;5305:28;5276:20;5305:28;:::i;:::-;5211:128;;;:::o;5344:1473::-;5479:6;5487;5495;5503;5511;5564:3;5552:9;5543:7;5539:23;5535:33;5532:53;;;5581:1;5578;5571:12;5532:53;5621:9;5608:23;5650:18;5691:2;5683:6;5680:14;5677:34;;;5707:1;5704;5697:12;5677:34;5746:70;5808:7;5799:6;5788:9;5784:22;5746:70;:::i;:::-;5835:8;;-1:-1:-1;5720:96:88;-1:-1:-1;5889:2:88;;-1:-1:-1;5929:18:88;;;5916:32;5960:16;;;5957:36;;;5989:1;5986;5979:12;5957:36;6012:24;;6067:4;6059:13;;6055:27;-1:-1:-1;6045:55:88;;6096:1;6093;6086:12;6045:55;6132:2;6119:16;6154:2;6150;6147:10;6144:36;;;6160:18;;:::i;:::-;6206:2;6203:1;6199:10;6189:20;;6229:28;6253:2;6249;6245:11;6229:28;:::i;:::-;6291:15;;;6361:11;;;6357:20;;;6322:12;;;;6389:19;;;6386:39;;;6421:1;6418;6411:12;6386:39;6445:11;;;;6465:217;6481:6;6476:3;6473:15;6465:217;;;6561:3;6548:17;6535:30;;6578:31;6603:5;6578:31;:::i;:::-;6622:18;;;6498:12;;;;6660;;;;6465:217;;;6701:5;-1:-1:-1;;;;6753:2:88;6738:18;;6725:32;;-1:-1:-1;6776:35:88;;-1:-1:-1;;6807:2:88;6792:18;;6776:35;:::i;:::-;6766:45;;5344:1473;;;;;;;;:::o;6822:1424::-;6967:6;6975;6983;6991;6999;7007;7060:3;7048:9;7039:7;7035:23;7031:33;7028:53;;;7077:1;7074;7067:12;7028:53;7116:9;7103:23;7135:31;7160:5;7135:31;:::i;:::-;7185:5;-1:-1:-1;7209:2:88;7248:18;;;7235:32;7276:33;7235:32;7276:33;:::i;:::-;7328:7;-1:-1:-1;7387:2:88;7372:18;;7359:32;7400:33;7359:32;7400:33;:::i;:::-;7452:7;-1:-1:-1;7506:2:88;7491:18;;7478:32;;-1:-1:-1;7562:3:88;7547:19;;7534:33;7576;7534;7576;:::i;:::-;7628:7;-1:-1:-1;7686:3:88;7671:19;;7658:33;7710:18;7740:14;;;7737:34;;;7767:1;7764;7757:12;7737:34;7805:6;7794:9;7790:22;7780:32;;7850:7;7843:4;7839:2;7835:13;7831:27;7821:55;;7872:1;7869;7862:12;7821:55;7908:2;7895:16;7930:2;7926;7923:10;7920:36;;;7936:18;;:::i;:::-;7978:53;8021:2;8002:13;;-1:-1:-1;;7998:27:88;7994:36;;7978:53;:::i;:::-;7965:66;;8054:2;8047:5;8040:17;8094:7;8089:2;8084;8080;8076:11;8072:20;8069:33;8066:53;;;8115:1;8112;8105:12;8066:53;8170:2;8165;8161;8157:11;8152:2;8145:5;8141:14;8128:45;8214:1;8209:2;8204;8197:5;8193:14;8189:23;8182:34;;8235:5;8225:15;;;;;6822:1424;;;;;;;;:::o;9163:184::-;9233:6;9286:2;9274:9;9265:7;9261:23;9257:32;9254:52;;;9302:1;9299;9292:12;9254:52;-1:-1:-1;9325:16:88;;9163:184;-1:-1:-1;9163:184:88:o;9689:431::-;9942:2;9938:15;;;-1:-1:-1;;9934:24:88;;;9922:37;;10015:3;9993:16;;;;-1:-1:-1;;;;;;9989:41:88;9984:2;9975:12;;9968:63;10065:15;;10061:24;10056:2;10047:12;;10040:46;10111:2;10102:12;;9689:431::o;10125:251::-;10195:6;10248:2;10236:9;10227:7;10223:23;10219:32;10216:52;;;10264:1;10261;10254:12;10216:52;10296:9;10290:16;10315:31;10340:5;10315:31;:::i;10660:245::-;10727:6;10780:2;10768:9;10759:7;10755:23;10751:32;10748:52;;;10796:1;10793;10786:12;10748:52;10828:9;10822:16;10847:28;10869:5;10847:28;:::i;11120:127::-;11181:10;11176:3;11172:20;11169:1;11162:31;11212:4;11209:1;11202:15;11236:4;11233:1;11226:15;11252:521;11329:4;11335:6;11395:11;11382:25;11489:2;11485:7;11474:8;11458:14;11454:29;11450:43;11430:18;11426:68;11416:96;;11508:1;11505;11498:12;11416:96;11535:33;;11587:20;;;-1:-1:-1;11630:18:88;11619:30;;11616:50;;;11662:1;11659;11652:12;11616:50;11695:4;11683:17;;-1:-1:-1;11726:14:88;11722:27;;;11712:38;;11709:58;;;11763:1;11760;11753:12;11778:824;-1:-1:-1;;;;;12113:15:88;;;12095:34;;12165:15;;;12160:2;12145:18;;12138:43;12217:15;;;12212:2;12197:18;;12190:43;12264:2;12249:18;;12242:34;;;12313:15;;12307:3;12292:19;;12285:44;12366:3;12075;12345:19;;12338:32;;;12386:19;;12379:35;;;12038:4;12407:6;12457;12451:3;12436:19;;12423:49;12522:1;12516:3;12507:6;12496:9;12492:22;12488:32;12481:43;12592:3;12585:2;12581:7;12576:2;12568:6;12564:15;12560:29;12549:9;12545:45;12541:55;12533:63;;11778:824;;;;;;;;;;:::o;12607:250::-;12692:1;12702:113;12716:6;12713:1;12710:13;12702:113;;;12792:11;;;12786:18;12773:11;;;12766:39;12738:2;12731:10;12702:113;;;-1:-1:-1;;12849:1:88;12831:16;;12824:27;12607:250::o;12862:270::-;12903:3;12941:5;12935:12;12968:6;12963:3;12956:19;12984:76;13053:6;13046:4;13041:3;13037:14;13030:4;13023:5;13019:16;12984:76;:::i;:::-;13114:2;13093:15;-1:-1:-1;;13089:29:88;13080:39;;;;13121:4;13076:50;;12862:270;-1:-1:-1;;12862:270:88:o;13137:385::-;13369:1;13365;13360:3;13356:11;13352:19;13344:6;13340:32;13329:9;13322:51;13409:6;13404:2;13393:9;13389:18;13382:34;13452:2;13447;13436:9;13432:18;13425:30;13303:4;13472:44;13512:2;13501:9;13497:18;13489:6;13472:44;:::i;:::-;13464:52;13137:385;-1:-1:-1;;;;;13137:385:88:o;13527:127::-;13588:10;13583:3;13579:20;13576:1;13569:31;13619:4;13616:1;13609:15;13643:4;13640:1;13633:15;13659:135;13698:3;13719:17;;;13716:43;;13739:18;;:::i;:::-;-1:-1:-1;13786:1:88;13775:13;;13659:135::o;13799:654::-;13998:2;13987:9;13980:21;13961:4;14036:6;14030:13;14079:4;14074:2;14063:9;14059:18;14052:32;14107:51;14153:3;14142:9;14138:19;14124:12;14107:51;:::i;:::-;14093:65;;14239:1;14235;14230:3;14226:11;14222:19;14216:2;14208:6;14204:15;14198:22;14194:48;14189:2;14178:9;14174:18;14167:76;14297:2;14289:6;14285:15;14279:22;14274:2;14263:9;14259:18;14252:50;14357:2;14349:6;14345:15;14339:22;14333:3;14322:9;14318:19;14311:51;14418:3;14410:6;14406:16;14400:23;14393:4;14382:9;14378:20;14371:53;14441:6;14433:14;;;13799:654;;;;:::o;14458:168::-;14531:9;;;14562;;14579:15;;;14573:22;;14559:37;14549:71;;14600:18;;:::i;:::-;14458:168;;;;:::o;14631:217::-;14671:1;14697;14687:132;;14741:10;14736:3;14732:20;14729:1;14722:31;14776:4;14773:1;14766:15;14804:4;14801:1;14794:15;14687:132;-1:-1:-1;14833:9:88;;14631:217::o;14853:287::-;14982:3;15020:6;15014:13;15036:66;15095:6;15090:3;15083:4;15075:6;15071:17;15036:66;:::i;:::-;15118:16;;;;;14853:287;-1:-1:-1;;14853:287:88:o;15877:290::-;16054:2;16043:9;16036:21;16017:4;16074:44;16114:2;16103:9;16099:18;16091:6;16074:44;:::i;:::-;16066:52;;16154:6;16149:2;16138:9;16134:18;16127:34;15877:290;;;;;:::o;17348:219::-;17497:2;17486:9;17479:21;17460:4;17517:44;17557:2;17546:9;17542:18;17534:6;17517:44;:::i",
    linkReferences: {},
    immutableReferences: {
      "61182": [
        { start: 686, length: 32 },
        { start: 2825, length: 32 }
      ],
      "61185": [{ start: 3581, length: 32 }]
    }
  },
  methodIdentifiers: {
    "changeOffchain(address)": "0ee7f143",
    "changeOwner1(address)": "840a1128",
    "changeOwner2(address)": "c16e76b2",
    "liquidate(address[],address[],address[],uint256[],address[],bytes[])": "9ade7279",
    "offchain()": "0251acae",
    "onMorphoFlashLoan(uint256,bytes)": "31f57072",
    "owner1()": "73688914",
    "owner2()": "52709725",
    "setApprove(address[],address[],uint256,bool)": "fbf78349",
    "setvalidatorShare(uint256)": "7672a626",
    "sweepNative(address,uint256)": "9646f3ea",
    "sweepToken(address,address,uint256)": "64aff9ec"
  },
  rawMetadata: "{\"compiler\":{\"version\":\"0.8.20+commit.a1b79de6\"},\"language\":\"Solidity\",\"output\":{\"abi\":[{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_owner1\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_owner2\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_offchain\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_morpho\",\"type\":\"address\"},{\"internalType\":\"contract ISwapRouter\",\"name\":\"_uniV3Router\",\"type\":\"address\"}],\"stateMutability\":\"nonpayable\",\"type\":\"constructor\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_offchain\",\"type\":\"address\"}],\"name\":\"changeOffchain\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner1\",\"type\":\"address\"}],\"name\":\"changeOwner1\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_newOwner2\",\"type\":\"address\"}],\"name\":\"changeOwner2\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_repayTokens\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_cMarkets\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_borrowers\",\"type\":\"address[]\"},{\"internalType\":\"uint256[]\",\"name\":\"_repayAmounts\",\"type\":\"uint256[]\"},{\"internalType\":\"address[]\",\"name\":\"_cMarketCollaterals\",\"type\":\"address[]\"},{\"internalType\":\"bytes[]\",\"name\":\"_path\",\"type\":\"bytes[]\"}],\"name\":\"liquidate\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"offchain\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bytes\",\"name\":\"FLdata\",\"type\":\"bytes\"}],\"name\":\"onMorphoFlashLoan\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner1\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[],\"name\":\"owner2\",\"outputs\":[{\"internalType\":\"address\",\"name\":\"\",\"type\":\"address\"}],\"stateMutability\":\"view\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address[]\",\"name\":\"_tokenAddress\",\"type\":\"address[]\"},{\"internalType\":\"address[]\",\"name\":\"_target\",\"type\":\"address[]\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"},{\"internalType\":\"bool\",\"name\":\"_every2every\",\"type\":\"bool\"}],\"name\":\"setApprove\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"uint256\",\"name\":\"_share\",\"type\":\"uint256\"}],\"name\":\"setvalidatorShare\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sweepNative\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"inputs\":[{\"internalType\":\"address\",\"name\":\"_token\",\"type\":\"address\"},{\"internalType\":\"address\",\"name\":\"_to\",\"type\":\"address\"},{\"internalType\":\"uint256\",\"name\":\"_amount\",\"type\":\"uint256\"}],\"name\":\"sweepToken\",\"outputs\":[],\"stateMutability\":\"nonpayable\",\"type\":\"function\"},{\"stateMutability\":\"payable\",\"type\":\"receive\"}],\"devdoc\":{\"kind\":\"dev\",\"methods\":{},\"version\":1},\"userdoc\":{\"kind\":\"user\",\"methods\":{},\"version\":1}},\"settings\":{\"compilationTarget\":{\"src/LiquidBot_v1.sol\":\"LiquidBot_v1\"},\"evmVersion\":\"paris\",\"libraries\":{},\"metadata\":{\"bytecodeHash\":\"ipfs\"},\"optimizer\":{\"enabled\":true,\"runs\":200},\"remappings\":[\":@chainlink/=lib/chainlink/\",\":@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/\",\":@uniswap/v3-core/=lib/uniswapV3/v3-core/\",\":@uniswap/v3-periphery/=lib/uniswapV3/v3-periphery/\",\":ds-test/=lib/forge-std/lib/ds-test/src/\",\":erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/\",\":forge-std/=lib/forge-std/src/\",\":openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/\",\":openzeppelin-contracts/=lib/openzeppelin-contracts/\",\":openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/\",\":uniswapV3/=lib/uniswapV3/\"]},\"sources\":{\"lib/forge-std/src/Base.sol\":{\"keccak256\":\"0x4ff1a785311017d1eedb1b4737956fa383067ad34eb439abfec1d989754dde1c\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f553622969b9fdb930246704a4c10dfaee6b1a4468c142fa7eb9dc292a438224\",\"dweb:/ipfs/QmcxqHnqdQsMVtgsfH9VNLmZ3g7GhgNagfq7yvNCDcCHFK\"]},\"lib/forge-std/src/StdAssertions.sol\":{\"keccak256\":\"0xf513292ab066e6017db48ca749c1e63a44dfc5cba0326fc65c718f96e029d361\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://02d715ae2898f1fabd08133f80e6a7a3b87a2796ca5d23d1cb3fed9f4367f34c\",\"dweb:/ipfs/QmfESqa4j3PQAvvdfrnDQ1xUH1TnVCfvZYHsAEDK8z4X4k\"]},\"lib/forge-std/src/StdChains.sol\":{\"keccak256\":\"0x9cc29c28f49d0b7f7b2f1aa32d8273f8a087bf62eb3fb22d893df824052c25ef\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://42dcb36cb10b878a0d5b20ce3a4a3ba4f51f44d7731a66ac1133c699bc80b31b\",\"dweb:/ipfs/QmY6q7SaHQMLBb3rS6xZdArPaXoskWeqF6oJwUeZ3gKLZj\"]},\"lib/forge-std/src/StdCheats.sol\":{\"keccak256\":\"0xb72f3519e0bf7d31df5d68557525f4fc55d861c3fb3b0f7793144ef7c94cbeb7\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://f3456d0f78e6f61203fa7871ba2df0d35925f10db3baee14be623ce2a35b84e2\",\"dweb:/ipfs/QmWE6QQSBvJifHMraisBTrf1x4WCwrDoTPLX8UKajTiApc\"]},\"lib/forge-std/src/StdError.sol\":{\"keccak256\":\"0xbf477b11a42d7611696956546bcfaa29317d1166bf65e402344599c05943fc77\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bc2e117d1135e030862b96a6526a43feb38d396cc79857f1fb696d4eff0e5fd6\",\"dweb:/ipfs/QmdSuQ5RrQudTLsNmWXGEeVJX8gR5U9XPm6m4dwwuQnJrj\"]},\"lib/forge-std/src/StdInvariant.sol\":{\"keccak256\":\"0x67299bfacd77fddfa2a67b8e2b901e0e333618a4975fb94850b07475e51f6de6\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://1b61121d310f4053ce344b345b4a9ccf43b059daf9097ec2647f594beaca896d\",\"dweb:/ipfs/QmZUCoTtXBM9zfAZVbj2dFPPnKaV1CSZzXE7zictyg3Gfz\"]},\"lib/forge-std/src/StdJson.sol\":{\"keccak256\":\"0x62bed173cb126f6d5006706cf249bac8a2d51bfa18f773f314784ff18adc622d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5acc33dddbf2492e37dc32e89cd56ce917272d303a6874805f3a5768a6bfbf54\",\"dweb:/ipfs/QmTsgFhcpUf16gAVazUXU3WspgX8nHke2hzVCvoqS25WEp\"]},\"lib/forge-std/src/StdMath.sol\":{\"keccak256\":\"0xd90ad4fd8aeaeb8929964e686e769fdedd5eded3fc3815df194a0ab9f91a3fb2\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://7919b70f636c7b805223992f28ad1ad0145d6c1385b5931a3589aface5fe6c92\",\"dweb:/ipfs/QmY7FRaULwoGgFteF8GawjQJRfasNgpWnU2aiMsFrYpuTC\"]},\"lib/forge-std/src/StdStorage.sol\":{\"keccak256\":\"0x651d84d948832f0ef45686417aa68ffb871378fa788a4123dbf37844903c66f3\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://ff20f5ac9de3dc3ba86b1bf1f2723174e82ce3499ad67cb0ccfa7d28baeee678\",\"dweb:/ipfs/QmRZkUFKz7AmF7yk6o317sk822HHhGVPXZQgX8G4LfYfft\"]},\"lib/forge-std/src/StdStyle.sol\":{\"keccak256\":\"0x43e2a8a9b9c2574dabe74f11adf6f782df218f463540e3b5b563609fe108597d\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://51363ca97404cf4128e1141428949768c31929e75e014b02c85e887fbbb4f1b8\",\"dweb:/ipfs/QmVhtbQc2fU4rRmbcfBtz34mAgG4BAZBsbna1Ca4SkoPsK\"]},\"lib/forge-std/src/StdToml.sol\":{\"keccak256\":\"0xc8a57915ace96f5b6a85b57e57690fc038cad9034a3dc368c11828a3707c61ab\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://fa880a1a6e5d94005dcf4811b4c0df8d9c06407017ae111bd351483e2b76a72d\",\"dweb:/ipfs/QmcxkEE58gE1vDcZofTr8QpvdjXjgR72yYg7o4vTPSLCsy\"]},\"lib/forge-std/src/StdUtils.sol\":{\"keccak256\":\"0x502b18a4becda6ecd91fa8b419d8034946bfa80e6cc7f6497f51f8565bfadae0\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bf499ee483a1dfd02023d4ce78ed4029a49794ccd5b849aaab912faea0d2ba61\",\"dweb:/ipfs/QmP6hwNZW7sYbQK9fBzuZWxfLm6Swx2nKzvZ54qWNqQkzX\"]},\"lib/forge-std/src/Test.sol\":{\"keccak256\":\"0x3b4bb409a156dee9ce261458117fe9f81080ca844a8a26c07c857c46d155effe\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://5792c69fe24bdc063a14e08fe68275007fdb1e5e7e343840a77938cb7e95a64e\",\"dweb:/ipfs/QmcAMhaurUwzhytJFYix4vRNeZeV8g27b8LnV3t7dvYtiK\"]},\"lib/forge-std/src/Vm.sol\":{\"keccak256\":\"0x30d73c4fea34a791ad7334dd701df60fbb565c643556aadd6621e49e48895d1f\",\"license\":\"MIT OR Apache-2.0\",\"urls\":[\"bzz-raw://be9cf80e55eff0f49ad0ab3c44214e56a3e53b5ecafe311a521f5472fa4bbf59\",\"dweb:/ipfs/QmQHrZZoscvkfKSD2m6jhktrh8ieSLV2fg9DHGDHJiBkjT\"]},\"lib/forge-std/src/console.sol\":{\"keccak256\":\"0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://91ccea707361e48b9b7a161fe81f496b9932bc471e9c4e4e1e9c283f2453cc70\",\"dweb:/ipfs/QmcB66sZhQ6Kz7MUHcLE78YXRUZxoZnnxZjN6yATsbB2ec\"]},\"lib/forge-std/src/console2.sol\":{\"keccak256\":\"0x954646445d1014c3cd85c7918f5e7adeeca5ee44b68c00bafa237e597a4e35ea\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://516fa3be52da4763147175bfba4be0aa011fadbb0c1afb01f97265bd4cee7973\",\"dweb:/ipfs/QmdixAyMJefx7qePChgdxcBH5MxhmN7vsqPuPLx3CgrVmF\"]},\"lib/forge-std/src/interfaces/IERC165.sol\":{\"keccak256\":\"0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://698352fb240868ea8f1d1fe389993035eeab930f10d06934f80ccfb2b6ccbfbc\",\"dweb:/ipfs/QmT6WLHAgXxFhh12kWym895oTzXid1326iZiwT3pyfggoT\"]},\"lib/forge-std/src/interfaces/IERC20.sol\":{\"keccak256\":\"0x4cab887298790f908c27de107e4e2907ca5413aee482ef776f8d2f353c5ef947\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bb715e0c4a2bdbe432bb624501506041f06e878e0b72675aebba30ad2c2b72e7\",\"dweb:/ipfs/QmWhhLSvkxS2NrukJJHqFY8gDVE5r9rD4PfHvR24pwdKv9\"]},\"lib/forge-std/src/interfaces/IERC721.sol\":{\"keccak256\":\"0xf069262a264fdb69f8f37a10d2df7374649e9ba73f8414c9c8a3b51184625f15\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://924a41ca82a68ffbd503a5faf2f76d13e9938f10501a71094716f12bb64b4b7f\",\"dweb:/ipfs/QmdWnqfKc5ZGhmxNPTde4zrFchnv9Yk9MpCMb2rdhXE5gm\"]},\"lib/forge-std/src/interfaces/IMulticall3.sol\":{\"keccak256\":\"0x7aac1389150499a922d1f9ef5749c908cef127cb2075b92fa17e9cb611263d0a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://d95ebb7c7c463e08ebc12dab639945752fb2480acfc6e86da32f72732a7fd0c0\",\"dweb:/ipfs/QmNXK8P8oPWwajsQHvAHw3JPyQidPLCGQN3hWu1Lk6PBL2\"]},\"lib/forge-std/src/mocks/MockERC20.sol\":{\"keccak256\":\"0xadbdfc6639edec00ba94bb1133a0fd8de31ccafe45c2ef5df9b3ca61b60b559b\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bc766f01bccf669abac8cc7b2096cc1352a66471ca3772ae61b1801dedc4ed4f\",\"dweb:/ipfs/QmNigaPj1LYkP7Z5xr4ijkUxr2K66fDGeoifG3WoM9ruyw\"]},\"lib/forge-std/src/mocks/MockERC721.sol\":{\"keccak256\":\"0x3293dcbb7acd28df553c954e4e39e288bf10aab7ecda8d50ef21b4f4a91a28d9\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://9eb374daf6df34f4392f8926f1fddbce9f22c423066aeaefdfbe77395f77967b\",\"dweb:/ipfs/QmWR81zBJRX2uyRjveGzikYPj6ZwKppWsU49YEQXTLWUsN\"]},\"lib/forge-std/src/safeconsole.sol\":{\"keccak256\":\"0xbaf41fdc6c54297e7cd8250e48b0f20eaac918e342a1028cef3f9a52ac086381\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://a500ad81dea226f9910e6b50f99a9ff930105e393a692cbfb2185e4cdb4424ae\",\"dweb:/ipfs/QmVbUQpXNMmMWRiy4FvBNczzq46BMGfUoBikvSHNiCxVTq\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol\":{\"keccak256\":\"0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bd39944e8fc06be6dbe2dd1d8449b5336e23c6a7ba3e8e9ae5ae0f37f35283f5\",\"dweb:/ipfs/QmPV3FGYjVwvKSgAXKUN3r9T9GwniZz83CxBpM7vyj2G53\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol\":{\"keccak256\":\"0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://bc5b5dc12fbc4002f282eaa7a5f06d8310ed62c1c77c5770f6283e058454c39a\",\"dweb:/ipfs/Qme9rE2wS3yBuyJq9GgbmzbsBQsW2M2sVFqYYLw7bosGrv\"]},\"lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol\":{\"keccak256\":\"0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://656cda26512ddd7373c2d5551c8fae759fc30f05b10f0fc2e738e9274199dbd4\",\"dweb:/ipfs/QmTSArSzQRFbQmHgq7U1PZXnsDFhvDZhKVu9CzMG4yo6Lx\"]},\"lib/openzeppelin-contracts/contracts/utils/Address.sol\":{\"keccak256\":\"0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa\",\"license\":\"MIT\",\"urls\":[\"bzz-raw://2455248c8ddd9cc6a7af76a13973cddf222072427e7b0e2a7d1aff345145e931\",\"dweb:/ipfs/QmfYjnjRbWqYpuxurqveE6HtzsY1Xx323J428AKQgtBJZm\"]},\"lib/uniswapV3/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol\":{\"keccak256\":\"0x3f485fb1a44e8fbeadefb5da07d66edab3cfe809f0ac4074b1e54e3eb3c4cf69\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://095ce0626b41318c772b3ebf19d548282607f6a8f3d6c41c13edfbd5370c8652\",\"dweb:/ipfs/QmVDZfJJ89UUCE1hMyzqpkZAtQ8jUsBgZNE5AMRG7RzRFS\"]},\"lib/uniswapV3/v3-periphery/contracts/interfaces/ISwapRouter.sol\":{\"keccak256\":\"0x9bfaf1feb32814623e627ab70f2409760b15d95f1f9b058e2b3399a8bb732975\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://a8a2c3e55965b61bcd91993d8e1d5d34b8b8a63e0fdfce87a85f6af92526fd53\",\"dweb:/ipfs/QmQj2CSCSwqDSU4KMNWxGsN2336Cy64WgpV1X1EHXNZWxM\"]},\"lib/uniswapV3/v3-periphery/contracts/libraries/TransferHelper.sol\":{\"keccak256\":\"0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://da1d1e81e5bf534f0bf2934b3193db6cb1933f91ec006d2b88e9ad10a617a2d2\",\"dweb:/ipfs/QmcPBk47QLMFWcX2y2S9eMFsJgoYWBd3R8ey55Bgmv6w6v\"]},\"src/CToken.sol\":{\"keccak256\":\"0x4c3bce6d07a0ff161e4228a76352c35443550af7cb050b653efc6859b42cef92\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://cc8a9ec2b8678b18374618b7dd64529dcfe1882736d1faaf92086a006e06959b\",\"dweb:/ipfs/QmPwooLx1MfTr1eJq8aAfeixNs1gFHCgSUWKjsuLoX3ffY\"]},\"src/CTokenInterfaces.sol\":{\"keccak256\":\"0x51f9fa61c4195c3c2b8d6b3e8df9cc350e7f85628289306953ece0bf91593acc\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://1e94cfa5317de7e7ea183b9289ea093124626367c243027cfb9d690bab55cb04\",\"dweb:/ipfs/QmNrznxfmTUbpLG8sFrHTXYQEdtZbKCYzBFkUcQU3y11fk\"]},\"src/ComptrollerInterface.sol\":{\"keccak256\":\"0x5af9ec0d72948965bd6435a55e4519795ebc0279b191e313e3b9d9a71d189fa6\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://aa5cf113eae9f9f5f5b095a393768815bbc80d9a4dae4698e72a60db24df8c92\",\"dweb:/ipfs/QmbNEn3juMwVYwJ28pWSWip7xBpmYezoKkNGWcj6W4BuB7\"]},\"src/EIP20Interface.sol\":{\"keccak256\":\"0xf44fc7783d4a0060119f0096a122c3f305c7a03da75aa21408393d8d7a2e649b\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://98edcf6c8e46b8340174c4fbda657a8390d71167dfad2fef6d26b049659549db\",\"dweb:/ipfs/QmPiqcGe1te4TBiNGuDuBDwEjnhSQWqfqC85hFkbwFVXzi\"]},\"src/EIP20NonStandardInterface.sol\":{\"keccak256\":\"0x5ce25bb36a4ec9490617567a24b55bc813e943bcd4411e060afffe122bea0416\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://ffb7208e6c62875cb0ee30940c5967411c8ddf6b259d52a445ee09fd7020d698\",\"dweb:/ipfs/QmX6HCfaWJxJsG4sK8EAzm75ymmJSgytxomXppgfnJgkh7\"]},\"src/ErrorReporter.sol\":{\"keccak256\":\"0xa21708ac32b7850c51afdc34ea45f569081eded185332c676bdf86221b7f2d37\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://e3597938546ab142122a231bae1fc0cebe1daf84491b4fc5b97943ab195455f5\",\"dweb:/ipfs/QmNdPjPg15tVgWC6yBf9FnKcuBVo9jSN4y9iB4jzvXMjv8\"]},\"src/ExponentialNoError.sol\":{\"keccak256\":\"0x3a05062282ef8cbf6ec372abc73387ac8105a7eb0ea0f38069ebfd0f434ff98b\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://2aed68e944fba607a9eb176f7b5c0fe59f84d82e2e102b8d6db63ce5018548a9\",\"dweb:/ipfs/QmZJVBDDtFpqA8ZerzX4rGdBUsnA1tooHKxpKCWWvqRhJC\"]},\"src/InterestRateModel.sol\":{\"keccak256\":\"0x470821c8ff2120381ead6f54dba5c7b4fc0209682062bde51ea20291176aa0be\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://183fcf6b83f8183ef7930b51a5438ef9ab5a16702b76ab953892e40ef3688e34\",\"dweb:/ipfs/QmTZXAJ6pCPiDbZmdzU1LpVzYru978ApNESrRqhGiKT4Lq\"]},\"src/Interfaces/CompoundV2/CTokenInterfaces.sol\":{\"keccak256\":\"0xb25f7c11df8d527c610dc328b641404ef1255aa30edea8d14e9735930445e8db\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://74f614284df9da7b3dd8ba8dc59d421257dd181c1e0ac1e5ed87575227c7a235\",\"dweb:/ipfs/QmZSBaLzKn5Cmv3oKLoMLer8E1WYoYirR5GH83fXP7DrfR\"]},\"src/Interfaces/CompoundV2/ICEther.sol\":{\"keccak256\":\"0xa0e5395f6e54919e4428d27dcd04e05eb7163afd2e6168ef71e48270e3a34171\",\"license\":\"BSD-3-Clause\",\"urls\":[\"bzz-raw://142ee914662f605aecbd0f628b0d0b68e2134951287e6ceae979b59a8fbf1cce\",\"dweb:/ipfs/QmS2yATyfVveFFxcapsrV5now17QRA97rtBcKAgUJQ8ck9\"]},\"src/Interfaces/IWETH.sol\":{\"keccak256\":\"0x29a81726f6e4c0d48239b6af3536b08d6dba5dbecab2b05e43d56b92b3d49322\",\"urls\":[\"bzz-raw://556debe5798243e9b69c12c88692392c1ebfaa0380ff7955d2b0b0ed625bfca1\",\"dweb:/ipfs/QmP6GWYxkJgi8KN4CFMorfPsx4kCiHrGRBrFoWtXXpnG8Q\"]},\"src/Interfaces/Morpho/IMorpho.sol\":{\"keccak256\":\"0x74c4f2d062f66d8aa9e3cf431bd1ad6443f51bfc42e38b97c8a9cb7670a1bb8f\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://d1cb39ed146ebd0adb42eb70c1144c28d457a9e751b5419c57ea3c4782126793\",\"dweb:/ipfs/QmXCmnQXKYRPLAhD2yzTKYy7cB1GS95d5vr3Ey8bYnGVpn\"]},\"src/Interfaces/Morpho/IMorphoCallbacks.sol\":{\"keccak256\":\"0xe4b3c0aea7b09b052c3a15663c3a57137f04fc54a94054371f28b2495798c573\",\"license\":\"GPL-2.0-or-later\",\"urls\":[\"bzz-raw://ed9900055b67066e303ddaf0beacb28d8246c5a19f25af7bf29b7da76edae8dc\",\"dweb:/ipfs/QmbPJpd8zMzkwz3YJLBPtVrbyYScjNH8BdUChCHnFKRNzs\"]},\"src/Interfaces/UniswapV2/IUniswapV2Router01.sol\":{\"keccak256\":\"0x66eb4b8355b7d1fcb2e9e3ca8a0968663d9e0b194ff02c09ef0d1ae7981aa67d\",\"urls\":[\"bzz-raw://f8da3fe63fbfd6331ce2b7f90983734e062193a54c67ca36826f40b6ccd9c7de\",\"dweb:/ipfs/QmcifLPYeYj3phcEqtBdz3oN2gy7EXbj7N5WUHEQ4FANsD\"]},\"src/Interfaces/UniswapV2/IUniswapV2Router02.sol\":{\"keccak256\":\"0xc81f478bae3d753f4abd565dccc92820dde09f844e3db034b8750409ab52154a\",\"urls\":[\"bzz-raw://3d77d94fc97dabd66e5da83896163edaaa44935a692de62b505654e89be54c63\",\"dweb:/ipfs/QmWtKmLb1WRsymA5zHkWhwWoZs5Tnej6UzWwvfJN5prxGb\"]},\"src/LiquidBot_v1.sol\":{\"keccak256\":\"0x6830a4faceb4e7404daa907d418e74130328d2987486cc1c15ffb44a5067b7cf\",\"license\":\"UNLICENSED\",\"urls\":[\"bzz-raw://a678bee91303a9d2f0924157bab06a5da0e2d26a160e53c60d6e2ef741e29a31\",\"dweb:/ipfs/QmTAzXSFQL3jUv12bkqbYE5nHaqrBeVDYHKjzBDE9P3PpP\"]}},\"version\":1}",
  metadata: {
    compiler: { version: "0.8.20+commit.a1b79de6" },
    language: "Solidity",
    output: {
      abi: [
        {
          inputs: [
            { internalType: "address", name: "_owner1", type: "address" },
            { internalType: "address", name: "_owner2", type: "address" },
            {
              internalType: "address",
              name: "_offchain",
              type: "address"
            },
            { internalType: "address", name: "_morpho", type: "address" },
            {
              internalType: "contract ISwapRouter",
              name: "_uniV3Router",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "constructor"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_offchain",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "changeOffchain"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_newOwner1",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "changeOwner1"
        },
        {
          inputs: [
            {
              internalType: "address",
              name: "_newOwner2",
              type: "address"
            }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "changeOwner2"
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_repayTokens",
              type: "address[]"
            },
            {
              internalType: "address[]",
              name: "_cMarkets",
              type: "address[]"
            },
            {
              internalType: "address[]",
              name: "_borrowers",
              type: "address[]"
            },
            {
              internalType: "uint256[]",
              name: "_repayAmounts",
              type: "uint256[]"
            },
            {
              internalType: "address[]",
              name: "_cMarketCollaterals",
              type: "address[]"
            },
            { internalType: "bytes[]", name: "_path", type: "bytes[]" }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "liquidate"
        },
        {
          inputs: [],
          stateMutability: "view",
          type: "function",
          name: "offchain",
          outputs: [
            { internalType: "address", name: "", type: "address" }
          ]
        },
        {
          inputs: [
            { internalType: "uint256", name: "_amount", type: "uint256" },
            { internalType: "bytes", name: "FLdata", type: "bytes" }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "onMorphoFlashLoan"
        },
        {
          inputs: [],
          stateMutability: "view",
          type: "function",
          name: "owner1",
          outputs: [
            { internalType: "address", name: "", type: "address" }
          ]
        },
        {
          inputs: [],
          stateMutability: "view",
          type: "function",
          name: "owner2",
          outputs: [
            { internalType: "address", name: "", type: "address" }
          ]
        },
        {
          inputs: [
            {
              internalType: "address[]",
              name: "_tokenAddress",
              type: "address[]"
            },
            {
              internalType: "address[]",
              name: "_target",
              type: "address[]"
            },
            { internalType: "uint256", name: "_amount", type: "uint256" },
            { internalType: "bool", name: "_every2every", type: "bool" }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "setApprove"
        },
        {
          inputs: [
            { internalType: "uint256", name: "_share", type: "uint256" }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "setvalidatorShare"
        },
        {
          inputs: [
            { internalType: "address", name: "_to", type: "address" },
            { internalType: "uint256", name: "_amount", type: "uint256" }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "sweepNative"
        },
        {
          inputs: [
            { internalType: "address", name: "_token", type: "address" },
            { internalType: "address", name: "_to", type: "address" },
            { internalType: "uint256", name: "_amount", type: "uint256" }
          ],
          stateMutability: "nonpayable",
          type: "function",
          name: "sweepToken"
        },
        { inputs: [], stateMutability: "payable", type: "receive" }
      ],
      devdoc: { kind: "dev", methods: {}, version: 1 },
      userdoc: { kind: "user", methods: {}, version: 1 }
    },
    settings: {
      remappings: [
        "@chainlink/=lib/chainlink/",
        "@openzeppelin/contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/contracts/",
        "@openzeppelin/contracts/=lib/openzeppelin-contracts/contracts/",
        "@uniswap/v3-core/=lib/uniswapV3/v3-core/",
        "@uniswap/v3-periphery/=lib/uniswapV3/v3-periphery/",
        "ds-test/=lib/forge-std/lib/ds-test/src/",
        "erc4626-tests/=lib/openzeppelin-contracts/lib/erc4626-tests/",
        "forge-std/=lib/forge-std/src/",
        "openzeppelin-contracts-upgradeable/=lib/openzeppelin-contracts-upgradeable/",
        "openzeppelin-contracts/=lib/openzeppelin-contracts/",
        "openzeppelin/=lib/openzeppelin-contracts-upgradeable/contracts/",
        "uniswapV3/=lib/uniswapV3/"
      ],
      optimizer: { enabled: true, runs: 200 },
      metadata: { bytecodeHash: "ipfs" },
      compilationTarget: { "src/LiquidBot_v1.sol": "LiquidBot_v1" },
      evmVersion: "paris",
      libraries: {}
    },
    sources: {
      "lib/forge-std/src/Base.sol": {
        keccak256: "0x4ff1a785311017d1eedb1b4737956fa383067ad34eb439abfec1d989754dde1c",
        urls: [
          "bzz-raw://f553622969b9fdb930246704a4c10dfaee6b1a4468c142fa7eb9dc292a438224",
          "dweb:/ipfs/QmcxqHnqdQsMVtgsfH9VNLmZ3g7GhgNagfq7yvNCDcCHFK"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdAssertions.sol": {
        keccak256: "0xf513292ab066e6017db48ca749c1e63a44dfc5cba0326fc65c718f96e029d361",
        urls: [
          "bzz-raw://02d715ae2898f1fabd08133f80e6a7a3b87a2796ca5d23d1cb3fed9f4367f34c",
          "dweb:/ipfs/QmfESqa4j3PQAvvdfrnDQ1xUH1TnVCfvZYHsAEDK8z4X4k"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdChains.sol": {
        keccak256: "0x9cc29c28f49d0b7f7b2f1aa32d8273f8a087bf62eb3fb22d893df824052c25ef",
        urls: [
          "bzz-raw://42dcb36cb10b878a0d5b20ce3a4a3ba4f51f44d7731a66ac1133c699bc80b31b",
          "dweb:/ipfs/QmY6q7SaHQMLBb3rS6xZdArPaXoskWeqF6oJwUeZ3gKLZj"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdCheats.sol": {
        keccak256: "0xb72f3519e0bf7d31df5d68557525f4fc55d861c3fb3b0f7793144ef7c94cbeb7",
        urls: [
          "bzz-raw://f3456d0f78e6f61203fa7871ba2df0d35925f10db3baee14be623ce2a35b84e2",
          "dweb:/ipfs/QmWE6QQSBvJifHMraisBTrf1x4WCwrDoTPLX8UKajTiApc"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdError.sol": {
        keccak256: "0xbf477b11a42d7611696956546bcfaa29317d1166bf65e402344599c05943fc77",
        urls: [
          "bzz-raw://bc2e117d1135e030862b96a6526a43feb38d396cc79857f1fb696d4eff0e5fd6",
          "dweb:/ipfs/QmdSuQ5RrQudTLsNmWXGEeVJX8gR5U9XPm6m4dwwuQnJrj"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdInvariant.sol": {
        keccak256: "0x67299bfacd77fddfa2a67b8e2b901e0e333618a4975fb94850b07475e51f6de6",
        urls: [
          "bzz-raw://1b61121d310f4053ce344b345b4a9ccf43b059daf9097ec2647f594beaca896d",
          "dweb:/ipfs/QmZUCoTtXBM9zfAZVbj2dFPPnKaV1CSZzXE7zictyg3Gfz"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdJson.sol": {
        keccak256: "0x62bed173cb126f6d5006706cf249bac8a2d51bfa18f773f314784ff18adc622d",
        urls: [
          "bzz-raw://5acc33dddbf2492e37dc32e89cd56ce917272d303a6874805f3a5768a6bfbf54",
          "dweb:/ipfs/QmTsgFhcpUf16gAVazUXU3WspgX8nHke2hzVCvoqS25WEp"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdMath.sol": {
        keccak256: "0xd90ad4fd8aeaeb8929964e686e769fdedd5eded3fc3815df194a0ab9f91a3fb2",
        urls: [
          "bzz-raw://7919b70f636c7b805223992f28ad1ad0145d6c1385b5931a3589aface5fe6c92",
          "dweb:/ipfs/QmY7FRaULwoGgFteF8GawjQJRfasNgpWnU2aiMsFrYpuTC"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdStorage.sol": {
        keccak256: "0x651d84d948832f0ef45686417aa68ffb871378fa788a4123dbf37844903c66f3",
        urls: [
          "bzz-raw://ff20f5ac9de3dc3ba86b1bf1f2723174e82ce3499ad67cb0ccfa7d28baeee678",
          "dweb:/ipfs/QmRZkUFKz7AmF7yk6o317sk822HHhGVPXZQgX8G4LfYfft"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdStyle.sol": {
        keccak256: "0x43e2a8a9b9c2574dabe74f11adf6f782df218f463540e3b5b563609fe108597d",
        urls: [
          "bzz-raw://51363ca97404cf4128e1141428949768c31929e75e014b02c85e887fbbb4f1b8",
          "dweb:/ipfs/QmVhtbQc2fU4rRmbcfBtz34mAgG4BAZBsbna1Ca4SkoPsK"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdToml.sol": {
        keccak256: "0xc8a57915ace96f5b6a85b57e57690fc038cad9034a3dc368c11828a3707c61ab",
        urls: [
          "bzz-raw://fa880a1a6e5d94005dcf4811b4c0df8d9c06407017ae111bd351483e2b76a72d",
          "dweb:/ipfs/QmcxkEE58gE1vDcZofTr8QpvdjXjgR72yYg7o4vTPSLCsy"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/StdUtils.sol": {
        keccak256: "0x502b18a4becda6ecd91fa8b419d8034946bfa80e6cc7f6497f51f8565bfadae0",
        urls: [
          "bzz-raw://bf499ee483a1dfd02023d4ce78ed4029a49794ccd5b849aaab912faea0d2ba61",
          "dweb:/ipfs/QmP6hwNZW7sYbQK9fBzuZWxfLm6Swx2nKzvZ54qWNqQkzX"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/Test.sol": {
        keccak256: "0x3b4bb409a156dee9ce261458117fe9f81080ca844a8a26c07c857c46d155effe",
        urls: [
          "bzz-raw://5792c69fe24bdc063a14e08fe68275007fdb1e5e7e343840a77938cb7e95a64e",
          "dweb:/ipfs/QmcAMhaurUwzhytJFYix4vRNeZeV8g27b8LnV3t7dvYtiK"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/Vm.sol": {
        keccak256: "0x30d73c4fea34a791ad7334dd701df60fbb565c643556aadd6621e49e48895d1f",
        urls: [
          "bzz-raw://be9cf80e55eff0f49ad0ab3c44214e56a3e53b5ecafe311a521f5472fa4bbf59",
          "dweb:/ipfs/QmQHrZZoscvkfKSD2m6jhktrh8ieSLV2fg9DHGDHJiBkjT"
        ],
        license: "MIT OR Apache-2.0"
      },
      "lib/forge-std/src/console.sol": {
        keccak256: "0x91d5413c2434ca58fd278b6e1e79fd98d10c83931cc2596a6038eee4daeb34ba",
        urls: [
          "bzz-raw://91ccea707361e48b9b7a161fe81f496b9932bc471e9c4e4e1e9c283f2453cc70",
          "dweb:/ipfs/QmcB66sZhQ6Kz7MUHcLE78YXRUZxoZnnxZjN6yATsbB2ec"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/console2.sol": {
        keccak256: "0x954646445d1014c3cd85c7918f5e7adeeca5ee44b68c00bafa237e597a4e35ea",
        urls: [
          "bzz-raw://516fa3be52da4763147175bfba4be0aa011fadbb0c1afb01f97265bd4cee7973",
          "dweb:/ipfs/QmdixAyMJefx7qePChgdxcBH5MxhmN7vsqPuPLx3CgrVmF"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/interfaces/IERC165.sol": {
        keccak256: "0x414b2861b1acbf816ccb7346d3f16cf6c1e002e9e5e40d2f1f26fa5ddc2ea600",
        urls: [
          "bzz-raw://698352fb240868ea8f1d1fe389993035eeab930f10d06934f80ccfb2b6ccbfbc",
          "dweb:/ipfs/QmT6WLHAgXxFhh12kWym895oTzXid1326iZiwT3pyfggoT"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/interfaces/IERC20.sol": {
        keccak256: "0x4cab887298790f908c27de107e4e2907ca5413aee482ef776f8d2f353c5ef947",
        urls: [
          "bzz-raw://bb715e0c4a2bdbe432bb624501506041f06e878e0b72675aebba30ad2c2b72e7",
          "dweb:/ipfs/QmWhhLSvkxS2NrukJJHqFY8gDVE5r9rD4PfHvR24pwdKv9"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/interfaces/IERC721.sol": {
        keccak256: "0xf069262a264fdb69f8f37a10d2df7374649e9ba73f8414c9c8a3b51184625f15",
        urls: [
          "bzz-raw://924a41ca82a68ffbd503a5faf2f76d13e9938f10501a71094716f12bb64b4b7f",
          "dweb:/ipfs/QmdWnqfKc5ZGhmxNPTde4zrFchnv9Yk9MpCMb2rdhXE5gm"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/interfaces/IMulticall3.sol": {
        keccak256: "0x7aac1389150499a922d1f9ef5749c908cef127cb2075b92fa17e9cb611263d0a",
        urls: [
          "bzz-raw://d95ebb7c7c463e08ebc12dab639945752fb2480acfc6e86da32f72732a7fd0c0",
          "dweb:/ipfs/QmNXK8P8oPWwajsQHvAHw3JPyQidPLCGQN3hWu1Lk6PBL2"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/mocks/MockERC20.sol": {
        keccak256: "0xadbdfc6639edec00ba94bb1133a0fd8de31ccafe45c2ef5df9b3ca61b60b559b",
        urls: [
          "bzz-raw://bc766f01bccf669abac8cc7b2096cc1352a66471ca3772ae61b1801dedc4ed4f",
          "dweb:/ipfs/QmNigaPj1LYkP7Z5xr4ijkUxr2K66fDGeoifG3WoM9ruyw"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/mocks/MockERC721.sol": {
        keccak256: "0x3293dcbb7acd28df553c954e4e39e288bf10aab7ecda8d50ef21b4f4a91a28d9",
        urls: [
          "bzz-raw://9eb374daf6df34f4392f8926f1fddbce9f22c423066aeaefdfbe77395f77967b",
          "dweb:/ipfs/QmWR81zBJRX2uyRjveGzikYPj6ZwKppWsU49YEQXTLWUsN"
        ],
        license: "MIT"
      },
      "lib/forge-std/src/safeconsole.sol": {
        keccak256: "0xbaf41fdc6c54297e7cd8250e48b0f20eaac918e342a1028cef3f9a52ac086381",
        urls: [
          "bzz-raw://a500ad81dea226f9910e6b50f99a9ff930105e393a692cbfb2185e4cdb4424ae",
          "dweb:/ipfs/QmVbUQpXNMmMWRiy4FvBNczzq46BMGfUoBikvSHNiCxVTq"
        ],
        license: "MIT"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/IERC20.sol": {
        keccak256: "0x287b55befed2961a7eabd7d7b1b2839cbca8a5b80ef8dcbb25ed3d4c2002c305",
        urls: [
          "bzz-raw://bd39944e8fc06be6dbe2dd1d8449b5336e23c6a7ba3e8e9ae5ae0f37f35283f5",
          "dweb:/ipfs/QmPV3FGYjVwvKSgAXKUN3r9T9GwniZz83CxBpM7vyj2G53"
        ],
        license: "MIT"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/extensions/IERC20Permit.sol": {
        keccak256: "0xec63854014a5b4f2b3290ab9103a21bdf902a508d0f41a8573fea49e98bf571a",
        urls: [
          "bzz-raw://bc5b5dc12fbc4002f282eaa7a5f06d8310ed62c1c77c5770f6283e058454c39a",
          "dweb:/ipfs/Qme9rE2wS3yBuyJq9GgbmzbsBQsW2M2sVFqYYLw7bosGrv"
        ],
        license: "MIT"
      },
      "lib/openzeppelin-contracts/contracts/token/ERC20/utils/SafeERC20.sol": {
        keccak256: "0x909d608c2db6eb165ca178c81289a07ed2e118e444d0025b2a85c97d0b44a4fa",
        urls: [
          "bzz-raw://656cda26512ddd7373c2d5551c8fae759fc30f05b10f0fc2e738e9274199dbd4",
          "dweb:/ipfs/QmTSArSzQRFbQmHgq7U1PZXnsDFhvDZhKVu9CzMG4yo6Lx"
        ],
        license: "MIT"
      },
      "lib/openzeppelin-contracts/contracts/utils/Address.sol": {
        keccak256: "0x006dd67219697fe68d7fbfdea512e7c4cb64a43565ed86171d67e844982da6fa",
        urls: [
          "bzz-raw://2455248c8ddd9cc6a7af76a13973cddf222072427e7b0e2a7d1aff345145e931",
          "dweb:/ipfs/QmfYjnjRbWqYpuxurqveE6HtzsY1Xx323J428AKQgtBJZm"
        ],
        license: "MIT"
      },
      "lib/uniswapV3/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
        keccak256: "0x3f485fb1a44e8fbeadefb5da07d66edab3cfe809f0ac4074b1e54e3eb3c4cf69",
        urls: [
          "bzz-raw://095ce0626b41318c772b3ebf19d548282607f6a8f3d6c41c13edfbd5370c8652",
          "dweb:/ipfs/QmVDZfJJ89UUCE1hMyzqpkZAtQ8jUsBgZNE5AMRG7RzRFS"
        ],
        license: "GPL-2.0-or-later"
      },
      "lib/uniswapV3/v3-periphery/contracts/interfaces/ISwapRouter.sol": {
        keccak256: "0x9bfaf1feb32814623e627ab70f2409760b15d95f1f9b058e2b3399a8bb732975",
        urls: [
          "bzz-raw://a8a2c3e55965b61bcd91993d8e1d5d34b8b8a63e0fdfce87a85f6af92526fd53",
          "dweb:/ipfs/QmQj2CSCSwqDSU4KMNWxGsN2336Cy64WgpV1X1EHXNZWxM"
        ],
        license: "GPL-2.0-or-later"
      },
      "lib/uniswapV3/v3-periphery/contracts/libraries/TransferHelper.sol": {
        keccak256: "0x9af98b0908c96320ca6d08b22f0efca864742f6adbe5794cafe2d1d2e808b0cd",
        urls: [
          "bzz-raw://da1d1e81e5bf534f0bf2934b3193db6cb1933f91ec006d2b88e9ad10a617a2d2",
          "dweb:/ipfs/QmcPBk47QLMFWcX2y2S9eMFsJgoYWBd3R8ey55Bgmv6w6v"
        ],
        license: "GPL-2.0-or-later"
      },
      "src/CToken.sol": {
        keccak256: "0x4c3bce6d07a0ff161e4228a76352c35443550af7cb050b653efc6859b42cef92",
        urls: [
          "bzz-raw://cc8a9ec2b8678b18374618b7dd64529dcfe1882736d1faaf92086a006e06959b",
          "dweb:/ipfs/QmPwooLx1MfTr1eJq8aAfeixNs1gFHCgSUWKjsuLoX3ffY"
        ],
        license: "BSD-3-Clause"
      },
      "src/CTokenInterfaces.sol": {
        keccak256: "0x51f9fa61c4195c3c2b8d6b3e8df9cc350e7f85628289306953ece0bf91593acc",
        urls: [
          "bzz-raw://1e94cfa5317de7e7ea183b9289ea093124626367c243027cfb9d690bab55cb04",
          "dweb:/ipfs/QmNrznxfmTUbpLG8sFrHTXYQEdtZbKCYzBFkUcQU3y11fk"
        ],
        license: "BSD-3-Clause"
      },
      "src/ComptrollerInterface.sol": {
        keccak256: "0x5af9ec0d72948965bd6435a55e4519795ebc0279b191e313e3b9d9a71d189fa6",
        urls: [
          "bzz-raw://aa5cf113eae9f9f5f5b095a393768815bbc80d9a4dae4698e72a60db24df8c92",
          "dweb:/ipfs/QmbNEn3juMwVYwJ28pWSWip7xBpmYezoKkNGWcj6W4BuB7"
        ],
        license: "BSD-3-Clause"
      },
      "src/EIP20Interface.sol": {
        keccak256: "0xf44fc7783d4a0060119f0096a122c3f305c7a03da75aa21408393d8d7a2e649b",
        urls: [
          "bzz-raw://98edcf6c8e46b8340174c4fbda657a8390d71167dfad2fef6d26b049659549db",
          "dweb:/ipfs/QmPiqcGe1te4TBiNGuDuBDwEjnhSQWqfqC85hFkbwFVXzi"
        ],
        license: "BSD-3-Clause"
      },
      "src/EIP20NonStandardInterface.sol": {
        keccak256: "0x5ce25bb36a4ec9490617567a24b55bc813e943bcd4411e060afffe122bea0416",
        urls: [
          "bzz-raw://ffb7208e6c62875cb0ee30940c5967411c8ddf6b259d52a445ee09fd7020d698",
          "dweb:/ipfs/QmX6HCfaWJxJsG4sK8EAzm75ymmJSgytxomXppgfnJgkh7"
        ],
        license: "BSD-3-Clause"
      },
      "src/ErrorReporter.sol": {
        keccak256: "0xa21708ac32b7850c51afdc34ea45f569081eded185332c676bdf86221b7f2d37",
        urls: [
          "bzz-raw://e3597938546ab142122a231bae1fc0cebe1daf84491b4fc5b97943ab195455f5",
          "dweb:/ipfs/QmNdPjPg15tVgWC6yBf9FnKcuBVo9jSN4y9iB4jzvXMjv8"
        ],
        license: "BSD-3-Clause"
      },
      "src/ExponentialNoError.sol": {
        keccak256: "0x3a05062282ef8cbf6ec372abc73387ac8105a7eb0ea0f38069ebfd0f434ff98b",
        urls: [
          "bzz-raw://2aed68e944fba607a9eb176f7b5c0fe59f84d82e2e102b8d6db63ce5018548a9",
          "dweb:/ipfs/QmZJVBDDtFpqA8ZerzX4rGdBUsnA1tooHKxpKCWWvqRhJC"
        ],
        license: "BSD-3-Clause"
      },
      "src/InterestRateModel.sol": {
        keccak256: "0x470821c8ff2120381ead6f54dba5c7b4fc0209682062bde51ea20291176aa0be",
        urls: [
          "bzz-raw://183fcf6b83f8183ef7930b51a5438ef9ab5a16702b76ab953892e40ef3688e34",
          "dweb:/ipfs/QmTZXAJ6pCPiDbZmdzU1LpVzYru978ApNESrRqhGiKT4Lq"
        ],
        license: "BSD-3-Clause"
      },
      "src/Interfaces/CompoundV2/CTokenInterfaces.sol": {
        keccak256: "0xb25f7c11df8d527c610dc328b641404ef1255aa30edea8d14e9735930445e8db",
        urls: [
          "bzz-raw://74f614284df9da7b3dd8ba8dc59d421257dd181c1e0ac1e5ed87575227c7a235",
          "dweb:/ipfs/QmZSBaLzKn5Cmv3oKLoMLer8E1WYoYirR5GH83fXP7DrfR"
        ],
        license: "BSD-3-Clause"
      },
      "src/Interfaces/CompoundV2/ICEther.sol": {
        keccak256: "0xa0e5395f6e54919e4428d27dcd04e05eb7163afd2e6168ef71e48270e3a34171",
        urls: [
          "bzz-raw://142ee914662f605aecbd0f628b0d0b68e2134951287e6ceae979b59a8fbf1cce",
          "dweb:/ipfs/QmS2yATyfVveFFxcapsrV5now17QRA97rtBcKAgUJQ8ck9"
        ],
        license: "BSD-3-Clause"
      },
      "src/Interfaces/IWETH.sol": {
        keccak256: "0x29a81726f6e4c0d48239b6af3536b08d6dba5dbecab2b05e43d56b92b3d49322",
        urls: [
          "bzz-raw://556debe5798243e9b69c12c88692392c1ebfaa0380ff7955d2b0b0ed625bfca1",
          "dweb:/ipfs/QmP6GWYxkJgi8KN4CFMorfPsx4kCiHrGRBrFoWtXXpnG8Q"
        ],
        license: null
      },
      "src/Interfaces/Morpho/IMorpho.sol": {
        keccak256: "0x74c4f2d062f66d8aa9e3cf431bd1ad6443f51bfc42e38b97c8a9cb7670a1bb8f",
        urls: [
          "bzz-raw://d1cb39ed146ebd0adb42eb70c1144c28d457a9e751b5419c57ea3c4782126793",
          "dweb:/ipfs/QmXCmnQXKYRPLAhD2yzTKYy7cB1GS95d5vr3Ey8bYnGVpn"
        ],
        license: "GPL-2.0-or-later"
      },
      "src/Interfaces/Morpho/IMorphoCallbacks.sol": {
        keccak256: "0xe4b3c0aea7b09b052c3a15663c3a57137f04fc54a94054371f28b2495798c573",
        urls: [
          "bzz-raw://ed9900055b67066e303ddaf0beacb28d8246c5a19f25af7bf29b7da76edae8dc",
          "dweb:/ipfs/QmbPJpd8zMzkwz3YJLBPtVrbyYScjNH8BdUChCHnFKRNzs"
        ],
        license: "GPL-2.0-or-later"
      },
      "src/Interfaces/UniswapV2/IUniswapV2Router01.sol": {
        keccak256: "0x66eb4b8355b7d1fcb2e9e3ca8a0968663d9e0b194ff02c09ef0d1ae7981aa67d",
        urls: [
          "bzz-raw://f8da3fe63fbfd6331ce2b7f90983734e062193a54c67ca36826f40b6ccd9c7de",
          "dweb:/ipfs/QmcifLPYeYj3phcEqtBdz3oN2gy7EXbj7N5WUHEQ4FANsD"
        ],
        license: null
      },
      "src/Interfaces/UniswapV2/IUniswapV2Router02.sol": {
        keccak256: "0xc81f478bae3d753f4abd565dccc92820dde09f844e3db034b8750409ab52154a",
        urls: [
          "bzz-raw://3d77d94fc97dabd66e5da83896163edaaa44935a692de62b505654e89be54c63",
          "dweb:/ipfs/QmWtKmLb1WRsymA5zHkWhwWoZs5Tnej6UzWwvfJN5prxGb"
        ],
        license: null
      },
      "src/LiquidBot_v1.sol": {
        keccak256: "0x6830a4faceb4e7404daa907d418e74130328d2987486cc1c15ffb44a5067b7cf",
        urls: [
          "bzz-raw://a678bee91303a9d2f0924157bab06a5da0e2d26a160e53c60d6e2ef741e29a31",
          "dweb:/ipfs/QmTAzXSFQL3jUv12bkqbYE5nHaqrBeVDYHKjzBDE9P3PpP"
        ],
        license: "UNLICENSED"
      }
    },
    version: 1
  },
  id: 70
};

// common/helpers/deepCopy.ts
function deepCopy2(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  const copy4 = Array.isArray(obj) ? [] : {};
  for (const key in obj) {
    const value = obj[key];
    copy4[key] = deepCopy2(value);
  }
  return copy4;
}

// packages/compound-v2-liquidator/src/liquidator/liquidator.constants.ts
var WETH_ADDRESS = "0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2";

// packages/compound-v2-liquidator/artifacts/network/Path.json
var Path_default = {
  "ETH-DAI": "0x6b175474e89094c44da98b954eedeac495271d0f000064a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-USDT": "0xdac17f958d2ee523a2206206994597c13d831ec7000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-WBTC": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-COMP": "0xc00e94cb662c3520282e6f5717214004a7f26888000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-LINK": "0x514910771af9ca656af840dff83e8264ecf986ca000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-MKR": "0x9f8f72aa9304c8b593d555f12ef6589cc3a579a2000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-SUSHI": "",
  "ETH-AAVE": "0x7fc66500c84a76ad7e9c93437bfc5ac33e2ddae9000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-BAT": "0x0d8775f648430679a709e98d2b0cb6250d2887ef000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "ETH-ZRX": "0xe41d2489571d322189246dafa5ebde1f4699f498000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2",
  "DAI-ETH": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000646b175474e89094c44da98b954eedeac495271d0f",
  "DAI-USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000646b175474e89094c44da98b954eedeac495271d0f",
  "DAI-USDT": "0xdac17f958d2ee523a2206206994597c13d831ec70000646b175474e89094c44da98b954eedeac495271d0f",
  "DAI-WBTC": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599000bb8dac17f958d2ee523a2206206994597c13d831ec70000646b175474e89094c44da98b954eedeac495271d0f",
  "DAI-UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb4800000000000000000000000000000000000000000000000000000000000000186b175474e89094c44da98b954eedeac495271d0f",
  "DAI-COMP": "0xc00e94cb662c3520282e6f5717214004a7f26888000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb480000646b175474e89094c44da98b954eedeac495271d0f",
  "DAI-LINK": "",
  "DAI-MKR": "",
  "DAI-SUSHI": "",
  "DAI-AAVE": "",
  "DAI-BAT": "",
  "DAI-ZRX": "",
  "USDT-ETH": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8dac17f958d2ee523a2206206994597c13d831ec7",
  "USDT-DAI": "0x6b175474e89094c44da98b954eedeac495271d0f000064dac17f958d2ee523a2206206994597c13d831ec7",
  "USDT-USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000064dac17f958d2ee523a2206206994597c13d831ec7",
  "USDT-WBTC": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599000bb8dac17f958d2ee523a2206206994597c13d831ec7",
  "USDT-UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8dac17f958d2ee523a2206206994597c13d831ec7",
  "USDT-COMP": "0xc00e94cb662c3520282e6f5717214004a7f26888000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8dac17f958d2ee523a2206206994597c13d831ec7",
  "USDT-LINK": "",
  "USDT-MKR": "",
  "USDT-SUSHI": "",
  "USDT-AAVE": "",
  "USDT-BAT": "",
  "USDT-ZRX": "",
  "USDC-ETH": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "USDC-DAI": "0x6b175474e89094c44da98b954eedeac495271d0f000064a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "USDC-USDT": "0xdac17f958d2ee523a2206206994597c13d831ec7000064a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "USDC-WBTC": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "USDC-UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "USDC-COMP": "0xc00e94cb662c3520282e6f5717214004a7f26888000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb8a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48",
  "USDC-LINK": "",
  "USDC-MKR": "",
  "USDC-SUSHI": "",
  "USDC-AAVE": "",
  "USDC-BAT": "",
  "USDC-ZRX": "",
  "WBTC-ETH": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb82260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "WBTC-DAI": "0x6b175474e89094c44da98b954eedeac495271d0f000064dac17f958d2ee523a2206206994597c13d831ec7000bb82260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "WBTC-USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000bb82260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "WBTC-USDT": "0xdac17f958d2ee523a2206206994597c13d831ec7000bb82260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "WBTC-UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb82260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "WBTC-COMP": "0xc00e94cb662c3520282e6f5717214004a7f26888000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb82260fac5e5542a773aa44fbcfedf7c193bc2c599",
  "WBTC-LINK": "",
  "WBTC-MKR": "",
  "WBTC-SUSHI": "",
  "WBTC-AAVE": "",
  "WBTC-BAT": "",
  "WBTC-ZRX": "",
  "AAVE-ETH": "0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb87fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
  "AAVE-DAI": "0x6b175474e89094c44da98b954eedeac495271d0f000064a0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb87fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
  "AAVE-USDC": "0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb87fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
  "AAVE-USDT": "0xdac17f958d2ee523a2206206994597c13d831ec7000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb87fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
  "AAVE-WBTC": "0x2260fac5e5542a773aa44fbcfedf7c193bc2c599000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb87fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
  "AAVE-UNI": "0x1f9840a85d5af5bf1d1762f925bdaddc4201f984000bb8c02aaa39b223fe8d0a0e5c4f27ead9083c756cc2000bb87fc66500c84a76ad7e9c93437bfc5ac33e2ddae9",
  "AAVE-COMP": "",
  "AAVE-LINK": "",
  "AAVE-MKR": "",
  "AAVE-SUSHI": "",
  "AAVE-BAT": "",
  "AAVE-ZRX": ""
};

// packages/compound-v2-liquidator/src/liquidator/liquidator.service.ts
class LiquidatorService extends Service {
  storageService;
  priceOracleService;
  web3Service;
  accountService;
  bundleService;
  telegramService;
  txData = new Map;
  constructor(storageService, priceOracleService, web3Service, accountService, bundleService, telegramService) {
    super();
    this.storageService = storageService;
    this.priceOracleService = priceOracleService;
    this.web3Service = web3Service;
    this.accountService = accountService;
    this.bundleService = bundleService;
    this.telegramService = telegramService;
  }
  async processPendingPriceUpdate(message) {
    console.log("method -> liquidatorService.processPendingPriceUpdate");
    const [pendingPriceConfig, rawTx] = message.data;
    this.txData.set(pendingPriceConfig.symbolHash, [
      rawTx,
      {
        _repayTokens: [],
        _cMarkets: [],
        _borrowers: [],
        _repayAmounts: [],
        _cMarketCollaterals: [],
        _path: []
      }
    ]);
    const oldPrices = [];
    const markets = [];
    const tokenConfigs = this.storageService.getTokenConfigsBySymbolHash(pendingPriceConfig.symbolHash);
    if (pendingPriceConfig.symbolHash === EthSymbolHash) {
      const fixedEthTokenConfigs = this.storageService.getFixedEthTokenConfigs();
      tokenConfigs.push(...fixedEthTokenConfigs);
    }
    for (const tokenConfig of tokenConfigs) {
      oldPrices.push(tokenConfig.price);
      if (tokenConfig.symbolHash === pendingPriceConfig.symbolHash) {
        tokenConfig.price = pendingPriceConfig.price;
      }
      const newPendingUnderlyingPriceMantissa = this.priceOracleService.getUnderlyingPrice(tokenConfig);
      const market = this.storageService.getMarket(tokenConfig.marketAddress);
      market.pendingUnderlyingPriceMantissa = newPendingUnderlyingPriceMantissa;
      console.log("pendingPriceConfig", pendingPriceConfig);
      console.log("market", market.symbol, market.address);
      console.log("newPendingUnderlyingPriceMantissa", newPendingUnderlyingPriceMantissa);
      markets.push(market);
    }
    if (!markets.length) {
      console.error("No markets found");
    }
    const accounts2 = Array.from(markets.reduce((acc, market) => {
      market.accounts.forEach((address28) => acc.add(address28));
      return acc;
    }, new Set));
    const start = Date.now();
    await Promise.all(accounts2.map((account2) => this.findLiquidationData(account2, pendingPriceConfig.symbolHash)));
    for (const tokenConfig of tokenConfigs) {
      const market = this.storageService.getMarket(tokenConfig.marketAddress);
      market.pendingUnderlyingPriceMantissa = 0n;
      tokenConfig.price = oldPrices.shift();
    }
    console.log("markets", markets.map(({ symbol: symbol2 }) => symbol2));
    console.log("Account quantity:", accounts2.length);
    console.log("Time of liquidity calculations:", Date.now() - start, "ms");
    const [rawTargetTx, liquidationData] = this.txData.get(pendingPriceConfig.symbolHash);
    console.log("total victims:", liquidationData._repayTokens.length);
    console.log("_repayToken", liquidationData._repayTokens);
    console.log("_cMarket", liquidationData._cMarkets);
    console.log("_borrower", liquidationData._borrowers);
    console.log("_repayAmount", liquidationData._repayAmounts);
    console.log("_cMarketCollateral", liquidationData._cMarketCollaterals);
    console.log("_path", liquidationData._path);
    if (liquidationData._repayTokens.length === 0) {
      this.txData.delete(pendingPriceConfig.symbolHash);
      return;
    }
    let tx2;
    try {
      const tx3 = await this.createLiquidationTx(liquidationData);
    } catch (e) {
      this.sendLiquidationErrorToTelegram(e);
      this.txData.delete(pendingPriceConfig.symbolHash);
      return;
    }
    if (!tx2) {
      this.txData.delete(pendingPriceConfig.symbolHash);
      return;
    }
    const blockNumber = this.storageService.getNetworkHeight() + 1;
    this.bundleService.submitBundleBLXR(blockNumber, [rawTargetTx, tx2.rawTransaction]).then((bundleHash) => {
      const infoParts = [
        `bundleHash: ${bundleHash}`,
        `blockNumber: ${blockNumber}`,
        `txHash: ${tx2.transactionHash}`
      ];
      this.sendLiquidationDataToTelegram(infoParts);
    }).catch(this.sendLiquidationErrorToTelegram);
    this.txData.delete(pendingPriceConfig.symbolHash);
  }
  async sendLiquidationDataToTelegram(args) {
    const bundlePrefix = "Liquidation info:";
    args.unshift(bundlePrefix);
    const message = args.join("\n");
    await this.telegramService.sendMessage(message);
  }
  async sendLiquidationErrorToTelegram(error) {
    const errorMessage = error.message;
    const message = `Liquidation error:\n${errorMessage}`;
    await this.telegramService.sendMessage(message);
  }
  async findLiquidationData(address28, symbolHash) {
    const account2 = this.storageService.getAccount(address28);
    const [liquidity, shortfall] = this.calculateAccountLiquidity(account2);
    if (liquidity > 0n || shortfall === 0n) {
      return;
    }
    this.appendAccountLiqData(account2, liquidity, symbolHash);
  }
  async createLiquidationTx(liquidationLoopData) {
    console.log("method -> liquidatorService.createLiquidationTx");
    const address28 = env_default.LIQUIDATOR_CONTRACT_ADDRESS;
    const abi7 = LiqBot_v1_default.abi.find((item) => item.name === "liquidate");
    const args = Object.values(liquidationLoopData);
    const maxFeePerGas = this.storageService.getBaseFeePerGas() * 2n;
    const gas = (args[0].length * 1500000).toString();
    const tx2 = await this.web3Service.createAndSignTx({
      address: address28,
      abi: abi7,
      args,
      gas,
      maxFeePerGas
    });
    return tx2;
  }
  appendAccountLiqData(_account, initialLiquidity, symbolHash) {
    const account2 = deepCopy2(_account);
    let liquidity = initialLiquidity;
    const { liquidationIncentiveMantissa } = this.storageService.getComptroller();
    while (liquidity === 0n) {
      const collateral = this.findCollateralToLiquidate(account2);
      if (Math.round(Number(collateral.collateralValue) / 1000000000000000000) <= env_default.MINIMUM_LIQUIDATION_VALUE / 2 * (Number(liquidationIncentiveMantissa) / 1000000000000000000)) {
        break;
      }
      const borrow = this.findBorrowToLiquidate(account2);
      if (Math.round(Number(borrow.borrowValue) / 1000000000000000000) < env_default.MINIMUM_LIQUIDATION_VALUE) {
        break;
      }
      const repayAmount = this.calculateRepayAmount(borrow, collateral);
      if (repayAmount <= 0n) {
        break;
      }
      const borrowMarket = this.storageService.getMarket(borrow.address);
      const collateralMarket = this.storageService.getMarket(collateral.address);
      const data15 = this.txData.get(symbolHash)[1];
      const path = this.getPath(borrowMarket.underlyingSymbol, collateralMarket.underlyingSymbol);
      if (!path) {
        console.error(`Path not found for borrow market ${borrowMarket.underlyingSymbol} and collateral market ${collateralMarket.underlyingSymbol}`);
        account2.tokens[collateral.address] = 0n;
        console.log("borrower", account2.address);
        continue;
      }
      data15._path.push(path);
      data15._cMarkets.push(borrow.address);
      data15._borrowers.push(account2.address);
      data15._repayAmounts.push(repayAmount.toString());
      data15._cMarketCollaterals.push(collateral.address);
      data15._repayTokens.push(borrowMarket.symbol === "cETH" ? WETH_ADDRESS : borrowMarket.underlyingAddress);
      const seizeTokens = this.calculateSeizeTokens(borrow.address, collateral.address, repayAmount);
      account2.tokens[collateral.address] -= seizeTokens;
      findAsset(account2, borrow.address).principal -= repayAmount;
      liquidity = this.calculateAccountLiquidity(account2)[0];
    }
  }
  calculateAccountLiquidity(account2) {
    const { assets, tokens } = account2;
    let sumCollateral = 0n;
    let sumBorrow = 0n;
    for (const asset of assets) {
      const { address: address28, principal } = asset;
      const balance = tokens[address28];
      const {
        borrowIndex,
        exchangeRateMantissa,
        collateralFactorMantissa,
        underlyingPriceMantissa: _underlyingPriceMantissa,
        pendingUnderlyingPriceMantissa
      } = this.storageService.getMarket(address28);
      const underlyingPriceMantissa = pendingUnderlyingPriceMantissa || _underlyingPriceMantissa;
      if (balance > 0n) {
        const tokensToDenomMantissa = mul_Mantissa(mul_Mantissa(collateralFactorMantissa, exchangeRateMantissa), underlyingPriceMantissa);
        sumCollateral = mulScalarTruncateAddUInt(tokensToDenomMantissa, balance, sumCollateral);
      }
      if (principal > 0n) {
        const borrowBalance = this.accountService.borrowBalance(asset, borrowIndex);
        sumBorrow = mulScalarTruncateAddUInt(underlyingPriceMantissa, borrowBalance, sumBorrow);
      }
    }
    return sumCollateral > sumBorrow ? [sumCollateral - sumBorrow, 0n] : [0n, sumBorrow - sumCollateral];
  }
  findBorrowToLiquidate(account2) {
    const assets = account2.assets;
    let address28 = "";
    let borrowValue = 0n;
    for (const asset of assets) {
      const { principal, address: _address } = asset;
      const {
        borrowIndex,
        underlyingPriceMantissa: _underlyingPriceMantissa,
        pendingUnderlyingPriceMantissa
      } = this.storageService.getMarket(_address);
      const underlyingPriceMantissa = pendingUnderlyingPriceMantissa || _underlyingPriceMantissa;
      if (!AllowedBorrowMarkets.includes(_address) || principal === 0n) {
        continue;
      }
      const borrowBalance = this.accountService.borrowBalance(asset, borrowIndex);
      const _borrowValue = mul_Mantissa(underlyingPriceMantissa, borrowBalance);
      if (_borrowValue > borrowValue) {
        address28 = _address;
        borrowValue = _borrowValue;
      }
    }
    return {
      address: address28,
      borrowValue
    };
  }
  findCollateralToLiquidate(account2) {
    const tokens = Object.entries(account2.tokens);
    let address28 = "";
    let collateralValue = 0n;
    for (const [_address, balance] of tokens) {
      if (balance === 0n) {
        continue;
      }
      if (_address === CSaiSymbolHash) {
        continue;
      }
      const {
        exchangeRateMantissa,
        underlyingPriceMantissa: _underlyingPriceMantissa,
        pendingUnderlyingPriceMantissa
      } = this.storageService.getMarket(_address);
      const underlyingPriceMantissa = pendingUnderlyingPriceMantissa || _underlyingPriceMantissa;
      const ratio = mul_Mantissa(underlyingPriceMantissa, exchangeRateMantissa);
      const tokenValue = mul_Mantissa(ratio, balance);
      if (tokenValue > collateralValue) {
        address28 = _address;
        collateralValue = tokenValue;
      }
    }
    return {
      address: address28,
      collateralValue
    };
  }
  calculateRepayAmount(borrowAsset, collateral) {
    const { closeFactorMantissa } = this.storageService.getComptroller();
    const borrowMarket = this.storageService.getMarket(borrowAsset.address);
    const priceBorrowedMantissa = borrowMarket.pendingUnderlyingPriceMantissa || borrowMarket.underlyingPriceMantissa;
    const { collateralValue } = collateral;
    const { borrowValue } = borrowAsset;
    const maxRepayValue = mul_Mantissa(borrowValue, closeFactorMantissa);
    const repayValue = collateralValue <= maxRepayValue ? collateralValue : maxRepayValue;
    const repayAmount = div_MantissaB(repayValue, priceBorrowedMantissa);
    return repayAmount - 1000n;
  }
  calculateSeizeTokens(cTokenBorrowed, cTokenCollateral, actualRepayAmount) {
    const borrowMarket = this.storageService.getMarket(cTokenBorrowed);
    const collateralMarket = this.storageService.getMarket(cTokenCollateral);
    const priceBorrowedMantissa = borrowMarket.pendingUnderlyingPriceMantissa || borrowMarket.underlyingPriceMantissa;
    const priceCollateralMantissa = collateralMarket.pendingUnderlyingPriceMantissa || collateralMarket.underlyingPriceMantissa;
    const liquidationIncentiveMantissa = this.storageService.getComptroller().liquidationIncentiveMantissa;
    const exchangeRateCollateralMantissa = collateralMarket.exchangeRateMantissa;
    const numerator = mul_Mantissa(liquidationIncentiveMantissa, priceBorrowedMantissa);
    const denominator = mul_Mantissa(priceCollateralMantissa, exchangeRateCollateralMantissa);
    const ratio = div_MantissaB(numerator, denominator);
    const seizeTokens = mul_Mantissa(ratio, actualRepayAmount);
    return seizeTokens;
  }
  getPath(borrowSymbol, collateralSymbol) {
    const key = `${borrowSymbol}-${collateralSymbol}`;
    return Path_default[key];
  }
}

// packages/compound-v2-liquidator/src/liquidator/liquidator.module.ts
class LiquidatorModule extends Module {
  constructor(storageModule, web3Module, priceOracleModule, accountModule, bundleModule, telegramModule) {
    super();
    const storageService = storageModule.getService("storageService");
    const web3Service = web3Module.getService("web3Service");
    const priceOracleService = priceOracleModule.getService("priceOracleService");
    const accountService = accountModule.getService("accountService");
    const bundleService = bundleModule.getService("bundleService");
    const telegramService = telegramModule.getService("telegramService");
    const liquidatorService = new LiquidatorService(storageService, priceOracleService, web3Service, accountService, bundleService, telegramService);
    this.registerService("liquidatorService", liquidatorService);
  }
}

// packages/compound-v2-liquidator/src/bundle/bundle.service.ts
class BundleService extends Service {
  web3Service;
  constructor(web3Service) {
    super();
    this.web3Service = web3Service;
  }
  async testBundleTxs([tokenConfig, rawOriginTx]) {
    console.log("method -> liquidatorService.testBundleTxs");
    const blockNumber = await this.web3Service.getNetworkHeight() + 1;
    console.log("blockNumber", blockNumber);
    const rawTestTx = await this.web3Service.createRawTestTx();
    console.log("rawOriginTx", rawOriginTx);
    console.log("rawTestTx", rawTestTx);
    const bundleHash = await this.submitBundleBLXR(blockNumber, [
      rawOriginTx,
      rawTestTx
    ]);
    console.log("bundleHash", bundleHash);
  }
  async submitBundleBLXR(blockNumber, txs) {
    console.log("method -> liquidatorService.submitBundle");
    const body = JSON.stringify({
      method: "blxr_submit_bundle",
      id: "1",
      params: {
        block_number: "0x" + blockNumber.toString(16),
        transaction: txs,
        mev_builders: { all: "" }
      }
    });
    let response;
    try {
      response = await fetch(env_default.BLOXROUTE_HTTPS_URL, {
        method: "POST",
        tls: {
          rejectUnauthorized: false
        },
        headers: {
          "Content-Type": "application/json",
          Authorization: env_default.BLOXROUTE_AUTH_HEADER
        },
        body
      });
    } catch (error) {
      console.error(error);
    }
    if (!response.ok) {
      return;
    }
    const {
      result: { bundleHash }
    } = await response.json();
    return bundleHash;
  }
  async sendBundleFB(blockNumber, txs) {
    console.log("method -> liquidatorService.sendBundle");
    const body = JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "eth_sendBundle",
      params: [
        {
          txs,
          blockNumber: "0x" + blockNumber.toString(16)
        }
      ]
    });
    const flashbotsSignature = await this.web3Service.getFlashbotsSignature(body);
    let response;
    try {
      response = await fetch(env_default.FLASHBOTS_HTTPS_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Flashbots-Signature": flashbotsSignature
        },
        body
      });
      return response.json();
    } catch (error) {
      console.error(error);
    }
  }
  async callBundleFB(blockNumber, txs) {
    const body = JSON.stringify({
      jsonrpc: "2.0",
      id: 1,
      method: "eth_callBundle",
      params: [
        {
          txs,
          blockNumber: "0x" + blockNumber.toString(16),
          stateBlockNumber: "latest"
        }
      ]
    });
    const flashbotsSignature = await this.web3Service.getFlashbotsSignature(body);
    console.log("flashbotsSignature", flashbotsSignature);
    let response;
    try {
      response = await fetch(env_default.FLASHBOTS_HTTPS_URL, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "X-Flashbots-Signature": flashbotsSignature
        },
        body
      });
      return response.json();
    } catch (error) {
      console.error(error);
    }
  }
  async traceBundle(bundleHash) {
    console.log("method -> liquidatorService.traceBundle");
    let response;
    try {
      response = await fetch(`https://tools.bloxroute.com/ethbundletrace/${bundleHash}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: "NzdiNWYwNmItNTA3OC00ZWVkLTk4M2QtODQ0OWE3ZmI4ODMxOmE1NTE2ZGQyMDA2ZTkwNWRkY2Q2MThhZjk0NmRjOGJi"
        }
      });
    } catch (error) {
      console.error(error);
    }
    return await response.json();
  }
  async validateBundleBLXR(blockNumber, txs) {
    const auth = "MGU5NGI1ZWYtYWE2OC00YmE4LWIwNmMtNjZjNzhkNmY5NjcxOjNkZjZmN2MwMDhiNGVjZjZkZmY3ZTE0ZjdhYmJkYWY3";
    try {
      const response = await fetch(`https://tools.bloxroute.com/bundlevalidation?block_number=0x${blockNumber.toString(16)}` + `&transaction=${txs.join(",")}` + `&auth_header=${auth}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: auth
        }
      });
      return await response.json();
    } catch (error) {
      console.error(error);
    }
  }
}

// packages/compound-v2-liquidator/src/bundle/bundle.module.ts
class BundleModule extends Module {
  web3Module;
  constructor(web3Module) {
    super();
    this.web3Module = web3Module;
    const service12 = new BundleService(web3Module.getService("web3Service"));
    this.registerService("bundleService", service12);
  }
}

// packages/compound-v2-liquidator/src/block/block.service.ts
class BlockService extends Service {
  storageService;
  collectorService;
  ws;
  subscriptionId;
  constructor(storageService, collectorService) {
    super();
    this.storageService = storageService;
    this.collectorService = collectorService;
  }
  listenForNewBlocks() {
    this.ws?.close();
    this.ws = new WebSocket(env_default.BLOXROUTE_WS_URL, {
      rejectUnauthorized: false,
      headers: {
        Authorization: env_default.BLOXROUTE_AUTH_HEADER
      }
    });
    this.ws.onopen = this.proceedNewBlocksSubscription.bind(this);
    this.ws.onmessage = this.handleNewBlock.bind(this);
    this.ws.onerror = console.error;
    this.ws.onclose = async () => {
      console.log("Connection closed");
    };
  }
  async handleNewBlock(nextNotification) {
    try {
      const data15 = JSON.parse(nextNotification.data);
      if (!data15)
        throw new Error("Invalid data");
      if (data15.error)
        throw new Error(data15.error);
      if (typeof data15.result === "string") {
        this.subscriptionId = data15.result;
        console.log("Subscription ID:", this.subscriptionId);
        return;
      }
      const { number: number10, baseFeePerGas } = data15.params.result.header;
      this.storageService.setNetworkHeight(number10);
      this.storageService.setBaseFeePerGas(baseFeePerGas);
      await this.collectorService.collectPastEvents(false);
    } catch (e) {
      console.error(e);
    }
  }
  proceedNewBlocksSubscription() {
    console.log("blockService -> Connection established");
    const data15 = JSON.stringify({
      id: 1,
      method: "subscribe",
      params: [
        "newBlocks",
        {
          include: ["header"]
        }
      ]
    });
    this.ws?.send(data15);
  }
  unsubscribeNewBlocks() {
    if (this.ws && this.subscriptionId) {
      const data15 = JSON.stringify({
        jsonrpc: "2.0",
        id: 2,
        method: "unsubscribe",
        params: [this.subscriptionId]
      });
      this.ws.send(data15);
    }
  }
  terminate() {
    if (this.ws) {
      this.unsubscribeNewBlocks();
      this.ws.close();
    }
  }
}

// packages/compound-v2-liquidator/src/block/block.module.ts
class BlockModule extends Module {
  collectorModule;
  storageModule;
  constructor(collectorModule, storageModule) {
    super();
    this.collectorModule = collectorModule;
    this.storageModule = storageModule;
    const collectorService = collectorModule.getService("collectorService");
    const storageService = storageModule.getService("storageService");
    const service13 = new BlockService(storageService, collectorService);
    this.registerService("blockService", service13);
  }
}

// packages/compound-v2-liquidator/src/telegram/telegram.service.ts
var import_telegraf = __toESM(require_lib2(), 1);
class TelegramService extends Service {
  bot = new import_telegraf.Telegraf(env_default.TG_BOT_TOKEN);
  constructor() {
    super();
  }
  async sendMessageToPeers(message) {
    const peers = env_default.CHAT_ID.split(",");
    for (const peer of peers) {
      this.bot.telegram.sendMessage(peer, message);
    }
  }
  async sendMessage(message) {
    await this.sendMessageToPeers(message);
  }
}

// packages/compound-v2-liquidator/src/telegram/telegram.module.ts
class TelegramModule extends Module {
  constructor() {
    super();
    const service14 = new TelegramService;
    this.registerService("telegramService", service14);
  }
}

// packages/compound-v2-liquidator/src/master/master.module.ts
class MasterModule extends Module {
  cacheModule;
  web3Module;
  storageModule;
  accountModule;
  priceOracleModule;
  marketModule;
  comptrollerModule;
  validatorProxyModule;
  collectorModule;
  workerModule;
  liquidatorModule;
  bundleModule;
  blockModule;
  telegramModule;
  constructor(mempoolWorker) {
    super();
    this.telegramModule = new TelegramModule;
    this.cacheModule = new CacheModule;
    this.web3Module = new Web3Module(env_default.HTTPS_RPC_URL);
    this.storageModule = new StorageModule(this.cacheModule);
    this.accountModule = new AccountModule(this.storageModule, this.web3Module);
    this.marketModule = new MarketModule(this.storageModule, this.web3Module, this.accountModule);
    this.validatorProxyModule = new ValidatorProxyModule(this.web3Module, this.storageModule);
    this.priceOracleModule = new PriceOracleModule(this.web3Module, this.storageModule, this.validatorProxyModule, this.marketModule);
    this.bundleModule = new BundleModule(this.web3Module);
    this.liquidatorModule = new LiquidatorModule(this.storageModule, this.web3Module, this.priceOracleModule, this.accountModule, this.bundleModule, this.telegramModule);
    this.workerModule = new WorkerModule(mempoolWorker, this.liquidatorModule);
    this.validatorProxyModule.setupWorkerModule(this.workerModule);
    this.comptrollerModule = new ComptrollerModule(this.storageModule, this.web3Module, this.accountModule, this.priceOracleModule, this.marketModule, this.workerModule);
    this.collectorModule = new CollectorModule(this.storageModule, this.web3Module, this.comptrollerModule, this.marketModule, this.priceOracleModule, this.validatorProxyModule);
    this.blockModule = new BlockModule(this.collectorModule, this.storageModule);
    const storageService = this.storageModule.getService("storageService");
    const workerService = this.workerModule.getService("workerService");
    const web3Service = this.web3Module.getService("web3Service");
    const collectorService = this.collectorModule.getService("collectorService");
    const blockService = this.blockModule.getService("blockService");
    const masterService = new MasterService(storageService, workerService, web3Service, collectorService, blockService);
    this.registerService("masterService", masterService);
  }
}

// packages/compound-v2-liquidator/main.ts
async function main() {
  const mempoolWorkerUrl = new URL("workers/mempool.worker.ts", import.meta.url).href;
  const mempoolWorker = new Worker(mempoolWorkerUrl);
  const masterModule = new MasterModule(mempoolWorker);
  await masterModule.getService("masterService").init();
}
main();
